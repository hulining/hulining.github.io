<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go 学习笔记之基本类型</title>
    <url>/2020/04/30/go-study-notes-basis/</url>
    <content><![CDATA[<h2 id="Go-中支持的数据类型有哪些"><a href="#Go-中支持的数据类型有哪些" class="headerlink" title="Go 中支持的数据类型有哪些"></a>Go 中支持的数据类型有哪些</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">长度</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">1</td>
<td align="center">false</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">uint8 (alias for uint8)</td>
</tr>
<tr>
<td align="center">int, uint</td>
<td align="center">4,8</td>
<td align="center">0</td>
<td align="center">默认整数类型,根据目标平台 32 位或 64 位置</td>
</tr>
<tr>
<td align="center">int8, uint8</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">-127 ~ 128, 0 ~ 255</td>
</tr>
<tr>
<td align="center">int16, uint16</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">-32768 ~ 32767, 0 ~ 65535</td>
</tr>
<tr>
<td align="center">int32, uint32</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">-2^31 ~ 2^31 -1, 0~2^32</td>
</tr>
<tr>
<td align="center">int64, uint64</td>
<td align="center">8</td>
<td align="center">0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float32</td>
<td align="center">4</td>
<td align="center">0.0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float64</td>
<td align="center">8</td>
<td align="center">0.0</td>
<td align="center">默认浮点类型数据</td>
</tr>
<tr>
<td align="center">complex64</td>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">complex128</td>
<td align="center">16</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rune</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">int32 (alias for uint8)</td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">4, 8</td>
<td align="center">0</td>
<td align="center">足够存储指针的 uint</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center"></td>
<td align="center">“”</td>
<td align="center">字符串, 默认为空字符串, 而非 nil</td>
</tr>
<tr>
<td align="center">array</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">struct</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">结构体</td>
</tr>
<tr>
<td align="center">function</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">函数, 引用类型</td>
</tr>
<tr>
<td align="center">interface</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">接口, 引用类型</td>
</tr>
<tr>
<td align="center">map</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">字典, 引用类型</td>
</tr>
<tr>
<td align="center">slice</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">切片, 引用类型</td>
</tr>
<tr>
<td align="center">channel</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">通道, 引用类型</td>
</tr>
</tbody></table>
<h2 id="常量和变量有什么不同"><a href="#常量和变量有什么不同" class="headerlink" title="常量和变量有什么不同"></a>常量和变量有什么不同</h2><ul>
<li>常量在定义的时候必须初始化</li>
<li>常量在相同作用域下是唯一且不可修改的. 一经声明并赋值后, 常量变为”只读”</li>
<li>常量智能修饰 <code>bool</code>, 数值类型(int, float 系列), <code>string</code> 类型</li>
<li>常量不会被分配存储空间, 无法像变量那样通过内存寻址来取值, 因此无法获取其地址, 见如下代码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name <span class="keyword">string</span> = <span class="string">"name"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    age := <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p"</span>, &amp;name)  <span class="comment">// cannot take the address of name</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, &amp;age)  <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iota-是什么-如何使用"><a href="#iota-是什么-如何使用" class="headerlink" title="iota 是什么? 如何使用"></a><code>iota</code> 是什么? 如何使用</h2><p><code>iota</code> 是 Go 语言的常量计数器, 只能在 <code>const</code> 常量声明中使用, 多用于 <code>const</code> 常量声明块(<code>const ()</code> 定义多个常量的格式). 它有如下特点:</p>
<ul>
<li><code>iota</code> 在 <code>const</code> 常量声明第一次出现时将被重置为 0</li>
<li><code>const</code> 常量声明块中每新增一<strong>行</strong>常量声明将使 <code>iota</code> 计数一次(值增加 1).</li>
</ul>
<p>使用 <code>iota</code> 能简化常量定义, 在定义枚举时很有用. 举例如下:</p>
<ul>
<li>每次 <code>const</code> 出现时, <code>iota</code> 初始化为0</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">iota</span> <span class="comment">// a = 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    b = <span class="literal">iota</span> <span class="comment">// b = 0</span></span><br><span class="line">    c        <span class="comment">// c = 1   相当于 c = iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>每<strong>行</strong>变量声明计数器加 1</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">// iota = 0, a = 0</span></span><br><span class="line">    b         <span class="comment">// iota = 1, b = iota, 即 b = 1</span></span><br><span class="line">    c = <span class="number">100</span>   <span class="comment">// iota = 2, c = 100</span></span><br><span class="line">    d = <span class="literal">iota</span>  <span class="comment">// iota = 3, d = 3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    A, B = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// iota = 0, A = 1, B = 2</span></span><br><span class="line">    C, D                      <span class="comment">// iota = 1, C, D = iota + 1, iota + 2, C, D = 2, 3</span></span><br><span class="line">    E, F                      <span class="comment">// iota = 2, E, F = iota + 1, iota + 2, E, F = 3, 4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义枚举类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> color <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    red color = <span class="literal">iota</span></span><br><span class="line">    yellow</span><br><span class="line">    blue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可通过如下方式定义数量级</span></span><br><span class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span>             <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 1 &lt;&lt; (10*1)</span></span><br><span class="line">    MB                             <span class="comment">// 1 &lt;&lt; (10*2)</span></span><br><span class="line">    GB                             <span class="comment">// 1 &lt;&lt; (10*3)</span></span><br><span class="line">    TB                             <span class="comment">// 1 &lt;&lt; (10*4)</span></span><br><span class="line">    PB                             <span class="comment">// 1 &lt;&lt; (10*5)</span></span><br><span class="line">    EB                             <span class="comment">// 1 &lt;&lt; (10*6)</span></span><br><span class="line">    ZB                             <span class="comment">// 1 &lt;&lt; (10*7)</span></span><br><span class="line">    YB                             <span class="comment">// 1 &lt;&lt; (10*8)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">    numberOfDays <span class="comment">// 这个常量没有导出</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型包括 <code>slice</code>, <code>map</code>, <code>channel</code> 这 3 种数据类型</p>
<p>相比数字, 数组等类型, 引用类型拥有更复杂的数据结构. 除了分配内存外, 还需要初始化一系列属性, 如指针, 长度, 甚至包括哈希分布, 数据队列等.</p>
<p>引用类型使用 <code>make()</code> 函数创建, 以确保完成内存分配和相关属性初始化.</p>
<p>引用类型之所以可以引用, 是因为我们创建引用类型的变量其实是一个包含指向底层数据结构指针的变量. 当我们在函数中传递引用类型时，其实传递的是这个变量的副本, 它所指向的底层结构并没有被复制传递, 函数中对引用类型所做的所有操作可以理解为操作该对象的内存地址, 都会作用到其底层数据结构上, 这也是引用类型传递高效的原因</p>
<p>本质上，我们可以理解函数传递参数都是值拷贝,只不过引用类型传递的是一个指向底层数据的指针, 所以我们在函数中操作的时候, 实际操作的是共享的底层数据值, 进而影响到所有引用到这个共享底层数据的变量</p>
<p><img src="/images/difference_between_valueType_and_referenceType.jpg" alt="值类型与引用类型的区别"></p>
<p>同理, 在进行拷贝操作时, 值类型和引用类型会将变量的值进行拷贝, 值类型中变量的值是真实的数据, 因此可以理解为深拷贝. 引用类型中变量的值是真实存储数据的内存地址, 拷贝后变量的值也是该内存地址, 二者仍然共享同一底层数据, 因此可以理解为浅拷贝.</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>使用 <code>type</code> 关键字自定义类型, 包括现有基础类型创建, 结构体, 函数类型等.</p>
<p>即便自定义类型使用了基础类型, 如 <code>type integer int</code>, 也只表明它们有相同的底层数据结构, 两者之间不存在任何关系, 属于完全不同的两种数据类型.<br>除操作符外, 自定义类型不会继承基础类型的其它信息(包括方法). 不能视作别名, 不能隐式转换, 不能直接用于比较表达式.</p>
<h2 id="未命名类型-匿名类型"><a href="#未命名类型-匿名类型" class="headerlink" title="未命名类型(匿名类型)"></a>未命名类型(匿名类型)</h2><p>与有明确标识符 <code>bool</code>, <code>int</code>, <code>string</code> 等类型相比, <code>array</code>, <code>slice</code>, <code>map</code>, <code>channel</code> 等类型与具体元素类型或长度等属性有关, 故称作未命名类型</p>
<p>具有相同声明的未命名类型被视为同一类型, 如:</p>
<ul>
<li>具有相同基类型的指针</li>
<li>具有相同元素类型和长度的数组</li>
<li>具有相同元素类型的切片</li>
<li>具有相同键值类型的字典</li>
<li>具有相同数据类型及操作方向的通道</li>
<li>具有相同字段序列(字段名,字段类型,标签,字段顺序)的匿名结构体</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">        y <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">        y <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span></span><br><span class="line">    fmt.Println(a == b)  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之常用数据类型</title>
    <url>/2020/04/30/go-study-notes-data-type/</url>
    <content><![CDATA[<h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 <code>string</code></h2><p>字符串 <code>string</code> 是 Go 中的基本类型, 它是一个不可变的 UTF-8 字符(byte)序列.</p>
<p>特点和注意事项如下:</p>
<ul>
<li>字符串默认值不是 <code>nil</code>, 而是 <code>&quot;&quot;</code></li>
<li>允许以索引方式访问字节数组, 但不能获取元素地址或对其中元素修改</li>
<li>可以使用反引号(`)定义不做任何转义处理的原始字符串, 支持跨行</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">    fmt.Println(str) <span class="comment">// ""</span></span><br><span class="line">    str = <span class="string">"string"</span></span><br><span class="line">    fmt.Print(str[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment">// tr</span></span><br><span class="line">    <span class="comment">// fmt.Printf("%p", &amp;str[1]) // 报错 cannot take the address of 'str[1]', 不能获取 str[1] 的指针地址</span></span><br><span class="line">    <span class="comment">// str[1] = 'x'              // 报错, cannot assign to str[1], 字符串是不可变的, 不能对其中元素进行修改</span></span><br><span class="line">    multiLine := <span class="string">`line \n</span></span><br><span class="line"><span class="string">            line2`</span></span><br><span class="line">    fmt.Println(multiLine)    <span class="comment">// 会按照  multiLine 的原始字符输出,不做任何转义操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 for 循环遍历字符串时, 分 <code>byte</code> 和 <code>rune</code> 两种方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    str := <span class="string">"Hello 北京!"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%v: %v\n"</span>, i, str[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%v: %v\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到 for-range (rune)方式输出可以看到中文字符, 而 for-i (byte)方式则不能</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要修改字符串, 需要将其转换为 <code>[]rune</code> 或 <code>[]byte</code> 数组, 待修改完成后再使用 <code>string()</code> 强制转换回来.</li>
</ul>
<h2 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 <code>array</code></h2><p>数组的一般形式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name [<span class="built_in">len</span>]Type = [<span class="built_in">len</span>]Type&#123;element1, element2, element3...&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>数组用于保存相同类型元素的集合, 数组是有长度的. 只有元素类型与长度都相同的数组才属于同一种类型.</li>
<li>数组支持使用索引访问元素内容</li>
<li>对于定义时不确定长度的数组, 可用 <code>[...]Type</code> 进行定义, 但一旦初始化赋值, 其长度也会随之确定. 定义多维数组时, 仅允许第一维数组长度使用 <code>...</code></li>
<li>内置函数 <code>len()</code>, <code>cap()</code> 均返回数组的第一维长度</li>
<li>指针数组是指元素为指针的数组, 如 <code>arr := [3]*int{&amp;x, &amp;y}</code> , 数组指针是内存中数组的地址, 如<code>&amp;arr</code>. 数组指针可来操作元素</li>
<li>数组是值类型, 赋值和传参都会复制整个数组数据, 可以使用指针或切片,避免数据复制</li>
</ul>
<p>代码示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(x [2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"x: %p, %v\n"</span>, &amp;x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(p *[2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"p: %p, %v\n"</span>, p, *p)</span><br><span class="line">    p[<span class="number">1</span>] += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    b := a</span><br><span class="line">    fmt.Printf(<span class="string">"a: %p, %v\n"</span>, &amp;a, a)</span><br><span class="line">    fmt.Printf(<span class="string">"b: %p, %v\n"</span>, &amp;b, b)</span><br><span class="line">    test1(a)</span><br><span class="line">    test2(&amp;a)</span><br><span class="line">    fmt.Printf(<span class="string">"a: %p, %v\n"</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a: 0xc00000a0d0, [1 2]</span></span><br><span class="line"><span class="comment">// b: 0xc00000a0e0, [1 2]</span></span><br><span class="line"><span class="comment">// x: 0xc00000a130, [1 2]</span></span><br><span class="line"><span class="comment">// p: 0xc00000a0d0, [1 2]</span></span><br><span class="line"><span class="comment">// a: 0xc00000a0d0, [1 102]</span></span><br></pre></td></tr></table></figure>

<h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 <code>slice</code></h2><p>切片的一般形式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sliceName []Type = []Type&#123;element1, element2, element3...&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>可使用内置函数 <code>make([]Type, len, cap)</code> 初始化一个长度为 <code>len</code> 元素值为默认值的切片, 并完成长度为 <code>cap</code> 用于存储底层数据的数组的内存分配. 其中 <code>cap</code> 为容量, 可以省略(默认为 <code>len</code>), 否则必须大于等于 <code>len</code>. 切片的长度及容量均可超过其初始定义时的长度和容量, 此时会为底层数组重新分配内存地址空间</li>
<li>切片是<strong>引用类型</strong>, 所有在函数内的对其元素的操作都会作用到其底层数据结构上</li>
<li>可基于数组或数组指针创建切片, 以开始索引或结束索引确定切片所引用的数据字段. 不支持反向索引</li>
<li>使用形如 <code>var s []int</code> 创建的切片为 <code>nil</code></li>
<li>切片支持使用索引号访问元素内容</li>
<li><code>append()</code> 可用于向切片尾部添加数据, 返回对象的内存地址不会发生改变, 但是如果 <code>append</code> 后的切片超过 <code>cap</code> 容量, 则会为底层数组重新分配内存空间. 新分配的 <code>cap</code> 容量为一般初始 <code>cap</code> 容量的整数倍</li>
<li><code>copy(dst, src []Type)</code> 可用于在两个切片对象间复制数据, 最终所复制的数据以较短的切片长度为准.</li>
</ul>
<p>代码示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nilSli []<span class="keyword">int</span></span><br><span class="line">    fmt.Println(nilArr == <span class="literal">nil</span>)  <span class="comment">// true</span></span><br><span class="line">    sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%v,%v,%p\n"</span>, &amp;sli, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli), &amp;sli[<span class="number">0</span>])</span><br><span class="line">    arr = <span class="built_in">append</span>(arr, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;...)</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%v,%v,%p\n"</span>, &amp;sli, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli), &amp;sli[<span class="number">0</span>])  </span><br><span class="line">    <span class="comment">// 可以看到 append 前后 `&amp;arr` 没有变化, 但是 `cap(arr) 变为原来的 2 倍,实际上是对底层数组重新分配了新的内存空间(原来数组的内存空间也会被重新分配)</span></span><br><span class="line">    p := &amp;sli</span><br><span class="line">    p0 := &amp;sli[<span class="number">0</span>]</span><br><span class="line">    p1 := &amp;sli[<span class="number">1</span>]</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%p,%p\n"</span>, p, p0, p1)</span><br><span class="line">    (*p)[<span class="number">0</span>] += <span class="number">100</span></span><br><span class="line">    *p1 += <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, sli) <span class="comment">// [100 100 1 2 3 4 5 6]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 0xc0000044c0,2,5,0xc00000c300</span></span><br><span class="line"><span class="comment">// 0xc0000044c0,8,10,0xc000014190</span></span><br><span class="line"><span class="comment">// 0xc0000044c0,0xc000014190,0xc000014198</span></span><br><span class="line"><span class="comment">// [100 100 1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] += <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v,%p\n"</span>, s, &amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">32</span>&#125;  <span class="comment">// 等价于 var s = make([]int, 3, 3); s = []int&#123;1, 20, 32&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v,%p\n"</span>, s, &amp;s)</span><br><span class="line">    change(s)</span><br><span class="line">    fmt.Printf(<span class="string">"%v,%p\n"</span>, s, &amp;s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// [1 20 32],0xc0000044c0</span></span><br><span class="line"><span class="comment">// [101 20 32],0xc000004520</span></span><br><span class="line"><span class="comment">// [101 20 32],0xc0000044c0</span></span><br></pre></td></tr></table></figure>

<h2 id="字典-map"><a href="#字典-map" class="headerlink" title="字典 map"></a>字典 <code>map</code></h2><p>字典的一般形式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mapName <span class="keyword">map</span>[KeyType]ValueType = <span class="keyword">map</span>[KeyType]ValueType&#123;</span><br><span class="line">    KeyType: ValueType,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>字典是引用类型, 一般使用 <code>make(map[KeyType]ValueType, size)</code> 或初始化语句表达式创建. 内容为空的字典已经做了初始化操作, 与 <code>nil</code> 是不同的</li>
<li>函数 <code>len()</code> 返回当前键值对数量</li>
<li>Key 必须支持等值比较(<code>==</code>, <code>!=</code>), 类型可以为数字,字符串,指针,数组,结构体,接口等类型.常见的一般为字符串</li>
<li>访问键值时, 推荐使用 <code>v, ok := m[key]</code> 模式. 可以通过 <code>ok</code> 判断键是否存在. 如果存在, <code>ok</code> 会返回 <code>true</code>; 否则, 返回 <code>false</code></li>
<li>字典是一种无序键值对集合, 对字典进行 for-range 遍历, 每次遍历的次序都不相同</li>
<li>因为访问安全和哈希算法的缘故, 字典被设计为 “not addressable”, 因此不能直接修改 <code>value</code> 成员(结构体或数组). 只能返回整个 <code>value</code>, 修改后重新对字典赋值. 或直接使用指针类型</li>
</ul>
<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nilMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">    fmt.Println(nilMap == <span class="literal">nil</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]user, <span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%v\n"</span>, &amp;m, m)</span><br><span class="line">    m[<span class="string">"tom"</span>] = user&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;</span><br><span class="line">    m[<span class="string">"jack"</span>] = user&#123;<span class="string">"jack"</span>, <span class="number">21</span>&#125;</span><br><span class="line">    m[<span class="string">"lucy"</span>] = user&#123;<span class="string">"lucy"</span>, <span class="number">19</span>&#125;</span><br><span class="line">    v, ok := m[<span class="string">"liming"</span>]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%p,%v\n"</span>, &amp;m, m)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)  <span class="comment">// 每次输出循序都不一样</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//m["lucy"].age += 1 // 报错, cannot assign to `m["lucy"].age`, 不能对字典值的成员变量直接赋值</span></span><br><span class="line">    lucy := m[<span class="string">"lucy"</span>]</span><br><span class="line">    lucy.age += <span class="number">1</span></span><br><span class="line">    m[<span class="string">"lucy"</span>] = lucy</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 0xc000006030,map[]</span></span><br><span class="line"><span class="comment">// 0xc000006030,map[jack:&#123;jack 21&#125; lucy:&#123;tom 19&#125; tom:&#123;tom 20&#125;]</span></span><br><span class="line"><span class="comment">// tom &#123;tom 20&#125;</span></span><br><span class="line"><span class="comment">// jack &#123;jack 21&#125;</span></span><br><span class="line"><span class="comment">// lucy &#123;tom 19&#125;</span></span><br><span class="line"><span class="comment">// map[jack:&#123;jack 21&#125; lucy:&#123;tom 20&#125; tom:&#123;tom 20&#125;]</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 <code>struct</code></h2><p><code>struct</code> 将多个不通类型的字段序列打包成一个复合类型, 类似于<code>类</code>的概念. 一般定义方式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> structName <span class="keyword">struct</span>&#123;</span><br><span class="line">    fieldName fieldType</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>字段名必须唯一, 支持使用 <code>_</code> 补位字段名(忽略该字段). 支持直接指定字段类型, 从而使用匿名字段, 实际上是使用与类型名相同的字段</li>
<li>可直接使用 <code>structName.fieldName</code> 访问结构体字段. 对于匿名字段, 可以使用 <code>structName.fieldType</code> 访问该匿名字段</li>
<li>由于 Go 语言底层的优化, 可使用结构体指针直接操作结构体字段 如, 如果 <code>p := &amp;structName</code>, 则 <code>*(p).fieldName</code> 等价于 <code>p.fieldName</code></li>
<li>结构体支持多个结构体嵌套, 可以理解为:<strong>内层结构体作为外层结构体一个或多个匿名或非匿名字段</strong>.</li>
<li><strong>结构体嵌套过程中, 如果内层结构体(innerStructName)与外层结构体(outerStructName)有相同的字段 <code>fieldName</code>, 则 <code>outerStructName.fieldName</code> 表示访问外层结构体. 内层结构体 <code>fieldName</code> 字段只能通过 <code>outerStructName.innerStructFieldName.fieldName</code> 访问.<br>如果外层结构体没有内层结构体字段<code>innerFieldName</code>, 则可以通过 <code>outerStructName.innerFieldName</code> 访问 <code>innerFieldName</code> 字段.其实就是就近原则</strong></li>
<li>如果多个内层结构体有相同的字段, 则必须指定内层结构体名称才能访问到该字段,否则会编译报错</li>
</ul>
<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">    _    <span class="keyword">string</span></span><br><span class="line">    _    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    <span class="comment">//int  // 报错, 重复定义 int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    inneruser1</span><br><span class="line">    inneruser2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> inneruser1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> inneruser2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    age   <span class="keyword">int</span></span><br><span class="line">    score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := test&#123;</span><br><span class="line">        Name: <span class="string">"test"</span>,</span><br><span class="line">        Age:  <span class="number">20</span>,</span><br><span class="line">        <span class="keyword">int</span>:  <span class="number">4</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">    u := user&#123;</span><br><span class="line">        name:       <span class="string">"outeruser"</span>,</span><br><span class="line">        inneruser1: inneruser1&#123;<span class="string">"inneruser1"</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        inneruser2: inneruser2&#123;<span class="string">"inneruser2"</span>, <span class="number">20</span>, <span class="number">89.5</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(u.name)</span><br><span class="line">    <span class="comment">// fmt.Println(u.age) // 报错, Ambiguous reference 'age', 编译器搞不清使用哪个 age</span></span><br><span class="line">    fmt.Println(u.inneruser1.age)</span><br><span class="line">    fmt.Println(u.score)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;test 20   4&#125;</span></span><br><span class="line"><span class="comment">// outeruser</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 89.5</span></span><br></pre></td></tr></table></figure>

<h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p>字段标签并不是注释, 而是用来对字段进行描述的元数据.</p>
<ul>
<li>在运行期间, 可用反射获取标签信息, 常被用作格式校验, 数据库关系映射等.</li>
<li>由于 Go 中私有变量与可导入变量是通过首字母大小写区分的. 因此对于可导入变量, 还可以用作 json 格式化输出字段</li>
</ul>
<p>示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// `` 反引号中的内容为该字段的 tag 标签</span></span><br><span class="line">    Age  <span class="keyword">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := user&#123;</span><br><span class="line">        Name: <span class="string">"tom"</span>,</span><br><span class="line">        Age:  <span class="number">10</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    val := reflect.ValueOf(u)</span><br><span class="line">    valType := val.Type()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%v: %v\n"</span>, valType.Field(i).Tag.Get(<span class="string">"json"</span>), val.Field(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str, err := json.Marshal(u)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"格式转换出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(str))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// name: tom</span></span><br><span class="line"><span class="comment">// age: 10</span></span><br><span class="line"><span class="comment">// &#123;"name":"tom","age":10&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之并发</title>
    <url>/2020/04/30/go-study-notes-concurrency/</url>
    <content><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>首先理解一下并发(concurrency) 与并行(parallesim)</p>
<ul>
<li>并发: 在一段时间内交替做不同事情的能力, 可以理解为单线程(协程)/多线程运行在单核处理器上, 如果有其中一个任务/线程阻塞, CPU 立即切换, 执行另一个任务/线程的代码逻辑</li>
<li>并行: 在同一时刻做不同事情的能力, 可以理解为多线程运行在多核处理器上, 一个线程绑定一个 CPU, 多个 CPU 同时处理代码逻辑</li>
</ul>
<p>我们通常所说的程序是并发设计的, 允许多个任务同时执行. 但实际上,在单核处理器上, 某一时刻, 一个 CPU 只能处理一个任务. 而多个任务是以切换方式进行的, 只不过切换时间非常短, 我们无法感知.</p>
<p>而并行依赖多核处理器, 让多个任务真正在同一时刻进行. 因此多线程或多进程是并行的基本条件.</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>Go 语言中采用 <code>goroutine</code> 来处理并发任务, <code>goroutine</code> 是建立在线程之上的轻量级抽象, 它允许我们以非常低的代价在同一地址空间中并行地执行多个函数或方法. 相比于线程, 它的创建和销毁的代价要小很多. <code>goroutine</code> 所需要的内存通常只有 2KB, 线程所需要的内存默认 MB 级别</p>
<p>在 Go 中创建一个 <code>goroutine</code> 非常简单, 在函数调用前加 <code>go</code> 关键字即可创建并发任务.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>  // 创建一个 <span class="title">goroutine</span></span></span><br></pre></td></tr></table></figure>

<p>需要注意的是, <code>go</code> 关键字并非执行并发操作, 而是创建一个并发任务单元. 新建的任务被放置在系统队列中, 等待调度器安排合适的系统线程执行. 当前任务流程不会阻塞, 不会等待该任务启动或结束, 且运行时也不保证并发任务的执行次序.</p>
<p>与 <code>defer</code> 定义的延迟调用函数一样, <code>go</code> 定义的 <code>goroutine</code> 函数也会立即计算并记录当时上下文中参数对象的状态, 并复制参数对象用于真正调用时隐式传入.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c++</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"main: %p,%v\n"</span>, &amp;a, a)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)                <span class="comment">// 让 goroutine 在 mian 逻辑之后执行</span></span><br><span class="line">        fmt.Printf(<span class="string">"go: %p,%v,%v\n"</span>, &amp;x, x, y) <span class="comment">// 立即计算并复制参数</span></span><br><span class="line">    &#125;(a, counter())</span><br><span class="line"></span><br><span class="line">    a += <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"main: %p,%v,%v\n"</span>, &amp;a, a, counter())</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// main: 0xc000062090,100</span></span><br><span class="line"><span class="comment">// main: 0xc000062090,200,2</span></span><br><span class="line"><span class="comment">// go: 0xc00000a038,100,1</span></span><br></pre></td></tr></table></figure>

<p>以上代码只能通过 <code>time.sleep()</code> 的方式等待 <code>goroutine</code> 执行完毕, 我们不能判断 <code>goroutine</code> 中的任务何时执行结束, <code>main</code> 函数 <code>sleep</code> 的时间也就不能确定.</p>
<h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>为了解决以上问题,我们可以使用 <code>channel</code> 阻塞 <code>main</code> 函数,然后在 goroutine 中发出退出信号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 创建 channel</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"goroutine done"</span>)</span><br><span class="line">        <span class="built_in">close</span>(exit) <span class="comment">// 关闭 channel, 发出信号</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"main..."</span>)</span><br><span class="line">    val, ok := &lt;-exit <span class="comment">// 如果 channel 关闭,则可以解除阻塞</span></span><br><span class="line">    fmt.Println(val, ok) <span class="comment">// 但此时实际上是没有任何数据传入管道的,取出的数据为初始化时的定义类型的默认值,ok 为 false</span></span><br><span class="line">    fmt.Println(<span class="string">"main exit..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要等待多个任务结束, 推荐使用 <code>sync.WaitGroup</code>. 通过设定计数器, 让每个 goroutine 在退出时递减, 直到归 0 时解除阻塞.</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 每次新创建一个 goroutine, 计数器加 1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done() <span class="comment">// 每个 goroutine 执行完成后, 计数器减 1</span></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            fmt.Printf(<span class="string">"goroutine %v done\n"</span>, id)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"main..."</span>)</span><br><span class="line">    wg.Wait() <span class="comment">// 阻塞, 直到计数器归 0</span></span><br><span class="line">    fmt.Println(<span class="string">"main exit..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WaitGroup.Add</code> 实现了原子操作,但仍然建议在 <code>goroutine</code> 外累加计数器, 防止累加(Add)操作尚未执行, 阻塞(Wait)已经退出</p>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a><code>channel</code></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Go 鼓励使用 CSP(Communicating Sequential Process) channel, 以通信来代替内存共享,实现并发安全.</p>
<blockquote>
<p>Don’t communicate by sharing memory, share memory by communicating. 不要以共享内存来进行通信, 而是通过通信来共享内存.</p>
</blockquote>
<p>作为 CSP 核心, channel 是显式的, 要求操作双方必须知道数据类型和具体通道,但并不关心另一端操作者身份和数量. 可如果另一端未准备妥当或消息未及时处理时,会阻塞当前端.</p>
<p>channel 定义方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channelName = <span class="built_in">make</span>(<span class="keyword">chan</span> Type, [<span class="built_in">cap</span>])  <span class="comment">// 初始化缓冲区容量为 cap 的 channel, 用于传递 Type 类型的对象.其中 cap 可省略</span></span><br></pre></td></tr></table></figure>

<h3 id="channel-注意事项"><a href="#channel-注意事项" class="headerlink" title="channel 注意事项"></a>channel 注意事项</h3><ul>
<li>缓冲区大小仅是内部属性, 不属于类型组成部分. channel 本身就是指针, 可用相等操作符判断是否为同一对象或 nil</li>
<li>内置函数 <code>cap()</code> 和 <code>len()</code> 返回缓冲区大小和当前已缓冲数量.而对于同步通道(cap 为 0 的 channel)则都返回 0, 据此可判断通道是同步(0)还是异步(非0).</li>
<li>同步模式(cap 为 0 的 channel)必须有成对的发送/接收数据的 goroutine 出现, 否则会一直阻塞</li>
<li>channel 支持使用 ok-idom 或 for-range 模式处理数据.其中 for-range 模式只能处理已关闭的具有缓冲区的 channel,否则会引发死锁 <code>fatal error: all goroutines are asleep - deadlock</code>.若 channel 已关闭,则 ok-idom 返回值为 <code>defaultValue, false</code>.可通过 ok 判断 channel 是否已经关闭,取值是否可用</li>
<li>向已关闭的 channel 发送数据,会引发 panic.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(intChan)  <span class="comment">// 关闭 intChan</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        intChan &lt;- i  <span class="comment">// 向 intChan 发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPrime</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value &lt;= <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> value%<span class="number">2</span> == <span class="number">0</span> || value%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">5</span>; i*i &lt;= value; i += <span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> value%i == <span class="number">0</span> || value%(i+<span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>, outChan <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> value := <span class="keyword">range</span> intChan &#123;  <span class="comment">// 通过 for-range 遍历已关闭的 intChan 中的数据</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(value) &#123;</span><br><span class="line">            outChan &lt;- value  <span class="comment">// 找到符合条件的数据,发送到 outChan</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> inChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)  <span class="comment">// 定义缓冲区为 10 的 channel</span></span><br><span class="line">    <span class="keyword">var</span> outChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1000</span>) <span class="comment">// 定义缓冲区为 1000 的 channel</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> putNum(inChannel)    <span class="comment">// 已经在 putNum 中关闭了 inChannel</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> getNum(inChannel, outChannel, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(outChannel)   <span class="comment">// 关闭 outChannel,后面才可以使用 for-range 进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> outChannel &#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有缓冲与无缓冲的通道"><a href="#有缓冲与无缓冲的通道" class="headerlink" title="有缓冲与无缓冲的通道"></a>有缓冲与无缓冲的通道</h3><p>无缓冲的通道又称为阻塞通道或同步通道.先看一下下面的代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">10</span>    <span class="comment">// 在这里发生阻塞,等待通道的另一端进行接收</span></span><br><span class="line">    fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码能够通过编译,但是执行的时候会出现以下错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>原因是上述代码会阻塞在 <code>ch &lt;- 10</code> 这一行阻塞,形成死锁.解决此问题的方式为通过 goroutine 接收值.如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">"接收成功"</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch) <span class="comment">// 启用 goroutine 从通道另一端接收值</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决上述问题的还有一种方法是创建有缓冲区的通道.我们可以在使用 <code>make</code> 函数初始化通道时指定通道的容量,如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h4><p>channel 默认是双向的, 并不区分发送和接收端. 但我们可在定义时, 指定其为单向 channel, 且不能在单向 channel 上做逆向操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// &lt;-send // 报错, invalid operation: &lt;-send (recevice from send-only type chan&lt;- int), 无效操作</span></span><br><span class="line"><span class="comment">// recv &lt;- 1</span></span><br></pre></td></tr></table></figure>

<h4 id="select-多路复用"><a href="#select-多路复用" class="headerlink" title="select 多路复用"></a><code>select</code> 多路复用</h4><p>如要同时处理多个 channel, 可选用 <code>select</code> 语句.</p>
<p><code>select</code> 语句与 <code>switch</code> 语句类似, 它要求每个 case 必须是一个通信操作, 要么发送要么接收. 它会随机执行一个可运行的 case. 如果没有 case 可运行, 则会执行 default 或一直阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    ach, bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            name <span class="keyword">string</span></span><br><span class="line">            x    <span class="keyword">int</span></span><br><span class="line">            ok   <span class="keyword">bool</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> x, ok = &lt;-a:</span><br><span class="line">                name = <span class="string">"a"</span></span><br><span class="line">            <span class="keyword">case</span> x, ok = &lt;-b:</span><br><span class="line">                name = <span class="string">"b"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(name, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(&amp;wg, ach, bch)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, a, b <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(a)</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(b)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> a &lt;- i:</span><br><span class="line">            <span class="keyword">case</span> b &lt;- i * <span class="number">10</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(&amp;wg, ach, bch)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>default 可用于 处理一些默认逻辑, 如添加新的缓存 channel 等.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    data := []<span class="keyword">chan</span> <span class="keyword">int</span>&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> data[<span class="built_in">len</span>(data)<span class="number">-1</span>] &lt;- i:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                data = <span class="built_in">append</span>(data, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>))  <span class="comment">// default 语句用于添加新的 channel 等.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-done <span class="comment">// 阻塞, 直到 goroutine 执行结束</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">        c := data[i]</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> c &#123;</span><br><span class="line">            fmt.Println(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="channel-应用"><a href="#channel-应用" class="headerlink" title="channel 应用"></a>channel 应用</h4><p>channel 本身就是一个并发安全的队列, 可用作 ID 生成器, Pool 等用途</p>
<p>如下是 Pool 的简单实现:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pool <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPool</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">pool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">cap</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pool)</span> <span class="title">get</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bytes []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> bytes = &lt;-p:</span><br><span class="line">        fmt.Println(<span class="string">"获取成功并返回"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"获取失败, 返回默认"</span>)</span><br><span class="line">        bytes = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pool)</span> <span class="title">put</span><span class="params">(bytes []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> p &lt;- bytes:</span><br><span class="line">        fmt.Println(<span class="string">"放回成功"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"放回失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在 Go 代码中可能会存在多个 goroutine 同时操作一个资源,这种情况会发生数据竞争问题.如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(wg *sync.WaitGroup, x *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        *x = *x + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> add(&amp;wg, &amp;x)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现与预期结果不符,原因是两个 goroutine 在访问和修改 x 变量的时候会存在数据竞争.</p>
<p>为解决以上问题,Go 引入了锁的概念.Go 语言中使用 <code>sync.Mutex</code> 类型来实现互斥锁.使用互斥锁来修复上面代码的问题:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(wg *sync.WaitGroup, x *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">        *x = *x + <span class="number">1</span></span><br><span class="line">        lock.Unlock() <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> add(&amp;wg, &amp;x)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁虽然保障了数据的准确性,但是加锁是非常消耗性能的一种做法.因此合理使用锁机制是 Go 语言中高性能并发的关键因素之一.</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>加锁操作因为涉及内核态的上下文切换会比较耗时.针对基本数据类型我们还可以使用原子操作来保证并发安全.性能比加锁操作更好.</p>
<p>Go 语言中原子操作由内置的标准库 <code>sync/atomic</code> 提供.常用的方法如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 int32 或 int64 数据修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="keyword">int64</span>, delta <span class="keyword">int64</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="keyword">uint32</span>, delta <span class="keyword">uint32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="keyword">uint64</span>, delta <span class="keyword">uint64</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">uint64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 int32 或 int64 数据写入到指定地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="keyword">int32</span>, val <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="keyword">int64</span>, val <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="keyword">uint32</span>, val <span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="keyword">uint64</span>, val <span class="keyword">uint64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取指定地址的 int32 或 int64 数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="keyword">int32</span>)</span> <span class="params">(val <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="keyword">int64</span>)</span> <span class="params">(val <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="keyword">uint32</span>)</span> <span class="params">(val <span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="keyword">uint64</span>)</span> <span class="params">(val <span class="keyword">uint64</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较并交换.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="keyword">int64</span>, old, <span class="built_in">new</span> <span class="keyword">int64</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="keyword">uint32</span>, old, <span class="built_in">new</span> <span class="keyword">uint32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="keyword">uint64</span>, old, <span class="built_in">new</span> <span class="keyword">uint64</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 虽然不清楚什么意思.但是在 sync.waitgroup.go#func (wg *WaitGroup) Wait() 函数有用到.先记录一下</span></span><br></pre></td></tr></table></figure>

<p>使用原子操作对上面变量 x 进行修改.代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(wg *sync.WaitGroup, x *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        atomic.AddInt64(x, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> add(&amp;wg, &amp;x)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goroutine</tag>
        <tag>面试</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之语言陷阱</title>
    <url>/2020/05/17/go-study-notes-maybe-trap/</url>
    <content><![CDATA[<h2 id="range-复用临时变量"><a href="#range-复用临时变量" class="headerlink" title="range 复用临时变量"></a><code>range</code> 复用临时变量</h2><p>先来看一段简单的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    arr := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"(%v,%v)"</span>, i, v)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// (3,3)(3,3)(3,3)(3,3)</span></span><br></pre></td></tr></table></figure>

<p>程序并没有像我们预期的一样遍历切片 <code>arr</code>,而是全部打印其索引下标.其实有两点原因会导致这个问题</p>
<ul>
<li><code>for range</code> 下的迭代变量 i, v 的值是共用的</li>
<li>main 函数所在的 goroutine 与后续启动的 goroutine 存在竞争关系,可通过 <code>go run -race main.go</code> 看到 goroutine 之间的竞争关系</li>
</ul>
<p>因此,<code>range</code> 在迭代写过程中,多个 goroutine 并发地去读,导致传入闭包中 i,v 数据一直在做更改,从而出现上述情况</p>
<p>可以使用函数函数参数做一次数据复制,而不是闭包.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    arr := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 这里有一个实参到形参的值拷贝</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i, v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"(%v,%v)"</span>, i, v)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i, v)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下: 随着 goroutine 执行完成顺序不同,输出顺序也会发生改变</span></span><br><span class="line">(<span class="number">3</span>,<span class="number">3</span>)(<span class="number">0</span>,<span class="number">0</span>)(<span class="number">1</span>,<span class="number">1</span>)(<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到新程序的结果符合预期.其实质是在迭代过程中,向函数传参时, <code>i,v</code> 的值已经传递给 <code>a,b</code>(值拷贝),因此输出的值也是遍历之后的值</p>
<h2 id="defer-陷阱"><a href="#defer-陷阱" class="headerlink" title="defer 陷阱"></a><code>defer</code> 陷阱</h2><p>先来看一下如下几个函数的执行结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += <span class="number">5</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        r += <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"f1=%v,f2=%v,f3=%v"</span>, f1(), f2(), f3())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line">f1=<span class="number">3</span>,f2=<span class="number">5</span>,f3=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个理解起来可能有些难度,我们逐个进行分析</p>
<p>首先,我们要明白在以上函数中, <code>r</code> 作为返回值,在函数定义时,已经被定义并赋值为 <code>return</code> 关键字返回的值.因此</p>
<ol>
<li>在 <code>f1</code> 中, <code>r</code> 的初始值为 2.在函数返回之前 <code>defer</code> 修饰的闭包函数对 <code>r</code> 的值做了修改.通过本篇文章中第一个示例可以看出,闭包函数中的操作会影响到函数的返回值.因此 <code>f1</code> 在返回之前会执行闭包函数而修改 <code>r</code> 的值(自增).因此返回 3</li>
<li>在 <code>f2</code> 中, <code>r</code> 的初始值为变量 <code>t</code> 的值(变量 <code>t</code> 做值拷贝后将值传给 <code>r</code>), 为 5.在函数返回之前 <code>defer</code> 修饰的闭包函数对 <code>t</code> 的值做了修改,而 <code>r</code> 的值没有受到影响.因此 <code>f2</code> 的返回值是 5</li>
<li>在 <code>f3</code> 中, <code>r</code> 的初始值为 1.在函数返回之前, 将 <code>r</code> 做值拷贝后将值作为参数传递给 <code>defer</code> 修饰的函数(非闭包),<code>defer</code> 修饰的函数中的操作对外部参数 <code>r</code> 没有影响.因此 <code>f3</code> 的返回值是 1</li>
</ol>
<p>其实以上主要是闭包函数在使用过程中可能忽略的陷阱,而我们要始终知道的是 <strong>Go 中所有的变量赋值及参数传递均为值拷贝,变量值可能是具体的一个对象,也可能是指向某一对象的内存地址.而闭包不会进行参数传递,闭包函数内与外的变量都使用同一内存地址</strong></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="创建方式与底层数据结构"><a href="#创建方式与底层数据结构" class="headerlink" title="创建方式与底层数据结构"></a>创建方式与底层数据结构</h3><p>切片的创建方式如下:</p>
<ul>
<li>通过数组创建</li>
<li>通过内置的 make 函数创建</li>
<li>直接声明</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s1 := arr[:]</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s4 []<span class="keyword">int</span>  <span class="comment">// s4 = nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $&#123;GOROOT&#125;/src/runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer    <span class="comment">// 底层其实是一个数组</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是以哪种类型创建,其数据的底层存储都是数组.且由 <code>${GOROOT}/src/runtime/slice.go</code> 可以看出切片的数据结构有 3 个成员,分别是指向底层数组的指针,切片的当前大小和底层数组的大小.当 len 增长超过 cap 时,会申请一个更大容量的底层数组,并将数据复制过来</p>
<p>需要注意的是 <code>var s = make([]int, 0)</code> 与 <code>var s []int</code> 创建的对象是有区别的,前者会对底层数组进行内存分配,并初始化为没有值的切片,后者不会进行内存分配,其实为 nil.</p>
<h3 id="多个切片引用同一底层数组引发的混乱"><a href="#多个切片引用同一底层数组引发的混乱" class="headerlink" title="多个切片引用同一底层数组引发的混乱"></a>多个切片引用同一底层数组引发的混乱</h3><p>使用内置函数 <code>append</code> 扩展切片过程中可能会修改底层数组的元素,间接影响其它切片的值,也可能引发数组重建,可能会引发意想不到的错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [<span class="number">7</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    a := arr[:]</span><br><span class="line">    b := arr[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">    as := (*reflect.SliceHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">    bs := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"a=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a), &amp;a, as.Data)</span><br><span class="line">    fmt.Printf(<span class="string">"b=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b), &amp;b, bs.Data)</span><br><span class="line"></span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"arr=%v,len=%d,cap=%d,pointer=%p\n"</span>, arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">    fmt.Printf(<span class="string">"a=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a), &amp;a, as.Data)</span><br><span class="line">    fmt.Printf(<span class="string">"b=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b), &amp;b, bs.Data)</span><br><span class="line"></span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">13</span>, <span class="number">14</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"arr=%v,len=%d,cap=%d,pointer=%p\n"</span>, arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">    fmt.Printf(<span class="string">"a=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a), &amp;a, as.Data)</span><br><span class="line">    fmt.Printf(<span class="string">"b=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b), &amp;b, bs.Data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// a=[0 1 2 3 4 5 6],len=7,cap=7,pointer=0xc000098420, type=824634474624</span></span><br><span class="line"><span class="comment">// b=[0 1 2 3],len=4,cap=7,pointer=0xc000098440, type=824634474624</span></span><br><span class="line"><span class="comment">// arr=[0 1 2 3 10 11 12],len=7,cap=7,pointer=%!p(MISSING)</span></span><br><span class="line"><span class="comment">// a=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc000098420, type=824634474624</span></span><br><span class="line"><span class="comment">// b=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc000098440, type=824634474624</span></span><br><span class="line"><span class="comment">// arr=[0 1 2 3 10 11 12],len=7,cap=7,pointer=%!p(MISSING)</span></span><br><span class="line"><span class="comment">// a=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc000098420, type=824634474624</span></span><br><span class="line"><span class="comment">// b=[0 1 2 3 10 11 12 13 14],len=9,cap=14,pointer=0xc000098440, type=824634605680</span></span><br></pre></td></tr></table></figure>

<p>由输出可以看出:</p>
<ul>
<li>在第一次调用 <code>append</code> 函数向切片 b 追加元素后,底层数组 arr 的值发生改变.从而导致切片 a 中元素也发生改变</li>
<li>第二次调用 <code>append</code> 函数向切片 b 追加元素后,由于 <code>len(b) &gt; cap(b)</code>,底层数组重新分配内存空间,产生更大容量的数组结构,并将原来数组值复制到新数组.原始数组 arr 不发生变化</li>
</ul>
<h2 id="传值还是传引用"><a href="#传值还是传引用" class="headerlink" title="传值还是传引用"></a>传值还是传引用</h2><p>Go 中所有的变量赋值及参数传递均为值拷贝.</p>
<ul>
<li>当变量赋值或参数传递为指针时,同样是值拷贝,但是指针及其副本指向的地址是同一个地址,因此操作的是同一数据</li>
<li>当变量赋值或参数传递为引用类型数据时(<code>chan,map,slice</code>),其内部都是通过指针指向具体的数据,实际上相当于传递了指针的副本</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>面试</tag>
        <tag>trap</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之表达式</title>
    <url>/2020/04/30/go-study-notes-expression/</url>
    <content><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针会分配内存空间, 相当于一个专门用来保存对象地址的整型变量. 它有自身的内存地址, 其值为另外一个对象的内存地址</p>
<ul>
<li>取址运算符 <code>&amp;</code> 用于获取对象地址.</li>
<li>指针运算符 <code>*</code> 用于间接引用目标对象.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    p := &amp;x</span><br><span class="line">    fmt.Printf(<span class="string">"p 的类型为:%T, p 的地址为:%p\n"</span>, p, &amp;p) <span class="comment">// p 为 *int 类型,有自己的地址,</span></span><br><span class="line">    fmt.Printf(<span class="string">"p 的值为:%v, x 的地址为:%p\n"</span>, p, &amp;x)  <span class="comment">// 变量 p 保存了 x 的内存地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"x 的值为:%v, p 的引用值为:%v\n"</span>, x, *p) <span class="comment">// p 的引用为变量 x 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在结构体指针引用使用过程中, 由于 Go 语言底层做了优化, 对结构体属性的访问可直接使用指针变量进行, 如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        age <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    stu := Student&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;</span><br><span class="line">    p := &amp;stu</span><br><span class="line">    (*p).Name=<span class="string">"jack"</span>  <span class="comment">// 先使用指针进行引用后, 对引用对象属性进行修改, 但是看起来比较复杂</span></span><br><span class="line">    p.Name = <span class="string">"jack"</span>   <span class="comment">// 与上述引用相同, Go 语言在底层做了优化, 看起来/写起来比较简单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h2><p>主要有两种形式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> x &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 其中, index 表示 x 的索引下标, value 为 x 对应索引下标的值</span></span><br><span class="line">    <span class="comment">// 可使用 _ 对其中元素进行站位操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 中没有 <code>while</code>, <code>until</code> 等关键字, 因此没有 <code>while true</code> 或 <code>do...until</code> 等形式, 我们可以使用 <code>for</code> + <code>if</code> 条件判断达到类似的效果. 如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一直循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do...while 形式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">if</span> expression &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if-else-流程控制"><a href="#if-else-流程控制" class="headerlink" title="if-else 流程控制"></a><code>if-else</code> 流程控制</h2><p><code>if-else</code> 控制比较简单, 一般形式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch-流程控制"><a href="#switch-流程控制" class="headerlink" title="switch 流程控制"></a><code>switch</code> 流程控制</h2><p>与 <code>if-else</code> 类似相同, <code>switch</code> 语句也用于选择执行, 但具体使用场景会有所不同</p>
<p>一般来说具有以下特点:</p>
<ul>
<li>支持 <code>switch</code> 代码块内赋值等初始化语句</li>
<li><code>case</code> 语句支持多个匹配条件逻辑或</li>
<li>只有全部 <code>case</code> 语句匹配失败时才会执行 <code>default</code> 块</li>
<li>相邻的空 <code>case</code> 表示执行的代码块为空</li>
<li>无需显示指定 <code>break</code> 语句, <code>case</code> 执行完毕后自动中断</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> x := <span class="number">5</span>; x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">// 隐式 "case 0: break;"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">"工作日"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">        fmt.Println(<span class="string">"周末"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"错误输入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 可以用来替换 <code>if</code> 语句, 被省略的 <code>switch</code> 条件表达式默认为 <code>true</code>, 继而与 <code>case</code> 表达式结果匹配: 如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">20</span></span><br><span class="line">    <span class="keyword">switch</span>  &#123;</span><br><span class="line">    <span class="keyword">case</span> x &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">18</span>:</span><br><span class="line">        fmt.Println(<span class="string">"未成年人"</span>)</span><br><span class="line">    <span class="keyword">case</span> x &gt;= <span class="number">18</span>:</span><br><span class="line">        fmt.Println(<span class="string">"成年人"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"错误输入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select-随机选择控制"><a href="#select-随机选择控制" class="headerlink" title="select 随机选择控制"></a><code>select</code> 随机选择控制</h2><p><code>select</code> 是 Go 中的一个控制结构,其语法与 <code>switch</code> 流程控制类似.<code>select</code> 会随机执行一个可运行的 case.如果没有 case 可执行,则执行 default 语句块或阻塞直到有 case 可运行</p>
<p>一般来说语法结构如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> communicating_1:</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">case</span> communicating_2:</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 可选</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说具有以下特点:</p>
<ul>
<li>每个 case 都必须是一个通信过程</li>
<li>如果有多个 case 可运行, select 会随机选择一个执行,其它不会被执行</li>
<li>如果没有 case 可执行,则如果有 default 子句,执行该语句块;否则阻塞,直到某个通信可进行</li>
</ul>
<p>示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    data := []<span class="keyword">chan</span> <span class="keyword">int</span>&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> data[<span class="built_in">len</span>(data)<span class="number">-1</span>] &lt;- i:</span><br><span class="line">                fmt.Println(<span class="string">"case 1 执行"</span>)</span><br><span class="line">            <span class="keyword">case</span> data[<span class="built_in">len</span>(data)<span class="number">-1</span>] &lt;- i:</span><br><span class="line">                fmt.Println(<span class="string">"case 2 执行"</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                data = <span class="built_in">append</span>(data, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>))  <span class="comment">// default 语句用于添加新的 channel 等.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-done <span class="comment">// 阻塞, 直到 goroutine 执行结束</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">        c := data[i]</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> c &#123;</span><br><span class="line">            fmt.Println(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可看到 case 1 2 随机执行</span></span><br></pre></td></tr></table></figure>

<h3 id="fallthrough-关键字"><a href="#fallthrough-关键字" class="headerlink" title="fallthrough 关键字"></a><code>fallthrough</code> 关键字</h3><p><code>fallthrough</code> 关键字用于继续执行<strong>下一个</strong> <code>case</code> 语句, 必须放在 <code>case</code> 代码块末尾</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> x := <span class="number">0</span>; x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"0"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">"工作日"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">        fmt.Println(<span class="string">"周末"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"错误输入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 工作日</span></span><br></pre></td></tr></table></figure>

<h2 id="goto-continue-break-关键字"><a href="#goto-continue-break-关键字" class="headerlink" title="goto, continue, break 关键字"></a><code>goto</code>, <code>continue</code>, <code>break</code> 关键字</h2><ul>
<li><code>goto</code> 用于定点跳转, 代码跳转到指定标签的代码位置, 但不能跳转到其他函数或内层代码块内</li>
<li><code>continue</code> 仅用于 <code>for</code> 循环, 终止本次循环逻辑, 立即进入下一轮循环.</li>
<li><code>break</code> 用于 <code>switch</code>, <code>for</code>, <code>select</code> 语句, 跳出整个语句块</li>
</ul>
<p>配合标签, <code>continue</code> 和 <code>break</code> 可在多层嵌套中指定目标层级.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">outer:</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">5</span>; x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y &gt; <span class="number">2</span> &#123;</span><br><span class="line">                fmt.Println()</span><br><span class="line">                <span class="keyword">continue</span> outer</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> outer</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"%v:%v"</span>, x, y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// 0:0 0:1 0:2</span></span><br><span class="line"><span class="comment">// 1:0 1:1 1:2</span></span><br><span class="line"><span class="comment">// 2:0 2:1 2:2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 go 命令</title>
    <url>/2020/05/02/go-study-notes-go-command/</url>
    <content><![CDATA[<p>安装配置好 Go 语言环境之后, 让我们先来看一看 go 为我们提供了哪些命令, 以及这些命令可以做什么吧</p>
<p>查看 go 命令行帮助可以了解到 <code>go</code> 是用于管理 Go 代码的命令行工具.</p>
<p>它提供了很多子命令来实现各种功能. 使用方式为 <code>go &lt;command&gt; [arguments]</code>, 使用 <code>go help &lt;command&gt;</code> 可以查看子命令的帮助信息</p>
<p>以下是 go 的子命令及其简单描述</p>
<table>
<thead>
<tr>
<th align="center">子命令</th>
<th align="left">简单解释</th>
<th align="left">详细描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bug</td>
<td align="left">bug/issue 报告</td>
<td align="left">它会收集当前系统及 Go 语言信息, 在 <code>github/golang/go</code> 代码仓库中帮助你创建一个 issues</td>
</tr>
<tr>
<td align="center">build</td>
<td align="left">编译软件包和依赖</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">clean</td>
<td align="left">删除旧的对象文件和缓存文件</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">doc</td>
<td align="left">显示包及其内容或符号的帮助文档</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">env</td>
<td align="left">打印当前 Go 环境信息</td>
<td align="left">包括 <code>GO111MODULE</code>, <code>GOARCH</code>, <code>GOBIN</code>, <code>GOHOSTARCH</code>, <code>GOHOSTOS</code>, <code>GOPATH</code>, <code>GOPROXY</code>, <code>GOROOT</code>, <code>GOTOOLDIR</code>,<code>GOMOD</code> 等环境变量</td>
</tr>
<tr>
<td align="center">fix</td>
<td align="left">更新软件包以使用新的 API</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">fmt</td>
<td align="left">用于格式化 go 源代码</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">generate</td>
<td align="left">通过预处理源生成 Go 代码文件</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">get</td>
<td align="left">将依赖项添加到当前模块并安装它们</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">install</td>
<td align="left">编译并安装软件包和依赖</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">list</td>
<td align="left">列出软件包或模块</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">mod</td>
<td align="left">提供对模块的操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">run</td>
<td align="left">编译并运行 Go 程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">test</td>
<td align="left">测试包</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">tool</td>
<td align="left">运行指定的 go 工具</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">version</td>
<td align="left">打印 Go 版本信息</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">vet</td>
<td align="left">报告包中可能的错误</td>
<td align="left">一些语法上虽然没有错误, 但是逻辑上可能存在问题的错误, 如死循环</td>
</tr>
</tbody></table>
<p>它还提供了一些额外的话题帮助. 使用 <code>go help &lt;topic&gt;</code> 可以查看关于该话题的更多帮助.</p>
<table>
<thead>
<tr>
<th align="left">topic</th>
<th align="left">简单描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">buildmode</td>
<td align="left">构建模式</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">Go 与 C 语言间的调用</td>
</tr>
<tr>
<td align="left">cache</td>
<td align="left">简历并测试缓存</td>
</tr>
<tr>
<td align="left">environment</td>
<td align="left">环境变量</td>
</tr>
<tr>
<td align="left">filetype</td>
<td align="left">文件类型</td>
</tr>
<tr>
<td align="left">go.mod</td>
<td align="left">go.mod 文件, 该文件保存了项目依赖的模块, 类似于依赖包的集合(python 中的 requirements.txt 文件)</td>
</tr>
<tr>
<td align="left">gopath</td>
<td align="left"><code>GOPATH</code> 环境变量</td>
</tr>
<tr>
<td align="left">gopath-get</td>
<td align="left">早期的 go get 的 GOPATH</td>
</tr>
<tr>
<td align="left">goproxy</td>
<td align="left">访问 go module 的代理</td>
</tr>
<tr>
<td align="left">importpath</td>
<td align="left">import 导入包路径的语法</td>
</tr>
<tr>
<td align="left">modules</td>
<td align="left">模块, 模块版本等</td>
</tr>
<tr>
<td align="left">module-get</td>
<td align="left">go get 的模块感知</td>
</tr>
<tr>
<td align="left">module-auth</td>
<td align="left">使用 go.sum 进行身份认证</td>
</tr>
<tr>
<td align="left">module-private</td>
<td align="left">非公共模块的相关配置</td>
</tr>
<tr>
<td align="left">packages</td>
<td align="left">包</td>
</tr>
<tr>
<td align="left">testflag</td>
<td align="left">测试的标志</td>
</tr>
<tr>
<td align="left">testfunc</td>
<td align="left">测试函数</td>
</tr>
</tbody></table>
<h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a><code>go build</code></h2><p>构建编译包及其依赖, 但是不会安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build [-o output] [-i] [build flags] [packages]</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要构建的参数是单个目录中的 <code>.go</code> 列表文件, 则 build 会将其视为指定单个程序包的源文件列表</li>
<li>编译软件包时, build 会忽略以 <code>_test.go</code> 结尾的文件</li>
<li>编译单个 main 包时, build 将生成的可执行文件输出为第一个源代码文件名或源代码目录名文件(如 <code>go build ed.go rx.go</code> 生成 <code>ed</code>/<code>ed.exe</code>, <code>go build unix/sam</code> 生成 <code>sam</code>/<code>sam.exe</code>). 编译 Windows 系统可以执行文件时, 会添加 “.exe” 后缀</li>
<li>编译多个软件包或单个非 main 软件包时, build 会编译软件包, 但是会丢弃生成的对象. 仅用作检查是否可以构建软件包</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-o</code></td>
<td align="left">将生成的可执行文件或对象输出为指定的文件名或输出到指定目录</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="left">安装依赖的软件包</td>
</tr>
</tbody></table>
<p>以下标志是 <code>build</code>, <code>clean</code>, <code>get</code>, <code>install</code>, <code>list</code>, <code>run</code>, <code>test</code> 命令共享的</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-a</code></td>
<td align="left">强制重新构建编译已更新的软件包</td>
</tr>
<tr>
<td align="center"><code>-n</code></td>
<td align="left">打印命令, 但不运行</td>
</tr>
<tr>
<td align="center"><code>-p n</code></td>
<td align="left">可以并行运行的程序数量, 默认是可用的 CPU 数量</td>
</tr>
<tr>
<td align="center"><code>-race</code></td>
<td align="left">启用数据竞争检测, 仅支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64</td>
</tr>
<tr>
<td align="center"><code>-msan</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>-v</code></td>
<td align="left">在编译时打印软件包名称</td>
</tr>
<tr>
<td align="center"><code>-work</code></td>
<td align="left">打印临时工作目录名, 退出时不要删除它</td>
</tr>
<tr>
<td align="center"><code>-x</code></td>
<td align="left">打印命令</td>
</tr>
<tr>
<td align="center"><code>-asm</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>-buildmode mode</code></td>
<td align="left">构建的模式选择, 可选模式为 <code>archive</code>, <code>c-archive</code>, <code>c-shared</code>, <code>default</code>, <code>shared</code>, <code>exe</code>, <code>pie</code>, <code>plugin</code>. 详见 <code>go help buildmode</code></td>
</tr>
<tr>
<td align="center"><code>-compiler name</code></td>
<td align="left">编译器的名称 如 <code>runtime.Compiler</code>(gccgo 或 gc)</td>
</tr>
<tr>
<td align="center"><code>-ldflags -X arg=value</code></td>
<td align="left">传递编译过程中调用的参数. 如在编译时将代码的 <code>git</code> 等信息作为参数值传入到代码变量中.见下面示例</td>
</tr>
<tr>
<td align="center"><code>-mod mode</code></td>
<td align="left">模块的下载模式: readonly 或 vendor</td>
</tr>
<tr>
<td align="center"><code>-pkgdir dir</code></td>
<td align="left">从指定目录安装和加载所有软件包, 在非标准配置进行构建时, 使用 -pkgdir 将生成的软件包保存在单独的位置</td>
</tr>
<tr>
<td align="center"><code>-tags tag,list</code></td>
<td align="left">以逗号分割的构建标记列表</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">BUILD_VERSION=<span class="variable">$&#123;TAG_VERSION&#125;</span></span><br><span class="line">BUILD_DATE=$(date -u +<span class="string">'%Y-%m-%dT%H:%M:%SZ'</span>)</span><br><span class="line">COMMIT_ID=$(git <span class="built_in">log</span> | head -n1 | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add_ldflag</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> key=<span class="variable">$&#123;1&#125;</span></span><br><span class="line">  <span class="built_in">local</span> val=<span class="variable">$&#123;2&#125;</span></span><br><span class="line">  ldflags+=(</span><br><span class="line">    <span class="string">"-X 'main.<span class="variable">$&#123;key&#125;</span>=<span class="variable">$&#123;val&#125;</span>'"</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add_ldflag <span class="string">'Version'</span> <span class="variable">$&#123;BUILD_VERSION&#125;</span></span><br><span class="line">add_ldflag <span class="string">'buildDate'</span> <span class="variable">$&#123;BUILD_DATE&#125;</span></span><br><span class="line">add_ldflag <span class="string">'gitCommit'</span> <span class="variable">$&#123;COMMIT_ID&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;ldflags[*]-&#125;</span>"</span></span><br><span class="line">go build -ldflags <span class="string">"<span class="variable">$&#123;ldflags[*]-&#125;</span>"</span> <span class="variable">$&#123;PRO_ROOT&#125;</span>/main.go -o <span class="variable">$&#123;PRO_ROOT&#125;</span>/main</span><br></pre></td></tr></table></figure>

<h2 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a><code>go clean</code></h2><p>从软件包源目录中删除目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go clean [clean flags] [build flags] [packages]</span><br></pre></td></tr></table></figure>

<p>go 命令在临时目录中构建大多数对象, 因此 <code>go clean</code> 主要与其它工具或手动调用 <code>go build</code> 留下的对象文件有关</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-i</code></td>
<td align="left">删除相应的已安装的归档文件或二进制文件</td>
</tr>
<tr>
<td align="center"><code>-n</code></td>
<td align="left">打印即将执行的删除命令, 但不运行</td>
</tr>
<tr>
<td align="center"><code>-r</code></td>
<td align="left">递归应用于包的所有依赖项</td>
</tr>
<tr>
<td align="center"><code>-x</code></td>
<td align="left">在执行删除命令时打印它们</td>
</tr>
<tr>
<td align="center"><code>-cache</code></td>
<td align="left">删除所有 <code>go build</code> 缓存</td>
</tr>
<tr>
<td align="center"><code>-modcache</code></td>
<td align="left">删除所有模块下载缓存, 包括源代码的版本依赖</td>
</tr>
</tbody></table>
<h2 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a><code>go doc</code></h2><p>显示帮助文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]</span><br></pre></td></tr></table></figure>

<p>打印指定对象的注释文档(package, const, func, type, var, method, struct), 然后打印其下属对象的单行摘要</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-all</code></td>
<td align="left">显示包所有的帮助文档</td>
</tr>
<tr>
<td align="center"><code>-c</code></td>
<td align="left">匹配符号时要注意大小写</td>
</tr>
<tr>
<td align="center"><code>-cmd</code></td>
<td align="left">将 command (package main) 视为常规程序包, 否则, 显示软件包的顶级文档时, 软件包主要的导出符号将被隐藏</td>
</tr>
<tr>
<td align="center"><code>-src</code></td>
<td align="left">显示该链接的完整源代码</td>
</tr>
<tr>
<td align="center"><code>-u</code></td>
<td align="left">显示未导出以及已导出符号, 方法和字段的文档</td>
</tr>
</tbody></table>
<h2 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a><code>go env</code></h2><p>输出 Go 环境变量信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go env [-json] [-u] [-w] [var ...]</span><br></pre></td></tr></table></figure>

<p>默认情况下, env 将信息作为 shell 脚本输出(在 Windows 中为批处理文件). 如果给定一个或多个变量的名称作为参数, 则输出每个变量的值</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-json</code></td>
<td align="left">以 JSON 格式输出环境变量</td>
</tr>
<tr>
<td align="center"><code>-u &lt;arg&gt; ...</code></td>
<td align="left">会取消 <code>go env -w NAME=VALUE</code> 设置的指定环境变量</td>
</tr>
<tr>
<td align="center"><code>-w &lt;NAME=VALUE&gt; ...</code></td>
<td align="left">修改默认环境变量值(不能新添自定义环境变量)</td>
</tr>
</tbody></table>
<h2 id="go-fix"><a href="#go-fix" class="headerlink" title="go fix"></a><code>go fix</code></h2><p>更新软件包以使用新的 API</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go fix [packages]</span><br></pre></td></tr></table></figure>

<h2 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a><code>go fmt</code></h2><p>格式化 go 代码包, 在指定包中运行 <code>gofmt -l -w</code>. 返回已修改文件的名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go fmt [-n] [-x] [packages]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-n</code></td>
<td align="left">只打印将要执行的命令</td>
</tr>
<tr>
<td align="center"><code>-x</code></td>
<td align="left">打印并执行命令</td>
</tr>
</tbody></table>
<h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a><code>go get</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]</span><br></pre></td></tr></table></figure>

<p>下载指定包及其依赖项, 然后安装它</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-d</code></td>
<td align="left">只下载包, 不要安装</td>
</tr>
<tr>
<td align="center"><code>-f</code></td>
<td align="left">仅在 <code>-u</code> 设置后才有效, 强制 <code>-u</code> 不验证每个包是否已从其导入路径所隐含的代码仓库导出. 如果是本地的 fork 源文件将很有用</td>
</tr>
<tr>
<td align="center"><code>-fix</code></td>
<td align="left">在解决依赖关系或构建代码之前, 先对下载的包运行 fix 工具</td>
</tr>
<tr>
<td align="center"><code>-insecure</code></td>
<td align="left">允许使用非安全方式从代码库中获取信息并解析自定义域名. 谨慎使用</td>
</tr>
<tr>
<td align="center"><code>-t</code></td>
<td align="left">对包生成测试所需的模块</td>
</tr>
<tr>
<td align="center"><code>-u</code></td>
<td align="left">使用网络更新指定的包及其依赖关系. 默认情况下, 使用网络检查丢失的软件包, 而不使用它来查找对现有包的更新</td>
</tr>
<tr>
<td align="center"><code>-v</code></td>
<td align="left">启用输出详细进度和调试信息</td>
</tr>
</tbody></table>
<p>checkout 新的包时, get 将创建目录 <code>GOPATH/src/&lt;import-path&gt;</code>. 如果 <code>GOPATH</code> 包含多个条目, 则默认使用第一个. 详见 <code>go help gopath</code>.</p>
<p>在 checkout 或更新软件包时, get 查找与本地安装的 Go 版本匹配的 brach 或 tag. 如果不存在这样的版本, 将获取包的默认分支.</p>
<p>当 go get checkout 或更新 git 仓库时, 它还会更新该存储库引用的所有 git 子模块</p>
<p>get 永远不会 checkout 或更新保存在 vendor 目录中的代码</p>
<h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a><code>go install</code></h2><p>编译并安装指定的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install [-i] [build flags] [packages]</span><br></pre></td></tr></table></figure>

<p>可执行文件安装在环境变量 <code>GOBIN</code> 所命名的目录中, 默认为 <code>$GOPATH/bin</code>. 如果没有设置 <code>GOPATH</code>, 则设置为 <code>$HOME/go/bin</code>. <code>$GOROOT</code> 中的可执行文件安装在 <code>$GOROOT/bin</code> 或 <code>$GOTOOLDIR</code> 中, 而不是 <code>$GOBIN</code>.</p>
<p>禁用 module-aware, 其它包安装在 <code>$GOPATH/pkg/$GOOS_$GOARCH</code>. 启用 module-aware, 将构建并缓存其它包, 但不安装.</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-i</code></td>
<td align="left">同时安装指定包的依赖</td>
</tr>
</tbody></table>
<h2 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a><code>go list</code></h2><p>列出指定包或其子包包名，每行一个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go list [-f format] [-json] [-m] [list flags] [build flags] [packages]</span><br></pre></td></tr></table></figure>

<p>默认打印包的导入路径, 每行一个. 使用 <code>...</code> 可以输出指定包及其子包. 如 <code>go list net/...</code> 列出 “net” 及其子包的导入路径, 每行一个</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-f</code></td>
<td align="left">使用包模版的语法指定列出包的输出格式</td>
</tr>
<tr>
<td align="center"><code>-json</code></td>
<td align="left">使用 json 格式输出列出的包的信息</td>
</tr>
<tr>
<td align="center"><code>-deps</code></td>
<td align="left">遍历包名及其依赖, 依赖以深度优先的后续遍历访问它们.</td>
</tr>
<tr>
<td align="center"><code>-export</code></td>
<td align="left">将给定包的信息导出到包的 <code>Export</code> 字段设置的文件名</td>
</tr>
<tr>
<td align="center"><code>-find</code></td>
<td align="left">列出指定的包, 但不解析其依赖关系, <code>Imports</code> 和 <code>Deps</code> 列表为空</td>
</tr>
<tr>
<td align="center"><code>-test</code></td>
<td align="left">列出指定的包及其测试二进制文件, 以将测试二进制文件的确切构造传达给代码分析工具</td>
</tr>
<tr>
<td align="center"><code>-m</code></td>
<td align="left">列出模块 , 而不是包</td>
</tr>
</tbody></table>
<p>最常用的标志是 <code>-f</code> , 它根据包和模块定义信息, 按照指定格式输出所需信息. 如 <code>&#39;\{\{ .ImportPath }}&#39;</code>(删除反斜线) 显示包的导入路径(默认), <code>&#39;\{\{ .Name }}&#39;</code>(删除反斜线)显示包的名称等.</p>
<p>包的详细定义信息见如下结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Package <span class="keyword">struct</span> &#123;</span><br><span class="line">        Dir           <span class="keyword">string</span>   <span class="comment">// 包含包源代码的目录</span></span><br><span class="line">        ImportPath    <span class="keyword">string</span>   <span class="comment">// 包在目录中的导入路径, `go list` 的默认输出格式</span></span><br><span class="line">        ImportComment <span class="keyword">string</span>   <span class="comment">// package语句的import注释中的路径</span></span><br><span class="line">        Name          <span class="keyword">string</span>   <span class="comment">// 包名称</span></span><br><span class="line">        Doc           <span class="keyword">string</span>   <span class="comment">// 包文档字符串</span></span><br><span class="line">        Target        <span class="keyword">string</span>   <span class="comment">// 安装路径</span></span><br><span class="line">        Shlib         <span class="keyword">string</span>   <span class="comment">// 包含此包的共享库（仅在-linkshared时设置）</span></span><br><span class="line">        Goroot        <span class="keyword">bool</span>     <span class="comment">// 这个包在GOROOT目录下吗?</span></span><br><span class="line">        Standard      <span class="keyword">bool</span>     <span class="comment">// 这个包是标准go库的一部分吗?</span></span><br><span class="line">        Stale         <span class="keyword">bool</span>     <span class="comment">// `go install`对这个包有什么作用码?</span></span><br><span class="line">        StaleReason   <span class="keyword">string</span>   <span class="comment">// explanation for Stale==true</span></span><br><span class="line">        Root          <span class="keyword">string</span>   <span class="comment">// 包含这个包的GOROOT或GOPATH目录</span></span><br><span class="line">        ConflictDir   <span class="keyword">string</span>   <span class="comment">// $GOPATH中的这个目录shadows dir</span></span><br><span class="line">        BinaryOnly    <span class="keyword">bool</span>     <span class="comment">// binary-only package (no longer supported)</span></span><br><span class="line">        ForTest       <span class="keyword">string</span>   <span class="comment">// package is only for use in named test</span></span><br><span class="line">        Export        <span class="keyword">string</span>   <span class="comment">// file containing export data (when using -export)</span></span><br><span class="line">        Module        *Module  <span class="comment">// info about package's containing module, if any (can be nil)</span></span><br><span class="line">        Match         []<span class="keyword">string</span> <span class="comment">// command-line patterns matching this package</span></span><br><span class="line">        DepOnly       <span class="keyword">bool</span>     <span class="comment">// package is only a dependency, not explicitly listed</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Source files</span></span><br><span class="line">        GoFiles         []<span class="keyword">string</span> <span class="comment">// .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)</span></span><br><span class="line">        CgoFiles        []<span class="keyword">string</span> <span class="comment">// .go source files that import "C"</span></span><br><span class="line">        CompiledGoFiles []<span class="keyword">string</span> <span class="comment">// .go files presented to compiler (when using -compiled)</span></span><br><span class="line">        IgnoredGoFiles  []<span class="keyword">string</span> <span class="comment">// .go source files ignored due to build constraints</span></span><br><span class="line">        CFiles          []<span class="keyword">string</span> <span class="comment">// .c source files</span></span><br><span class="line">        CXXFiles        []<span class="keyword">string</span> <span class="comment">// .cc, .cxx and .cpp source files</span></span><br><span class="line">        MFiles          []<span class="keyword">string</span> <span class="comment">// .m source files</span></span><br><span class="line">        HFiles          []<span class="keyword">string</span> <span class="comment">// .h, .hh, .hpp and .hxx source files</span></span><br><span class="line">        FFiles          []<span class="keyword">string</span> <span class="comment">// .f, .F, .for and .f90 Fortran source files</span></span><br><span class="line">        SFiles          []<span class="keyword">string</span> <span class="comment">// .s source files</span></span><br><span class="line">        SwigFiles       []<span class="keyword">string</span> <span class="comment">// .swig files</span></span><br><span class="line">        SwigCXXFiles    []<span class="keyword">string</span> <span class="comment">// .swigcxx files</span></span><br><span class="line">        SysoFiles       []<span class="keyword">string</span> <span class="comment">// .syso object files to add to archive</span></span><br><span class="line">        TestGoFiles     []<span class="keyword">string</span> <span class="comment">// _test.go files in package</span></span><br><span class="line">        XTestGoFiles    []<span class="keyword">string</span> <span class="comment">// _test.go files outside package</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cgo directives</span></span><br><span class="line">        CgoCFLAGS    []<span class="keyword">string</span> <span class="comment">// cgo: flags for C compiler</span></span><br><span class="line">        CgoCPPFLAGS  []<span class="keyword">string</span> <span class="comment">// cgo: flags for C preprocessor</span></span><br><span class="line">        CgoCXXFLAGS  []<span class="keyword">string</span> <span class="comment">// cgo: flags for C++ compiler</span></span><br><span class="line">        CgoFFLAGS    []<span class="keyword">string</span> <span class="comment">// cgo: flags for Fortran compiler</span></span><br><span class="line">        CgoLDFLAGS   []<span class="keyword">string</span> <span class="comment">// cgo: flags for linker</span></span><br><span class="line">        CgoPkgConfig []<span class="keyword">string</span> <span class="comment">// cgo: pkg-config names</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dependency information</span></span><br><span class="line">        Imports      []<span class="keyword">string</span>          <span class="comment">// import paths used by this package</span></span><br><span class="line">        ImportMap    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// map from source import to ImportPath (identity entries omitted)</span></span><br><span class="line">        Deps         []<span class="keyword">string</span>          <span class="comment">// all (recursively) imported dependencies</span></span><br><span class="line">        TestImports  []<span class="keyword">string</span>          <span class="comment">// imports from TestGoFiles</span></span><br><span class="line">        XTestImports []<span class="keyword">string</span>          <span class="comment">// imports from XTestGoFiles</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error information</span></span><br><span class="line">        Incomplete <span class="keyword">bool</span>            <span class="comment">// this package or a dependency has an error</span></span><br><span class="line">        Error      *PackageError   <span class="comment">// error loading package</span></span><br><span class="line">        DepsErrors []*PackageError <span class="comment">// errors loading dependencies</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块的详细定义信息见如下结构体:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Module <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path      <span class="keyword">string</span>       <span class="comment">// 模块路径</span></span><br><span class="line">    Version   <span class="keyword">string</span>       <span class="comment">// 模块版本</span></span><br><span class="line">    Versions  []<span class="keyword">string</span>     <span class="comment">// 可用的模块版本 (with -versions)</span></span><br><span class="line">    Replace   *Module      <span class="comment">// 替换为指定模块</span></span><br><span class="line">    Time      *time.Time   <span class="comment">// 创建的时间版本信息</span></span><br><span class="line">    Update    *Module      <span class="comment">// 可用的任何更新 (with -u)</span></span><br><span class="line">    Main      <span class="keyword">bool</span>         <span class="comment">// 是否是主模块</span></span><br><span class="line">    Indirect  <span class="keyword">bool</span>         <span class="comment">// 是否只是主模块的间接依赖吗?</span></span><br><span class="line">    Dir       <span class="keyword">string</span>       <span class="comment">// 模块的保存文件目录</span></span><br><span class="line">    GoMod     <span class="keyword">string</span>       <span class="comment">// go.mod 文件路径</span></span><br><span class="line">    GoVersion <span class="keyword">string</span>       <span class="comment">// 模块使用的 Go 版本信息</span></span><br><span class="line">    Error     *ModuleError <span class="comment">// 加载模块的错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ModuleError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Err <span class="keyword">string</span> <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a><code>go mod</code></h2><p>提供对模块的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod &lt;<span class="built_in">command</span>&gt; [arguments]</span><br></pre></td></tr></table></figure>

<p>包含如下子命令</p>
<table>
<thead>
<tr>
<th align="center">command</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">download</td>
<td align="left">下载模块到本地缓存(默认为 GOPATH/pkg/mod 目录)</td>
</tr>
<tr>
<td align="center">edit</td>
<td align="left">通过工具或脚本编辑 go.mod</td>
</tr>
<tr>
<td align="center">graph</td>
<td align="left">打印模块依赖图</td>
</tr>
<tr>
<td align="center">init</td>
<td align="left">在当前目录下初始化新模块, 创建 go.mod</td>
</tr>
<tr>
<td align="center">tidy</td>
<td align="left">增加缺少的包,删除没有用到的包</td>
</tr>
<tr>
<td align="center">vendor</td>
<td align="left">将依赖复制到 vendor 目录下</td>
</tr>
<tr>
<td align="center">verify</td>
<td align="left">校验依赖</td>
</tr>
<tr>
<td align="center">why</td>
<td align="left">解释为什么需要软件包或模块</td>
</tr>
</tbody></table>
<h3 id="download"><a href="#download" class="headerlink" title="download"></a><code>download</code></h3><p>下载指定模块, 这些模块是主模块依赖的模块, 也可以是 <code>path@version</code> 形式的模块查询. 如果没有参数, 则下载主模块的所有依赖.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod download [-json] [modules]</span><br></pre></td></tr></table></figure>

<p>go 命令在正常执行期间根据需要自动下载模块. <code>go mod download</code> 命令主要用于预填充本地缓存或得到 go 模块代理的响应</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-json</code></td>
<td align="left">打印一系列 json 对象到标准输出, 模数每个下载的模块信息. 与下面 Go Module 结构体相对应</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Module <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path     <span class="keyword">string</span> <span class="comment">// module path</span></span><br><span class="line">    Version  <span class="keyword">string</span> <span class="comment">// module version</span></span><br><span class="line">    Error    <span class="keyword">string</span> <span class="comment">// error loading module</span></span><br><span class="line">    Info     <span class="keyword">string</span> <span class="comment">// absolute path to cached .info file</span></span><br><span class="line">    GoMod    <span class="keyword">string</span> <span class="comment">// absolute path to cached .mod file</span></span><br><span class="line">    Zip      <span class="keyword">string</span> <span class="comment">// absolute path to cached .zip file</span></span><br><span class="line">    Dir      <span class="keyword">string</span> <span class="comment">// absolute path to cached source root directory</span></span><br><span class="line">    Sum      <span class="keyword">string</span> <span class="comment">// checksum for path, version (as in go.sum)</span></span><br><span class="line">    GoModSum <span class="keyword">string</span> <span class="comment">// checksum for go.mod (as in go.sum)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a><code>edit</code></h3><p>提供了一个用于编辑 go.mod 的命令行界面, 主要供工具或脚本使用. 它只读取 go.mod, 不查找所涉及的模块信息.</p>
<p>默认情况下, edit 读写主模块的 go.mod 文件,但可以指定其它目标文件</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-fmt</code></td>
<td align="left">重新格式化 go.mod 文件, 而不进行其它更改</td>
</tr>
<tr>
<td align="center"><code>-module</code></td>
<td align="left">更改模块的路径</td>
</tr>
<tr>
<td align="center"><code>-require=path@version</code>/<code>-droprequire=path</code></td>
<td align="left">添加给定的 <code>path@version</code> 的模块/删除指定 path 的模块</td>
</tr>
<tr>
<td align="center"><code>-exclude=path@version</code>/<code>-dropexclude=path@version</code></td>
<td align="left">为给定的 <code>path@version</code> 模块添加/删除 exclude 信息</td>
</tr>
<tr>
<td align="center"><code>-replace=old[@v]=new[@v]</code>/<code>-dropreplace=old[@v]</code></td>
<td align="left">添加和删除对给定 <code>path@version</code> 模块的替换</td>
</tr>
<tr>
<td align="center"><code>-go=version</code></td>
<td align="left">设置预期的 Go 语言版本</td>
</tr>
<tr>
<td align="center"><code>-print</code></td>
<td align="left">以文本格式打印最终的 go.mod, 而不是将其写回到 go.mod</td>
</tr>
<tr>
<td align="center"><code>-json</code></td>
<td align="left">以 JSON 格式打印最终的 go.mod, 而不是将其写回到 go.mod. JSON 格式对应的 Go 结构体如下</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Module <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    Version <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GoMod <span class="keyword">struct</span> &#123;</span><br><span class="line">    Module  Module</span><br><span class="line">    Go      <span class="keyword">string</span></span><br><span class="line">    Require []Require</span><br><span class="line">    Exclude []Module</span><br><span class="line">    Replace []Replace</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Require <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    Version <span class="keyword">string</span></span><br><span class="line">    Indirect <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Replace <span class="keyword">struct</span> &#123;</span><br><span class="line">    Old Module</span><br><span class="line">    New Module</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h3><p>初始化一个新的 go.mod 保存在当前目录, 实际上是创建了一个以当前目录为 <code>/</code> 的新模块. go.mod 文件必须不存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init [module]</span><br></pre></td></tr></table></figure>

<h3 id="tidy"><a href="#tidy" class="headerlink" title="tidy"></a><code>tidy</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod tidy [-v]</span><br></pre></td></tr></table></figure>

<p>确保 go.mod 与模块中的源代码匹配, 它添加了构建当前模块的程序包和依赖项所需的所有缺少的模块, 并删除程序包的未使用模块. 它还会将所有缺少的条目添加到 go.sum 中, 并删除所有不必要的条目.</p>
<p><code>-v</code> 标志将有关已删除模块的信息打印为标准错误</p>
<h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a><code>vendor</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod vendor [-v]</span><br></pre></td></tr></table></figure>

<p>用于重置主模块的 vendor 目录, 以使其包含主模块构建和测试所需要的所有包. 它不包括已 vendored 软件包的测试代码.</p>
<p><code>-v</code> 标志将已 vendored 模块和包因为到标准错误</p>
<h2 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a><code>go run</code></h2><p>编译并运行指定的 Go 主程序包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run [build flags] [-<span class="built_in">exec</span> xprog] package [arguments...]</span><br></pre></td></tr></table></figure>

<p>通常, 该软件包被指定为来自单个目录的 .go 源文件列表, 但也可以是导入路径, 文件系统路径或模式匹配单个已知包.</p>
<p>默认情况下, <code>go run</code> 直接运行编译的二进制文件. 如果添加 <code>-exec</code> 标志, 那么 <code>go run</code> 使用 xprog 调用二进制文件. 如果未提供 <code>-exec</code> 标志, 则 GOOS 或 <code>GOARCH</code> 与系统不同的情况下, 可以找到名为 <code>go_$GOOS_$GOARCH_exec</code> 的程序文件</p>
<h2 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a><code>go test</code></h2><p>自动测试由导入路径命名的包, 输出测试结果的摘要信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> [build/<span class="built_in">test</span> flags] [packages] [build/<span class="built_in">test</span> flags &amp; <span class="built_in">test</span> binary flags]</span><br></pre></td></tr></table></figure>

<p><code>go test</code> 重新编译每个包以及文件名与 <code>*_test.go</code> 模式匹配的文件. 这些附加文件可以包含测试函数,压力测试和示例函数. 每个列出的包都会导致执行单独的测试二进制文件. 文件名以 <code>_</code> 或 <code>.</code> 开头的文件(包括<code>_test.go</code>)将被忽略</p>
<p>用后缀 <code>_test</code> 声明包的测试文件将被编译为单独的包, 然后与主测试二进制链接并运行. go 工具将会忽略名为 testdata 的目录, 使其可以保存测试所需的辅助数据</p>
<p>go test 有两种不同的运行模式:</p>
<ul>
<li>本地目录模式: 在没有指定 package 包参数的情况下调用 go test 采用的模式. 在此模式下, go test 编译当前目录中包的源码和测试文件, 然后运行生成的二进制测试文件. 在此模式下, 将禁用缓存. 测试完成后, 输出测试的摘要信息, 包括测试状态(ok 或 FAIL), 包名和测试时间</li>
<li>包列表模式: 在显示指定 package 包参数的情况下调用 go test 采用的模式. 在此模式下, go test 编译并测试命令行中列出的每个包, 如果测试通过, 则只输出 ok 摘要行. 否则, 输出完整的测试输出.</li>
</ul>
<p>在包列表模式下, go test 缓存成功的测试结果, 避免运行不必要的重复测试.</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-args</code></td>
<td align="left">将命令行其余部分(-args 之后的所有内容)传递给测试二进制文件. 一般放在所有参数最后</td>
</tr>
<tr>
<td align="center"><code>-c</code></td>
<td align="left">将测试二进制文件编译为 <code>pkg.test</code>, 但不运行它(pkg 是包导入路径的最后一个元素). 可以使用 <code>-o</code> 更改文件名</td>
</tr>
<tr>
<td align="center"><code>-exec xprog</code></td>
<td align="left">使用 xprog 运行测试二进制文件</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="left">安装测试依赖项的包, 不运行测试</td>
</tr>
<tr>
<td align="center"><code>-json</code></td>
<td align="left">将测试输出转换为适合自动处理的 JSON 文本</td>
</tr>
<tr>
<td align="center"><code>-o file</code></td>
<td align="left">将测试二进制文件编译为指定命名的文件, 仍然运行测试(除非指定了 -c 或 -i)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之函数</title>
    <url>/2020/04/30/go-study-notes-func/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>关键字 <code>func</code> 用于定义函数. Go 语言中函数有以下特点:</p>
<ul>
<li>无须前置声明</li>
<li>不支持命名嵌套定义</li>
<li>不支持同名函数重载</li>
<li>不支持默认参数</li>
<li>支持不定长变参</li>
<li>支持多返回值</li>
<li>支持命名返回值</li>
<li>支持匿名函数和闭包</li>
</ul>
<p>一般来说,表示方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(函数参数)</span> <span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带参数</span></span><br><span class="line"><span class="comment">// `args... argsType` 本质上是一个切片, 表示可以传入多个参数, 该参数形式只能放在参数的最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">(arg argType, args ...argsType)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带返回值</span></span><br><span class="line"><span class="comment">// returnName 可省略, 返回值可以为逗号 `,` 分割的多个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">()</span> <span class="params">(returnName returnType)</span></span> &#123;</span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="comment">// 匿名函数只是没有名称, 其使用方式基本与普通函数没有区别, 多用于只调用一次或定义后立即调用的情况</span></span><br><span class="line">a := <span class="function"><span class="keyword">func</span> <span class="params">(arg argType)</span> <span class="params">(returnName returnType)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">FuncName(args)</span><br><span class="line">a(args)</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>函数的参数可视作局部变量, 因此不能在相同层次定义同名变量</p>
<blockquote>
<p>函数的形参是指函数中定义的参数, 实参则是函数调用时所传递的参数.</p>
</blockquote>
<p>不管传入的参数是指针,引用类型,还是其它类型参数,都是值拷贝传递.区别在于是拷贝指针,还是拷贝目标对象.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Change</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChangePtr</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *x = <span class="number">200</span></span><br><span class="line">    fmt.Println(*x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    Change(x)       <span class="comment">// 100</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    ChangePtr(&amp;x)   <span class="comment">// 200</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不定长变参"><a href="#不定长变参" class="headerlink" title="不定长变参"></a>不定长变参</h3><p>变参本质上是一个切片,只能接收一到多个同类型的参数,且必须放在参数列表末尾</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `args... argsType` 本质上是一个切片, 表示可以传入多个参数, 该参数形式只能放在参数的最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">(arg argType, args ...argsType)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将切片作为变参传入函数时,需进行展开操作.如果是数组,则需要将其转化为切片. 切片作为引用类型, 其在函数中所做的一切操作会影响到底层的数据. 如果需要可以使用内置函数 <code>copy()</code> 复制底层数据.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> a &#123;</span><br><span class="line">        a[i] += <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">    s := arr[:]</span><br><span class="line">    scopy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(scopy, s)  <span class="comment">// 将切片 s 底层数据复制一份到 scopy</span></span><br><span class="line">    test(s...)</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>有返回值的语句, 必须有明确的 <code>return</code> 终止语句</li>
<li>Go 函数支持多返回值模式</li>
<li>返回值在命名时, 其实已经在函数内部隐式创建了指定类型和名称的变量, 可当作局部变量使用, 且不能在函数体内对已经命名的返回值变量 <code>a</code> 使用形如 <code>a := xxx</code> 的变量定义表达式</li>
<li>返回值在命名时, 需要对全部返回值命名, 否则会编译出错</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出 0</span></span><br><span class="line">    a := <span class="number">10</span>        <span class="comment">// 报错,No new variables on left side of :=, 表示 a 不是一个新定义的变量, 只能使用 = 对其赋值</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>除没有名字外, 匿名函数与普通函数完全相同. 匿名函数可以直接被调用, 保存到变量, 作为参数或返回值</p>
<ul>
<li>直接执行或赋值给变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接执行</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值给变量</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span> <span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作为参数传递</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作为返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add := test()</span><br><span class="line">    fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>示例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := test(<span class="number">123</span>)</span><br><span class="line">    f()  <span class="comment">// 输出 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就上述代码而言, <code>test</code> 返回的匿名函数会引用上下文环境变量 <code>x</code>. 当该函数在 <code>main</code> 中执行时, 它依然可以读取 <code>x</code> 的值, 这种现象就称作闭包.</p>
<p>闭包通过指针引用环境变量, 那么可能导致其生命周期延长, 还有可能发生 “延迟求值”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(&amp;i, i)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> test() &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// 0xc000062090 2</span></span><br><span class="line"><span class="comment">// 0xc000062090 2</span></span><br></pre></td></tr></table></figure>

<p>在以上示例中, for 循环复用局部变量 i, 每次添加的匿名函数引用的变量是同一变量. 添加仅仅是将匿名函数放入列表, 并未执行. 因此在 main 函数调用这些函数时, 它们读取的是环境变量 i 最后一次循环时的值,为 2.</p>
<p>解决方法就是每次使用不同的环境变量或传参复制, 让各自的闭包环境各不相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        x := i <span class="comment">// x 在每次循环都重新定义</span></span><br><span class="line">        s = <span class="built_in">append</span>(s, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(&amp;x, x)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defer-语句延迟调用"><a href="#defer-语句延迟调用" class="headerlink" title="defer 语句延迟调用"></a><code>defer</code> 语句延迟调用</h2><ul>
<li><code>defer</code> 语句定义的语句直到当前函数执行结束前在被执行, 常用于资源释放, 解除绑定, 错误处理等操作. 多个 <code>defer</code> 语句会按照”先进后出”(FILO)的次序执行.</li>
<li><code>defer</code> 语句定义的语句会被延迟调用, 其中传入的参数被复制并被缓存起来. 调用时使用的参数为 <code>defer</code> 语句定义时的参数值. 如</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"传入 defer 语句中 a b 值分别为 "</span>, a, b)  <span class="comment">// 只有传入的参数保存了当时的状态</span></span><br><span class="line">        fmt.Println(<span class="string">"不以 defer 语句参数方式输出 x y 值分别为"</span>, x, y)</span><br><span class="line">    &#125;(x, y)</span><br><span class="line">    x += <span class="number">100</span></span><br><span class="line">    y += <span class="number">100</span></span><br><span class="line">    fmt.Println(<span class="string">"函数结束前 x y 值为"</span>, x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// 函数结束前 x y 值为 101 102</span></span><br><span class="line"><span class="comment">// 传入 defer 语句中 a b 值分别为  1 2</span></span><br><span class="line"><span class="comment">// 不以 defer 语句参数方式输出 x y 值分别为 101 102</span></span><br></pre></td></tr></table></figure>

<h3 id="误用"><a href="#误用" class="headerlink" title="误用"></a>误用</h3><p><code>defer</code> 语句在函数结束时才被执行. 不合理的使用方式会浪费资源.</p>
<p>如下案例是在 for 循环中不恰当使用 <code>defer</code> 语句导致文件关闭时间延长</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        path := fmt.Sprintf(<span class="string">"log/%d.txt"</span>, i)</span><br><span class="line">        file, err := os.Open(path)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个文件关闭操作在 main 函数结束时才会执行,而不是在当前循环结束后执行</span></span><br><span class="line">        <span class="keyword">defer</span> file.Close()</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们应该将带有 <code>defer</code> 语句的循环体重构为函数,在循环中调用. 这样, 在每次循环执行后, <code>defer</code> 语句都会被执行一次, 即时释放资源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        path := fmt.Sprintf(<span class="string">"log/%d.txt"</span>, n)</span><br><span class="line">        file, err := os.Open(path)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个文件关闭操作在该函数结束时调用</span></span><br><span class="line">        <span class="keyword">defer</span> file.Close()</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        do()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h2 id="error"><a href="#error" class="headerlink" title="error"></a><code>error</code></h2><p>官方推荐的做法是返回 <code>error</code></p>
<p>标准库将 <code>error</code> 定义为接口类型, 以便实现自定义错误类型. 我们在自定义错误类型时, 只需实现该接口即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Go 内置的 error 接口</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Error</span></span><br><span class="line"><span class="keyword">type</span> DivError <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(divError *DivError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> divError.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库也提供了创建 <code>error</code> 的函数, 可以方便地创建包含错误文本的 <code>error</code> 对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">"some description for error"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="panic-revover-内置函数"><a href="#panic-revover-内置函数" class="headerlink" title="panic(), revover() 内置函数"></a><code>panic()</code>, <code>revover()</code> 内置函数</h3><ul>
<li><code>panic()</code> 内置函数接收 <code>interface</code> 作为参数, 会立即中断当前函数流程, 执行延迟调用并将 <code>panice</code> 向外传递</li>
<li><code>revover()</code> 内置函数返回 <code>interface</code> 对象, 多用于捕获 <code>panic()</code> 函数引发的错误. <strong>该函数必须在延迟调用函数中才能正常工作</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">catch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Println(<span class="string">"捕获成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> catch()                <span class="comment">// 捕获成功</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>()) <span class="comment">// 捕获失败</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">recover</span>()              <span class="comment">// 捕获失败</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之方法</title>
    <url>/2020/05/02/go-study-notes-method/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>方法是与对象实例绑定的特殊函数. 方法与函数定义的语法区别在于前者有前置实例接收参数, 编译器以此确定方法所属类型. 一般来说定义方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> structName <span class="keyword">struct</span>&#123;</span><br><span class="line">    fieldName fieldType</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver structName)</span> <span class="title">MethodName</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    <span class="comment">// func expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>可以为当前包,已经除接口和指针以外的任何类型定义方法</li>
<li>方法被看作特殊的函数, 同样不支持重载, receiver 类型可以是基础类型或指针类型, 这关系到调用时对象实例是否被复制</li>
<li>可以使用实例值或指针值调用方法, 编译器会根据方法 receiver 类型自动在基础实例和指针类型间转换</li>
<li>对于结构体嵌套, 外层结构体可以直接重载或直接调用内层结构体的方法</li>
</ul>
<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;</span><br><span class="line">    N</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">value</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n++</span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span> <span class="title">pointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (*n)++</span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v\n"</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n N = <span class="number">20</span></span><br><span class="line">    n.value()                     <span class="comment">// 0xc00000a0d0, 21</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;n, n) <span class="comment">// 0xc00000a0b8 ,20</span></span><br><span class="line">    n.pointer()                   <span class="comment">// 0xc00000a0b8,21</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;n, n) <span class="comment">// 0xc00000a0b8, 21</span></span><br><span class="line"></span><br><span class="line">    s := S&#123;<span class="number">23000</span>&#125;</span><br><span class="line">    s.value()                     <span class="comment">// 0xc00000a120, 23001</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;s, s) <span class="comment">// 0xc00000a118, &#123;23000&#125;</span></span><br><span class="line">    s.pointer()                   <span class="comment">// 0xc00000a118, 23001</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;s, s) <span class="comment">// 0xc00000a118, &#123;23001&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>面向对象的三大特征 “封装”, “继承” “多态”, Go 仅实现了部分特征, 它更倾向于 “组合优于继承” 这种思想. 将模块分解成相互独立的更小单元, 分别处理不同方面的需求, 最后以匿名嵌入方式组合到一起, 共同实现对外接口. 而其简短一致的调用方式, 更是隐藏了内部实现细节.</p>
</blockquote>
<h2 id="方法转化为表达式"><a href="#方法转化为表达式" class="headerlink" title="方法转化为表达式"></a>方法转化为表达式</h2><p>方法和函数一样, 除直接调用外, 还可以作为参数传递, 依照具体引用方式不同, 可以分为 expression 和 value 两种状态.</p>
<h2 id="表达式类型"><a href="#表达式类型" class="headerlink" title="表达式类型"></a>表达式类型</h2><p>通过类型引用的 method expression 会被还原为普通函数样式, receiver 是第一参数, 需要显示传参. 至于类型, 可以是 T 或 *T.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">    fmt.Printf(<span class="string">"main.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">    f1 := N.test        <span class="comment">// 也可以直接调用 N.test(n)</span></span><br><span class="line">    f1(n)</span><br><span class="line">    f2 := (*N).test     <span class="comment">// 也可以直接调用 (*N).test(&amp;n)</span></span><br><span class="line">    f2(&amp;n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// main.n: 0xc00000a0b8, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a0f0, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a100, 25</span></span><br></pre></td></tr></table></figure>

<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul>
<li>基于实例或指针引用的 method value, 依旧按照正常方式调用. 但当 method value 被赋值给变量或作为参数传递时, 会立即计算并<strong>复制</strong>该方法执行所需的 receiver 对象, 并与其绑定. 在后续调用时, 能够隐式传入 receiver 对象</li>
<li>如果目标方法的 receiver 是指针类型, 那么被复制的仅是指针. 会在调用时寻找该指针指向的对象, 所以传入的对象参数为调用时的上下文中的对象</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">value</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *n)</span> <span class="title">pointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">    p := &amp;n</span><br><span class="line">    n++  <span class="comment">// 101</span></span><br><span class="line">    f1 := n.value       <span class="comment">// 记录此时上下文中变量 n 的状态,并以此状态复制后一个新的对象, 将该对象隐式传入到 test 函数</span></span><br><span class="line">    f3 := n.pointer     <span class="comment">// 记录并复制此时上下文中变量 n 的指针 &amp;n</span></span><br><span class="line">    n++  <span class="comment">// 102</span></span><br><span class="line">    f2 := p.value       <span class="comment">// 记录此时上下文中指针 p 指向的内存地址对象, 并以此地址状态复制后一个新的内存地址对象, 将该对象隐式传入到 test 函数</span></span><br><span class="line">    f4 := m.pointer     <span class="comment">// 记录并复制此时上下文中变量 n 的指针 &amp;n</span></span><br><span class="line">    n++  <span class="comment">// 103</span></span><br><span class="line">    fmt.Printf(<span class="string">"main.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">    f1()</span><br><span class="line">    f3()    <span class="comment">// 达到延迟调用的效果 *n = 103</span></span><br><span class="line">    f2()</span><br><span class="line">    f4()    <span class="comment">// 达到延迟调用的效果 *n = 103</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// main.n: 0xc00000a0b8, 103</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a100, 101</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a0b8, 103</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a118, 102</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a0b8, 103</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之接口</title>
    <url>/2020/05/02/go-study-notes-interface/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一般来说, 定义方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interfaceName <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 方法名(参数列表) (返回值列表)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口内如果没有方法声明, 则该接口为空接口(<code>interface{}</code>). 空接口是所有类型均实现的接口, 可被赋值为任何类型的对象</li>
<li>接口的结构体内不能有字段</li>
<li>只能声明方法, 不能实现, 不能包含任何方法体</li>
<li>可嵌入其它接口类型, 相当于将其其它接口申明的方法集导入, 这要求不能有同名方法.</li>
<li>目标类型必须定义了接口中包含的全部方法才算实现了该接口. 如果两个接口定义的方法相同, 且目标类型实现了其中方法, 则该类型同时实现了两个接口</li>
<li>通过 <code>var i1 = interface{}</code> 声明的接口, 默认值为 <code>nil</code></li>
<li>将对象赋值给接口变量时, 会复制该对象, 此时不能通过接口修改原始对象的值; 将对象指针赋值给接口, 那么接口内存储的就是指针的复制品, 可以通过接口修改原始对象的值</li>
</ul>
<h2 id="类型转换-断言"><a href="#类型转换-断言" class="headerlink" title="类型转换/断言"></a>类型转换/断言</h2><p>类型推断可将接口变量转换为原始类型, 或判断是否实现了某个更具体的接口类型. 一般来说类型推断表达式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type, ok := x.(Type)    <span class="comment">// 判断是否可以转换为原始类型</span></span><br><span class="line">Type, ok := x.(interfaceName)  <span class="comment">// 判断是否实现某个接口</span></span><br></pre></td></tr></table></figure>

<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> interfaceName <span class="keyword">interface</span> &#123;</span><br><span class="line">  test() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = n</span><br><span class="line">    <span class="comment">// 在 `switch` 语句中使用 `x.(type)` 对 x 类型进行判断</span></span><br><span class="line">    <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">      fmt.Println(<span class="string">"nil"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">string</span>, N:</span><br><span class="line">      fmt.Println(x)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">string</span>:</span></span><br><span class="line">      fmt.Println(<span class="string">"func"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 x 是否可以转换为 N 类型</span></span><br><span class="line">  <span class="keyword">if</span> n, ok := x.(N); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%T, %v\n"</span>, n)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 判断 n 是否也实现了 interfaceName 接口</span></span><br><span class="line">  <span class="keyword">if</span> n, ok := x.(interfaceName); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%T, %v\n"</span>, n, n)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 bufio 包</title>
    <url>/2020/05/04/go-study-notes-package-bufio/</url>
    <content><![CDATA[<p><code>bufio</code> 包实现了缓冲的 IO. 它包含分别实现 <code>io.Reader()</code> 和 <code>io.Writer()</code> 接口的 <code>Reader</code> 和 <code>Writer</code>对象,提供了 IO 缓冲区和文本类型 IO 的一些支持.导入方式为 <code>import &quot;bufio&quot;</code></p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader 是实现了 `io.Reader` 接口的缓冲对象</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer 是实现了 `io.Writer` 接口的缓冲对象.</span></span><br><span class="line"><span class="comment">// 如果在写入 Writer 时发生错误,将不再接收数据,所有后续写入和 `Flush()`` 都将返回错误</span></span><br><span class="line"><span class="comment">// 写入所有数据后,客户端应显示调用 `Flush()` 方法确保所有数据都发送到基本 `io.Writer`</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scanner 提供了一些方便的接口来扫描缓冲区数据,如用换行符分隔行的文件.</span></span><br><span class="line"><span class="comment">// 通过连续调用 `Scan()` 方法将逐步浏览文件 'token'(文件内容),并跳过 token 之间的字节.token 的规范是由 `SplitFunc` 类型的分割函数定义的.默认的分割函数将输入分割成行,并去掉行尾的换行标志.</span></span><br><span class="line"><span class="comment">// 预定义的分割函数可以将输入分割成行,字节,unicode,空白分隔的 word.调用者可以定制自己的分割函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 需要更多对错误管理的控制或 token 很大,或必须从 reader 连续读取的程序,应使用 `bufio.Reader`代替</span></span><br><span class="line"><span class="keyword">type</span> Scanner <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于 Scanner 做词法分析的分割函数</span></span><br><span class="line"><span class="comment">// 函数的返回值是每次扫描的长度,分割后的字符(token)的切片表示及可能发生的错误</span></span><br><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 用于缓冲一个 token,实际需要的最大 token 尺寸可能小一些,例如缓冲中需要保存一整行内容</span></span><br><span class="line">    MaxScanTokenSize = <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="bufio-包函数"><a href="#bufio-包函数" class="headerlink" title="bufio 包函数"></a><code>bufio</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个带有默认大小缓冲区的 `Reader` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="comment">// 返回一个带有指定大小缓冲区的 `Reader` 对象,默认值为 4096,最小值为 16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="comment">// 返回一个带有默认大小缓冲区的 `Writer` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// 返回一个带有指定大小缓冲区的 `Writer` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// 使用 Reader,Writer 对象创建一个新的 ReadWriter 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReadWriter</span><span class="params">(r *Reader, w *Writer)</span> *<span class="title">ReadWriter</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下预定义函数用于 `scanner.Split()` 参数传递,是 Scanner 的分割函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区数据流按照字节分割作为 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanBytes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲区数据流按照 runes 分割作为 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanRunes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲区数据流按照单词分割作为 token,分割符号为空白字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanWords</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲区数据流按行分割作为 token,分割符号为 '\n'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanLines</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Reader-结构体方法"><a href="#Reader-结构体方法" class="headerlink" title="Reader 结构体方法"></a><code>Reader</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 丢弃缓冲区中的数据,清除任何错误,将 b 设置为从 r 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Reset</span><span class="params">(r io.Reader)</span></span></span><br><span class="line"><span class="comment">// 返回缓冲区现有的可读取的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回缓冲区的下 n 个字节及可能发生的错误.此函数不会移动读取指针位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 读取缓冲区数据写入到 p.返回写入 p 的字节数及可能发生的错误.读取到结尾时,n 为 0 且 err 为 io.EOF</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 读取缓冲区数据并返回一个字节及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按行读取,返回读取到的 byte 切片(不包括行尾换行符号),是否未读到行尾及发生的错误</span></span><br><span class="line"><span class="comment">// 如果行超过缓冲区大小,则一次只读取缓冲区大小的数据,且 isPrefix 为 true.本行的剩下的数据留作下一次读取,直到行读取结束,isPrefix 返回 false</span></span><br><span class="line"><span class="comment">// 多使用 `ReadBytes('\n')` 或 `ReadString('\n')` 方法代替</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 读取数据遇到 delim 字符.返回读取的字符切片及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 读取缓冲区数据直到遇到 delim 字符.返回读取到的字符串表示及可能发生的错误.实际是调用了 ReadBytes 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲数据流写入到 w</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Writer-结构体方法"><a href="#Writer-结构体方法" class="headerlink" title="Writer 结构体方法"></a><code>Writer</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span>  // 丢弃缓冲中的数据,清除任何错误,将 <span class="title">b</span> 设置为向 <span class="title">w</span> 写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span>  // 返回缓冲中现有的可写入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span>  // 将 <span class="title">p</span> 的内容写入缓冲.返回写入的字节数及可能发生的错误.如果 <span class="title">nn</span> &lt; <span class="title">len</span><span class="params">(p)</span>,<span class="title">err</span> 不为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span>  // 将 <span class="title">s</span> 写入缓冲.返回写入的字节数及可能发生的错误.如果 <span class="title">nn</span> &lt; <span class="title">len</span><span class="params">(p)</span>,<span class="title">err</span> 不为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span>  // 将单个字节 <span class="title">c</span> 写入缓冲,返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span>  // 将缓冲区数据持久化到文件中.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span>  // 实现 `<span class="title">io</span>.<span class="title">ReaderFrom</span>` 接口.从 <span class="title">r</span> 中读取数据到缓冲区</span></span><br></pre></td></tr></table></figure>

<h3 id="Scanner-结构体方法"><a href="#Scanner-结构体方法" class="headerlink" title="Scanner 结构体方法"></a><code>Scanner</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 Scanner 的分割函数.必须在 `Scan()` 之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Split</span><span class="params">(split SplitFunc)</span></span></span><br><span class="line"><span class="comment">// 获取当前位置的 token.让 Scanner 的扫描位置移动到下一个 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Scan</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 返回字符切片格式的最近一次 `Scan()` 方法调用生成的 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="comment">// 返回字符串格式的最近一次 `Scan()` 方法调用生成的 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Text</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回 Scanner 扫描过程中发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现有一文件 <code>filename</code> 内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">the second line: nice to meet you</span><br><span class="line">the third line: see you next time</span><br></pre></td></tr></table></figure>

<h2 id="bufio-读写示例"><a href="#bufio-读写示例" class="headerlink" title="bufio 读写示例"></a><code>bufio</code> 读写示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `bufio.Writer.WriteString()` 方法使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriterExample</span><span class="params">(bw *bufio.Writer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> bw.Flush() <span class="comment">// 需要显式将缓冲区中数据持久化到文件</span></span><br><span class="line">    bw.WriteString(<span class="string">"this new add line\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `bufio.Reader.ReadLine()` 方法使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadLineExample</span><span class="params">(br *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, isPrefix, err := br.ReadLine()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> isPrefix &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"该行未结束,读到内容为: %v"</span>, <span class="keyword">string</span>(line))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"该行结束,读到或剩余内容为: %v"</span>, <span class="keyword">string</span>(line))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println() <span class="comment">// 读取内容行尾的换行符不被保留,需手动换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `bufio.Reader.ReadString()` 方法使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadStringExample</span><span class="params">(br *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := br.ReadString(<span class="string">'\n'</span>) <span class="comment">// 使用 ReadString 按行读取</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            fmt.Print(line) <span class="comment">// 最后一行若没有换行符号,err 为 io.EOF,需要打印最后一行</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">"filename"</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"err"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    br := bufio.NewReaderSize(reader, <span class="number">16</span>) <span class="comment">// 设置为最小缓冲区,用于演示效果</span></span><br><span class="line">    ReadLineExample(br)</span><br><span class="line">    file.Seek(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment">// 将文件指针移到开始位置</span></span><br><span class="line">    fmt.Println(<span class="string">"------"</span>)</span><br><span class="line">    ReadStringExample(br)</span><br><span class="line">    file.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    bw := bufio.NewWriter(file)</span><br><span class="line">    WriterExample(bw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为以下内容:</span></span><br><span class="line"><span class="comment">// 该行结束,读到或剩余内容为: hello</span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为: the second line:</span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为:  nice to meet yo</span></span><br><span class="line"><span class="comment">// 该行结束,读到或剩余内容为: u</span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为: the third line:</span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为: see you next tim</span></span><br><span class="line"><span class="comment">// 该行结束,读到或剩余内容为: e</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// the second line: nice to meet you</span></span><br><span class="line"><span class="comment">// the third line: see you next time</span></span><br></pre></td></tr></table></figure>

<p>通过以上示例可以看到:</p>
<ul>
<li><code>ReadLine()</code> 超过缓冲区大小的数据被分为多次读取,且行尾的换行符不被保留</li>
<li>文件增加 “this new add line\n” 内容</li>
</ul>
<h2 id="bufio-Scanner-扫描示例"><a href="#bufio-Scanner-扫描示例" class="headerlink" title="bufio.Scanner 扫描示例"></a><code>bufio.Scanner</code> 扫描示例</h2><ul>
<li>统计单词个数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    scanner.Split(bufio.ScanWords) <span class="comment">// 为 scanner 设置分割函数</span></span><br><span class="line">    <span class="comment">// 统计单个个数</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintln(os.Stderr, <span class="string">"reading input:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用自定义分割函数</li>
</ul>
<p>如下示例尝试将分割分割的字符串转换为数字格式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"1234 5678 5681 1234567890123456"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    <span class="comment">// 创建自定义分割函数</span></span><br><span class="line">    split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        advance, token, err = bufio.ScanWords(data, atEOF)  <span class="comment">// 获取到以空格分割的 token</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; token != <span class="literal">nil</span> &#123;</span><br><span class="line">            _, err = strconv.ParseInt(<span class="keyword">string</span>(token), <span class="number">10</span>, <span class="number">32</span>)  <span class="comment">// 尝试转换为十进制数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置分割函数为自定义的分割函数 split</span></span><br><span class="line">    scanner.Split(split)</span><br><span class="line">    <span class="comment">// 开始扫描,并打印扫描到的文本</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Invalid input: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 context 包</title>
    <url>/2020/05/05/go-study-notes-package-context/</url>
    <content><![CDATA[<p>对服务的传入请求应创建一个上下文,而对服务器的传出调用应接受一个上下文.它们之间的函数调用链必须传播<code>Context</code> 上下文对象.</p>
<p>context 包定义了 <code>Context</code> 上下文类型,并可以选择使用 <code>WithCancel</code>,<code>WithDeadline</code>,<code>WithTimeout</code> 和 <code>WithValue</code> 等方法创建派生 <code>Context</code> 上下文对象.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>

<p><code>WithCancel</code>,<code>WithDeadline</code> 和 <code>WithTimeout</code> 函数传入父级 <code>Context</code> 对象,并返回派生的子级 <code>Context</code> 和<code>CancelFunc</code>.调用 <code>CancelFunc</code> 会取消该子级 <code>Context</code> 对象,删除父级对子级的引用,并停止所有关联的计时器.没有调用 <code>CancelFunc</code> 会使子级及其子级上下文对象泄漏,直到父代被取消或计时器触发为止.</p>
<p>上下文的使用遵循如下规则:</p>
<ul>
<li>不要将上下文存储在结构体中,而是将其作为参数传递给需要它的函数</li>
<li>不要传递 nil 上下文.如果不确定使用哪个上下文,则使用 <code>context.TODO</code></li>
<li>可以将相同的上下文传递给在不同 goroutine 中运行的函数.上下文对于由多个 goroutine 同时使用是安全的.</li>
</ul>
<h2 id="类型及函数定义"><a href="#类型及函数定义" class="headerlink" title="类型及函数定义"></a>类型及函数定义</h2><ul>
<li>常见类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消函数,会取消其上下文.多个 goroutine 可同时调用 CancelFunc,在第一个调用之后,随后对其调用将什么也不做</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文接口</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回取消该上下文的时间.如果未设置截止日期,则 ok 返回 false</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 返回一个取消此上下文或超时的通道</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 如果 Done() 返回的通道尚未关闭,返回 nil.否则返回非 nil 错误,用于解释原因</span></span><br><span class="line">    Err() error</span><br><span class="line">    <span class="comment">// 返回指定上下文中指定 key 的值.如果没有则返回 nil</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常用函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回具有新 Done 通道的 parent 上下文副本.</span></span><br><span class="line"><span class="comment">// 当调用返回的 cancel 函数或关闭 parent 上下文的 Done 通道时,关闭返回的上下文的 Done 通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回带有取消时间的 parent 上下文的副本</span></span><br><span class="line"><span class="comment">// 如果 parent 上下文的截止时间早于 d,则该函数返回的上下文在语义上等同于 parent.</span></span><br><span class="line"><span class="comment">// 当截止时间到期,调用返回的 cancel 函数或关闭 parent 上下文的 Done 通道时,将关闭返回的上下文的 Done 通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 WithDeadline(parent, time.Now().Add(timeout)),返回带有超时时间的 parent 上下文副本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个非空 Context 上下文,它永远不会被取消.它通常用于主函数,初始化和测试,用作传入请求的顶级上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个非空 Context 上下文,当不清楚要使用哪个上下文或尚不可用时,应使用 `context.TODO`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与 parent 上下文关联的副本,其中包含 key=val 变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><code>Context</code> 定义如下,包含了过期日期,取消信号和键值对等 API.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 返回代表此山下文工作完成时关闭的 channel.</span></span><br><span class="line">    <span class="comment">// 此 channel 在 WithCancel 在调用 cancel 函数时关闭,在 WithDeadline 在 deadline 之前关闭,在 WithTimeout 超时后关闭.</span></span><br><span class="line">    <span class="comment">// 同时可以在 select 语句中使用此函数,以接收上线关闭的信号.</span></span><br><span class="line">    <span class="comment">// select &#123;</span></span><br><span class="line">    <span class="comment">//      case &lt;-ctx.Done():</span></span><br><span class="line">    <span class="comment">//          return ctx.Err()</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    <span class="comment">// 返回与此上下文关联的键值</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel()"></a>WithCancel()</h2><p>首先看如下示例,创建了只能显式取消的子上下文对象.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ctxCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">"ctx.done()"</span>, ctx.Err())</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            fmt.Println(<span class="string">"time out"</span>, ctx.Err())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line">    <span class="comment">// Tip: 只能通过调用该函数向 ctx.Done() channel 发送完成的信号</span></span><br><span class="line">    cancel()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WithCancel()</code> 方法如下,返回 <code>cancelCtx</code> 对象与 <code>cancelFunc</code> 方法.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 WithCancel 创建子上下文对象的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cannot create context from nil parent"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cancelCtx 结构体如下</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tip: 显示关闭时调用的方法</span></span><br><span class="line"><span class="comment">// 可以看到该方法关闭了 c.done.取消了 c 的子上下文对象.并删除了其所有孩子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WithTimeout-与-WithDeadline"><a href="#WithTimeout-与-WithDeadline" class="headerlink" title="WithTimeout() 与 WithDeadline()"></a>WithTimeout() 与 WithDeadline()</h2><p>首先看如下示例,创建了带有超时时间与过期时间的子上下文对象.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ctxTimeout</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// Tip: 设置自动超时时间,向 ctx.Done() 发送信号</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// Tip: 若函数退出,则自动调用 cancel() 函数,释放上下文及其子上下文资源</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">"ctx.done()"</span>, ctx.Err())</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// Tip: 这里应该大于 ctx 的超时时间</span></span><br><span class="line">            fmt.Println(<span class="string">"time out"</span>, ctx.Err())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ctxDeadline</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// Tip: 设置自动过期时间,向 ctx.Done() 发送信号</span></span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Millisecond))</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">"ctx.done()"</span>, ctx.Err())</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// Tip: 这里应该大于 ctx 的超时时间</span></span><br><span class="line">            fmt.Println(<span class="string">"time out"</span>, ctx.Err())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>WithTimeout()</code> 函数其实是调用了 <code>WithDeadline()</code> 函数.返回的上下对象为 <code>timerCtx</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cannot create context from nil parent"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">        <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">        <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        cancelCtx: newCancelCtx(parent),</span><br><span class="line">        deadline:  d,</span><br><span class="line">    &#125;</span><br><span class="line">    propagateCancel(parent, c)</span><br><span class="line">    dur := time.Until(d)</span><br><span class="line">    <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>timerCtx</code> 结构体如下.相比于 <code>cancelCtx</code>,该结构体包含了计时器 <code>timer</code> 与 <code>deadline</code> 过期时间.它调用了 <code>cancelCtx.cancel()</code>,并停止了计时器.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tip: 调用了 cancelCtx.cancel() 来取消上下文,并停止了 timer,将其设置为 nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        <span class="comment">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue()"></a>WithValue()</h2><p>首先看如下示例,创建了带有父上下文中键值对的子上下文对象.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ctxValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// Tip: 创建包含键值对的 ctx,其中 key,value 均为 interface 类型,可以将对象传入</span></span><br><span class="line">    user := User&#123;</span><br><span class="line">        name: <span class="string">"tom"</span>,</span><br><span class="line">        age:  <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ctx := context.WithValue(context.Background(), <span class="string">"user"</span>, user)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// Tip: 可以在携程中通过传入的上下文对象将指定键值取出来</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := ctx.Value(<span class="string">"user"</span>).(User); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"user is %v"</span>, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>WithValue()</code> 函数返回的上下对象为 <code>valueCtx</code>,且不提供相关的 <code>cancelFunc</code> 方法.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cannot create context from nil parent"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>valueCtx</code> 结构体如下,其仅在 <code>Context</code> 的基础上添加了 <code>key, val interface{}</code> 成员对象,用于将键值对传入到子上下文对象中.其中其 <code>Value()</code> 方法会首先在当前上下文中查找指定键的值,找到则返回,否则在其父上下文中进行查找.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tip: 用于查找上下文中指定的键,并返回其值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是:</p>
<ul>
<li><code>WithValue()</code> 函数传入的 <code>key</code> 必须是可比较的,并且不能为字符串类型或任何其他内置类型,以避免在上下文之间发生冲突.</li>
<li>用户应定义自己的 <code>key</code> 类型,<code>key</code> 通常是具体的的 <code>struct{}</code> 结构体.</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 encoding 包</title>
    <url>/2020/05/15/go-study-notes-package-encoding/</url>
    <content><![CDATA[<p><code>encoding</code> 包定义了其它包共享的接口,其子包实现了数据与字节表示形式和文本形式的互相转换,主要包括:</p>
<ul>
<li><code>encoding/bash64</code> 实现了bas64 格式编码与解码.</li>
<li><code>encoding/json</code> 实现了 json 格式数据的编码与解码.</li>
<li><code>encoding/pem</code> 实现了 PEM 数据编码,常用于 TLS 密钥和证书中</li>
<li><code>encoding/xml</code> 实现了 xml 格式数据的编码与解码</li>
</ul>
<h2 id="encoding-base64-包"><a href="#encoding-base64-包" class="headerlink" title="encoding/base64 包"></a><code>encoding/base64</code> 包</h2><h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> encodeStd = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span></span><br><span class="line"><span class="keyword">const</span> encodeURL = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StdPadding <span class="keyword">rune</span> = <span class="string">'='</span> <span class="comment">// 标准填充字符</span></span><br><span class="line">    NoPadding  <span class="keyword">rune</span> = <span class="number">-1</span>  <span class="comment">// 不填充</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 未填充的标准原生编码格式</span></span><br><span class="line"><span class="keyword">var</span> RawStdEncoding = StdEncoding.WithPadding(NoPadding)</span><br><span class="line"><span class="comment">// 未填充的 URL 编码格式,常用于 URL 或文件名中</span></span><br><span class="line"><span class="keyword">var</span> RawURLEncoding = URLEncoding.WithPadding(NoPadding)</span><br><span class="line"><span class="comment">// 标准原生编码格式</span></span><br><span class="line"><span class="keyword">var</span> StdEncoding = NewEncoding(encodeStd)</span><br><span class="line"><span class="comment">// 标准 URL 编码格式,常用于 URL 或文件名中</span></span><br><span class="line"><span class="keyword">var</span> URLEncoding = NewEncoding(encodeURL)</span><br></pre></td></tr></table></figure>

<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li>包函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回给定字母定义的填充 Encoding 对象,可以使用该对象的 WithPadding 方法修改填充字符或禁用填充字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoding</span><span class="params">(encoder <span class="keyword">string</span>)</span> *<span class="title">Encoding</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Encoding</code> 结构体方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对已编码的数据 src 进行解码,最多将 DecodedLen(len(src)) 个字节写入 dst</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">Decode</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 对已编码后的 s 进行解码,返回解码后的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">DecodeString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 对数据 src 进行编码,最多将 DecodedLen(len(src)) 个字节写入 dst</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">Encode</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span></span><br><span class="line"><span class="comment">// 对数据 src 进行编码,返回编码后的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">EncodeToString</span><span class="params">(src []<span class="keyword">byte</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 修改填充字符或禁用填充字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc Encoding)</span> <span class="title">WithPadding</span><span class="params">(padding <span class="keyword">rune</span>)</span> *<span class="title">Encoding</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dataForEncoding := []<span class="keyword">byte</span>(<span class="string">"string for encoding"</span>)</span><br><span class="line">    strAfterEncode := base64.StdEncoding.EncodeToString(dataForEncoding)</span><br><span class="line">    fmt.Println(strAfterEncode)</span><br><span class="line"></span><br><span class="line">    strForDecode := <span class="string">"c29tZSBkYXRhIHdpdGggACBhbmQg77u/"</span></span><br><span class="line">    dataAfterDecode, err := base64.StdEncoding.DecodeString(strForDecode)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, dataAfterDecode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="encoding-json-包"><a href="#encoding-json-包" class="headerlink" title="encoding/json 包"></a><code>encoding/json</code> 包</h2><p><code>encoding/json</code> 实现了 json 格式数据的编码与解码.主要用于对象实例与 JSON 格式数据间的相互转换.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将对象实例转换为 JSON 格式数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将对象实例转换为 JSON 格式数据,每个 JSON 元素以新的缩进行及 prefix 开头,且根据嵌套深度跟一个或多个 indent 副本,可用于美化输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将 JSON 格式数据转换为对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>当结构体定义时,字段带有 <code>json: &quot;jsonField&quot;</code> 格式的标签,则会按照 <code>jsonField</code> 名称解析对象字段.示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span>      <span class="string">`json:"id"`</span></span><br><span class="line">    Name   <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">    Colors []<span class="keyword">string</span> <span class="string">`json:"colors"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    group := ColorGroup&#123;</span><br><span class="line">        ID:     <span class="number">1</span>,</span><br><span class="line">        Name:   <span class="string">"Reds"</span>,</span><br><span class="line">        Colors: []<span class="keyword">string</span>&#123;<span class="string">"Crimson"</span>, <span class="string">"Red"</span>, <span class="string">"Ruby"</span>, <span class="string">"Maroon"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    b, err := json.MarshalIndent(group, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.Write(b)</span><br><span class="line">    fmt.Println()</span><br><span class="line">    color := []<span class="keyword">byte</span>(<span class="string">`&#123;"id":2,"name":"Greens","colors":["Crimson","Green"]&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> colorGroup ColorGroup</span><br><span class="line">    err = json.Unmarshal(color, &amp;colorGroup)</span><br><span class="line">    fmt.Println(colorGroup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="encoding-pem-包"><a href="#encoding-pem-包" class="headerlink" title="encoding/pem 包"></a><code>encoding/pem</code> 包</h2><p><code>pem</code> 包实现了 PEM 数据编码,常用于 TLS 密钥和证书中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以用于 PEM 编码的结构体,编码后格式如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-----BEGIN Type-----</span></span><br><span class="line"><span class="comment">Headers</span></span><br><span class="line"><span class="comment">base64-encoded Bytes</span></span><br><span class="line"><span class="comment">-----END Type-----</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="keyword">string</span>            <span class="comment">// The type, taken from the preamble (i.e. "RSA PRIVATE KEY").</span></span><br><span class="line">    Headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// Optional headers.</span></span><br><span class="line">    Bytes   []<span class="keyword">byte</span>            <span class="comment">// The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 b PEM 编码后的数据写入 out</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(out io.Writer, b *Block)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 对 PEM 编码后的数据进行解码,返回 Block 对象,一般带有 TLS 私钥或公钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(p *Block, rest []<span class="keyword">byte</span>)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="encoding-xml-包"><a href="#encoding-xml-包" class="headerlink" title="encoding/xml 包"></a><code>encoding/xml</code> 包</h2><p>与 <code>encoding/json</code> 类似,<code>encoding/xml</code> 实现了 xml 格式数据的编码与解码.主要用于对象实例与 xml 格式数据间的相互转换.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将对象实例转换为 xml 格式数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将对象实例转换为 xml 格式数据,每个 xml 元素以新的缩进行及 prefix 开头,且根据嵌套深度跟一个或多个 indent 副本,可用于美化输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将 xml 格式数据转换为对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>当结构体定义时,字段带有 <code>xml: &quot;xmlField&quot;</code> 格式的标签,则会按照 <code>xmlField</code> 名称解析对象字段.示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/xml"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    City, State <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    XMLName   xml.Name <span class="string">`xml:"person"`</span></span><br><span class="line">    Id        <span class="keyword">int</span>      <span class="string">`xml:"id,attr"`</span></span><br><span class="line">    FirstName <span class="keyword">string</span>   <span class="string">`xml:"name&gt;first"`</span></span><br><span class="line">    LastName  <span class="keyword">string</span>   <span class="string">`xml:"name&gt;last"`</span></span><br><span class="line">    Age       <span class="keyword">int</span>      <span class="string">`xml:"age"`</span></span><br><span class="line">    Height    <span class="keyword">float32</span>  <span class="string">`xml:"height,omitempty"`</span></span><br><span class="line">    Married   <span class="keyword">bool</span></span><br><span class="line">    Address</span><br><span class="line">    Comment <span class="keyword">string</span> <span class="string">`xml:",comment"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person := &amp;Person&#123;Id: <span class="number">13</span>, FirstName: <span class="string">"John"</span>, LastName: <span class="string">"Doe"</span>, Age: <span class="number">42</span>&#125;</span><br><span class="line">    person.Comment = <span class="string">" Need more details. "</span></span><br><span class="line">    person.Address = Address&#123;<span class="string">"Hanga Roa"</span>, <span class="string">"Easter Island"</span>&#125;</span><br><span class="line"></span><br><span class="line">    output, err := xml.MarshalIndent(person, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.Write(output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 crypto 包</title>
    <url>/2020/05/05/go-study-notes-package-crypto/</url>
    <content><![CDATA[<h2 id="crypto-包"><a href="#crypto-包" class="headerlink" title="crypto 包"></a><code>crypto 包</code></h2><p>crypto 包包含了通用加密算法的集合,提供了一些加密过程中基本对象的封装或基本接口的定义.导入方式为 <code>import &quot;crypto&quot;</code>.</p>
<p>当前我们项目中常用的加解密的方式无非三种.</p>
<ul>
<li>对称加密: 加解密都使用的是同一个密钥,其中的代表就是 AES,DES(已被攻破)</li>
<li>非对加解密: 加解密使用不同的密钥,其中的代表就是 RSA</li>
<li>签名算法: 主要用于验证,防止信息被修改,多用于文件校验,数字签名,鉴权协议的等,其中算法主要有 MD5,SHA1,HMAC 等</li>
</ul>
<h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>它主要包含如下加密过程中的基本类型定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decrypter 是非公开私钥的接口,可用于非对称解密操作.一个示例是保存在硬件模块中的 RSA 密钥</span></span><br><span class="line"><span class="keyword">type</span> Decrypter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回与非公开私钥相对应的公钥</span></span><br><span class="line">    Public() PublicKey</span><br><span class="line">    <span class="comment">// 解密 msg.opts 参数应该是所使用的加密算法函数.详情参见每个实现文档</span></span><br><span class="line">    Decrypt(rand io.Reader, msg []<span class="keyword">byte</span>, opts DecrypterOpts) (plaintext []<span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DecrypterOpts <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash 标识在其它包中实现的加密哈希函数</span></span><br><span class="line"><span class="keyword">type</span> Hash <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示未指定算法的私钥</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示未指定算法的公钥</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signer 是非公开私钥的接口,可用于签名操作.</span></span><br><span class="line"><span class="keyword">type</span> Signer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回与非公开私钥相对应的公钥</span></span><br><span class="line">    Public() PublicKey</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用私钥对 digest 进行签名</span></span><br><span class="line">    Sign(rand io.Reader, digest []<span class="keyword">byte</span>, opts SignerOpts) (signature []<span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于使用 Signer 签名的参数</span></span><br><span class="line"><span class="keyword">type</span> SignerOpts <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回用于生成传递给 `Signer.Sign` 的消息的哈希函数,或零表示没有哈希完成</span></span><br><span class="line">    HashFunc() Hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MD4         Hash = <span class="number">1</span> + <span class="literal">iota</span> <span class="comment">// import golang.org/x/crypto/md4</span></span><br><span class="line">    MD5                         <span class="comment">// import crypto/md5</span></span><br><span class="line">    SHA1                        <span class="comment">// import crypto/sha1</span></span><br><span class="line">    SHA224                      <span class="comment">// import crypto/sha256</span></span><br><span class="line">    SHA256                      <span class="comment">// import crypto/sha256</span></span><br><span class="line">    SHA384                      <span class="comment">// import crypto/sha512</span></span><br><span class="line">    SHA512                      <span class="comment">// import crypto/sha512</span></span><br><span class="line">    MD5SHA1                     <span class="comment">// no implementation; MD5+SHA1 used for TLS RSA</span></span><br><span class="line">    RIPEMD160                   <span class="comment">// import golang.org/x/crypto/ripemd160</span></span><br><span class="line">    SHA3_224                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA3_256                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA3_384                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA3_512                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA512_224                  <span class="comment">// import crypto/sha512</span></span><br><span class="line">    SHA512_256                  <span class="comment">// import crypto/sha512</span></span><br><span class="line">    BLAKE2s_256                 <span class="comment">// import golang.org/x/crypto/blake2s</span></span><br><span class="line">    BLAKE2b_256                 <span class="comment">// import golang.org/x/crypto/blake2b</span></span><br><span class="line">    BLAKE2b_384                 <span class="comment">// import golang.org/x/crypto/blake2b</span></span><br><span class="line">    BLAKE2b_512                 <span class="comment">// import golang.org/x/crypto/blake2b</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="子包"><a href="#子包" class="headerlink" title="子包"></a>子包</h3><p>它包含众多子包,如下</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aes</td>
<td align="left">实现了 AES加密</td>
</tr>
<tr>
<td align="left">cipher</td>
<td align="left">实现了标准分组密码模式(CBC,ECB 等),可以将其包装在低级分组密码实现中</td>
</tr>
<tr>
<td align="left">des</td>
<td align="left">实现了数据加密标准(DES)和三重数据加密算法(TDEA)</td>
</tr>
<tr>
<td align="left">dsa</td>
<td align="left">实现了 FIPS 186-3 中定义的数字签名算法</td>
</tr>
<tr>
<td align="left">ecdsa</td>
<td align="left">实现了 FIPS 186-3 中定义的椭圆曲线数字签名算法</td>
</tr>
<tr>
<td align="left">ed25519</td>
<td align="left">实现了 ED25519签名算法</td>
</tr>
<tr>
<td align="left">elliptic</td>
<td align="left">实现了在素数域上的几个标准椭圆曲线</td>
</tr>
<tr>
<td align="left">hmac</td>
<td align="left">实现了 Keyed-Hash 消息认证码</td>
</tr>
<tr>
<td align="left">md5</td>
<td align="left">实现了 RFC 1321 中定义的 MD5 哈希算法</td>
</tr>
<tr>
<td align="left">rand</td>
<td align="left">实现了加密安全的随机数生成器</td>
</tr>
<tr>
<td align="left">rc4</td>
<td align="left">实现了 RC4 加密</td>
</tr>
<tr>
<td align="left">rsa</td>
<td align="left">实现了 PKCS#1 中定义的 RSA 加密</td>
</tr>
<tr>
<td align="left">sha1</td>
<td align="left">实现了 RFC 3174 中定义的 SHA-1 哈希算法</td>
</tr>
<tr>
<td align="left">sha256</td>
<td align="left">实现了 FIPS 180-4 中定义的 SHA224 和 SHA256 哈希算法</td>
</tr>
<tr>
<td align="left">sha512</td>
<td align="left">实现了 FIPS 180-4 中定义的 SHA-384, SHA-512, SHA-512/224 和 SHA-512/256 哈希算法</td>
</tr>
<tr>
<td align="left">tls</td>
<td align="left">部分实现了 RFC 5246 中指定的 TLS 1.2 和 RFC 8446 中指定的 TLS 1.3</td>
</tr>
<tr>
<td align="left">x509</td>
<td align="left">解析 X.509 编码的密钥和证书</td>
</tr>
<tr>
<td align="left">x509/pkix</td>
<td align="left">包含用于X.509证书,CRL 和 OCSP 的 ASN.1 解析和序列化的共享低级结构</td>
</tr>
</tbody></table>
<h2 id="crypto-aes"><a href="#crypto-aes" class="headerlink" title="crypto/aes"></a><code>crypto/aes</code></h2><p>aes 包实现了 AES 对称加密.导入方式为 <code>import &quot;crypto/aes&quot;</code></p>
<h3 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AES 块大小.以字节为单位</span></span><br><span class="line"><span class="keyword">const</span> BlockSize = <span class="number">16</span></span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并返回新的 `cipher.Block`</span></span><br><span class="line"><span class="comment">// 参数 key 是 AES 密钥,支持 16,24 或 32 个字节选择使用 AES-128, AES-192 或 AES-256 加密算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="crypto-cipher"><a href="#crypto-cipher" class="headerlink" title="crypto/cipher"></a><code>crypto/cipher</code></h2><p>cipher 包实现标准的分组加密模式(CBC,ECB 等),可以将其包装在低级分组加密实现中.导入方式为 <code>import &quot;crypto/cipher&quot;</code></p>
<h3 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AEAD 加密模式接口,对关联数据进行身份验证加密</span></span><br><span class="line"><span class="keyword">type</span> AEAD <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回必须传递给 Seal 和 Open 的随机数的大小</span></span><br><span class="line">    NonceSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回明文长度与密文长度间的最大差值</span></span><br><span class="line">    Overhead() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对明文进行加密,返回密文内容</span></span><br><span class="line">    <span class="comment">// 对于给定的密钥,nonce 的长度必须为 NonceSize() 返回的长度</span></span><br><span class="line">    <span class="comment">// 对于一个完整的加密解密过程而言,nonce始终是唯一的</span></span><br><span class="line">    Seal(dst, nonce, plaintext, additionalData []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对密文进行解密,返回明文内容</span></span><br><span class="line">    <span class="comment">// 对于给定的密钥,nonce 的长度必须为 NonceSize() 返回的长度</span></span><br><span class="line">    <span class="comment">// 对于一个完整的加密解密过程而言,nonce始终是唯一的</span></span><br><span class="line">    Open(dst, nonce, ciphertext, additionalData []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示使用给定密钥分组加密的接口.它提供了加密或解密单个分组的功能.模式的实现将该功能扩展为流式分组</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密的分组大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 将 src 中第一个分组加密为 dst. dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    Encrypt(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">    <span class="comment">// 将 src 中第一个分组解密为 dst. dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    Decrypt(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示基于指定分组模式加密的接口</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回分组模式加密的分组大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密多个分组. src 的长度必须是分组的整数倍,且dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示流加密</span></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 对给定切片中的每个字节与密码密钥流中的字节进行 XOR.dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StreamReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    S Stream</span><br><span class="line">    R io.Reader</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StreamWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    S   Stream</span><br><span class="line">    W   io.Writer</span><br><span class="line">    Err error <span class="comment">// unused</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="cipher-包方法"><a href="#cipher-包方法" class="headerlink" title="cipher 包方法"></a><code>cipher</code> 包方法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回以GCM模式下以标准随机数长度(12)包装的 128 位 AEAD 分组加密模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGCM</span><span class="params">(cipher Block)</span> <span class="params">(AEAD, error)</span></span></span><br><span class="line"><span class="comment">// 返回以GCM模式下以指定随机数长度(12)包装的 128 位 AEAD 分组加密模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGCMWithNonceSize</span><span class="params">(cipher Block, size <span class="keyword">int</span>)</span> <span class="params">(AEAD, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以分组加密链接模式(CBC)解密的分组模式</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与加密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line"><span class="comment">// 返回以分组解密链接模式(CBC)解密的分组模式</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以加密反馈模式(CFB)解密的分组模式</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCFBDecrypter</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br><span class="line"><span class="comment">// 返回以加密反馈模式(CFB)加密的 Stream</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCFBEncrypter</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以计数器模式下进行加密/解密的 Stream</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以输出反馈模式(OFB)加密或解密的 Stream</span></span><br><span class="line"><span class="comment">// iv 的长度必须与等于 b 的分组大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOFB</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="AES-GCM-模式认证加密解密"><a href="#AES-GCM-模式认证加密解密" class="headerlink" title="AES GCM 模式认证加密解密"></a>AES GCM 模式认证加密解密</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/aes"</span></span><br><span class="line">    <span class="string">"crypto/cipher"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESGCMEncrypt</span><span class="params">(plaintextStr <span class="keyword">string</span>, keyStr <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将明文和密钥转换为字节切片</span></span><br><span class="line">    plaintext := []<span class="keyword">byte</span>(plaintextStr)</span><br><span class="line">    key := []<span class="keyword">byte</span>(keyStr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建加密分组</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 GCM 模式的 AEAD</span></span><br><span class="line">    aesgcm, err := cipher.NewGCM(block)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建随机数,这里在实际应用中让它只生成一次.不然每次都需要进行修改</span></span><br><span class="line">    nonce := <span class="built_in">make</span>([]<span class="keyword">byte</span>, aesgcm.NonceSize())</span><br><span class="line">    <span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, nonce); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成密文</span></span><br><span class="line">    ciphertext := aesgcm.Seal(<span class="literal">nil</span>, nonce, plaintext, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 返回密文及随机数的 base64 编码</span></span><br><span class="line">    fmt.Println(ciphertext, nonce, key)</span><br><span class="line">    <span class="keyword">return</span> base64.RawURLEncoding.EncodeToString(ciphertext), base64.RawURLEncoding.EncodeToString(nonce)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESGCMDecrypt</span><span class="params">(ciphertextStr <span class="keyword">string</span>, keyStr <span class="keyword">string</span>, nonceStr <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将密文,密钥和生成的随机数转换为字节切片</span></span><br><span class="line">    ciphertext, _ := base64.RawURLEncoding.DecodeString(ciphertextStr)</span><br><span class="line">    nonce, _ := base64.RawURLEncoding.DecodeString(nonceStr)</span><br><span class="line">    key := []<span class="keyword">byte</span>(keyStr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建加密分组</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 GCM 模式的 AEAD</span></span><br><span class="line">    aesgcm, err := cipher.NewGCM(block)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 明文内容</span></span><br><span class="line">    plaintext, err := aesgcm.Open(<span class="literal">nil</span>, nonce, ciphertext, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(plaintext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    plaintext := <span class="string">"hello world"</span></span><br><span class="line">    key := <span class="string">"123456781234567812345678"</span> <span class="comment">// 16,24,32 位的密钥</span></span><br><span class="line">    fmt.Println(<span class="string">"原文："</span>, plaintext)</span><br><span class="line">    ciphertext, nonce := AESGCMEncrypt(plaintext, key)</span><br><span class="line">    fmt.Println(<span class="string">"密文: "</span>, ciphertext, nonce)</span><br><span class="line">    fmt.Println(<span class="string">"解密结果: "</span>, AESGCMDecrypt(ciphertext, key, nonce))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AES-CBC-模式加密解密"><a href="#AES-CBC-模式加密解密" class="headerlink" title="AES CBC 模式加密解密"></a>AES CBC 模式加密解密</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/aes"</span></span><br><span class="line">    <span class="string">"crypto/cipher"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESCBCEncrypt</span><span class="params">(plaintextStr <span class="keyword">string</span>, keyStr <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 转成字节数组</span></span><br><span class="line">    plaintext := []<span class="keyword">byte</span>(plaintextStr)</span><br><span class="line">    key := []<span class="keyword">byte</span>(keyStr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组秘钥</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取秘钥块的长度</span></span><br><span class="line">    blockSize := block.BlockSize()</span><br><span class="line">    <span class="comment">// 补全码</span></span><br><span class="line">    plaintext = PKCS7Padding(plaintext, blockSize)</span><br><span class="line">    <span class="comment">// 加密模式</span></span><br><span class="line">    blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    ciphertext := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(plaintext))</span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    blockMode.CryptBlocks(ciphertext, plaintext)</span><br><span class="line">    <span class="comment">//使用 RawURLEncoding,不要使用 StdEncoding,放在url参数中会导致错误</span></span><br><span class="line">    <span class="keyword">return</span> base64.RawURLEncoding.EncodeToString(ciphertext)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESCBCDecrypt</span><span class="params">(ciphertextStr <span class="keyword">string</span>, key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用 RawURLEncoding,不要使用 StdEncoding 放在url参数中回导致错误</span></span><br><span class="line">    ciphertext, _ := base64.RawURLEncoding.DecodeString(ciphertextStr)</span><br><span class="line">    k := []<span class="keyword">byte</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组秘钥</span></span><br><span class="line">    block, err := aes.NewCipher(k)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取秘钥块的长度</span></span><br><span class="line">    blockSize := block.BlockSize()</span><br><span class="line">    <span class="comment">// 加密模式</span></span><br><span class="line">    blockMode := cipher.NewCBCDecrypter(block, k[:blockSize])</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    plaintext := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(ciphertext))</span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    blockMode.CryptBlocks(plaintext, ciphertext)</span><br><span class="line">    <span class="comment">// 去补全码</span></span><br><span class="line">    plaintext = PKCS7UnPadding(plaintext)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(plaintext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//补码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7Padding</span><span class="params">(plaintext []<span class="keyword">byte</span>, blocksize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    padding := blocksize - <span class="built_in">len</span>(plaintext)%blocksize</span><br><span class="line">    padtext := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(plaintext, padtext...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7UnPadding</span><span class="params">(plaintext []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(plaintext)</span><br><span class="line">    unpadding := <span class="keyword">int</span>(plaintext[length<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> plaintext[:(length - unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    plaintext := <span class="string">"hello world"</span></span><br><span class="line">    key := <span class="string">"123456781234567812345678"</span> <span class="comment">// 16,24,32 位的密钥</span></span><br><span class="line">    fmt.Println(<span class="string">"原文: "</span>, plaintext)</span><br><span class="line">    ciphertext := AESCBCEncrypt(plaintext, key)</span><br><span class="line">    fmt.Println(<span class="string">"密文: "</span>, ciphertext)</span><br><span class="line">    plaintext2 := AESCBCDecrypt(ciphertext, key)</span><br><span class="line">    fmt.Println(<span class="string">"解密结果: "</span>, plaintext2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CFB 模式加密用法与 CBC 加密模式用法基本一致,在创建 <code>blockMode</code> 时调用对应的方法即可</p>
<h2 id="crypto-md5"><a href="#crypto-md5" class="headerlink" title="crypto/md5"></a><code>crypto/md5</code></h2><p>md5 包实现了 RFC 1321 中定义的 MD5 哈希算法.导入方式 <code>import &quot;crypto/md5&quot;</code>. <code>sha1</code>,<code>sha256</code>,<code>sha512</code> 变量定义与相关方法与 <code>md5</code> 类似,不再赘述</p>
<h3 id="常量及变量-1"><a href="#常量及变量-1" class="headerlink" title="常量及变量"></a>常量及变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MD5的块大小,以字节为单位</span></span><br><span class="line"><span class="keyword">const</span> BlockSize = <span class="number">64</span></span><br><span class="line"><span class="comment">// MD5 校验和的大小</span></span><br><span class="line"><span class="keyword">const</span> Size = <span class="number">16</span></span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 `hash.Hash`,用于计算 MD5校验和.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">hash</span>.<span class="title">Hash</span></span></span><br><span class="line"><span class="comment">// 返回 data 的 MD5 校验和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(data []<span class="keyword">byte</span>)</span> [<span class="title">Size</span>]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h3 id="计算字符串的校验和"><a href="#计算字符串的校验和" class="headerlink" title="计算字符串的校验和"></a>计算字符串的校验和</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 `hash.Hash`</span></span><br><span class="line">    h := md5.New()</span><br><span class="line">    <span class="comment">// 向其中写入数据</span></span><br><span class="line">    io.WriteString(h, <span class="string">"The fog is getting thicker!"</span>)</span><br><span class="line">    io.WriteString(h, <span class="string">"And Leon's getting laaarger!"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>)) <span class="comment">// h.Sum() 用于计算校验和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或直接使用包函数 md5.Sum(data []byte) 计算校验和</span></span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">"These pretzels are making me thirsty."</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%x"</span>, md5.Sum(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算文件的校验和"><a href="#计算文件的校验和" class="headerlink" title="计算文件的校验和"></a>计算文件的校验和</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"file.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    h := md5.New()</span><br><span class="line">    <span class="comment">// 其实还是将文件中数据读出来,写入到 h 对象中</span></span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(h, f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="crypto-rand"><a href="#crypto-rand" class="headerlink" title="crypto/rand"></a><code>crypto/rand</code></h2><p>rand 包实现了加密安全的随机数生成器.它在包中定义了全局唯一的 <code>var Reader io.Reader</code> 变量提供了以下方法用于生成随机数</p>
<h3 id="常量及变量-2"><a href="#常量及变量-2" class="headerlink" title="常量及变量"></a>常量及变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密安全的随机数生成其的全局共享实例</span></span><br><span class="line"><span class="keyword">var</span> Reader io.Reader</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回范围为 [0,max) 的随机整数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(rand io.Reader, max *big.Int)</span> <span class="params">(n *big.Int, err error)</span></span></span><br><span class="line"><span class="comment">// 将随机数传入 b.其实是调用了 io.ReadFull(Reader, b),是该函数的辅助函数.</span></span><br><span class="line"><span class="comment">// 当且仅当 n=len(b)时,返回 err=nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建随机数的切片,使用 `io.ReadFull` 将 rand.Reader 产生的随机数写入 nonce 中</span></span><br><span class="line">nonce := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, nonce); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="crypto-rsa"><a href="#crypto-rsa" class="headerlink" title="crypto/rsa"></a><code>crypto/rsa</code></h2><p>rsa 实现了 RSA 非对称加密算法,该算法通过生成密钥对实现加密和加密,公钥文件用于加密,私钥用于解密.</p>
<p>RSA 是一个基本操作,在此程序包中用于实现公钥加密或公钥签名.此包中的 RSA 操作未使用固定时间算法实现.</p>
<h3 id="常量及变量-3"><a href="#常量及变量-3" class="headerlink" title="常量及变量"></a>常量及变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// PSSSaltLengthAuto 会使 RSA-PSS 签名中的盐在签名时尽可能大,并在验证时自动检测</span></span><br><span class="line">    PSSSaltLengthAuto = <span class="number">0</span></span><br><span class="line">    <span class="comment">// PSSSaltLengthEqualsHash 使盐的长度等于签名中使用的哈希的长度</span></span><br><span class="line">    PSSSaltLengthEqualsHash = <span class="number">-1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="类型定义-1"><a href="#类型定义-1" class="headerlink" title="类型定义"></a>类型定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RSA 私钥的结构体定义,可通过 `rsa.GenerateKey` 生成对象</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey            <span class="comment">// 公钥部分</span></span><br><span class="line">    D         *big.Int   <span class="comment">// private exponent</span></span><br><span class="line">    Primes    []*big.Int <span class="comment">// prime factors of N, has &gt;= 2 elements.</span></span><br><span class="line">    <span class="comment">// Precomputed contains precomputed values that speed up private operations, if available.</span></span><br><span class="line">    Precomputed PrecomputedValues</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA 公钥结构体定义,包含在私钥中</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    N *big.Int <span class="comment">// modulus</span></span><br><span class="line">    E <span class="keyword">int</span>      <span class="comment">// public exponent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于使用 `crypto.Decrypter` 解密的 OAEP 选项结构体</span></span><br><span class="line"><span class="keyword">type</span> OAEPOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 生成掩码时使用的哈希函数.</span></span><br><span class="line">    Hash crypto.Hash</span><br><span class="line">    <span class="comment">// 任意字节字符,必须等于加密时使用的 Label</span></span><br><span class="line">    Label []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于使用 `crypto.Decrypter` PKCS#1 v1.5 解密的 PKCS1v15 选项结构体</span></span><br><span class="line"><span class="keyword">type</span> PKCS1v15DecryptOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 要解密的会话密钥的长度. 如果不为零,解密期间的错误将返回此长度的随机明文,而不是返回错误</span></span><br><span class="line">    SessionKeyLen <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建和验证 RSA-PSS 签名的选项结构体</span></span><br><span class="line"><span class="keyword">type</span> PSSOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 控制 PSS 签名中使用盐的长度,可以是一个数字,也可以是特殊 PSSSaltLength 常量之一</span></span><br><span class="line">    SaltLength <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖传递给 SignPSS 的 hash 函数</span></span><br><span class="line">    <span class="comment">// 这是使用 crypto.Signer 接口时指定哈希函数的唯一方法</span></span><br><span class="line">    Hash crypto.Hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><h3 id="rsa-包函数"><a href="#rsa-包函数" class="headerlink" title="rsa 包函数"></a><code>rsa</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用随机树源 random 生成指定 bits 的 RSA 密钥对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(random io.Reader, bits <span class="keyword">int</span>)</span> <span class="params">(*PrivateKey, error)</span></span></span><br><span class="line"><span class="comment">// 使用 RSA-OAEP 对 msg 进行加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptOAEP</span><span class="params">(hash hash.Hash, random io.Reader, pub *PublicKey, msg []<span class="keyword">byte</span>, label []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 使用 RSA-OAEP 对 ciphertext 进行解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptOAEP</span><span class="params">(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []<span class="keyword">byte</span>, label []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RSA 和 PKCS#1 v1.5 中的补充协议对给定 msg 进行加密解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptPKCS1v15</span><span class="params">(rand io.Reader, pub *PublicKey, msg []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, ciphertext []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用来自 RSA PKCS＃1 v1.5 的 RSASSA-PKCS1-V1_5-SIGN 计算 hashed 的签名及认证</span></span><br><span class="line"><span class="comment">// hashed 必须是使用 hash 函数对 msg 进行哈希的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyPKCS1v15</span><span class="params">(pub *PublicKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用 RSASSA-PSS [1]计算 hashed 的签名及认证</span></span><br><span class="line"><span class="comment">// hashed 必须是使用 hash 函数对 msg 进行哈希的结果.opts参数可以为nil,使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignPSS</span><span class="params">(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>, opts *PSSOptions)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="PrivateKey-结构体方法"><a href="#PrivateKey-结构体方法" class="headerlink" title="PrivateKey 结构体方法"></a><code>PrivateKey</code> 结构体方法</h4><p><code>PrivateKey</code> 结构体实现了 <code>crypto.Decrypter</code> 和 <code>crypto.Signer</code> 接口.具有以下方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 priv 对指定 ciphertext 密文解密,返回解密后的明文即可能产生的错误</span></span><br><span class="line"><span class="comment">// 如果 opts 为空或 *PKCS1v15DecryptOptions,则使用 PKCS#1 v1.5 解密.否则必须为 *OAEPOptions 使用 OAEP 解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Decrypt</span><span class="params">(rand io.Reader, ciphertext []<span class="keyword">byte</span>, opts crypto.DecrypterOpts)</span> <span class="params">(plaintext []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 执行一些运算,加快将来私钥操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Precompute</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 返回公钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Public</span><span class="params">()</span> <span class="title">crypto</span>.<span class="title">PublicKey</span></span></span><br><span class="line"><span class="comment">// 使用私钥签名,从 rand 读取随机数</span></span><br><span class="line"><span class="comment">// 如果 opts 是 *PSSOptions 将使用 PSS签名,否则使用 PKCS#1 v1.5 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Sign</span><span class="params">(rand io.Reader, digest []<span class="keyword">byte</span>, opts crypto.SignerOpts)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 对密钥执行基本的完整性检查.返回检查过程中可能出现的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><h3 id="对数据进行加密解密"><a href="#对数据进行加密解密" class="headerlink" title="对数据进行加密解密"></a>对数据进行加密解密</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    privateKey, err := rsa.GenerateKey(rand.Reader, <span class="number">2048</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    msg := []<span class="keyword">byte</span>(<span class="string">"send reinforcements, we're going to advance"</span>)</span><br><span class="line">    label := []<span class="keyword">byte</span>(<span class="string">"orders"</span>)</span><br><span class="line">    rng := rand.Reader</span><br><span class="line">    <span class="comment">// 使用公钥对数据进行加密</span></span><br><span class="line">    ciphertext, err := rsa.EncryptOAEP(sha256.New(), rng, &amp;privateKey.PublicKey, msg, label)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from encryption: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Ciphertext: %x\n"</span>, ciphertext)</span><br><span class="line">    <span class="comment">// 使用私钥对数据进行解密</span></span><br><span class="line">    plaintext, err := rsa.DecryptOAEP(sha256.New(), rng, privateKey, ciphertext, label)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from deecryption: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Plaintext: %s\n"</span>, <span class="keyword">string</span>(plaintext))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对数据进行签名认证"><a href="#对数据进行签名认证" class="headerlink" title="对数据进行签名认证"></a>对数据进行签名认证</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    privateKey, err := rsa.GenerateKey(rand.Reader, <span class="number">2048</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    message := []<span class="keyword">byte</span>(<span class="string">"message to be signed"</span>)</span><br><span class="line">    hashed := sha256.Sum256(message)  <span class="comment">// 使用 sha256 进行哈希</span></span><br><span class="line">    <span class="comment">// 使用 rsa 私钥进行签名</span></span><br><span class="line">    signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hashed[:])</span><br><span class="line">    <span class="comment">// 或使用 rsa PSS 进行签名</span></span><br><span class="line">    <span class="comment">// signature, err := rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, hashed[:], nil)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from signing: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Signature: %x\n"</span>, signature)</span><br><span class="line">    <span class="comment">// 使用 rsa 公钥进行认证</span></span><br><span class="line">    err = rsa.VerifyPKCS1v15(&amp;privateKey.PublicKey, crypto.SHA256, hashed[:], signature)</span><br><span class="line">    <span class="comment">// 或使用 rsa PSS 进行认证</span></span><br><span class="line">    <span class="comment">// err = rsa.VerifyPSS(&amp;privateKey.PublicKey, crypto.SHA256, hashed[:], signature, nil)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from verification: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"认证通过"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 fmt 包</title>
    <url>/2020/05/16/go-study-notes-package-fmt/</url>
    <content><![CDATA[<p>fmt 包采用占位符的方式实现了格式化的 I/O.主要占位符如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: <span class="string">"name"</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常规占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%v</td>
<td align="center">默认格式的值</td>
<td align="center"><code>Printf(&quot;%v&quot;, user)</code></td>
<td align="center">{name}</td>
</tr>
<tr>
<td align="center">%+v</td>
<td align="center">打印结构体时,会添加字段名</td>
<td align="center"><code>Printf(&quot;%+v&quot;, user)</code></td>
<td align="center">{Name:name}</td>
</tr>
<tr>
<td align="center">%#v</td>
<td align="center">Go 语法表示的值</td>
<td align="center"><code>Printf(&quot;%#v&quot;, user)</code></td>
<td align="center">main.User{Name:”name”}</td>
</tr>
<tr>
<td align="center">%T</td>
<td align="center">Go 语法表示的值的类型</td>
<td align="center"><code>Printf(&quot;%T&quot;, user)</code></td>
<td align="center">main.User</td>
</tr>
<tr>
<td align="center">%%</td>
<td align="center">百分号</td>
<td align="center"><code>Printf(&quot;%%&quot;)</code></td>
<td align="center">%</td>
</tr>
</tbody></table>
<ul>
<li>布尔占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%t</td>
<td align="center">true 或 false</td>
<td align="center"><code>Printf(&quot;%t&quot;, true)</code></td>
<td align="center">true</td>
</tr>
</tbody></table>
<ul>
<li>整型占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%b</td>
<td align="center">二进制表示(不以 0 开头,且只有 01)</td>
<td align="center"><code>Printf(&quot;%b&quot;, 8)</code></td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">十进制表示(不以 0 开头,且只有0-9)</td>
<td align="center"><code>Printf(&quot;%b&quot;, 8)</code></td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">%o</td>
<td align="center">八进制表示(以 0 开头,且只有 0-7)</td>
<td align="center"><code>Printf(&quot;%o&quot;, 32)</code></td>
<td align="center">40</td>
</tr>
<tr>
<td align="center">%x</td>
<td align="center">十六进制的小写表示(以 0x 开头)</td>
<td align="center"><code>Printf(&quot;%x&quot;, 223)</code></td>
<td align="center">df</td>
</tr>
<tr>
<td align="center">%X</td>
<td align="center">十六进制的大写表示(以 0X 开头)</td>
<td align="center"><code>Printf(&quot;%X&quot;, 223)</code></td>
<td align="center">DF</td>
</tr>
</tbody></table>
<ul>
<li>浮点型占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%e</td>
<td align="center">科学计数,小写表示</td>
<td align="center"><code>Printf(&quot;%.2e&quot;, 1024.5)</code></td>
<td align="center">1.02e+03</td>
</tr>
<tr>
<td align="center">%E</td>
<td align="center">科学计数,大写表示</td>
<td align="center"><code>Printf(&quot;%.2E&quot;, 1024.5)</code></td>
<td align="center">1.02E+03</td>
</tr>
<tr>
<td align="center">%f</td>
<td align="center">浮点数表示,多用于限制小数位数</td>
<td align="center"><code>Printf(&quot;%.2f&quot;, 22.2335)</code></td>
<td align="center">2.23</td>
</tr>
</tbody></table>
<ul>
<li>字符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%s</td>
<td align="center">字符串或字符切片的字符串表示</td>
<td align="center"><code>Printf(&quot;%s,%s&quot;, &quot;str&quot;, []byte(&quot;str&quot;)</code></td>
<td align="center">str,str</td>
</tr>
</tbody></table>
<ul>
<li>指针</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%p</td>
<td align="center">对象的指针表示,切片为也为第一个元素的指针地址</td>
<td align="center">Printf(“%p”, []byte(“string”))</td>
<td align="center">0xc0000160b0</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定格式将数据进行格式化,并写入 w</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描从 r 读取的数据,以空格为分隔符存储到参数中,返回成功扫描的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出到标准输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从标准输入扫描数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 format 给出的格式,返回格式化后的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描 str 参数,以空格为分隔符存储到参数中,返回成功扫描的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="keyword">string</span>, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 io 包</title>
    <url>/2020/05/05/go-study-notes-package-io/</url>
    <content><![CDATA[<p><code>io</code> 包提供了对 IO 原语的基本接口. 它主要封装了一些已有的实现(如 os 包中的),并将这些抽象为使用性的功能和一些其它相关接口.</p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读相关接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">     <span class="comment">// 从数据流里将 len(p) 个字节读入 p.返回读取的字节数(0&lt;=n&lt;=len(p)和可能发生的错误.在文件读取时, 返回 0和 io.EOF 表示读取到文件结尾</span></span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 从数据流里 off 位置开始将 len(p) 个字节读入 p.返回读取的字节数(0&lt;=n&lt;=len(p)和可能发生的错误</span></span><br><span class="line">    ReadAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 从 r 读取数据直到发生错误或文件结束(EOF). 返回读取的字节数 n 及遇到的错误(EOF除外)</span></span><br><span class="line">    ReadFrom(r Reader) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回读取的单个字节及可能发生的错误</span></span><br><span class="line">    ReadByte() (c <span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写相关接口</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 将 p 的 len(p) 个字节写入数据流.返回写入的字节数(0&lt;=n&lt;=len(p)和可能发生的错误.</span></span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 从数据流 off 位置开始,将 p 的 len(p) 个字节写入数据流.返回写入的字节数(0&lt;=n&lt;=len(p)和可能发生的错误.</span></span><br><span class="line">    WriteAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 写入数据到 w 直到发生错误.返回读取的字节数 n 及遇到的错误</span></span><br><span class="line">    WriteTo(w Writer) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串 s 写入到数据流中,返回写入的字节数(0&lt;=n&lt;=len(s)和可能发生的错误</span></span><br><span class="line">    WriteString(s <span class="keyword">string</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写接口</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭接口</span></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭数据流</span></span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写指针移位接口</span></span><br><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 设置下一次读写的位置,whence 设置参照点,offset 设置偏移量.</span></span><br><span class="line">    <span class="comment">// whence 可选值为 `io.SeekStart`(0,文件开始),`io.SeekCurrent`(1,当前位置),`io.SeekEnd`(2,结尾位置).</span></span><br><span class="line">    Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SeekStart   = <span class="number">0</span> <span class="comment">// 相对于文件开始位置</span></span><br><span class="line">    SeekCurrent = <span class="number">1</span> <span class="comment">// 相对于文件当前位置</span></span><br><span class="line">    SeekEnd     = <span class="number">2</span> <span class="comment">// 相对于文件结尾位置</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当无法得到更多输入时,Read 方法返回 EOF.可以作为文件读取结束的表示</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h2 id="io-包方法"><a href="#io-包方法" class="headerlink" title="io 包方法"></a><code>io</code> 包方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 src 的数据拷贝到 dst.返回拷贝的字节数和可能发生的错误</span></span><br><span class="line"><span class="comment">// 底层调用了 `CopyBuffer(dst, src, nil)`, 使用默认的缓冲区,默认大小为 32 * 1024</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 从 src 拷贝 n 个字节数据到 dst,直到发生错误或 EOF.返回复制的字节数和可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyN</span><span class="params">(dst Writer, src Reader, n <span class="keyword">int64</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将 src 的数据拷贝到 dst.返回拷贝的字节数和可能发生的错误. buf 可以指定指定缓冲区的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将 r 中 min 个字节读取到 buf 中.返回复制的字节数及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>, min <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将 r 中 len(buf) 个字节读取到 buf 中.返回复制的字节数及可能发生的错误</span></span><br><span class="line"><span class="comment">// 其实是调用了,ReadAtLeast(r, buf, len(buf)).如果 n&lt;len(buf),则产生非 io.EOF 错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">//  将字符串 s 写入 w 中.返回写入的字节长度及可能发生的错误</span></span><br><span class="line"><span class="comment">//  如果 w 实现了 StringWriter 接口, `w.WriteString()` 将直接被调用.参见 https://github.com/golang/go/blob/master/src/io/io.go#L293</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>拷贝文件</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFileExample</span><span class="params">(src, dest <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    srcFile, err := os.Open(src)</span><br><span class="line">    <span class="keyword">defer</span> srcFile.Close()</span><br><span class="line">    destFile, err := os.OpenFile(dest, os.O_CREATE|os.O_RDWR|os.O_SYNC, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">defer</span> destFile.Close()</span><br><span class="line">    _, err = io.Copy(destFile, srcFile)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := copyFileExample(<span class="string">"src"</span>, <span class="string">"dest"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 http 包</title>
    <url>/2020/05/10/go-study-notes-package-http/</url>
    <content><![CDATA[<p><code>http</code> 包提供了 HTTP 客户端和服务端的实现.它提供了 HTTP 通信过程中各种对象的定义及实现.导入方式为 <code>import &quot;net/http&quot;</code></p>
<p>对于客户端,它可以使用 <code>Get</code>,<code>Head</code>,<code>Post</code>和<code>PostForm</code> 等方法直接发送对应的 HTTP 请求,也可以通过 <code>Client</code> 类型自定义客户端,从而调用其中方法发送 HTTP 请求.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接发送请求,并接收响应</span></span><br><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line">resp, err := http.PostForm(<span class="string">"http://example.com/form"</span>,</span><br><span class="line">    url.Values&#123;<span class="string">"key"</span>: &#123;<span class="string">"Value"</span>&#125;, <span class="string">"id"</span>: &#123;<span class="string">"123"</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// 客户端必须显式关闭响应体</span></span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 Client 实例对象,并使用该对象发送请求</span></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">    CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"http://example.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以预生成请求,然后由客户端发送</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>对于传输过程,它提供了支持代理,TLS 配置,keep-alive,压缩等传输方式的 <code>Transport</code> 类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 Transport 对象实例,并使参数在传输过程中生效</span></span><br><span class="line">tr := &amp;http.Transport&#123;</span><br><span class="line">    MaxIdleConns:       <span class="number">10</span>,</span><br><span class="line">    IdleConnTimeout:    <span class="number">30</span> * time.Second,</span><br><span class="line">    DisableCompression: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure>

<p>对于服务端,它提供了 <code>ListenAndServe</code> 函数使用给定的地址和处理程序启动 HTTP 服务器,还提供了 <code>Server</code> 类型用于自定义服务端及处理请求的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</span><br><span class="line">http.HandleFunc(<span class="string">"/bar"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := &amp;http.Server&#123;</span><br><span class="line">    Addr:           <span class="string">":8080"</span>,</span><br><span class="line">    Handler:        myHandler,</span><br><span class="line">    ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">    WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">    MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(s.ListenAndServe())</span><br></pre></td></tr></table></figure>

<p><code>http</code> 包的 <code>Transport</code> 和 <code>Server</code> 类型对于简单的配置都自动支持 HTTP/2 协议.要使用更为复杂的 HTTP/2 协议,请直接导入 <code>golang.org/x/net/http2</code>,并使用其 <code>ConfigureTransport</code> 或 <code>ConfigureServer</code> 类型的相关函数.</p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端类型结构体定义,用于自定义客户端</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 发出 HTTP 请求机制.默认使用 `DefaultTransport`</span></span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    <span class="comment">// 指定重定向策略.如果不为 nil,则在 HTTP 重定向之前调用它.否则使用默认策略,在连续 10 个请求后停止</span></span><br><span class="line">    <span class="comment">// req 与 via 分别为即将到来的请求和已发出的请求.</span></span><br><span class="line">    CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span> <span class="title">error</span></span></span><br><span class="line">    Jar CookieJar  <span class="comment">// 指定 CookieJar</span></span><br><span class="line">    Timeout time.Duration  <span class="comment">// 超时时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求的函数接口</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求的函数</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求头</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求对象</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    Method <span class="keyword">string</span>  <span class="comment">// 请求方法</span></span><br><span class="line">    URL *url.URL  <span class="comment">// 请求 URL</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// 请求协议,对于客户端来说,默认是 HTTP/1.1 或 HTTP/2</span></span><br><span class="line">    Header Header  <span class="comment">// 请求头</span></span><br><span class="line">    Body io.ReadCloser  <span class="comment">// 请求体</span></span><br><span class="line">    GetBody <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.ReadCloser, error)</span> // 获取请求体的方法</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span>  <span class="comment">// 请求长度,-1 表示未知</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line">    Close <span class="keyword">bool</span>  <span class="comment">// 发送请求后是否关闭 TCP 连接</span></span><br><span class="line">    Host <span class="keyword">string</span>  <span class="comment">// 请求主机,如果为空,则使用 URL.Host 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下三个属性需要调用`ParseForm` 或 `ParseMultipartForm` 后才可获取属性值</span></span><br><span class="line">    Form url.Values  <span class="comment">// 已解析的表单数据,包含 URL 参数,PATCH,POST,PUT 表单数据.</span></span><br><span class="line">    PostForm url.Values <span class="comment">// 已解析的表单数据,包含 PATCH,POST,PUT 表单数据</span></span><br><span class="line">    MultipartForm *multipart.Form <span class="comment">// 已解析的表单数据,主要用于文件上传</span></span><br><span class="line"></span><br><span class="line">    RemoteAddr <span class="keyword">string</span>  <span class="comment">// 远程地址</span></span><br><span class="line">    RequestURI <span class="keyword">string</span>  <span class="comment">// 请求 URI</span></span><br><span class="line">    TLS *tls.ConnectionState  <span class="comment">// TLS 连接信息</span></span><br><span class="line">    Response *Response <span class="comment">// 响应</span></span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 响应对象</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status     <span class="keyword">string</span> <span class="comment">// 状态</span></span><br><span class="line">    StatusCode <span class="keyword">int</span>    <span class="comment">// 状态码</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// 协议</span></span><br><span class="line">    Header Header  <span class="comment">// 响应头</span></span><br><span class="line">    Body io.ReadCloser  <span class="comment">// 响应体</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span>  <span class="comment">// 响应长度</span></span><br><span class="line">    Uncompressed <span class="keyword">bool</span> <span class="comment">// 报告是否以压缩方式发送了响应</span></span><br><span class="line">    Request *Request  <span class="comment">// 请求</span></span><br><span class="line">    TLS *tls.ConnectionState <span class="comment">// TLS 相关信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务端结构体定义,用于自定义服务端</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="keyword">string</span>  <span class="comment">// HTTP 服务监听的地址,默认为":80"</span></span><br><span class="line">    Handler Handler <span class="comment">// 调用处理请求的程序,默认为 `http.DefaultServeMux`</span></span><br><span class="line">    TLSConfig *tls.Config  <span class="comment">// TLS 相关配置</span></span><br><span class="line">    ReadTimeout time.Duration  <span class="comment">// 读取整个请求的超时时间</span></span><br><span class="line">    ReadHeaderTimeout time.Duration <span class="comment">// 读取请求头的超时时间</span></span><br><span class="line">    WriteTimeout time.Duration  <span class="comment">// 响应的超时时间</span></span><br><span class="line">    IdleTimeout time.Duration <span class="comment">// 启动 keep-alived 后,等待下一个请求的超时时间</span></span><br><span class="line">    MaxHeaderBytes <span class="keyword">int</span> <span class="comment">// 控制请求头的最大字节数</span></span><br><span class="line">    ConnState <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span> // 客户端连接状态更改时的回调函数</span></span><br><span class="line">    ErrorLog *log.Logger <span class="comment">// 错误日志记录器.默认为 log 包提供的标准 logger</span></span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见 HTTP 响应状态码定义(仅包含常见部分),详见 https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusOK                   = <span class="number">200</span> <span class="comment">// RFC 7231, 6.3.1</span></span><br><span class="line">    StatusNoContent            = <span class="number">204</span> <span class="comment">// RFC 7231, 6.3.5</span></span><br><span class="line"></span><br><span class="line">    StatusMovedPermanently = <span class="number">301</span> <span class="comment">// RFC 7231, 6.4.2</span></span><br><span class="line">    StatusFound            = <span class="number">302</span> <span class="comment">// RFC 7231, 6.4.3</span></span><br><span class="line">    StatusTemporaryRedirect = <span class="number">307</span> <span class="comment">// RFC 7231, 6.4.7</span></span><br><span class="line">    StatusPermanentRedirect = <span class="number">308</span> <span class="comment">// RFC 7538, 3</span></span><br><span class="line"></span><br><span class="line">    StatusBadRequest                   = <span class="number">400</span> <span class="comment">// RFC 7231, 6.5.1</span></span><br><span class="line">    StatusUnauthorized                 = <span class="number">401</span> <span class="comment">// RFC 7235, 3.1</span></span><br><span class="line">    StatusPaymentRequired              = <span class="number">402</span> <span class="comment">// RFC 7231, 6.5.2</span></span><br><span class="line">    StatusForbidden                    = <span class="number">403</span> <span class="comment">// RFC 7231, 6.5.3</span></span><br><span class="line">    StatusNotFound                     = <span class="number">404</span> <span class="comment">// RFC 7231, 6.5.4</span></span><br><span class="line">    StatusMethodNotAllowed             = <span class="number">405</span> <span class="comment">// RFC 7231, 6.5.5</span></span><br><span class="line">    StatusRequestTimeout               = <span class="number">408</span> <span class="comment">// RFC 7231, 6.5.7</span></span><br><span class="line">    StatusRequestEntityTooLarge        = <span class="number">413</span> <span class="comment">// RFC 7231, 6.5.11</span></span><br><span class="line">    StatusRequestURITooLong            = <span class="number">414</span> <span class="comment">// RFC 7231, 6.5.12</span></span><br><span class="line">    StatusUnsupportedMediaType         = <span class="number">415</span> <span class="comment">// RFC 7231, 6.5.13</span></span><br><span class="line">    StatusTooManyRequests              = <span class="number">429</span> <span class="comment">// RFC 6585, 4</span></span><br><span class="line"></span><br><span class="line">    StatusInternalServerError           = <span class="number">500</span> <span class="comment">// RFC 7231, 6.6.1</span></span><br><span class="line">    StatusNotImplemented                = <span class="number">501</span> <span class="comment">// RFC 7231, 6.6.2</span></span><br><span class="line">    StatusBadGateway                    = <span class="number">502</span> <span class="comment">// RFC 7231, 6.6.3</span></span><br><span class="line">    StatusServiceUnavailable            = <span class="number">503</span> <span class="comment">// RFC 7231, 6.6.4</span></span><br><span class="line">    StatusGatewayTimeout                = <span class="number">504</span> <span class="comment">// RFC 7231, 6.6.5</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 默认的传输方式</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment,</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">        DualStack: <span class="literal">true</span>,</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">    MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">    IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">    TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">    ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认请求处理实例对象,该类型实现了 Handler 接口</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h2 id="http-包函数"><a href="#http-包函数" class="headerlink" title="http 包函数"></a><code>http</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 DefaultServeMux 中对给定的 pattern 注册请求处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听并使用 handler 处理请求.如果 handler 为 nil,则使用 `DefaultServeMux`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr, certFile, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Listener 实例及给定 handler 请求处理启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeTLS</span><span class="params">(l net.Listener, handler Handler, certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建请求对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequestWithContext</span><span class="params">(ctx context.Context, method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ServeMux 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">()</span> *<span class="title">ServeMux</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对应 Handler 对象,返回值可用于传入 Handle</span></span><br><span class="line"><span class="comment">// 以 root 目录作为根目录为 HTTP 请求提供服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileServer</span><span class="params">(root FileSystem)</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 使用 "404 page not found" 响应每个请求,响应状态码为 404</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFoundHandler</span><span class="params">()</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 重定向处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RedirectHandler</span><span class="params">(url <span class="keyword">string</span>, code <span class="keyword">int</span>)</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 从 URL 的路径中删除给定前缀并调用处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StripPrefix</span><span class="params">(prefix <span class="keyword">string</span>, h Handler)</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 返回给定时间限制下的运行 h 的 Handler,并在超时时提示 msg</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeoutHandler</span><span class="params">(h Handler, dt time.Duration, msg <span class="keyword">string</span>)</span> <span class="title">Handler</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下函数多用于作为 handler 变量向 HandleFunc 传入或通过自定义 Handler 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFound</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br><span class="line"><span class="comment">// 使用给定文件或目录的内容答复请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeFile</span><span class="params">(w ResponseWriter, r *Request, name <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="comment">// 设置响应的 cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Client-结构体方法"><a href="#Client-结构体方法" class="headerlink" title="Client 结构体方法"></a><code>Client</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭等待连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">CloseIdleConnections</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 使用配置的客户端发送请求并返回响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span></span><br><span class="line"><span class="comment">// 向 url 发送 Get,Head,Post,Post(提交表单) 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Head</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Post</span><span class="params">(url, contentType <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">// 向 url 发送 Post 请求,data 的键值编码为请求正文.(`url.Values` 为 `map[string][]string` 格式的字典对象)</span></span><br><span class="line"><span class="comment">// 此时 Content-Type 请求头设置为 application/x-www-form-urlencoded</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">PostForm</span><span class="params">(url <span class="keyword">string</span>, data url.Values)</span> <span class="params">(resp *Response, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Header-结构体方法"><a href="#Header-结构体方法" class="headerlink" title="Header 结构体方法"></a><code>Header</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Header</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Values</span><span class="params">(key <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">WriteSubset</span><span class="params">(w io.Writer, exclude <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Request-结构体方法"><a href="#Request-结构体方法" class="headerlink" title="Request 结构体方法"></a><code>Request</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">AddCookie</span><span class="params">(c *Cookie)</span>  // 添加 <span class="title">cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">BasicAuth</span><span class="params">()</span> <span class="params">(username, password <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span> // 返回请求基本认证中的用户名密码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookie</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Cookie, error)</span> // 返回指定名称的 <span class="title">Cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span>  // 返回所有 <span class="title">cookie</span></span></span><br><span class="line"><span class="comment">// 返回表单中指定 key 中的第一个文件对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormFile</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(multipart.File, *multipart.FileHeader, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span> // 返回表单中 <span class="title">key</span> 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseForm</span><span class="params">()</span> <span class="title">error</span>  // 解析表单</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseMultipartForm</span><span class="params">(maxMemory <span class="keyword">int64</span>)</span> <span class="title">error</span> // 解析带有文件的表单</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Referer</span><span class="params">()</span> <span class="title">string</span>  // 返回引用 <span class="title">URL</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">SetBasicAuth</span><span class="params">(username, password <span class="keyword">string</span>)</span>  // 设置基本认证请求的用户名密码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">UserAgent</span><span class="params">()</span> <span class="title">string</span> // 返回请求的客户端代理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span> // 将请求写入文件</span></span><br></pre></td></tr></table></figure>

<h3 id="Response-结构体方法"><a href="#Response-结构体方法" class="headerlink" title="Response 结构体方法"></a><code>Response</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Response)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span>  // 响应的 <span class="title">cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Response)</span> <span class="title">Location</span><span class="params">()</span> <span class="params">(*url.URL, error)</span> // 返回响应的`<span class="title">Location</span>` 响应头</span></span><br></pre></td></tr></table></figure>

<h3 id="ServeMux-结构体方法"><a href="#ServeMux-结构体方法" class="headerlink" title="ServeMux 结构体方法"></a><code>ServeMux</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册处理请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class="line"><span class="comment">// 返回给定请求的处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Server-结构体方法"><a href="#Server-结构体方法" class="headerlink" title="Server 结构体方法"></a><code>Server</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即关闭服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"> <span class="comment">// 监听并启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServeTLS</span><span class="params">(certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 注册一个函数,当 server 关闭时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">RegisterOnShutdown</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br><span class="line"><span class="comment">// 在 listener 上接受连接,并为每个连接创建一个新的 goroutine 处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ServeTLS</span><span class="params">(l net.Listener, certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 设置是否启用 keep-alive</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">SetKeepAlivesEnabled</span><span class="params">(v <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 优雅的关闭服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// StripPrefix 用于将请求前缀删除,请求 `/tmpfiles/` 会请求到 `/`</span></span><br><span class="line">    <span class="comment">// http.Handle("/tmpfiles/", http.StripPrefix("/tmpfiles/", http.FileServer(http.Dir("/usr/share/doc"))))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会自动解析 index.html.如果没有,则会返回路径下的文件链接</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, http.FileServer(http.Dir(<span class="string">"/usr/share/doc"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用-PostForm-发送请求及数据"><a href="#调用-PostForm-发送请求及数据" class="headerlink" title="调用 PostForm 发送请求及数据"></a>调用 <code>PostForm</code> 发送请求及数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := url.Values&#123;</span><br><span class="line">        <span class="string">"name"</span>: []<span class="keyword">string</span>&#123;<span class="string">"name"</span>&#125;,</span><br><span class="line">        <span class="string">"age"</span>:  []<span class="keyword">string</span>&#123;<span class="string">"20"</span>&#125;,</span><br><span class="line">        <span class="string">"addr"</span>: []<span class="keyword">string</span>&#123;<span class="string">"beijing"</span>, <span class="string">"shanghai"</span>, <span class="string">"guangzhou"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    res, _ := http.PostForm(<span class="string">"http://www.httpbin.org/post"</span>, data)</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    n, _ := res.Body.Read(buf)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br></pre></td></tr></table></figure>

<h2 id="Handle-与-HandleFunc"><a href="#Handle-与-HandleFunc" class="headerlink" title="Handle 与 HandleFunc"></a><code>Handle</code> 与 <code>HandleFunc</code></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h1 := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">        io.WriteString(w, <span class="string">"Hello from a HandleFunc #1!\n"</span>)</span><br><span class="line">    h2 := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">        io.WriteString(w, <span class="string">"Hello from a HandleFunc #2!\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    http.HandleFunc(<span class="string">"/h1"</span>, h1)</span><br><span class="line">    http.HandleFunc(<span class="string">"/h2"</span>, h2)</span><br><span class="line">    http.Handle(<span class="string">"/notfount"</span>, http.NotFoundHandler())</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义Handler"><a href="#自定义Handler" class="headerlink" title="自定义Handler"></a>自定义<code>Handler</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CustomHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"respose: %v"</span>, c.name) <span class="comment">// 向 w 中写入响应</span></span><br><span class="line">    http.ServeFile(w, req, c.name)  <span class="comment">// 会将文件内容返回给响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := CustomHandler&#123;<span class="string">"index.html"</span>&#125;</span><br><span class="line">    http.ListenAndServe(<span class="string">":80"</span>, http.TimeoutHandler(handler, time.Nanosecond, <span class="string">"请求超时"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 ioutil 包</title>
    <url>/2020/05/05/go-study-notes-package-ioutil/</url>
    <content><![CDATA[<p><code>ioutil</code> 包是 <code>io</code> 包的子包,它提供了一些基本 IO 操作的函数.导入方式为 <code>import &quot;io/ioutil&quot;</code></p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>以下是 <code>ioutil</code> 包中常用的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 r 读取所有数据,直到出现错误或 EOF.返回读取的数据及可能出现的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 读取指定目录下的文件.返回目录下按文件名排序的 `os.FileInfo` 列表及可能出现的错误.</span></span><br><span class="line"><span class="comment">// 只能读取一层.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span></span><br><span class="line"><span class="comment">// 返回读取的指定文件内容及可能出现的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定 dir 目录下创建带有 prefix 前缀的随机临时目录.返回创建的随机临时目录路径名及可能发生的错误</span></span><br><span class="line"><span class="comment">// dir 如果为空,则设定为 `os.TempDir()`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, prefix <span class="keyword">string</span>)</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 在指定 dir 目录下创建带有 pattern 前缀的随机临时目录.返回创建的随机文件的 `*os.File` 及可能发生的错误</span></span><br><span class="line"><span class="comment">// dir 如果为空,则设定为 `os.TempDir()`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(f *os.File, err error)</span></span></span><br><span class="line"><span class="comment">// 将 data 写入指定 filename.返回可能发生的错误</span></span><br><span class="line"><span class="comment">// 如果文件不存在,则以 perm 权限创建该文件;否则清空文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFileExample</span><span class="params">(src, dest <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    data, err := ioutil.ReadFile(src)</span><br><span class="line">    err = ioutil.WriteFile(dest, data, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := copyFileExample(<span class="string">"src"</span>, <span class="string">"dest"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取指定目录及其子目录所有文件"><a href="#读取指定目录及其子目录所有文件" class="headerlink" title="读取指定目录及其子目录所有文件"></a>读取指定目录及其子目录所有文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFile</span><span class="params">(dir <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    PathSeparator := <span class="keyword">string</span>(os.PathSeparator)</span><br><span class="line">    fileInfos, err := ioutil.ReadDir(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, fileInfo := <span class="keyword">range</span> fileInfos &#123;</span><br><span class="line">        <span class="keyword">if</span> fileInfo.IsDir() &#123;</span><br><span class="line">            dirname := strings.Join([]<span class="keyword">string</span>&#123;dir, fileInfo.Name()&#125;, PathSeparator)</span><br><span class="line">            findFile(dirname)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%v%v%v\n"</span>, dir, PathSeparator, fileInfo.Name())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    findFile(<span class="string">"."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 net 包</title>
    <url>/2020/05/10/go-study-notes-package-net/</url>
    <content><![CDATA[<p><code>net</code> 包为网络 I/O 提供了可移植的接口,包括 TCP/IP,UDP,域名解析和 Unix 套接字等.</p>
<p>该软件包提供了对底层网络原语的访问,大多数客户端仅需要 <code>net</code> 包提供的 <code>Dial</code> 和 <code>Listen</code> 函数, <code>Conn</code> 和 <code>Listener</code> 接口相关的的 <code>Accept</code> 方法. <code>crypto/tls</code> 软件包使用相同的接口提供 <code>Dial</code> 和 <code>Listen</code> 函数.</p>
<p>客户端与服务端最简单的通信主要代码示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略部分内容...</span></span><br><span class="line"><span class="comment">// 服务端,监听 tcp localhost:8080 端口</span></span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := ln.Accept()  <span class="comment">// 一直接收连接请求</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> handleConnection(conn)  <span class="comment">// 处理连接的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端调用 Dial 函数与 tcp localhost:8080 建立连接.</span></span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向 conn 写入数据,也就是向服务端发送请求,相关数据会交给服务端处理</span></span><br><span class="line">fmt.Fprintf(conn, <span class="string">"GET / HTTP/1.0\r\n\r\n"</span>)</span><br><span class="line"><span class="comment">// 服务端处理后的数据会写入 conn,客户端就可以从中读取相关响应</span></span><br><span class="line">status, err := bufio.NewReader(conn).ReadString(<span class="string">'\n'</span>)  </span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>域名解析</p>
</blockquote>
<p>域名解析相关方法因操作系统而异.</p>
<p>Unix 系统上,可以使用纯 Go 解析器将 DNS 请求直接发送到 <code>/etc/resolv.conf</code> 列出的两个 DNS 服务器,也可以使用 cgo 的解析器调用 C 语言库,如 getaddrinfo 和 getnameinfo.<br>默认情况下使用纯 Go 解释器,可通过如下方式进行修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GODEBUG=netdns=go    <span class="comment"># 强制使用 Go 解析器</span></span><br><span class="line"><span class="built_in">export</span> GODEBUG=netdns=cgo   <span class="comment"># 强制使用 cgo 解析器</span></span><br></pre></td></tr></table></figure>

<p>Windows 系统上,解析器始终调用 C 语言库函数,如 GetAddrInfo 和 DnsQuery</p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示网络端点地址</span></span><br><span class="line"><span class="comment">// 该接口的实现包括 IPAddr,IPNet,TCPAddr,UDPAddr,UnixAddr</span></span><br><span class="line"><span class="keyword">type</span> Addr <span class="keyword">interface</span> &#123;</span><br><span class="line">    Network() <span class="keyword">string</span> <span class="comment">// 网络类型</span></span><br><span class="line">    String() <span class="keyword">string</span>  <span class="comment">// 地址+端口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通用网络连接,多个 goroutine 可以安全调用 Conn 上的方法</span></span><br><span class="line"><span class="comment">// 该接口的实现包括 tls.Conn,IPConn,TCPConn,UDPConn,UnixConn</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error) <span class="comment">// 从连接中读数据</span></span><br><span class="line">    Write(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error) <span class="comment">// 向连接中写数据</span></span><br><span class="line">    Close() error <span class="comment">// 关闭连接</span></span><br><span class="line">    LocalAddr() Addr <span class="comment">// 连接的本地地址</span></span><br><span class="line">    RemoteAddr() Addr <span class="comment">// 连接的远程地址</span></span><br><span class="line">    SetDeadline(t time.Time) error <span class="comment">// 设置连接的截止时间,0 表示不会超时</span></span><br><span class="line">    SetReadDeadline(t time.Time) error</span><br><span class="line">    SetWriteDeadline(t time.Time) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听器接口定义</span></span><br><span class="line"><span class="comment">// 该接口的实现包括 TCPListener,UnixListener</span></span><br><span class="line"><span class="keyword">type</span> Listener <span class="keyword">interface</span> &#123;</span><br><span class="line">    Accept() (Conn, error)  <span class="comment">// 等待连接</span></span><br><span class="line">    Close() error  <span class="comment">// 关闭监听</span></span><br><span class="line">    Addr() Addr  <span class="comment">// 返回监听者的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h2 id="net-包函数"><a href="#net-包函数" class="headerlink" title="net 包函数"></a><code>net</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向给定的 network, address 发起连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTimeout</span><span class="params">(network, address <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Conn, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给定的 network, address 进行监听.返回监听的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析给定 host 的 IP 地址,返回 IP 列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookupIP</span><span class="params">(host <span class="keyword">string</span>)</span> <span class="params">([]IP, error)</span></span></span><br><span class="line"><span class="comment">// 将给的字符串解析为 IP 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseIP</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">IP</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="简单通信"><a href="#简单通信" class="headerlink" title="简单通信"></a>简单通信</h2><ul>
<li>server.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"server listen %v\n"</span>, listener.Addr())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"conn established from remote %v\n"</span>, conn.RemoteAddr())</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rn, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        message := <span class="keyword">string</span>(buf[:rn])</span><br><span class="line">        fmt.Printf(<span class="string">"client send: %v\n"</span>, message)</span><br><span class="line">        response := <span class="string">"response:"</span> + message</span><br><span class="line">        conn.Write([]<span class="keyword">byte</span>(response))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>client.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"conn from %v to %v\n"</span>, conn.LocalAddr(), conn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(<span class="string">"send message"</span>))</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    n, err := conn.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"recv response: %v"</span>, <span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 os 包</title>
    <url>/2020/05/04/go-study-notes-package-os/</url>
    <content><![CDATA[<p><code>os</code> 包提供了与平台无关的接口以便于为我们提供对系统进行操作函数.导入方式为 <code>import &quot;os&quot;</code></p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件类型掩码封装</span></span><br><span class="line"><span class="keyword">type</span> FileMode <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件对象结构体</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件信息接口</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span>       <span class="comment">// 文件的名字（不含扩展名）</span></span><br><span class="line">    Size() <span class="keyword">int64</span>        <span class="comment">// 普通文件返回值表示其大小,其他文件的返回值含义各系统不同</span></span><br><span class="line">    Mode() FileMode     <span class="comment">// 文件的模式位</span></span><br><span class="line">    ModTime() time.Time <span class="comment">// 文件的修改时间</span></span><br><span class="line">    IsDir() <span class="keyword">bool</span>        <span class="comment">// 等价于Mode().IsDir()</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 底层数据来源（可以返回nil）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h2><p>以下提供了 <code>os</code> 包中的常用常量,包含文件的类型权限,属性等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    &#x2F;&#x2F; 单个字符是 String() 方法格式化的缩写</span><br><span class="line">    ModeDir        FileMode &#x3D; 1 &lt;&lt; (32 - 1 - iota) &#x2F;&#x2F; d: 目录</span><br><span class="line">    ModeAppend                                     &#x2F;&#x2F; a: 追加</span><br><span class="line">    ModeExclusive                                  &#x2F;&#x2F; l: 执行</span><br><span class="line">    ModeTemporary                                  &#x2F;&#x2F; T: 临时文件</span><br><span class="line">    ModeSymlink                                    &#x2F;&#x2F; L: 链接文件</span><br><span class="line">    ModeDevice                                     &#x2F;&#x2F; D: 设备文件</span><br><span class="line">    ModeNamedPipe                                  &#x2F;&#x2F; p: 管道文件(FIFO)</span><br><span class="line">    ModeSocket                                     &#x2F;&#x2F; S: Unix 套接字文件</span><br><span class="line">    ModeSetuid                                     &#x2F;&#x2F; u: setuid</span><br><span class="line">    ModeSetgid                                     &#x2F;&#x2F; g: setgid</span><br><span class="line">    ModeCharDevice                                 &#x2F;&#x2F; c: Unix 字符设备</span><br><span class="line">    ModeSticky                                     &#x2F;&#x2F; t: sticky</span><br><span class="line">    ModeIrregular                                  &#x2F;&#x2F; ?: 非常规文件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类型的掩码,对于常规文件,设置为 none</span><br><span class="line">    ModeType &#x3D; ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeCharDevice | ModeIrregular</span><br><span class="line"></span><br><span class="line">    ModePerm FileMode &#x3D; 0777 &#x2F;&#x2F; Unix 权限位</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    &#x2F;&#x2F; 必须指定 O_RDONLY, O_WRONLY, O_RDWR 之一</span><br><span class="line">    O_RDONLY int &#x3D; syscall.O_RDONLY &#x2F;&#x2F; 只读方式打开文件</span><br><span class="line">    O_WRONLY int &#x3D; syscall.O_WRONLY &#x2F;&#x2F; 只写方式打开文件</span><br><span class="line">    O_RDWR   int &#x3D; syscall.O_RDWR   &#x2F;&#x2F; 读写方式打开文件</span><br><span class="line">    &#x2F;&#x2F; 下面的值可以用来控制行为</span><br><span class="line">    O_APPEND int &#x3D; syscall.O_APPEND &#x2F;&#x2F; 追加写入数据</span><br><span class="line">    O_CREATE int &#x3D; syscall.O_CREAT  &#x2F;&#x2F; 文件不存在则创建</span><br><span class="line">    O_EXCL   int &#x3D; syscall.O_EXCL   &#x2F;&#x2F; 与 O_CREATE 一起使用,文件必须不存在</span><br><span class="line">    O_SYNC   int &#x3D; syscall.O_SYNC   &#x2F;&#x2F; 以同步 I&#x2F;O 方式打开</span><br><span class="line">    O_TRUNC  int &#x3D; syscall.O_TRUNC  &#x2F;&#x2F; 打开时清空文件内容</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    SEEK_SET int &#x3D; 0 &#x2F;&#x2F; 相对于文件开始位置,已过时,而使用 io.SeekStart</span><br><span class="line">    SEEK_CUR int &#x3D; 1 &#x2F;&#x2F; 相对于文件当前位置,已过时,而使用 io.SeekCurrent</span><br><span class="line">    SEEK_END int &#x3D; 2 &#x2F;&#x2F; 相对于文件结尾位置,已过时,而使用 io.SeekEnd</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    PathSeparator     &#x3D; &#39;&#x2F;&#39; &#x2F;&#x2F; Unix 操作系统指定的路径分隔符</span><br><span class="line">    PathListSeparator &#x3D; &#39;:&#39; &#x2F;&#x2F; Unix 操作系统指定的表分隔符</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    PathSeparator     &#x3D; &#39;\\&#39; &#x2F;&#x2F; Windows 操作系统指定的路径分隔符</span><br><span class="line">    PathListSeparator &#x3D; &#39;;&#39; &#x2F;&#x2F; Windows 操作系统指定的表分隔符</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    Stdin  &#x3D; NewFile(uintptr(syscall.Stdin), &quot;&#x2F;dev&#x2F;stdin&quot;)</span><br><span class="line">    Stdout &#x3D; NewFile(uintptr(syscall.Stdout), &quot;&#x2F;dev&#x2F;stdout&quot;)</span><br><span class="line">    Stderr &#x3D; NewFile(uintptr(syscall.Stderr), &quot;&#x2F;dev&#x2F;stderr&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="os-包函数"><a href="#os-包函数" class="headerlink" title="os 包函数"></a><code>os</code> 包函数</h3><h4 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回系统主机名及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hostname</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 返回环境变量的字符串副本,形式为 "key=value"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Environ</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回指定环境变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getenv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span>  </span><br><span class="line"><span class="comment">// 设置环境变量(仅在当前进程生效),返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setenv</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 删除当前进程的所有环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clearenv</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 使程序按照给定的状态码退出,程序会立即终止, defer 函数不会执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exit</span><span class="params">(code <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getuid</span><span class="params">()</span> <span class="title">int</span>  // 返回调用者的用户<span class="title">ID</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getgid</span><span class="params">()</span> <span class="title">int</span>  // 返回调用者的组<span class="title">ID</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getpid</span><span class="params">()</span> <span class="title">int</span>  // 返回当前程序的进程<span class="title">ID</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getppid</span><span class="params">()</span> <span class="title">int</span>  // 返回当前进程的父进程<span class="title">ID</span></span></span><br></pre></td></tr></table></figure>

<h4 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回描述指定的文件的 FileInfo 及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo, err error)</span></span></span><br><span class="line"><span class="comment">// 采用 0666 模式创建文件,如果文件存在则清空.返回文件描述符为 O_RDWR 的 IO 文件对象及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br><span class="line"><span class="comment">// 以只读方式打开文件.返回文件描述符为 O_RDONLY 的只读文件对象及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br><span class="line"><span class="comment">// 以指定的文件描述符 flag,指定的模式打开或创建文件.返回文件对象及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(file *File, err error)</span></span></span><br><span class="line"><span class="comment">// 判断在文件操作过程中发生的错误是否是文件已存在的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断在文件操作过程中发生的错误是否是文件不存在的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断在文件操作过程中发生的错误是否是因权限问题而引发的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 返回当前工作目录路径.默认工作目录为 $GOPATH/src</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getwd</span><span class="params">()</span> <span class="params">(dir <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将当前工作目录修改为执行目录,并返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chdir</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改指定文件权限.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chmod</span><span class="params">(name <span class="keyword">string</span>, mode FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改指定文件属主属组.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改指定文件的访问时间和修改时间.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chtimes</span><span class="params">(name <span class="keyword">string</span>, atime time.Time, mtime time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用指定权限创建目录.如果上级目录不存存在,则会报错.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用指定权限创建目录.如果上级目录不存存在,则会递归创建.返回可能发生的错误.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(path <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 移动文件.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 删除文件或目录.如果目录不为空,则报错.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 删除 path 及其目录下所有文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 创建 newname 指向 oldname 的符号链.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Symlink</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回用于保存临时文件的默认目录.</span></span><br><span class="line"><span class="comment">// windows 下为 C:\Users\&lt;Username&gt;\AppData\Local\Temp, linux 下为 /tmp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="File-结构体方法"><a href="#File-结构体方法" class="headerlink" title="File 结构体方法"></a><code>File</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回文件的名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回描述指定的文件的 FileInfo 及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Stat</span><span class="params">()</span> <span class="params">(fi FileInfo, err error)</span></span></span><br><span class="line"><span class="comment">// 返回文件的整数类型的Unix文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Fd</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="comment">// 修改文件权限,返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chmod</span><span class="params">(mode FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改文件属主属组,返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chown</span><span class="params">(uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 保留 size 大小的文件内容,多出的部分就会被丢弃.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Truncate</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 从文件对象中最多读取 len(b) 字节数据并写入 b.返回读取的字节数和可能遇到的任何错误.文件终止标志是读取 0 个字节且err 为 io.EOF</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 从指定的位置读取len(b)字节数据并写入b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 向文件中写入len(b)字节数据,返回写入的字节数和可能发生的错误,如果 n!=len(b), nil 不为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 向文件中写入字符串,类似于 Write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ret <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 向文件指定位置写入字节数据,类似于 Write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 设置下一次读/写的位置,返回新的偏移量(相对于开头)及可能发生的错误.</span></span><br><span class="line"><span class="comment">// offset 为相对偏移量,whence 决定相对位置: 0为相对文件开头,1为相对当前位置,2为相对文件结尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Sync</span><span class="params">()</span> <span class="params">(err error)</span></span></span><br><span class="line"><span class="comment">// 关闭文件.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="文件读写示例"><a href="#文件读写示例" class="headerlink" title="文件读写示例"></a>文件读写示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">"filename"</span>, os.O_RDWR|os.O_CREATE|os.O_SYNC|os.O_APPEND, <span class="number">0</span>)  <span class="comment">// 打开文件方式为 读写,不存在则创建, 写同步, 追加</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"err"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件写入</span></span><br><span class="line">    <span class="keyword">var</span> bytes = []<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'\n'</span>&#125;</span><br><span class="line">    file.Write(bytes)  <span class="comment">// 以 []bete 方式写入文件</span></span><br><span class="line">    str := <span class="string">"this is string to write\n"</span></span><br><span class="line">    <span class="keyword">var</span> strBytes = []<span class="keyword">byte</span>(str)</span><br><span class="line">    file.Write(strBytes)</span><br><span class="line">    file.WriteString(str)  <span class="comment">// 向文件写入字符串</span></span><br><span class="line">    <span class="comment">// file.Sync() // 若 OpenFile 没有 os.O_TRUNC 标识,则需要显示同步,以上写入操作才会同步到文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件读取</span></span><br><span class="line">    buffer := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    file.Seek(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment">// 在写时,文件读取指针已经移到最后了,需要设置从文件开始位置开始读取. 如果是心打开的文件,可以不设置</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="built_in">len</span>, err := file.Read(buffer)  <span class="comment">// 读取文件内容到 buffer 中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span> == <span class="number">0</span> &amp;&amp; err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(<span class="keyword">string</span>(buffer[:<span class="built_in">len</span>]))  <span class="comment">// 输出文件内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os</code> 包没有直接提供对文件按行读取的方法,我们需要借助 <code><a href="/2020/05/01/go-study-notes-package-time/" title="bufio">bufio</a></code> 包来实现</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 sort 包</title>
    <url>/2020/05/16/go-study-notes-package-sort/</url>
    <content><![CDATA[<p><code>sort</code> 包提供了对于切片和用户定义的集合进行排序的原始函数,实现了 3 种基本的排序算法: 插入排序,快速排序和堆排序.它们只在 <code>sort</code> 包内部使用.用户无需考虑使用哪种排序方式. <code>sort</code> 包会根据实际数自动选择高效的排序算法.</p>
<p>在使用 <code>sort</code> 包对数据进行排序时,必须要求集合的元素由整数索引来枚举,那么我们只需要对该类型实现 <code>sort.Interface</code> 定义的三个方法即可.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 集合中元素的数量</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 决定了如何进行排序,排序后索引为 i 的元素是否应该在 索引为 j 的元素之前</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 交换索引为 i 和 j  的元素</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort 包中提供了三种实现了 sort.Interface 接口的类型</span></span><br><span class="line"><span class="keyword">type</span> Float64Slice []<span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用函数定义"><a href="#常用函数定义" class="headerlink" title="常用函数定义"></a>常用函数定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对浮点型,整型,字符串切片进行升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Strings</span><span class="params">(a []<span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断浮点型,整型,字符串是否已经升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64sAreSorted</span><span class="params">(a []<span class="keyword">float64</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntsAreSorted</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringsAreSorted</span><span class="params">(a []<span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个实现了 sort.Interface 接口的对象是否已经排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用二分查找并返回 [0, n) 中 f(i) 为 true 的最小索引.</span></span><br><span class="line"><span class="comment">// 多用于查找升序排序(运算符: &gt;=)或降序排序(运算符: &lt;=)的数据中查找指定元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在已排序切片中搜索 x,若查到,则返回查到的索引;否则返回将 x 有序插入 a 后,x 的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用给定的 less 函数对 slice 进行排序. SliceStable 可保证排序是稳定的.</span></span><br><span class="line"><span class="comment">// 如果 slice 不是切片,则会引发 panics</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceStable</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span></span><br><span class="line"><span class="comment">// 测试切片是否已经使用 less 排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceIsSorted</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对实现了 sort.Interface  接口的类型对象进行排序. Stable 可保证排序是稳定的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stable</span><span class="params">(data Interface)</span></span></span><br><span class="line"><span class="comment">// 对数据进行反向排序,常用于 sort.Sort(sort.Reverse(data)) 对数据进行反向排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="使用-sort-Sort-或-sort-Slice-进行排序"><a href="#使用-sort-Sort-或-sort-Slice-进行排序" class="headerlink" title="使用 sort.Sort 或 sort.Slice 进行排序"></a>使用 <code>sort.Sort</code> 或 <code>sort.Slice</code> 进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 sort.Interface 接口,可对 []Person 切片按照指定方式进行排序</span></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="comment">// 使用 Person 的 Age 属性做比较,降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []Person&#123;</span><br><span class="line">        &#123;<span class="string">"Bob"</span>, <span class="number">31</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"John"</span>, <span class="number">42</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Michael"</span>, <span class="number">17</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Jenny"</span>, <span class="number">26</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sort.Sort 方法进行排序</span></span><br><span class="line">    sort.Sort(ByAge(people))</span><br><span class="line">    fmt.Println(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sort.Slice 按指定 less 函数进行降序排序</span></span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> people[i].Age &gt; people[j].Age</span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用指定的属性进行排序"><a href="#使用指定的属性进行排序" class="headerlink" title="使用指定的属性进行排序"></a>使用指定的属性进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d, %.2f"</span>, p.Name, p.Age, p.Score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 "less" 函数类型,用于定义 Person 排序的方式</span></span><br><span class="line"><span class="keyword">type</span> By <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序的入口函数,传入 people 后构建 personSorter 对象,用于排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(by By)</span> <span class="title">Sort</span><span class="params">(people []Person)</span></span> &#123;</span><br><span class="line">    ps := &amp;personSorter&#123;</span><br><span class="line">        people: people,</span><br><span class="line">        by:     by, <span class="comment">// 使用函数的闭包将 by 对象(实际上是一个函数)作为 personSorter 的成员传入,</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(ps)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// personSorter 类型封装了要排序的对象和如何进行排序的函数</span></span><br><span class="line"><span class="keyword">type</span> personSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">    people []Person</span><br><span class="line">    by     <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span> // <span class="title">Closure</span> <span class="title">used</span> <span class="title">in</span> <span class="title">the</span> <span class="title">Less</span> <span class="title">method</span>.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *personSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s.people) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *personSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; s.people[i], s.people[j] = s.people[j], s.people[i] &#125;</span><br><span class="line"><span class="comment">// Less 方法滴啊用 by 成员(by 是一个函数),决定如何进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *personSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.by(&amp;s.people[i], &amp;s.people[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []Person&#123;</span><br><span class="line">        &#123;<span class="string">"Bob"</span>, <span class="number">31</span>, <span class="number">83.5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"John"</span>, <span class="number">42</span>, <span class="number">86.0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Michael"</span>, <span class="number">17</span>, <span class="number">79.6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Jenny"</span>, <span class="number">26</span>, <span class="number">89.3</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义排序的方式,按照 Person 各种属性进行排序,</span></span><br><span class="line">    name := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.Name &lt; p2.Name</span><br><span class="line">    &#125;</span><br><span class="line">    age := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.Age &lt; p2.Age</span><br><span class="line">    &#125;</span><br><span class="line">    score := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.Score &lt; p2.Score</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 score 方法, p1,p2 调换位置,实现倒序</span></span><br><span class="line">    decreasingScore := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score(p2, p1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照既定的方式进行排序</span></span><br><span class="line">    By(name).Sort(people)</span><br><span class="line">    fmt.Println(<span class="string">"By Name:"</span>, people)</span><br><span class="line">    By(age).Sort(people)</span><br><span class="line">    fmt.Println(<span class="string">"By Age:"</span>, people)</span><br><span class="line">    By(score).Sort(people)</span><br><span class="line">    fmt.Println(<span class="string">"By Score:"</span>, people)</span><br><span class="line">    By(decreasingScore).Sort(people)</span><br><span class="line">    fmt.Println(<span class="string">"By decreasing Score:"</span>, people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多个属性进行排序"><a href="#使用多个属性进行排序" class="headerlink" title="使用多个属性进行排序"></a>使用多个属性进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义待排序对象</span></span><br><span class="line"><span class="keyword">type</span> Change <span class="keyword">struct</span> &#123;</span><br><span class="line">    user     <span class="keyword">string</span></span><br><span class="line">    language <span class="keyword">string</span></span><br><span class="line">    lines    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定以 "less" 函数,用于定义排序的方式</span></span><br><span class="line"><span class="keyword">type</span> lessFunc <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Change)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multiSorter 实现了 sort.Interface 接口,按照指定方式对 changes 属性进行排序</span></span><br><span class="line"><span class="keyword">type</span> multiSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">    changes []Change</span><br><span class="line">    less    []lessFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(ms.changes) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; ms.changes[i], ms.changes[j] = ms.changes[j], ms.changes[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Less 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    p, q := &amp;ms.changes[i], &amp;ms.changes[j]</span><br><span class="line">    <span class="comment">// 依次按照 ms 中 less 中包含的函数进行判断,不包括最后一个</span></span><br><span class="line">    <span class="keyword">var</span> k <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">0</span>; k &lt; <span class="built_in">len</span>(ms.less)<span class="number">-1</span>; k++ &#123;</span><br><span class="line">        less := ms.less[k]</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> less(p, q):</span><br><span class="line">            <span class="comment">// p &lt; q, so we have a decision.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> less(q, p):</span><br><span class="line">            <span class="comment">// p &gt; q, so we have a decision.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p == q; 进行下次比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除最后一个,之前的函数都相等,此时 k = len(ms.less)-1,则按照最后一个函数进行判断</span></span><br><span class="line">    <span class="keyword">return</span> ms.less[k](p, q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序的入口函数,调用此方法对 changes 进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Sort</span><span class="params">(changes []Change)</span></span> &#123;</span><br><span class="line">    ms.changes = changes</span><br><span class="line">    sort.Sort(ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 multiSorter 对象调用其 Sort 方法进行排序</span></span><br><span class="line"><span class="comment">// 调用 Sort 方法后,该对象按照 less 函数定义的排序方式进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedBy</span><span class="params">(less ...lessFunc)</span> *<span class="title">multiSorter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;multiSorter&#123;</span><br><span class="line">        less: less,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> changes = []Change&#123;</span><br><span class="line">    &#123;<span class="string">"gri"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"ken"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"glenda"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"rsc"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"r"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"ken"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"dmr"</span>, <span class="string">"C"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"r"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"gri"</span>, <span class="string">"Smalltalk"</span>, <span class="number">80</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义排序的方式</span></span><br><span class="line">    user := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> c1.user &lt; c2.user &#125;</span><br><span class="line">    language := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> c1.language &lt; c2.language &#125;</span><br><span class="line">    increasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> c1.lines &lt; c2.lines &#125;</span><br><span class="line">    decreasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> increasingLines(c2, c1) &#125;</span><br><span class="line"></span><br><span class="line">    OrderedBy(user).Sort(changes)</span><br><span class="line">    fmt.Println(<span class="string">"By user:"</span>, changes)</span><br><span class="line">    <span class="comment">// 使用多键进行排序</span></span><br><span class="line">    OrderedBy(user, increasingLines).Sort(changes)</span><br><span class="line">    fmt.Println(<span class="string">"By user,&lt;lines:"</span>, changes)</span><br><span class="line">    OrderedBy(user, decreasingLines).Sort(changes)</span><br><span class="line">    fmt.Println(<span class="string">"By user,&gt;lines:"</span>, changes)</span><br><span class="line">    OrderedBy(language, increasingLines).Sort(changes)</span><br><span class="line">    fmt.Println(<span class="string">"By language,&lt;lines:"</span>, changes)</span><br><span class="line">    OrderedBy(language, increasingLines, user).Sort(changes)</span><br><span class="line">    fmt.Println(<span class="string">"By language,&lt;lines,user:"</span>, changes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用继承对数据进行排序"><a href="#使用继承对数据进行排序" class="headerlink" title="使用继承对数据进行排序"></a>使用继承对数据进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grams <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Grams)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%dg"</span>, <span class="keyword">int</span>(g)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Organ <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">    Weight Grams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Organs []*Organ</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Organs)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Organs)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Organs 并实现 Less 方法,从而实现 Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> ByName <span class="keyword">struct</span>&#123; Organs &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByName)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s.Organs[i].Name &lt; s.Organs[j].Name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Organs 并实现 Less 方法,从而实现 Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> ByWeight <span class="keyword">struct</span>&#123; Organs &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByWeight)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s.Organs[i].Weight &lt; s.Organs[j].Weight &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []*Organ&#123;</span><br><span class="line">        &#123;<span class="string">"brain"</span>, <span class="number">1340</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"heart"</span>, <span class="number">290</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"liver"</span>, <span class="number">1494</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"pancreas"</span>, <span class="number">131</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"prostate"</span>, <span class="number">62</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"spleen"</span>, <span class="number">162</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(ByWeight&#123;s&#125;)</span><br><span class="line">    fmt.Println(<span class="string">"Organs by weight:"</span>)</span><br><span class="line">    printOrgans(s)</span><br><span class="line">    sort.Sort(ByName&#123;s&#125;)</span><br><span class="line">    fmt.Println(<span class="string">"Organs by name:"</span>)</span><br><span class="line">    printOrgans(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOrgans</span><span class="params">(s []*Organ)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%-8s (%v)\n"</span>, o.Name, o.Weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-sort-Search-查找指定元素"><a href="#使用-sort-Search-查找指定元素" class="headerlink" title="使用 sort.Search 查找指定元素"></a>使用 <code>sort.Search</code> 查找指定元素</h2><ul>
<li>升序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">55</span>&#125;</span><br><span class="line">    x := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    i := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) &amp;&amp; a[i] == x &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"found %d at index %d in %v\n"</span>, x, i, a)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d not found in %v\n"</span>, x, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>降序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">55</span>, <span class="number">45</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;</span><br><span class="line">    x := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    i := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt;= x &#125;)</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) &amp;&amp; a[i] == x &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"found %d at index %d in %v\n"</span>, x, i, a)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d not found in %v\n"</span>, x, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 sql 包</title>
    <url>/2020/05/10/go-study-notes-package-sql/</url>
    <content><![CDATA[<p><code>database/sql/driver</code> 包定义了 <code>database/sql</code> 包使用的数据库程序要实现的接口<br><code>database/sql</code> 包提供了有关 SQL 的数据库通用接口. sql 包必须与数据库驱动程序一起使用.相关程序列表,参见 <a href="https://github.com/golang/go/wiki/SQLDrivers" target="_blank" rel="noopener">https://github.com/golang/go/wiki/SQLDrivers</a></p>
<p>如连接 mysql 需要使用导入 mysql 的驱动程序包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line"></span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"user:password@/dbname"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列的类型</span></span><br><span class="line"><span class="keyword">type</span> ColumnType <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单个数据库连接.除非特别需要连续的单个数据库连接,否则最好 DB 对象</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据库对象,对于多个 goroutine 时并发安全的.会自动创建并释放连接</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库统计信息</span></span><br><span class="line"><span class="keyword">type</span> DBStats <span class="keyword">struct</span> &#123;</span><br><span class="line">    MaxOpenConnections <span class="keyword">int</span> <span class="comment">// 最大连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池状态</span></span><br><span class="line">    OpenConnections <span class="keyword">int</span> <span class="comment">// 使用和空闲的连接数</span></span><br><span class="line">    InUse           <span class="keyword">int</span> <span class="comment">// 正在使用的连接数</span></span><br><span class="line">    Idle            <span class="keyword">int</span> <span class="comment">// 空闲连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="comment">//等待</span></span><br><span class="line">    WaitCount         <span class="keyword">int64</span>         <span class="comment">// 等待的连接总数</span></span><br><span class="line">    WaitDuration      time.Duration <span class="comment">// 等待新连接的总时间</span></span><br><span class="line">    MaxIdleClosed     <span class="keyword">int64</span>         <span class="comment">// 由于 SetMaxIdleConns 而关闭的连接总数</span></span><br><span class="line">    MaxLifetimeClosed <span class="keyword">int64</span>         <span class="comment">// 由于 SetConnMaxLifetime 而关闭的连接总数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果信息接口</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回数据库为响应命令而生成的整数.通常用于插入新行的自增列</span></span><br><span class="line">    LastInsertId() (<span class="keyword">int64</span>, error)</span><br><span class="line">    <span class="comment">// 受更新,插入或删除影响的行数.</span></span><br><span class="line">    RowsAffected() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QueryRow 产生的单行对象</span></span><br><span class="line"><span class="keyword">type</span> Row <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询的多行结果.它的光标从第一行开始,使用 `Next()` 逐行获取下一行的值</span></span><br><span class="line"><span class="keyword">type</span> Rows <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理的语句.可以被多个 goroutine 安全并发使用</span></span><br><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务</span></span><br><span class="line"><span class="keyword">type</span> Tx <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事务选项,定义了事务的隔离级别</span></span><br><span class="line"><span class="keyword">type</span> TxOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 事务的隔离级别</span></span><br><span class="line">    Isolation IsolationLevel</span><br><span class="line">    ReadOnly  <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隔离级别</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    LevelDefault IsolationLevel = <span class="literal">iota</span></span><br><span class="line">    LevelReadUncommitted</span><br><span class="line">    LevelReadCommitted</span><br><span class="line">    LevelWriteCommitted</span><br><span class="line">    LevelRepeatableRead</span><br><span class="line">    LevelSnapshot</span><br><span class="line">    LevelSerializable</span><br><span class="line">    LevelLinearizable</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="sql-包函数"><a href="#sql-包函数" class="headerlink" title="sql 包函数"></a><code>sql</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回已注册的驱动列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Drivers</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 注册驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, driver driver.Driver)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个由其数据库驱动名称 driverName 和特定驱动程序的数据源名称 dataSourceName 指定的数据库</span></span><br><span class="line"><span class="comment">// 该函数可能只验证参数而不创建与数据库的连接.要验证数据源名称是否有效,调用 Ping 函数</span></span><br><span class="line"><span class="comment">// 返回的数据库可安全的供多个 goroutine 并发使用,并维护自己的空闲连接池.因此此函数只需要调用一次</span></span><br><span class="line"><span class="comment">// dataSourceName 一般形式为 `username:password@protocol(address)/dbname?param=value`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span></span><br><span class="line"><span class="comment">// 使用连接器打开数据库,从而避免字符串的数据源名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenDB</span><span class="params">(c driver.Connector)</span> *<span class="title">DB</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ColumnType-结构体方法"><a href="#ColumnType-结构体方法" class="headerlink" title="ColumnType 结构体方法"></a><code>ColumnType</code> 结构体方法</h3><p><code>ColumnType</code> 定义了列的类型,它包含以下方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回数据库中对应的列的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">DatabaseTypeName</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回小数类型的小数精度和位数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">DecimalSize</span><span class="params">()</span> <span class="params">(precision, scale <span class="keyword">int64</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回可变类型长度列类型(如 text 和 binary)的列类型长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">Length</span><span class="params">()</span> <span class="params">(length <span class="keyword">int64</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回列的名称或列的别名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 该列是否可为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">Nullable</span><span class="params">()</span> <span class="params">(nullable, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回适合使用 Rows.Scan 进行扫描的 Go 反射类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">ScanType</span><span class="params">()</span> <span class="title">reflect</span>.<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<h3 id="DB-结构体方法"><a href="#DB-结构体方法" class="headerlink" title="DB 结构体方法"></a><code>DB</code> 结构体方法</h3><p><code>DB</code> 定义了数据库的实例对象.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始事务,默认的隔离级别取决与驱动程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Begin</span><span class="params">()</span> <span class="params">(*Tx, error)</span></span></span><br><span class="line"><span class="comment">// 开始事务,在事务提交或回滚之前,将使用上下文.如果上下文被取消,事务将回滚</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">BeginTx</span><span class="params">(ctx context.Context, opts *TxOptions)</span> <span class="params">(*Tx, error)</span></span></span><br><span class="line"><span class="comment">// 关闭数据库连接,阻止启动新查询.很少用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 打开新连接或从连接池返回现有连接. Conn 将阻塞,直到返回连接池或取消 ctx.使用后必须调用 Conn.Close 将每个 Conn 返回到数据库连接池</span></span><br><span class="line"><span class="comment">// 在同一 Conn 上运行的查询将在同一数据库会话中运行.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Conn</span><span class="params">(ctx context.Context)</span> <span class="params">(*Conn, error)</span></span></span><br><span class="line"><span class="comment">// 底层驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Driver</span><span class="params">()</span> <span class="title">driver</span>.<span class="title">Driver</span></span></span><br><span class="line"><span class="comment">// 执行 query 语句,但不返回任何行.args 参数用于查询中的占位符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">ExecContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="comment">// 验证与数据库的连接是否存在,必要时建立连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">PingContext</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 为后续查询或执行做好准备.Stmt 可以并发执行多个查询或执行,当不需要 Stmt 时,需要调用 Stmt.Close 显式关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">PrepareContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br><span class="line"><span class="comment">// 执行查询语句,返回多行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="comment">// 执行查询语句,返回单行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryRowContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="comment">// 设置可重用连接的最长时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetConnMaxLifetime</span><span class="params">(d time.Duration)</span></span></span><br><span class="line"><span class="comment">// 设置空闲连接池中的最大连接数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxIdleConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 设置数据库打开的最大连接数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxOpenConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 返回数据库统计信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Stats</span><span class="params">()</span> <span class="title">DBStats</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Rows-结构体方法"><a href="#Rows-结构体方法" class="headerlink" title="Rows 结构体方法"></a><code>Rows</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回列的信息,如类型,长度,是否可为空.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">ColumnTypes</span><span class="params">()</span> <span class="params">([]*ColumnType, error)</span></span></span><br><span class="line"><span class="comment">// 返回列的名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Columns</span><span class="params">()</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="comment">// 准备下一行,以使用 Scan 方法获取.如果策成功,返回 ture.每次调用 Scan 时,都必须先调用该函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 准备下一个要读取的结果集.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">NextResultSet</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 将当前行的列复制到 dest 指向的值中. dest 中值的数量必须与"行"中列数相同.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Scan</span><span class="params">(dest ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Stmt-结构体方法"><a href="#Stmt-结构体方法" class="headerlink" title="Stmt 结构体方法"></a><code>Stmt</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 执行,并返回 Result 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Exec</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">ExecContext</span><span class="params">(ctx context.Context, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="comment">// 查询,并返回查询到的行对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Query</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">QueryRow</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">QueryRowContext</span><span class="params">(ctx context.Context, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Tx-结构体方法"><a href="#Tx-结构体方法" class="headerlink" title="Tx 结构体方法"></a><code>Tx</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 执行查询,并返回查询结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Exec</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">ExecContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="comment">// 事务中创建 Stmt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Prepare</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">PrepareContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br><span class="line"><span class="comment">// 事务中查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">QueryRow</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">QueryRowContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Rollback</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用已有的 Stmt 创建 Stmt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Stmt</span><span class="params">(stmt *Stmt)</span> *<span class="title">Stmt</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">StmtContext</span><span class="params">(ctx context.Context, stmt *Stmt)</span> *<span class="title">Stmt</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cfg := mysql.Config&#123;</span><br><span class="line">        User:                 <span class="string">"username"</span>,</span><br><span class="line">        Passwd:               <span class="string">"password"</span>,</span><br><span class="line">        Net:                  <span class="string">"tcp"</span>,</span><br><span class="line">        Addr:                 <span class="string">"10.71.1.27:3306"</span>,</span><br><span class="line">        DBName:               <span class="string">"datastream-info"</span>,</span><br><span class="line">        AllowNativePasswords: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dataSourceName := cfg.FormatDSN() <span class="comment">// 支持使用 mysql 包中的配置转换方法转换 dataSourceName,也可以使用如下方式直接定义</span></span><br><span class="line">    <span class="comment">// dataSourceName := "username:password@tcp(10.71.1.27:3306)/test"</span></span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>, dataSourceName)</span><br><span class="line">    rows, err := db.Query(<span class="string">"select * from province_num"</span>)</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        id    <span class="keyword">int</span></span><br><span class="line">        name  <span class="keyword">string</span></span><br><span class="line">        value <span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> err = rows.Scan(&amp;id, &amp;name, &amp;value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(id, name, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 strings 包</title>
    <url>/2020/05/04/go-study-notes-package-strings/</url>
    <content><![CDATA[<p><code>strings</code> 包实现了用于操作字符的简单函数.导入方式为 <code>import &quot;strings&quot;</code></p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从字符串读取数据的封装,实现了 `io.Reader`,`io.Seeker`,`io.ReaderAt`,`io.WriterTo``io.ByteScanner`,`io.RuneScanner` 接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行字符替换的封装</span></span><br><span class="line"><span class="keyword">type</span> Replacer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h2 id="strings-包常用函数"><a href="#strings-包常用函数" class="headerlink" title="strings 包常用函数"></a><code>strings</code> 包常用函数</h2><p><code>strings</code> 包中提供了如下常用函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建从指定字符串读取数据的 Reader 对象实例.返回 Reader 对象的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="comment">// 使用多组 old,new 字符串创建 Replacer 对象.返回 Replacer 对象的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReplacer</span><span class="params">(oldnew ...<span class="keyword">string</span>)</span> *<span class="title">Replacer</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否有 prefix 前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否有 suffix 后缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否包含子串 substr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否包含字符串 chars 中的任一字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 字符串 s 中包含 sep 子串的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 子串 sep 在 s 中第一次出现的位置, 不存在则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 字符 c 在 s 中第一次出现的位置,不存在则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 子串 sep 在 s 中最后一次出现的位置, 不存在则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// s 中每个单词的首字母都改为标题格式的字符串拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将所有字母都转为对应的小写字母的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将所有字母都转为对应的大写字母的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回 count 个 s 串联的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 中前 n 个 old 子串都替换为 new 的新字符串, 如果 n&lt;0 会替换所有 old 子串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 前后 cutset 都删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 前后空白都删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 前面 cutset 删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 后面 cutset 删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 使用 sep 作为分隔符将 s 分割,返回分割后的字符串切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回分割后的字符串切片.n&gt;0,将 s 分割为 n 项, 最后一个子字符串包含未进行切割的部分, 并.如果 n 等于 0 , 返回 nil. n&lt;0,返回所有字符串切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将字符串切片 a 连接成一个字符串,中间用 sep 分割</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Reader-结构体方法"><a href="#Reader-结构体方法" class="headerlink" title="Reader 结构体方法"></a><code>Reader</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是 `io` 包中的相关接口的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(b <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Replacer-结构体方法"><a href="#Replacer-结构体方法" class="headerlink" title="Replacer 结构体方法"></a><code>Replacer</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回对字符串 s 替换进行完后的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">Replace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 向 w 中写入 s 的所有替换进行完后的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">WriteString</span><span class="params">(w io.Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 strconv 包</title>
    <url>/2020/05/10/go-study-notes-package-strconv/</url>
    <content><![CDATA[<p><code>strconv</code> 包实现了基本数据类型和其字符串表示的相互转换.导入方式为 <code>import &quot;strconv&quot;</code></p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>以下是 <code>strconv</code> 包中常用的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试将字符串转换为bool类型,否则返回错误</span></span><br><span class="line"><span class="comment">// 支持如下字符串`1,0,t,f,T,F,true,false,True,False,TRUE,FALSE`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将字符串转换为整数,支持正负号.</span></span><br><span class="line"><span class="comment">// base 指定进制, 如果为0,会根据 s 自行判断("0x"是16进制,"0"是8进制,否则是10进制)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将字符串转换为浮点型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将布尔值转换为字符串, "true" 或 "false"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回i的base进制的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将浮点数弄表示为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 是 ParseInt(s, 10, 0)的简写.字符串转 int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(i <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 是 FormatInt(i, 10) 的简写. int 转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 runtime 包</title>
    <url>/2020/05/04/go-study-notes-package-runtime/</url>
    <content><![CDATA[<p><code>runtime</code> 包提供了与 Go 运行时系统交互操作的函数.导入方式为 <code>import &quot;runtime&quot;</code></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>下面的主机上的环境变量控制 Go 程序的运行时行为,其用法和含义可能在各个版本间改变</p>
<h3 id="GOGC"><a href="#GOGC" class="headerlink" title="GOGC"></a><code>GOGC</code></h3><p><code>GOGC</code> 设置初始垃圾回收目标百分比.当新分配的数据与上一次垃圾回收之后的剩余数据之比达到此变量值时,将触发垃圾回收.默认 <code>GOGC=100</code>. <code>GOGC=off</code> 将完全禁用垃圾回收.<code>runtime/debug</code> 包的 <code>SetGCPercent</code> 函数可以在 Go 程序运行时修改此百分比.参见 <a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener">https://golang.org/pkg/runtime/debug/#SetGCPercent</a></p>
<h3 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a><code>GODEBUG</code></h3><p><code>GODEBUG</code> 环境变量控制运行时中的调试变量,它是一个用逗号分割的 <code>name=val</code> 列表,用于设置以下变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allocfreetrace: setting allocfreetrace&#x3D;1 causes every allocation to be profiled and a stack trace printed on each object&#39;s allocation and free</span><br><span class="line"></span><br><span class="line">clobberfree: setting clobberfree&#x3D;1 causes the garbage collector to clobber the memory content of an object with bad content when it freesthe object.</span><br><span class="line"></span><br><span class="line">cgocheck: setting cgocheck&#x3D;0 disables all checks for packages using cgo to incorrectly pass Go pointers to non-Go code.</span><br><span class="line">Setting cgocheck&#x3D;1 (the default) enables relatively cheap checks that may miss some errors.</span><br><span class="line">Setting cgocheck&#x3D;2 enables expensive checks that should not miss any errors, but will cause your program to run slower.</span><br><span class="line"></span><br><span class="line">efence: setting efence&#x3D;1 causes the allocator to run in a mode where each object is allocated on a unique page and addresses are never recycled.</span><br></pre></td></tr></table></figure>

<ul>
<li>allocfreetrace: 设置 allocfreetrace=1 使每次分配内存都进行分析,并在每个对象的内存分配及释放时打印堆栈跟踪信息</li>
<li>clobberfree: 设置 clobberfree=1 使垃圾回收器在释放对象时用不好的内容破坏对象的内存内容</li>
<li>cgocheck：设置 cgocheck=0 将禁用所有使用 cgo 将包指针错误传递给非 Go 代码的包检查;cgocheck=1(默认) 将启用相对低耗的检查,可能会丢失一些错误;cgocheck=2 将启用高消耗的检查,不会遗漏任何错误,但会导致程序运行缓慢</li>
<li>efence：设置 efence=1 分配器以每个对象都分配唯一页面,并且地址从不回收的方式运行</li>
</ul>
<h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><code>GOMAXPROCS</code></h3><p><code>GOMAXPROCS</code> 环境变量限制了可同时执行用户级 Go 代码的操作系统线程的数量.对 Go 代码在系统调用中被阻塞的线程数量没有限制.那些不计入 <code>GOMAXPROCS</code> 限制. <code>runtime.GOMAXPROCS()</code> 函数查询并修改限制.</p>
<h3 id="GORACE"><a href="#GORACE" class="headerlink" title="GORACE"></a><code>GORACE</code></h3><p><code>GORACE</code> 环境变量为使用 <code>-race</code> 标志的构建程序配置了竞争检测器.详情参见 <a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">https://golang.org/doc/articles/race_detector.html</a></p>
<h3 id="GOTRACEBACK"><a href="#GOTRACEBACK" class="headerlink" title="GOTRACEBACK"></a><code>GOTRACEBACK</code></h3><p><code>GOTRACEBACK</code> 环境变量控制在 Go 程序由于未处理的异常或意外的运行时条件而失败时产生的输出量.默认情况下,产生错误时将打印当前 goroutine 的堆栈跟踪,忽略运行时系统的内部函数,然后以退出代码 2 退出.如果没有当前 goroutine 或故障是运行时内部的,则产生错误时会打印所有 goroutine 的堆栈跟踪信息.</p>
<ul>
<li><code>GOTRACEBACK=none</code> 表示完全省略 goroutine 堆栈跟踪信息</li>
<li><code>GOTRACEBACK=single</code>(默认)的行为如上所述</li>
<li><code>GOTRACEBACK=all</code> 表示为所有的用户创建的 goroutine 添加堆栈跟踪信息</li>
<li><code>GOTRACEBACK=system</code> 与 <code>all</code>类似,但为运行时函数添加了堆栈跟踪信息,并显示了在运行时内部创建的 goroutine</li>
<li><code>GOTRACEBACK=crash</code> 类似于 <code>system</code>,但多用于操作系统崩溃而不是程序退出</li>
</ul>
<p>GOTRACEBACK 设置 0,1 和 2 分别是 none,all 和 system 的同义词.<code>runtime/debug</code> 包的<code>SetTraceback</code> 函数允许在运行时增加输出量,但不能将其减少到环境变量指定的量以下.请参阅 <a href="https://golang.org/pkg/runtime/debug/#SetTraceback" target="_blank" rel="noopener">https://golang.org/pkg/runtime/debug/#SetTraceback</a></p>
<h3 id="GOARCH-GOOS-GOPATH-GOROOT"><a href="#GOARCH-GOOS-GOPATH-GOROOT" class="headerlink" title="GOARCH,GOOS,GOPATH,GOROOT"></a><code>GOARCH</code>,<code>GOOS</code>,<code>GOPATH</code>,<code>GOROOT</code></h3><p><code>GOARCH</code>,<code>GOOS</code>,<code>GOPATH</code>,<code>GOROOT</code> 环境变量完善了 Go 环境变量集.它们会影响 Go 程序的构建(请参阅 <a href="https://golang.org/cmd/go" target="_blank" rel="noopener">https://golang.org/cmd/go</a> 和 <a href="https://golang.org/pkg/go/build" target="_blank" rel="noopener">https://golang.org/pkg/go/build</a>).<code>GOARCH</code>,<code>GOOS</code>,<code>GOROOT</code> 会在编译时记录下来,并可以通过此包中的常量或函数来使用,但它们不会影响运行时系统的执行.</p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Func <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用内置常量及变量"><a href="#常用内置常量及变量" class="headerlink" title="常用内置常量及变量"></a>常用内置常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Compiler = <span class="string">"gc"</span>  <span class="comment">// 编译器</span></span><br><span class="line"><span class="keyword">const</span> GOOS <span class="keyword">string</span> = sys.GOOS <span class="comment">// 操作系统,windows,linux,freebsd,darwin等</span></span><br><span class="line"><span class="keyword">const</span> GOARCH <span class="keyword">string</span> = sys.GOARCH <span class="comment">// 平台,386,amd64 或 arm</span></span><br><span class="line"><span class="keyword">var</span> MemProfileRate <span class="keyword">int</span> = <span class="number">512</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="runtime-包函数"><a href="#runtime-包函数" class="headerlink" title="runtime 包函数"></a><code>runtime</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Go 的根目录.如果存在 GOROOT 环境变量,返回该变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOROOT</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回 Go 的版本字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Version</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回机器的逻辑 CPU 个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCPU</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 设置可同时执行(并行)的最大 CPU 数.返回先前的设置.如果 n&lt;1,则不会更改当前设置.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 设置 CPU profile记录的频率为每秒 hz 次.如果 hz&lt;=0,会关闭 profile 记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCPUProfileRate</span><span class="params">(hz <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 显式执行一次垃圾回收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 终止调用它的 goroutine.其它 goroutine 不受影响.</span></span><br><span class="line"><span class="comment">// 在终止 goroutine 之前会运行所有的延迟调用,且函数中的 recover 调用都将返回 nil.</span></span><br><span class="line"><span class="comment">// 在主 goroutine 调用该函数会终止该 goroutine,主函数不会返回.程序将执行其它 goroutine.如果所有其它 goroutine 退出,程序将崩溃</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 使当前 goroutine 释放处理器,允许其它 goroutine 运行.他不会挂起当前 goroutine,因此当前 goroutine 会自动恢复执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 绑定当前 goroutine 到它所在的操作系统线程.当前 goroutine将总是在该线程中执行,其它 goroutine 则不能进入该线程,除非调用相同次数的 UnlockOSThread.</span></span><br><span class="line"><span class="comment">// 如果调用的 goroutine 在没有解锁线程的情况下退出,则该线程将终止.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LockOSThread</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 解除当前 goroutine 与操作系统线程的绑定关系.若 goroutine 未调用 LockOSThread,则不做操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnlockOSThread</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 返回当前进程对 cgo 调用的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCgoCall</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="comment">// 返回当前存在的 goroutine 数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumGoroutine</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回 *Func 用于描述给定指针地址的函数或 nil.如果 pc 由于内联表示多个函数,则将返回描述最内部的函数 *Func,但带有外部函数成员地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> *<span class="title">Func</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Func-结构体方法"><a href="#Func-结构体方法" class="headerlink" title="Func 结构体方法"></a><code>Func</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回外部函数的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Entry</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="comment">// 返回函数名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 sync 包</title>
    <url>/2020/05/05/go-study-notes-package-sync/</url>
    <content><![CDATA[<p><code>sync</code> 包提供了基础的同步方法和锁机制.导入方式为 <code>import &quot;sync&quot;</code></p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locker 接口,表示可以解锁和加锁的对象</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="comment">// 互斥锁与 goroutine 没有关联,允许一个 goroutine 添加锁,另一个 goroutine 释放锁</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅执行一次动作</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源池对象</span></span><br><span class="line"><span class="comment">// 池中的任何对象都可能被随时删除,并且没有通知.如果池中的唯一对象被删除,则该资源池对象也会被释放</span></span><br><span class="line"><span class="comment">// 资源池对象中的实例可被多个 goroutine 安全使用</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以指定一个函数,用于为 Get 生成一个对象.否则 Get 返回 nil</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 goroutine 运行结束</span></span><br><span class="line"><span class="comment">// 主线程调用 Add 方法设置要等待的 goroutine 数量,每个 goroutine 在运行完成后调用 Done.同时,使用 Wait 阻塞主函数,直到所有 goroutine 完成</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="Mutex-结构体方法"><a href="#Mutex-结构体方法" class="headerlink" title="Mutex 结构体方法"></a><code>Mutex</code> 结构体方法</h3><p>互斥锁与 goroutine 没有关联,允许一个 goroutine 添加锁,另一个 goroutine 释放锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明方式 `var m sync.Mutex`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁.如果锁已在使用中,则阻塞,直到互斥锁可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 释放锁.如果未加锁,则会出现运行时错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Once-结构体方法"><a href="#Once-结构体方法" class="headerlink" title="Once 结构体方法"></a><code>Once</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明 `var o sync.Once`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当且仅当 o 第一次调用 Do 方法时,调用函数 f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="Pool-结构体方法"><a href="#Pool-结构体方法" class="headerlink" title="Pool 结构体方法"></a><code>Pool</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明方式 `var p sync.Pool` 或 `var bufPool sync.Pool = sync.Pool&#123;New: funName&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从池中任意取出一个实例,并返回.如果资源池为空,且 p.New 不为空时,Get 返回调用 p.New 的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将 x 放入 p 资源池中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="WaitGroup-结构体方法"><a href="#WaitGroup-结构体方法" class="headerlink" title="WaitGroup 结构体方法"></a><code>WaitGroup</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明 `var wg sync.WaitGroup`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加可能为负数的 delta 到计数器中.</span></span><br><span class="line"><span class="comment">// 如果计数器为 0,则释放调用 Wait 处于阻塞状态的所有 goroutine</span></span><br><span class="line"><span class="comment">// 如果计数器变为负数,发生错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 使用 wg 计数器减 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 阻塞当前 goroutine 直到 wg 计数器为 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="Once-使用示例"><a href="#Once-使用示例" class="headerlink" title="Once 使用示例"></a><code>Once</code> 使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"在 i=%v 时被调用\n"</span>, i)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下. 可看到匿名函数仅在第一次调用 `once.Do()` 时执行一次,以后的循环不再执行</span></span><br><span class="line"><span class="comment">// 在 i=0 时被调用</span></span><br></pre></td></tr></table></figure>

<h3 id="Pool-使用示例"><a href="#Pool-使用示例" class="headerlink" title="Pool 使用示例"></a><code>Pool</code> 使用示例</h3><ul>
<li>使用 <code>Pool</code> 返回 5 个随机数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">var</span> p sync.Pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">            <span class="keyword">return</span> rand.Intn(<span class="number">100</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(p.Get())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WaitGroup-使用示例"><a href="#WaitGroup-使用示例" class="headerlink" title="WaitGroup 使用示例"></a><code>WaitGroup</code> 使用示例</h3><ul>
<li>使用 <code>WaitGroup</code> 等待所有 goroutine 执行结束</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">"goroutine %v done\n"</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 time 包</title>
    <url>/2020/05/01/go-study-notes-package-time/</url>
    <content><![CDATA[<p><code>time</code> 包提供了时间日期操作的函数, 包括时间的显示和计算.导入方式为 <code>import &quot;time&quot;</code></p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 星期几封装</span></span><br><span class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 月份封装</span></span><br><span class="line"><span class="keyword">type</span> Month <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地点,以及该地点所在的时区封装</span></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间点封装</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个时间点间隔封装</span></span><br><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br></pre></td></tr></table></figure>

<h2 id="常用内置常量及变量"><a href="#常用内置常量及变量" class="headerlink" title="常用内置常量及变量"></a>常用内置常量及变量</h2><p><code>time</code> 包中提供了如下常用常量或变量的定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间对象与字符串表示相互转换时,请记住 2006-01-02 15:04:05,有如下的对应关系</span></span><br><span class="line"><span class="comment">// 2006: 年, 01: 月, 02: 日</span></span><br><span class="line"><span class="comment">// 15: 时, 04: 分, 05: 秒</span></span><br><span class="line"><span class="comment">// 不管位置如何,只要看到 2006/06 就表示对年进转换</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    January Month = <span class="number">1</span> + <span class="literal">iota</span></span><br><span class="line">    February</span><br><span class="line">    March</span><br><span class="line">    April</span><br><span class="line">    May</span><br><span class="line">    June</span><br><span class="line">    July</span><br><span class="line">    August</span><br><span class="line">    September</span><br><span class="line">    October</span><br><span class="line">    November</span><br><span class="line">    December</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> UTC *Location = &amp;utcLoc  <span class="comment">// UTC 时区表示</span></span><br><span class="line"><span class="keyword">var</span> Local *Location = &amp;localLoc  <span class="comment">// 当地时区表示</span></span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h2 id="time-包函数"><a href="#time-包函数" class="headerlink" title="time 包函数"></a><code>time</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回表示当前时间的 `Time` 类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回由给定时间创建的 `Time` 类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="keyword">int</span>, month Month, day, hour, min, sec, nsec <span class="keyword">int</span>, loc *Location)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 根据 layout 指定的格式尝试将字符串转换为 `Time` 类型对象,转换成功则 `error = nil`.</span></span><br><span class="line"><span class="comment">// 其中 layout 必须是 `2006-01-02 15:04:05` 日期时间点, 格式可以随意变换.示例如下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="keyword">string</span>)</span> <span class="params">(Time, error)</span></span></span><br><span class="line"><span class="comment">// 休眠指定时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sleep</span><span class="params">(d Duration)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Time-结构体方法"><a href="#Time-结构体方法" class="headerlink" title="Time 结构体方法"></a><code>Time</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回根据 layout 指定的格式返回 t 代表的时间点的格式化文本表示. 示例如下所示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Format</span><span class="params">(layout <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回从 January 1, 1970 UTC 以来经过的秒数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Unix</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="comment">// 返回从 January 1, 1970 UTC 以来经过的纳秒数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UnixNano</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="comment">// 返回 UTC `Time` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UTC</span><span class="params">()</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回时间对象 t 的年月日三个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Date</span><span class="params">()</span> <span class="params">(year <span class="keyword">int</span>, month Month, day <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 返回时间对象 t 的时分秒三个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Clock</span><span class="params">()</span> <span class="params">(hour, min, sec <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 返回 t 增加 d 时间后的时间对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回增加指定年月日后时间对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">AddDate</span><span class="params">(years <span class="keyword">int</span>, months <span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回年份</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Year</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">//返回月份.是 Month 类型,可通过 int() 强转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Month</span><span class="params">()</span> <span class="title">Month</span></span></span><br><span class="line"><span class="comment">// 返回日</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Day</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回该日期是一年中的第几天,[1, 365]或[1, 366]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">YearDay</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回小时  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Hour</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回分钟</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Minute</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Second</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Nanosecond</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回星期几,是Weekday类型,可通过 int() 强转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Weekday</span><span class="params">()</span> <span class="title">Weekday</span></span></span><br><span class="line"><span class="comment">// 返回 Location 信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Location</span><span class="params">()</span> *<span class="title">Location</span></span></span><br><span class="line"><span class="comment">// 返回 Time 实例的时区规范名(如"CET")和该时区相对于 UTC 的时间偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Zone</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, offset <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 时间比较, 是否在 u 之后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 时间比较, 是否在 u 之前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 是否与 u 相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 返回 t-u 的时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="时间日志对象与字符串相互转换示例"><a href="#时间日志对象与字符串相互转换示例" class="headerlink" title="时间日志对象与字符串相互转换示例"></a>时间日志对象与字符串相互转换示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    <span class="comment">// layout 支持该日期时间点的部分随机组合, 可以这么理解 1 2 3 4 5 6 分别对应 月,日 时, 分, 秒, 年</span></span><br><span class="line">    <span class="comment">// layout 支持该日期时间点的短格式, 转换出来的字符串也为短格式</span></span><br><span class="line">    <span class="comment">// 将当前时间对象转换为 "yyyy-mm-dd hh:MM:ss" 形式输出</span></span><br><span class="line">    nowStr := now.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nowStr := now.Format("06-1-2 15:4:5")</span></span><br><span class="line">    <span class="comment">// nowStr := now.Format("01-02 15:04")</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(nowStr)</span><br><span class="line">    str := <span class="string">"2020年5月1日 15"</span></span><br><span class="line">    <span class="comment">// 当字符串为短格式时, layout 也必须为短格式</span></span><br><span class="line">    t := time.Parse(<span class="string">"2006年1月2日"</span>, str)</span><br><span class="line">    fmt.Printf(<span class="string">"%v, %T\n"</span>, t, t)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之包管理</title>
    <url>/2020/05/04/go-study-notes-package/</url>
    <content><![CDATA[<h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p>工作空间通常在 <code>GOPATH</code> 环境变量列表中定义(可通过 <code>go env</code> 查看), 由 src, bin, pkg 三个目录组成. <code>src</code> 用于保存源码文件, <code>bin,pkg</code> 主要影响 <code>go install/get</code> 命令, 它们将编译结果(可执行文件或静态库)安装到这两个目录下, 实现增量编译.</p>
<p>编译器按照 GOPATH 设置的路径搜索目标文件. 不同操作系统, GOPATH 列表分割符不同, Unix 使用 <code>:</code>, Windows 使用 <code>;</code>. <code>go get</code> 默认将下载的第三方包保存在列表的第一个工作空间内.</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>Go 语言使用包(package)来组织源代码, 包(package)是多个 Go 源码的集合.</p>
<p>任何源文件必须属于某个包, 同时源文件的第一行有效代码必须通过 <code>package pacakgeName</code> 语句声明该源文件所属的包.</p>
<p>一般来说, 包有以下特点或注意事项:</p>
<ul>
<li>包名一般小写, 使用简短且有意义的名称</li>
<li>包名一般要和所在的目录同名, 也可以不同, 包名中不能包含 <code>-</code> 等特殊符号</li>
<li>包一般使用域名作为目录名称,这样能保证包名的唯一性, 比如 GitHub 项目的包一般会放到 <code>GOPATH/src/github.com/userName/projectName</code> 目录下</li>
<li>包名为 <code>main</code> 的包为应用程序的入口包, 编译不包含 main 包的源码文件时不会得到可执行文件</li>
<li>一个文件夹下的所有源码文件只能属于同一个包, 同样属于同一个包的源码文件不能放在多个文件夹下</li>
</ul>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>要在代码中使用其它包, 需要使用 <code>import</code> 关键字导入. <code>import</code> 语句通常在包声明语句下面. 语法为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"path/to/package"</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"path/to/package1"</span></span><br><span class="line">    <span class="comment">//"path/to/package2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>一般情况下, 要导入的包名路径需要使用 <code>&quot;&quot;</code> 包裹, 且包名是以 <code>GOPATG/src/</code> 后开始计算的, 使用 <code>/</code> 进行路径分割. 如, <code>import &quot;custom/lib&quot;</code> 表示将 <code>GOPATH/src/custom/lib</code> 包中内容导入.</p>
<p>包支持 4 中引用格式:</p>
<ol>
<li>标准引用格式: <code>import &quot;fmt&quot;</code></li>
<li>自定义别名引用: <code>import f &quot;fmt&quot;</code>, 此时我们可以使用 <code>f.</code> 代替 <code>fmt.</code> 调用 fmt 包中的方法. 别名引用也多用于导入包重名或包名过长的情况</li>
<li>省略引用格式: <code>import . &quot;fmt&quot;</code>, 此时我们可不使用 <code>fmt.</code> 而直接调用 <code>fmt</code> 包内的方法, 如 <code>fmt.Println()</code> -&gt; <code>Println()</code></li>
<li>匿名格式引用: <code>import _ &quot;fmt&quot;</code>, 此时我们只是希望执行包内的初始化 <code>init()</code> 函数, 而不使用包的内容</li>
</ol>
<p>在导入包时, 有以下几点需要注意:</p>
<ul>
<li>而未使用的包导入会被编译器视为错误</li>
<li>一个包可以有多个 <code>init()</code> 函数, 包加载时会执行全部的 <code>init()</code> 函数, 但并不能保证执行顺序, 所以不建议在一个包中放入多个 <code>init()</code> 函数，而是将需要初始化的逻辑放到一个 <code>init()</code> 函数里面.</li>
<li>包不能出现环形引用的情况, 比如包 a 引用了 b, b 引用了 c, c 又引用了 a, 此时编译不能通过</li>
<li>包可以被重复引用, 且 Go 编译器能够保证被重复引用包的 <code>init()</code> 函数只会执行一次</li>
<li><strong>所有保存在 <code>internal</code> 目录下的包(包括自身)仅能被其父目录下的包(含所有层次的子目录)访问</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line">|</span><br><span class="line">+-- main.go</span><br><span class="line">|</span><br><span class="line">+-- lib&#x2F;            # 内部包 internal&#x2F;&#123;a, b&#125; 仅能被 lib, lib&#x2F;x, lib&#x2F;x&#x2F;y 访问</span><br><span class="line">|   |</span><br><span class="line">|   +-- internal&#x2F;  # 内部包之间可相互访问</span><br><span class="line">|   |      |</span><br><span class="line">|   |      +-- a&#x2F;  # 可以导入外部包, 如 lib&#x2F;x&#x2F;y</span><br><span class="line">|   |      |</span><br><span class="line">|   |      +-- b&#x2F;</span><br><span class="line">|   |</span><br><span class="line">|   +-- x&#x2F;</span><br><span class="line">|       |</span><br><span class="line">|       +-- y</span><br><span class="line">|</span><br><span class="line">+-- z&#x2F;              # z 包不可导入 lib&#x2F;internal 下所有内容, 但可以导入 lib&#x2F;x 包</span><br></pre></td></tr></table></figure>

<p>在执行 <code>main</code> 包的 <code>main</code> 函数之前,Go 程序先对整个程序的包进行初始化.包内的源码文件都可以定义一到多个初始化函数,编译器首先确保完成所有全局变量初始化,然后开始执行 <code>init()</code> 初始化函数,直到这些全部结束后,运行时才进入 <code>main.main</code> 入口函数.</p>
<ol>
<li>从 main 函数引用的包开始,逐级查找包的引用,直到找到没有引用其它包的包</li>
<li>单个包在初始化过程中,先初始化常量,然后是全局变量,最后执行包的 <code>init()</code> 函数</li>
</ol>
<p><img src="images/package_initialization_process_in_go.jpg" alt="Go 包的初始化"></p>
<h3 id="包的封装"><a href="#包的封装" class="headerlink" title="包的封装"></a>包的封装</h3><p>所有成员在包内均可访问, 无论是否在同一源码文件中. 但只有名称首字母大写的成员为可导出成员, 可在包外访问, 类似于 java 中的 <code>public</code>. 名称首字母小写的成员不可导出, 仅能在本包中访问, 类似于 <code>private</code>.</p>
<p>可通过提供可导出的工厂模式的函数, 对外提供一个构造函数, 同时对其属性对外提供 Get/Set 方法.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/model/person.go</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span> <span class="comment">// 其它包不能直接访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;person&#123;name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"model"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := model.NewPerson(<span class="string">"smith"</span>)</span><br><span class="line">    p.SetAge(<span class="number">18</span>)</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Println(p.Name, <span class="string">" age ="</span>, p.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Go Modules 是 Go 语言的一种依赖管方式, 该功能是在 Go 1.11 版本中出现的, 且在 Go 1.12 版本不断改进, Go 1.13 版本完善优化后, 演变为官方推荐的包依赖管理方式.</p>
<p>Go Modules 使用 <code>go.mod</code> 和 <code>go.sum</code> 管理程序中第三方包的依赖.</p>
<p><code>go.mod</code> 定义了模块的名称(可用作导入的包名), Go 的版本以及第三方包模块的依赖及版本等信息, 并提供了<code>module</code>, <code>require</code>, <code>replace</code> 和 <code>exclude</code> 四个命令来实现 go module 的功能.</p>
<ul>
<li><code>module</code> 语句指定包的名字(路径)</li>
<li><code>require</code> 语句指定的依赖项模块</li>
<li><code>replace</code> 语句指定替换依赖项模块</li>
<li><code>exclude</code> 语句指定可以忽略依赖项模块</li>
</ul>
<p><a href="https://github.com/gin-gonic" target="_blank" rel="noopener">github.com/gin-gonic/gin</a> 示例如下:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module github.com&#x2F;gin-gonic&#x2F;gin</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com&#x2F;gin-contrib&#x2F;sse v0.1.0</span><br><span class="line">    github.com&#x2F;go-playground&#x2F;validator&#x2F;v10 v10.2.0</span><br><span class="line">    github.com&#x2F;golang&#x2F;protobuf v1.3.3</span><br><span class="line">    github.com&#x2F;json-iterator&#x2F;go v1.1.9</span><br><span class="line">    github.com&#x2F;mattn&#x2F;go-isatty v0.0.12</span><br><span class="line">    github.com&#x2F;stretchr&#x2F;testify v1.4.0</span><br><span class="line">    github.com&#x2F;ugorji&#x2F;go&#x2F;codec v1.1.7</span><br><span class="line">    gopkg.in&#x2F;yaml.v2 v2.2.8</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>go.sum</code> 记录每个依赖包的版本和哈希值, 示例文件如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.com&#x2F;davecgh&#x2F;go-spew v1.1.0&#x2F;go.mod h1:J7Y8YcW2NihsgmVo&#x2F;mv3lAwl&#x2F;skON4iLHjSsI+c5H38&#x3D;</span><br><span class="line">github.com&#x2F;davecgh&#x2F;go-spew v1.1.1 h1:vj9j&#x2F;u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c&#x3D;</span><br><span class="line">github.com&#x2F;davecgh&#x2F;go-spew v1.1.1&#x2F;go.mod h1:J7Y8YcW2NihsgmVo&#x2F;mv3lAwl&#x2F;skON4iLHjSsI+c5H38&#x3D;</span><br><span class="line">github.com&#x2F;gin-contrib&#x2F;sse v0.1.0 h1:Y&#x2F;yl&#x2F;+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE&#x3D;</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure>

<p>那么如何使用 Go Modules 呢?</p>
<h3 id="启用-go-module-功能"><a href="#启用-go-module-功能" class="headerlink" title="启用 go module 功能"></a>启用 go module 功能</h3><ul>
<li>go 版本 &gt;= v1.11</li>
<li>设置 <code>GO111MODULE</code> 环境变量为 on.</li>
</ul>
<p><code>GO111MODULE</code> 有三个值, 默认为 <code>auto</code></p>
<ul>
<li><code>on</code>: 启用 go module, 编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖</li>
<li><code>off</code>: 禁用 go module, 编译时会从 GOPATH 和 vendor 文件夹中查找包</li>
<li><code>auto</code>: 当项目在 GOPATH/src 目录之外, 并且项目根目录有 go.mod 文件时，开启 go module</li>
</ul>
<p>可以通过设置 <code>GOPROXY</code> 环境变量设置获取依赖包时的代理.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure>

<p>目前公开的代理服务地址有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;goproxy.io&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;goproxy.cn&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;goproxy&#x2F;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<h3 id="使用-go-module-功能"><a href="#使用-go-module-功能" class="headerlink" title="使用 go module 功能"></a>使用 go module 功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化 go module, 创建一个 go.mod 文件,包含 module 信息和 go 版本信息</span></span><br><span class="line">go mod init  [module_name]</span><br><span class="line"><span class="comment"># 自动将包及其依赖打包成 module, 并修改 go.mod 文件, 增加缺少的包,删除没有用到的包</span></span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>istio可扩展的策略和遥测</title>
    <url>/2020/04/03/istio-adapter-configuration/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对服务进行全面管理,除了需要具备服务治理功能,还需要知道服务到底运行得怎么样,有没有问题,哪里有问题,这一般是 APM(Application Performance Management,应用性能管理) 的职能,其中涉及采集数据,存储数据和检索数据.</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Istio 将 Envoy 的遥测和策略功能提取出来,放到一个服务端组件 Mixer 上,在逻辑上将 Envoy 和各种遥测数据的收集解耦,并将 Envoy 和真正的遥测后端解耦.Envoy 和控制面组件 Mixer 的单条连接</p>
<p>基于 Mixer Adapter 提供的扩展机制,可以做到在遥测和策略执行时对业务代码的无侵入,解耦数据面 Envoy 和遥测与策略执行的后端服务,并开发自己的 Adapter,提供扩展和定制的能力,提供满足用户特定场景的服务运行监控和控制</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>简单来说,该流程主要有两步:</p>
<ol>
<li>Envoy 生成数据并将数据上报给 Mixer</li>
<li>Mixer 调用对应的服务后端处理收到的数据</li>
</ol>
<p>每个经过 Envoy 的请求都会调用 Mixer上报数据,Mixer将上报的这些数据作为策略和遥测报告的一部<br>分发送出来,并转换为对后端服务的调用</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h4><p>Envoy 上报的数据在 Istio 中被称为属性(Attribute).严格来讲,在以上 Mixer 处理流程的两个阶段,从Envoy到Mixer及从Mixer到后端服务,处理的<br>对象都是属性</p>
<h4 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">destination_service: destination.service</span><br><span class="line">response_code: response.code</span><br><span class="line">destination_version: destination.labels[&quot;version&quot;] | &quot;unknown&quot;</span><br></pre></td></tr></table></figure>

<p>更多属性表达式见 &lt;云原生服务网格 istio&gt; 表 4-1</p>
<h4 id="Mixer的配置模型"><a href="#Mixer的配置模型" class="headerlink" title="Mixer的配置模型"></a>Mixer的配置模型</h4><p>Istio 主要通过 <code>Handler</code>(业务处理),<code>Instance</code>(数据定义)和 <code>Rule</code>(关联规则)这三个资源对象来描述对 Adapter 的配置</p>
<h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a><code>Handler</code></h5><p>Handler 描述定义的 Adapters 及其配置,不同的 Adapter 有不同的配置.Handler 是 Adapter 定义的模板的实现,通过给模板上的参数赋值来进行实例化</p>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">stdio</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">handler</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">outputAsJson:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">handler</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">requests_total</span></span><br><span class="line">    <span class="attr">instance_name:</span> <span class="string">requestcount.metric.istio-system</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">COUNTER</span></span><br><span class="line">    <span class="attr">label_names:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reporter</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_name</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">request_protocol</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">response_code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">connection_security_policy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">request_duration_seconds</span></span><br><span class="line">    <span class="attr">instance_name:</span> <span class="string">requestduration.metric.istio-system</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">DISTRIBUTION</span></span><br><span class="line">    <span class="attr">label_names:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reporter</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_name</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">request_protocol</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">response_code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">connection_security_policy</span></span><br><span class="line">    <span class="attr">buckets:</span></span><br><span class="line">      <span class="attr">explicit_buckets:</span></span><br><span class="line">        <span class="attr">bounds:</span> <span class="string">[0.005,</span> <span class="number">0.01</span><span class="string">,</span> <span class="number">0.025</span><span class="string">,</span> <span class="number">0.05</span><span class="string">,</span> <span class="number">0.1</span><span class="string">,</span> <span class="number">0.25</span><span class="string">,</span> <span class="number">0.5</span><span class="string">,</span> <span class="number">1</span><span class="string">,</span> <span class="number">2.5</span><span class="string">,</span> <span class="number">5</span><span class="string">,</span> <span class="number">10</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<h5 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a><code>Instance</code></h5><p>Instance 定义了 Adapter 要处理的数据对象,通过模板为 Adapter 提供对元数据的定义.Mixer 通过 Instance 把来自代理的属性拆分并分发给不通的适配器</p>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">logentry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">accesslog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">severity:</span> <span class="string">'"Info"'</span></span><br><span class="line">  <span class="attr">timestamp:</span> <span class="string">request.time</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">sourceIp:</span> <span class="string">source.ip</span> <span class="string">|</span> <span class="string">ip("0.0.0.0")</span></span><br><span class="line">    <span class="attr">sourceApp:</span> <span class="string">source.labels["app"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourcePrincipal:</span> <span class="string">source.principal</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceName:</span> <span class="string">source.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceWorkload:</span> <span class="string">source.workload.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceNamespace:</span> <span class="string">source.namespace</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceOwner:</span> <span class="string">source.owner</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationApp:</span> <span class="string">destination.labels["app"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationIp:</span> <span class="string">destination.ip</span> <span class="string">|</span> <span class="string">ip("0.0.0.0")</span></span><br><span class="line">    <span class="attr">destinationServiceHost:</span> <span class="string">destination.service.host</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationWorkload:</span> <span class="string">destination.workload.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationName:</span> <span class="string">destination.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationNamespace:</span> <span class="string">destination.namespace</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationOwner:</span> <span class="string">destination.owner</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationPrincipal:</span> <span class="string">destination.principal</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">apiClaims:</span> <span class="string">request.auth.raw_claims</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">apiKey:</span> <span class="string">request.api_key</span> <span class="string">|</span> <span class="string">request.headers["x-api-key"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">request.scheme</span> <span class="string">|</span> <span class="string">context.protocol</span> <span class="string">|</span> <span class="string">"http"</span></span><br><span class="line">    <span class="attr">method:</span> <span class="string">request.method</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">request.path</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">responseCode:</span> <span class="string">response.code</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">responseSize:</span> <span class="string">response.size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">requestSize:</span> <span class="string">request.size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">requestId:</span> <span class="string">request.headers["x-request-id"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">clientTraceId:</span> <span class="string">request.headers["x-client-trace-id"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">latency:</span> <span class="string">response.duration</span> <span class="string">|</span> <span class="string">"0ms"</span></span><br><span class="line">    <span class="attr">connection_security_policy:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"unknown"</span><span class="string">,</span> <span class="string">conditional(connection.mtls</span> <span class="string">|</span> <span class="literal">false</span><span class="string">,</span> <span class="string">"mutual_tls"</span><span class="string">,</span> <span class="string">"none"</span><span class="string">))</span></span><br><span class="line">    <span class="attr">requestedServerName:</span> <span class="string">connection.requested_server_name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">userAgent:</span> <span class="string">request.useragent</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">responseTimestamp:</span> <span class="string">response.time</span></span><br><span class="line">    <span class="attr">receivedBytes:</span> <span class="string">request.total_size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">sentBytes:</span> <span class="string">response.total_size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">referer:</span> <span class="string">request.referer</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">httpAuthority:</span> <span class="string">request.headers[":authority"]</span> <span class="string">|</span> <span class="string">request.host</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">xForwardedFor:</span> <span class="string">request.headers["x-forwarded-for"]</span> <span class="string">|</span> <span class="string">"0.0.0.0"</span></span><br><span class="line">    <span class="attr">reporter:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"source"</span><span class="string">,</span> <span class="string">"destination"</span><span class="string">)</span></span><br><span class="line">  <span class="attr">monitored_resource_type:</span> <span class="string">'"global"'</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">metric</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">requestcount</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">"1"</span></span><br><span class="line">  <span class="attr">dimensions:</span></span><br><span class="line">    <span class="attr">reporter:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"source"</span><span class="string">,</span> <span class="string">"destination"</span><span class="string">)</span></span><br><span class="line">    <span class="attr">source_workload:</span> <span class="string">source.workload.name</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_workload_namespace:</span> <span class="string">source.workload.namespace</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_principal:</span> <span class="string">source.principal</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_app:</span> <span class="string">source.labels["app"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_version:</span> <span class="string">source.labels["version"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_workload:</span> <span class="string">destination.workload.name</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_workload_namespace:</span> <span class="string">destination.workload.namespace</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_principal:</span> <span class="string">destination.principal</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_app:</span> <span class="string">destination.labels["app"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_version:</span> <span class="string">destination.labels["version"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_service:</span> <span class="string">destination.service.host</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_service_name:</span> <span class="string">destination.service.name</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_service_namespace:</span> <span class="string">destination.service.namespace</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">request_protocol:</span> <span class="string">api.protocol</span> <span class="string">|</span> <span class="string">context.protocol</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">response_code:</span> <span class="string">response.code</span> <span class="string">|</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">connection_security_policy:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"unknown"</span><span class="string">,</span> <span class="string">conditional(connection.mtls</span> <span class="string">|</span> <span class="literal">false</span><span class="string">,</span> <span class="string">"mutual_tls"</span><span class="string">,</span> <span class="string">"none"</span><span class="string">))</span></span><br><span class="line">  <span class="attr">monitored_resource_type:</span> <span class="string">'"UNSPECIFIED"'</span></span><br></pre></td></tr></table></figure>

<h5 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a><code>Rule</code></h5><p>Rule 配置了一组规则,告诉 Mixer 有哪个 Instance 在什么时候被发送给哪个 Handler 来处理,一般包括一个匹配的表达式和执行动作(action)匹配表达式控制在什么时候调用 Adapter,在 Action 里配置 Adapter 和 Instance 的名称</p>
<p>字段如下</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必选</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">match</td>
<td align="center">是</td>
<td align="center">表示匹配条件,如果未定义条件,则判定为总是匹配</td>
</tr>
<tr>
<td align="center">actions</td>
<td align="center">是</td>
<td align="center">表示满足条件后执行的动作,是一个数组.包含 handler 和 instance 两个字段,用于指定 handler 和 instance 的名称(必须是全名,格式一般为 <code>&lt;name.kind&gt;</code>)</td>
</tr>
</tbody></table>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">stdio</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">match:</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"http"</span> <span class="string">||</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"grpc"</span></span><br><span class="line">  <span class="attr">actions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">handler:</span> <span class="string">handler.stdio</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">accesslog.logentry</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">promhttp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">match:</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"http"</span> <span class="string">||</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"grpc"</span></span><br><span class="line">  <span class="attr">actions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">handler:</span> <span class="string">handler.prometheus</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">requestcount.metric</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">requestduration.metric</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">requestsize.metric</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">responsesize.metric</span></span><br></pre></td></tr></table></figure>

<h2 id="遥测适配器配置"><a href="#遥测适配器配置" class="headerlink" title="遥测适配器配置"></a>遥测适配器配置</h2><h3 id="Prometheus-适配器"><a href="#Prometheus-适配器" class="headerlink" title="Prometheus 适配器"></a>Prometheus 适配器</h3><blockquote>
<p>工作流程</p>
</blockquote>
<ol>
<li>Envoy 通过 Report 接口上报数据给 Mixer</li>
<li>Mixer 根据配置将请求分发给 Prometheus Adapter</li>
<li>Prometheus Adapter 通过 HTTP 接口发 布Metric 数据</li>
<li>Prometheus 服务作为 Addon 在集群中进行安装,拉取并存储 Metric 数据,提供 Query 接口进行检索</li>
<li>集群内的 Dashboard(如Grafana)通过 Prometheus 的检索 API 访问 Metric 数据</li>
</ol>
<h4 id="handler-配置定义"><a href="#handler-配置定义" class="headerlink" title="handler 配置定义"></a>handler 配置定义</h4><p>handler 配置中最主要的字段是 <code>metrics</code>,用于在 Prometheus 中定义 metrics.它是一个数组,每个元素都具有如下属性</p>
<ul>
<li><code>name</code>: metric 的名称</li>
<li><code>instance_name</code>: instance 的全名称,格式为 <code>&lt;instance_name.kind.namespace&gt;</code></li>
<li><code>kind</code>: 定义指标类型,请求计数类型为 <code>COUNTER</code>,请求耗时类型为 <code>DISTRIBUTION</code>.DISTRIBUTION 类型的指标可以定义其 buckets</li>
<li><code>label_names</code>: 定义指标的标签,一般与 instance 中维度相同</li>
</ul>
<h4 id="instance-配置定义"><a href="#instance-配置定义" class="headerlink" title="instance 配置定义"></a>instance 配置定义</h4><p>instance 配置中最主要的字段是 <code>dimensions</code> 和 <code>value</code>,分别用于记录数据的维度及对应的值.这两个字段均支持属性表达式.其中维度中的 key 多用于 prometheus-metrics 的标签</p>
<h4 id="rule-配置定义"><a href="#rule-配置定义" class="headerlink" title="rule 配置定义"></a>rule 配置定义</h4><p>Rule 可以将 Handler 和 Instance建立关系,最主要的字段是 <code>match</code> 和 <code>actions</code>,分别用于匹配规则及匹配后的动作</p>
]]></content>
      <categories>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初识istio</title>
    <url>/2020/04/03/istio-first-step/</url>
    <content><![CDATA[<p>本文章为<a href="https://item.jd.com/12538407.html" target="_blank" rel="noopener">《云原生服务网格Istio：原理、实践、架构与源码解析》</a>第 1-2 章读书笔记.如果在学习过程中有理解不准确的地方,请以原书为准.</p>
<h2 id="istio-简介"><a href="#istio-简介" class="headerlink" title="istio 简介"></a>istio 简介</h2><p><a href="https://istio.io/" target="_blank" rel="noopener">Istio</a> 是一个与 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 紧密结合的适用于云原生场景的 Service Mesh 形态的用于服务治理的开放平台</p>
<h3 id="istio-可以做什么"><a href="#istio-可以做什么" class="headerlink" title="istio 可以做什么"></a>istio 可以做什么</h3><ul>
<li>自动通过服务发现获取服务实例列表,并根据负载均衡策略选择一个服务实例</li>
<li>对服务双方启用双向认证和通道加密</li>
<li>设置最大连接数,最大请求数,访问超时及设置限流机制等对服务进行保护</li>
<li>对请求进行重试</li>
<li>将一定特征的服务重定向,实现灰度发布</li>
<li>记录调用链,进行分布式追踪.根据访问数据形成完整的应用访问拓扑</li>
</ul>
<h2 id="istio-架构概述"><a href="#istio-架构概述" class="headerlink" title="istio 架构概述"></a>istio 架构概述</h2><h3 id="istio-工作机制"><a href="#istio-工作机制" class="headerlink" title="istio 工作机制"></a>istio 工作机制</h3><p><img src="/images/istio_working_mechanism_and_architecture.jpg" alt="istio 工作机制和架构"></p>
<ul>
<li><code>自动注入</code>: 在创建应用程序时自动注入 Sidecar 代理.在 Kubernetes 场景下创建 Pod 时,Kube-apiserver 调用管理面组件的 Sidecar-Injector 服务,自动修改应用程序的描述信息并注入 Sidecar.在创建Pod时,在创建业务容器的同时在Pod中创建 Sidecar 容器</li>
<li><code>流量拦截</code>: 在 Pod 初始化时设置 iptables 规则,当有流量到来时,基于配置的 iptables 规则拦截业务容器的 Inbound 流量和 Outbound 流量到 Sidecar 上.应用程序感知不到 Sidecar的存在,还以原本的方式进行互相访问</li>
<li><code>服务发现</code>: 服务发起方的 Envoy 调用管理面组件 Pilot 的服务发现接口获取目标服务的实例列表</li>
<li><code>负载均衡</code>: 服务发起方的 Envoy 根据配置的负载均衡策略选择服务实例,并连接对应的实例地址</li>
<li><code>流量治理</code>: Envoy 从 Pilot 中获取配置的流量规则,在拦截到 Inbound 流量和 Outbound 流量时执行治理逻辑</li>
<li><code>访问安全</code>: 在服务间访问时通过双方的 Envoy 进行双向认证和通道加密,并基于服务的身份进行授权管理.证书和密钥由管理面组件 Citadel 维护</li>
<li><code>服务遥测</code>: 在服务间通信时,通信双方的 Envoy 都会连接管理面组件 Mixer 上报访问数据,并通过 Mixer 将数据转发给对应的监控后端</li>
<li><code>策略执行</code>: 在进行服务访问时,通过Mixer连接后端服务来控制服务间的访问,判断对访问是放行还是拒绝</li>
<li><code>外部访问</code>: 在网格的入口处有一个 Envoy 扮演入口网关的角色</li>
</ul>
<h3 id="istio-服务模型"><a href="#istio-服务模型" class="headerlink" title="istio 服务模型"></a>istio 服务模型</h3><p>istio 服务模型与 kubernetes 中服务模型对应关系如下</p>
<table>
<thead>
<tr>
<th align="center">istio</th>
<th align="center">kubernetes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">service</td>
<td align="center">service</td>
</tr>
<tr>
<td align="center">服务版本</td>
<td align="center">Deployment,使用 app 和 version 标签区分不同服务的不同版本</td>
</tr>
<tr>
<td align="center">服务实例</td>
<td align="center">Endpoint</td>
</tr>
</tbody></table>
<h3 id="istio-主要组件"><a href="#istio-主要组件" class="headerlink" title="istio 主要组件"></a>istio 主要组件</h3><blockquote>
<p>istio-pilot 服务发现和服务治理</p>
</blockquote>
<ul>
<li>服务发现</li>
</ul>
<p>pilot 提供各种服务发现的 adapter 实现服务发现机制,并将其构造和转换成 istio 的服务发现模型.如 kubernetes 源数据<code>service(service),endpoint(instance),deployment(version)</code></p>
<p><img src="/images/service_discovery_on_pilot.png" alt="pilot 服务发现"></p>
<ul>
<li>服务治理</li>
</ul>
<p>向数据面下发规则,pilot 负责将各种规则转换成 Envoy 可识别的格式,通过标准的 xDS 协议发送给 Envoy,指导Envoy完成动作.</p>
<p>其规则的实现方式包括 <code>VirtualService,DestinationRule,Gateway,ServiceEntry</code> 等流量治理规则,也包括认证授权等安全规则.</p>
<blockquote>
<p>istio-mixer 数据收集,策略执行</p>
</blockquote>
<ul>
<li>使用 telemetry 服务组件收集遥测数据</li>
</ul>
<p>当网格中的两个服务间有调用发生时,服务的代理 Envoy 就会上报遥测数据给 istio-telemetry 服务组件,istio-telemetry 服务组件则根据配置将生成访问 Metric 等数据分发给后端的遥测服务</p>
<ul>
<li>使用 policy 服务组件管理网络策略</li>
</ul>
<p>数据面在转发服务的请求前调用 istio-policy 的 Check 接口检查服务间通信的策略,然后根据配置将请求转发到对应的 adapter 进行检查,给代理返回允许访问还是拒绝</p>
<blockquote>
<p>istio-citadel 安全中心</p>
</blockquote>
<p>istio-citadel 是 istio 的核心安全组件,提供了自动生成,分发,轮换与撤销密钥和证书功能.</p>
<p>citadel 一直监听  kube-apiserver,以 secret 的形式为每个服务都生成证书密钥,并在 pod 创建时挂载到 pod 上,代理容器使用这些文件来做服务身份认证,进而代理两端服务实现双向 TLS 认证,通道加密,访问授权等安全功能</p>
<blockquote>
<p>istio-galley 控制面上的配置中心</p>
</blockquote>
<p>istio-galley 在控制面上向其它组件提供支持,它用于验证配置信息的格式和内容的正确性,并将这些配置信息提供给管理面的 Pilot 和 Mixer.</p>
<blockquote>
<p>istio-sidecar-injector 自动注入</p>
</blockquote>
<p>istio-sidecar-injector 主要负责自动注入,在创建 Pod 时自动调用 istio-sidecar-injector 向 pod 中注入 sideCar 容器</p>
<blockquote>
<p>istio-proxy,Envoy,Sidecar Istio数据面轻量代理</p>
</blockquote>
<p>综合/分析 pilot 中规则,配置到 proxy,类似于4 和 7 层代理.作为服务网格的数据面,Envoy 提供了动态服务发现,负载均衡,TLS,HTTP/2 及 gRPC代理,熔断器,健康检查,流量拆分,灰度发布,故障注入等功能</p>
<blockquote>
<p>istio-ingressgateway 服务网格入口网关</p>
</blockquote>
<p>istio-ingressgateway 是服务网格入口处的网关,从网格外访问网格内的服务就是通过这个组件进行的.该组件是一个 Loadbalancer 类型的 Service,并开放了一组端口,用于外部访问.</p>
<h2 id="非侵入的流量治理"><a href="#非侵入的流量治理" class="headerlink" title="非侵入的流量治理"></a>非侵入的流量治理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>目标</p>
</blockquote>
<p>以基础设施的方式提供给用户非侵入的流量治理能力,用户只需<br>关注自己的业务逻辑开发,无须关注服务访问管理</p>
<blockquote>
<p>流程</p>
</blockquote>
<ol>
<li>管理员通过命令行或 API 创建流量规则</li>
<li>Pilot 将流量规则转换为 Envoy 的标准格式,并下发给 Envoy(转向数据面)</li>
<li>Envoy 拦截 Pod 上本地容器的 Inbound 流量和 Outbound 流量</li>
<li>在流量经过 Envoy 时执行对应的流量规则,对流量进行治理</li>
</ol>
<blockquote>
<p>应用场景和功能</p>
</blockquote>
<ul>
<li>负载均衡</li>
</ul>
<p>服务注册: 各服务将服务名和服务实例的对应信息注册到服务注册中心<br>服务发现: 在客户端发起服务访问时,以同步或者异步的方式从服务注册中心获取服务对应的实例列表<br>负载均衡: 据配置的负载均衡算法从实例列表中选择一个服务实例.目前支持的负载均衡算法有轮询,随机和最小连接数算法</p>
<ul>
<li>服务熔断</li>
</ul>
<p>故障检测和处理逻辑,防止临时故障或意外导致系统整体不可用.最典型的场景是防止网络和服务调用故障级联发生,限制故障的影响范围,防止故障蔓延导致系统整体性能下降或雪崩</p>
<ul>
<li>故障注入</li>
</ul>
<p>主要用于测试其健壮性和应对故障的能力,例如异常处理,故障恢复等Istio 的故障注入是在网格中对特定的应用层协议进行故障注入,可以模拟出应用的故障场景.</p>
<p>如注入 HTTP Code 503(服务端异常),请求延时(模拟响应慢)</p>
<ul>
<li>灰度发布</li>
</ul>
<p>新老版本同时在线,新版本只切分少量流量出来,在确认新版本没有问题后,再逐步加大流量比例</p>
<p>其中灰度发布主要有金丝雀发布,蓝绿发布,AB 测试 3 种方式</p>
<ul>
<li>服务访问入口</li>
</ul>
<p>Istio 中通过 Ingress Gateway 访问网格内的服务,做四层到六层的端口,TLS配置等基本功能,VirtualService则定义七层路由等丰富内容</p>
<ul>
<li>外部接入服务治理</li>
</ul>
<p>Istio 通过 ServiceEntry 资源对象将网格外的服务注册到网格上,然后像对网格内的普通服务一样对网格外的服务访问进行治理.有时需<br>要有一个专门的 Egress Gateway 来提供统一的出口网关.</p>
]]></content>
      <categories>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之反射</title>
    <url>/2020/04/30/go-study-notes-reflect/</url>
    <content><![CDATA[<p>反射是值在程序运行期间对程序本身进行访问和修改的能力. 程序在编译时, 变量被转换为内存地址, 程序运行时, 程序无法获取自身的信息.</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息, 如字段名称, 类型信息, 结构体信息等整合到可执行文件中, 并给程序提供接口访问反射信息, 这样就可以在程序运行期获取类型的反射信息, 并且有能力修改它们.</p>
<p>任意接口值在反射中都可以理解为由 Type 和 Value 组成的. Go 语言的反射是由 <code>reflect</code> 包提供的, 它定义了两个重要的类型 <code>reflect.Type</code> 和 <code>reflect.Value</code>, 并提供了 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 函数来获取任意对象的 Value 和 Type.</p>
<h2 id="反射的类型接口-reflect-Type"><a href="#反射的类型接口-reflect-Type" class="headerlink" title="反射的类型接口 reflect.Type"></a>反射的类型接口 <code>reflect.Type</code></h2><p>在 Go 语言程序中, 使用 <code>reflect.TypeOf()</code> 函数可以获得任意值的 <code>reflect.Type</code> 接口对象, 程序通过类型对象可以访问对象的类型信息.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    typeOfn := reflect.TypeOf(n)  <span class="comment">// 获取 n 的 反射的类型对象 `reflect.Type`</span></span><br><span class="line">    fmt.Println(<span class="string">"type:"</span>, typeOfn.Name(), <span class="string">"kind:"</span>, typeOfn.Kind())  <span class="comment">// 输出为 type: int kind: int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型名称-Name-与种类-Kind"><a href="#类型名称-Name-与种类-Kind" class="headerlink" title="类型名称(Name)与种类(Kind)"></a>类型名称(Name)与种类(Kind)</h3><ul>
<li>Name(类型名称) 返回反射类型的的名称, 包括 Go 语言中原生数据类型及通过 type 关键字自定义的数据类型. 获取方式为 <code>reflect.Type</code> 的 <code>Name()</code> 方法</li>
<li>Kind(种类) 指反射类型所属的种类, 它仅包含 Go 语言中原生数据种类. 获取方式为 <code>reflect.Type</code> 的 <code>Kind()</code> 方法, 返回 <code>reflect.Kind</code> 类型的常量</li>
</ul>
<p>在如下示例中, <code>stu</code> 对象的反射类型名称为自定义的 <code>Student</code>, 而其所属的反射种类为 <code>struct</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">        Name:  <span class="string">"tom"</span>,</span><br><span class="line">        Age:   <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    typeOfstu := reflect.TypeOf(stu)</span><br><span class="line">    fmt.Println(<span class="string">"type:"</span>, typeOfstu.Name(), <span class="string">"kind:"</span>, typeOfstu.Kind())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// type: Student kind: struct</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊反射种类的类型名称"><a href="#特殊反射种类的类型名称" class="headerlink" title="特殊反射种类的类型名称"></a>特殊反射种类的类型名称</h3><p>获取反射种类(Kind)为 <code>Array</code>, <code>Chan</code>, <code>Map</code>, <code>Ptr</code> 或 <code>Slice</code> 的对象的反射类型名称时, 通过 <code>Name()</code> 方法获得的类型名称为空字符串(“”)</p>
<p>要想获取以上对象的反射类型名称, 需要通过 <code>Elem()</code> 方法获取反射类型的元素类型, 然后再通过 <code>Name()</code> 方法获取其反射类型的名称</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">       Name:  <span class="string">"tom"</span>,</span><br><span class="line">       Age:   <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ptrOfstu := &amp;stu</span><br><span class="line">    typeOfptr := reflect.TypeOf(ptrOfstu)  <span class="comment">// 获取 &amp;stu 的反射的类型对象 `reflect.Type`</span></span><br><span class="line">    fmt.Println(<span class="string">"type:"</span>, typeOfptr.Name(), <span class="string">"kind:"</span>, typeOfptr.Kind())  <span class="comment">// 输出为 type:  kind: ptr</span></span><br><span class="line">    elem := typeOfptr.Elem()</span><br><span class="line">    fmt.Println(<span class="string">"elem's type:"</span>, elem.Name(), <span class="string">"elem's kind:"</span>, elem.Kind())  <span class="comment">// 输出为 elem's type: Student elem's kind: struct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// type:  kind: ptr</span></span><br><span class="line"><span class="comment">// type: Student kind: struct</span></span><br></pre></td></tr></table></figure>

<p><code>reflect.Type</code> 的 <code>Elem()</code> 方法仅当反射类型的种类是 <code>Array</code>, <code>Chan</code>, <code>Map</code>, <code>Ptr</code> 或 <code>Slice</code> 时才可以获取其元素类型, 否则 <code>Elem()</code> 方法会引发 panics.</p>
<h3 id="使用反射获取结构体的成员及方法信息"><a href="#使用反射获取结构体的成员及方法信息" class="headerlink" title="使用反射获取结构体的成员及方法信息"></a>使用反射获取结构体的成员及方法信息</h3><p>通过 <code>reflect.TypeOf()</code> 获得反射对象信息后, 如果它所属种类是结构体，可通过 <code>reflect.Type</code> 的 <code>NumField()</code> 和 <code>Field()</code> 方法获得结构体成员的详细信息, 可通过<code>NumMethod()</code> 和 <code>Method()</code> 方法获取结构体的方法详细信息</p>
<p><code>reflect.Type</code> 中与成员及方法获取相关的方法如下表所示</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>NumField()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体成员字段数量</td>
</tr>
<tr>
<td align="center"><code>Field(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.StructField</td>
<td align="center">根据索引返回索引对应的结构体字段的信息</td>
</tr>
<tr>
<td align="center"><code>NumMethod()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体方法数量</td>
</tr>
<tr>
<td align="center"><code>Method(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.Method</td>
<td align="center">根据索引返回索引对应的结构体方法的信息, 方法的排序是根据 ascii 码的先后顺序进行排序的</td>
</tr>
</tbody></table>
<p>需要注意的是, 方法相关信息可直接通过 <code>reflect.TypeOf(&amp;object).Method()</code> 方法获取, 且通过这种方法获取的方法包括 receiver 为 <code>&amp;object</code> 的方法. <code>reflect.TypeOf(object).Method()</code> 仅返回 receiver 为 <code>object</code> 的方法. 而字段相关信息只能通过 <code>Elem()</code> 获取元素类型后获取字段相关信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span>  <span class="string">`json: "name"`</span></span><br><span class="line">    Age   <span class="keyword">int</span>     <span class="string">`json: "age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(*stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stu.Name = name</span><br><span class="line">    stu.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">        Name: <span class="string">"tom"</span>,</span><br><span class="line">        Age:  <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    typeOfstu := reflect.TypeOf(stu)</span><br><span class="line">    kindOfstu := typeOfstu.Kind()</span><br><span class="line">    typeOfptr := reflect.TypeOf(&amp;stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> kindOfstu != reflect.Struct &#123;</span><br><span class="line">        fmt.Println(<span class="string">"except struct..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fieldNum := typeOfstu.NumField()</span><br><span class="line">    fmt.Println(<span class="string">"字段个数为: "</span>, fieldNum)  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; fieldNum; i++ &#123;</span><br><span class="line">        field := typeOfstu.Field(i)</span><br><span class="line">        fmt.Println(field)</span><br><span class="line">        fmt.Printf(<span class="string">"字段名: %v, 字段类型: %v, 字段的 json 标签: %v\n"</span>, field.Name, field.Type, field.Tag.Get(<span class="string">"json"</span>))  <span class="comment">// Tag.Get(key) 方法可以返回键值对格式的的标签指定键的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodNumOfstu := typeOfstu.NumMethod()</span><br><span class="line">    fmt.Println(<span class="string">"stu方法个数为: "</span>, methodNumOfstu)  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfstu; i++ &#123;</span><br><span class="line">        method := typeOfstu.Method(i)</span><br><span class="line">        fmt.Println(method)</span><br><span class="line">        fmt.Printf(<span class="string">"方法名: %v, 方法类型: %v\n"</span>, method.Name, method.Type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodNumOfptr := typeOfptr.NumMethod()</span><br><span class="line">    fmt.Println(<span class="string">"&amp;stu方法个数为: "</span>, methodNumOfptr)   <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfptr; i++ &#123;</span><br><span class="line">        method := typeOfptr.Method(i)</span><br><span class="line">        fmt.Println(method)</span><br><span class="line">        fmt.Printf(<span class="string">"方法名: %v, 方法类型: %v, 方法对象%v\n"</span>, method.Name, method.Type, method.Func)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射的值对象-reflect-Value"><a href="#反射的值对象-reflect-Value" class="headerlink" title="反射的值对象 reflect.Value"></a>反射的值对象 <code>reflect.Value</code></h2><p>使用 <code>reflect.ValueOf()</code> 函数可以获得对象的反射值对象 <code>reflect.Value</code>. <code>reflect.Value</code> 对象可以通过调用 <code>Type()</code> 方法返回 <code>reflect.Type</code> 对象, 完成值到类型对象的转换.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    valueOfN := reflect.ValueOf(n)  <span class="comment">// 获取 n 的 反射的值对象 `reflect.Value`</span></span><br><span class="line">    typeOfN := valueOfN.Type() <span class="comment">// 值对象可以转换为类型对象, 等价于 reflect.TypeOf(n)</span></span><br><span class="line">    fmt.Printf(<span class="string">"值为: %v, 实际类型为 %T"</span>, valueOfN, valueOfN)  <span class="comment">// 输出为 值为: 20, 实际类型为 reflect.Value</span></span><br><span class="line">    n2, ok := valueOfN.Interface().(<span class="keyword">int</span>) <span class="comment">// 先将 reflect.Value 转换为 interface, 然后通过类型断言来转换为 int 类型</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"转换后值为: %v, 类型为 %T"</span>, n2, n2)  <span class="comment">// 输出 转换后值为: 20, 类型为 int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/conversion_between_actual_type_and_reflection.jpg" alt="实际类型与反射间的转换"></p>
<p>通过以上可以看得出, 实际类型对象将自身通过接口方式传入 <code>reflect.ValueOf(i interface{})</code> 方法, 返回 <code>reflect.Value</code> 对象. <code>reflect.Value</code> 对象通过调用自身 <code>Interface()</code> 方法, 返回接口类型, 该接口类型可通过类型断言转化为实际类型对象.</p>
<h3 id="使用反射获取结构体的成员值及方法信息"><a href="#使用反射获取结构体的成员值及方法信息" class="headerlink" title="使用反射获取结构体的成员值及方法信息"></a>使用反射获取结构体的成员值及方法信息</h3><p>通过 <code>reflect.ValueOf()</code> 获得反射对象值信息后, 如果它所属种类是结构体，可通过 <code>reflect.Value</code> 的 <code>NumField()</code> 和 <code>Field()</code> 方法获得结构体成员的值信息, 可通过<code>NumMethod()</code> 和 <code>Method()</code> 方法获取结构体的方法等信息</p>
<p><code>reflect.Value</code> 中与成员及方法获取相关的方法如下表所示:</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>NumField()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体成员字段数量</td>
</tr>
<tr>
<td align="center"><code>Field(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.Value</td>
<td align="center">根据索引返回结构体字段对应的值对象</td>
</tr>
<tr>
<td align="center"><code>NumMethod()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体方法数量</td>
</tr>
<tr>
<td align="center"><code>Method(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.Value</td>
<td align="center">根据索引返回结构体方法对应的值对象, 输出为内存地址(尚不清楚是什么地址), 方法的排序是根据 ascii 码的先后顺序进行排序的</td>
</tr>
</tbody></table>
<p>需要注意的是, 方法相关信息可直接通过 <code>reflect.ValueOf(&amp;object).Method()</code> 方法获取, 且通过这种方法获取的方法包括 receiver 为 <code>&amp;object</code> 的方法. <code>reflect.ValueOf(object).Method()</code> 仅返回 receiver 为 <code>object</code> 的方法. 而字段值对象相关信息只能通过 <code>Elem()</code> 获取值元素后获取字段段值对象相关信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span>  <span class="string">`json: "name"`</span></span><br><span class="line">    Age   <span class="keyword">int</span>     <span class="string">`json: "age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(*stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stu.Name = name</span><br><span class="line">    stu.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">        Name: <span class="string">"tom"</span>,</span><br><span class="line">        Age:  <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    valueOfstu := reflect.ValueOf(stu)</span><br><span class="line">    valueOfptr := reflect.ValueOf(&amp;stu)</span><br><span class="line"></span><br><span class="line">    typeOfStu := valueOfstu.Type() <span class="comment">// 返回反射的类型</span></span><br><span class="line">    kindOfstu := valueOfstu.Kind() <span class="comment">// 返回反射的种类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> kindOfstu != reflect.Struct &#123;</span><br><span class="line">        fmt.Println(<span class="string">"except struct..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(typeOfStu)</span><br><span class="line"></span><br><span class="line">    fieldNum := valueOfstu.NumField()</span><br><span class="line">    fmt.Println(<span class="string">"字段个数为: "</span>, fieldNum) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; fieldNum; i++ &#123;</span><br><span class="line">        field := valueOfstu.Field(i)</span><br><span class="line">        fmt.Println(field) <span class="comment">// 直接输出各个字段的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodNumOfstu := valueOfstu.NumMethod()</span><br><span class="line">    fmt.Println(<span class="string">"stu方法个数为: "</span>, methodNumOfstu) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfstu; i++ &#123;</span><br><span class="line">        method := valueOfstu.Method(i)</span><br><span class="line">        fmt.Println(method) <span class="comment">// 直接输出一个形如 0x4878c0 的地址, 但是不确定是什么, 而且所有都是相同的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodNumOfptr := valueOfptr.NumMethod()</span><br><span class="line">    fmt.Println(<span class="string">"&amp;stu方法个数为: "</span>, methodNumOfptr) <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfptr; i++ &#123;</span><br><span class="line">        method := valueOfptr.Method(i)</span><br><span class="line">        fmt.Println(method) <span class="comment">// 直接输出一个形如 0x4878c0 的地址, 但是不确定是什么, 而且所有都是相同的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用反射调用结构体的方法"><a href="#使用反射调用结构体的方法" class="headerlink" title="使用反射调用结构体的方法"></a>使用反射调用结构体的方法</h3><p>继续看上一个例子, 通过反射如何调用 <code>Student</code> 中的方法呢?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span>  <span class="string">`json: "name"`</span></span><br><span class="line">    Age   <span class="keyword">int</span>     <span class="string">`json: "age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(*stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stu.Name = name</span><br><span class="line">    stu.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">        Name: <span class="string">"tom"</span>,</span><br><span class="line">        Age:  <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    valueOfStu := reflect.ValueOf(&amp;stu)  <span class="comment">// 需要注意这里传入的是 &amp;stu, 使反射能够调用所有的方法, 并修改原始对象的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reflect.Value 的 Call() 方法反射调用 GetSum(n1, n2 int) int 方法, Call()方法需传入 []reflect.Value 类型的值</span></span><br><span class="line">    <span class="keyword">var</span> paramsGetSum []reflect.Value</span><br><span class="line">    paramsGetSum = <span class="built_in">append</span>(paramsGetSum, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">    paramsGetSum = <span class="built_in">append</span>(paramsGetSum, reflect.ValueOf(<span class="number">20</span>))</span><br><span class="line">    resGetSum := valueOfStu.Method(<span class="number">0</span>).Call(paramsGetSum)  <span class="comment">// 调用后返回值为 []reflect.Value, 因此需要根据返回值个数使用索引来获取返回值</span></span><br><span class="line">    fmt.Printf(<span class="string">"调用结果为 %v, 类型为 %T\n"</span>, resGetSum, resGetSum)  <span class="comment">// 输出为 :调用结果为 30, 类型为 []reflect.Value</span></span><br><span class="line">    resGetSum0 := resGetSum[<span class="number">0</span>]</span><br><span class="line">    fmt.Printf(<span class="string">"第一个返回值为 %v, 类型为 %T\n"</span>, resGetSum0, resGetSum0)  <span class="comment">// 输出为 :第一个返回值为 30, 类型为 reflect.Value</span></span><br><span class="line">    realRes0 := resGetSum[<span class="number">0</span>].Interface().(<span class="keyword">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"实际结果为 %v, 类型为 %T\n"</span>, realRes0, realRes0)  <span class="comment">// 输出为 :实际结果为 30, 类型为 int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reflect.Value 的 Call() 方法反射调用 Print() 方法, Call()方法需传入 []reflect.Value 类型的值</span></span><br><span class="line">    <span class="keyword">var</span> paramsPrint []reflect.Value</span><br><span class="line">    resPrint := valueOfStu.Method(<span class="number">1</span>).Call(paramsPrint)</span><br><span class="line">    fmt.Printf(<span class="string">"调用结果为 %v, 类型为 %T"</span>, resPrint, resPrint)  <span class="comment">// 输出为 :调用结果为 [], 类型为 []reflect.Value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reflect.Value 的 Call() 方法反射调用 Set(name string, age int) 方法, Call()方法需传入 []reflect.Value 类型的值</span></span><br><span class="line">    <span class="keyword">var</span> paramsSet []reflect.Value</span><br><span class="line">    paramsSet = <span class="built_in">append</span>(paramsSet, reflect.ValueOf(<span class="string">"jack"</span>))</span><br><span class="line">    paramsSet = <span class="built_in">append</span>(paramsSet, reflect.ValueOf(<span class="number">30</span>))</span><br><span class="line">    resSet := valueOfStu.Method(<span class="number">2</span>).Call(paramsSet)</span><br><span class="line">    fmt.Printf(<span class="string">"调用结果为 %v, 类型为 %T\n"</span>, resSet, resSet) <span class="comment">// 输出为 :调用结果为 [], 类型为 []reflect.Value</span></span><br><span class="line">    fmt.Println(stu)  <span class="comment">// 可以看到 stu 已被修改为 &#123;jack 30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>istio 可插拔的服务安全</title>
    <url>/2020/04/03/istio-security-service/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>安全原理</p>
</blockquote>
<ul>
<li>安全核心组件 Citadel 用于密钥和证书管理</li>
<li>Envoy 作为数据面组件代理服务间的安全通信,包括认证,通道加密等</li>
<li>Pilot 作为配置管理服务,在安全场景下将安全相关的配置分发 Envoy</li>
<li>Mixer 可以通过配置 Adapter 来做授权和访问审计</li>
</ul>
<p>从控制面到数据面的配置流程:</p>
<ul>
<li>Citadel 监听Kube-apiserver,为每个 Service 都生成密钥和证书,并保存为 Kubernetes Secrets.当创建Pod时,Kubernetes 将包含密钥和证书的 Secret 挂载到对应的Pod中</li>
<li>Citadel会维护证书的生命周期,并根据配置定期重建 Kubernetes Secrets 以自动更新证书</li>
<li>Pilot生成配置信息,定义哪个 ServiceAccount 可以运行哪个服务，并将这个配置下发给 Envoy</li>
</ul>
<p>数据面主要流程如下:</p>
<ul>
<li>客户端的 Envoy 拦截到服务的 Outbound 流量</li>
<li>客户端的 Envoy 和服务端的 Envoy 进行双向 TLS 握手</li>
<li>在双向TLS建立后,请求到达服务端 Envoy,服务端 Envoy 将请求转发给本地服务</li>
</ul>
<p>Istio 提供的安全功能主要有认证和授权</p>
<blockquote>
<p>认证方式</p>
</blockquote>
<p>istio 中提供了两种认证方式:</p>
<ul>
<li>传输认证: 又称为从服务到服务的认证.Istio 基于双向 TLS 来实现传输认证,包括双向认证,通道安全和证书自动维护.基于双向TLS可以保护从服务到服务的通信</li>
<li>来源认证: 又称为最终用户认证,用于认证请求的最终用户或设备</li>
</ul>
<blockquote>
<p>授权</p>
</blockquote>
<p>istio 中的授权是基于角色的访问控制(RBAC)</p>
<blockquote>
<p>密钥证书管理</p>
</blockquote>
<p>Citadel 服务主要做 4 个操作:</p>
<ul>
<li>给每个 Service Account 都生成 SPIFFE 密钥证书对</li>
<li>根据Service Account 给对应的 Pod 分发密钥和证书对</li>
<li>定期替换密钥证书</li>
<li>根据需要撤销证书</li>
</ul>
<h2 id="服务认证配置"><a href="#服务认证配置" class="headerlink" title="服务认证配置"></a>服务认证配置</h2><p>示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为 forecast 开启双向认证</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast-weather-mtls</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">targets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="认证策略定义"><a href="#认证策略定义" class="headerlink" title="认证策略定义"></a>认证策略定义</h3><p>认证策略定义过程中重要字段如下:</p>
<ul>
<li><code>targets</code>: 表示策略作用的目标对象,如果为空,则对策略作用范围内的所有服务都生效.该字段包含 <code>name</code> 和 <code>ports</code> 分别表示服务名称及端口</li>
<li><code>peers</code>: 描述传输认证的配置.一般被赋值为 mtls,表示启用双向认证.若不启用,则不用赋值</li>
<li><code>orgins</code>: 描述访问来源认证的配置.</li>
</ul>
<h3 id="认证策略典型应用"><a href="#认证策略典型应用" class="headerlink" title="认证策略典型应用"></a>认证策略典型应用</h3><h4 id="全网格服务启用双向-TLS-认证"><a href="#全网格服务启用双向-TLS-认证" class="headerlink" title="全网格服务启用双向 TLS 认证"></a>全网格服务启用双向 TLS 认证</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作用范围: 全网格,只能存在一个</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MeshPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="全名称空间服务启用双向-TLS-认证"><a href="#全名称空间服务启用双向-TLS-认证" class="headerlink" title="全名称空间服务启用双向 TLS 认证()"></a>全名称空间服务启用双向 TLS 认证()</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作用范围: 名称空间,名称空间内只能存在一个</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="对特定服务不启用双向-TLS-认证"><a href="#对特定服务不启用双向-TLS-认证" class="headerlink" title="对特定服务不启用双向 TLS 认证"></a>对特定服务不启用双向 TLS 认证</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">enable_weather_tls</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">disable_adv_tls</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">targets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">advertisement</span></span><br></pre></td></tr></table></figure>

<h2 id="服务授权配置"><a href="#服务授权配置" class="headerlink" title="服务授权配置"></a>服务授权配置</h2><h3 id="授权启用配置"><a href="#授权启用配置" class="headerlink" title="授权启用配置"></a>授权启用配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRbacConfig</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="string">ClusterRbacConfig</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">"ON_WITH_INCLUSION"</span></span><br><span class="line">  <span class="comment"># 支持 4 种模式,OFF(所有关闭),ON(所有开启),ON_WITH_INCLUSION(只对 inclusion 启用授权),ON_WITH_EXCLUSION(只对 exclusion 禁用授权)</span></span><br><span class="line">  <span class="attr">inclusion:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather</span></span><br><span class="line">    <span class="comment"># services:</span></span><br><span class="line">    <span class="comment"># - weather_service</span></span><br></pre></td></tr></table></figure>

<h3 id="授权策略配置"><a href="#授权策略配置" class="headerlink" title="授权策略配置"></a>授权策略配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">binding-advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">source.namespace:</span> <span class="string">"terminal"</span></span><br><span class="line">  <span class="attr">roleRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br></pre></td></tr></table></figure>

<h4 id="serviceRole-定义"><a href="#serviceRole-定义" class="headerlink" title="serviceRole 定义"></a>serviceRole 定义</h4><p>关键字 <code>rules</code>,表示权限的许可,元素 rule 通过如下字段来定义</p>
<ul>
<li><code>servces</code>: 必选字段,表示作用的服务的集合</li>
<li><code>paths</code>: 配置对应服务的接口列表.未指定时表示所有 path</li>
<li><code>methods</code>: 指定接口的方法,如 GET,POST 等</li>
<li><code>constraints</code>: 可选字段,可以理解为服务的扩展字段.常用扩展字段如下<ul>
<li><code>destination.labels</code>: 目标服务上的标签,如 destination.labels[version] 是 [v1] 来描述对特定版本权限</li>
<li><code>request.headers</code>: 通过 Header 上取值 来描述规则</li>
<li><code>destination.ip</code>: 目标服务实例的 IP 地址</li>
<li><code>destination.port</code>: 目标服务端口</li>
<li><code>destination.namespace</code>: 目标服务名称空间</li>
<li><code>destination.user</code>: 目标服务负载上取到的标识</li>
</ul>
</li>
</ul>
<h4 id="serviceRoleBinding-定义"><a href="#serviceRoleBinding-定义" class="headerlink" title="serviceRoleBinding 定义"></a>serviceRoleBinding 定义</h4><p>serviceRoleBinding 作为绑定的定义,主要绑定两个对象,一个是定义的角色 <code>roleRef</code>,另一个是角色分配的目标对象 <code>subjects</code></p>
<ul>
<li><code>roleRef</code>: 必选字段,表示要绑定的角色.包含 <code>kind(角色类型,ServiceRole)</code> 和 <code>name(角色名称)</code> 两个字段</li>
<li><code>subjects</code>: 必选字段,表示角色分配的目标,是一个列表,可将角色分配到多个对象上.该字段有两个属性分类<ul>
<li><code>user</code>: 对应用户名或 ID. “*” 表示授权给所有用户和服务</li>
<li><code>properties</code>: 扩展属性.支持以下属性<ul>
<li><code>source.ip</code>: 源服务实例的 IP 地址</li>
<li><code>source.namespace</code>: 源服务实例的名称空间</li>
<li><code>source.principal</code>: 源服务实例标识</li>
<li><code>request.headers</code>: 请求 HTTP header</li>
<li><code>request.auth.principal</code>: 请求认证主体</li>
<li><code>request.auth.audiences</code>: 认证信息的目标受众</li>
<li><code>request.auth.presenter</code>: 授权的凭证提供者</li>
<li><code>request.auth.claims</code>: 来源 JWT 声明</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="授权策略典型应用"><a href="#授权策略典型应用" class="headerlink" title="授权策略典型应用"></a>授权策略典型应用</h3><h4 id="特定名称空间授权"><a href="#特定名称空间授权" class="headerlink" title="特定名称空间授权"></a>特定名称空间授权</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["*"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["*"]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">binding-advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">source.namespace:</span> <span class="string">"client"</span></span><br><span class="line">  <span class="attr">roleRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br></pre></td></tr></table></figure>

<h4 id="特定服务授权"><a href="#特定服务授权" class="headerlink" title="特定服务授权"></a>特定服务授权</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br></pre></td></tr></table></figure>

<h4 id="特定接口授权"><a href="#特定接口授权" class="headerlink" title="特定接口授权"></a>特定接口授权</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">paths:</span> <span class="string">["v2/weatherdata"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br></pre></td></tr></table></figure>

<h4 id="特定版本授权"><a href="#特定版本授权" class="headerlink" title="特定版本授权"></a>特定版本授权</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br><span class="line">    <span class="attr">constraints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"destination.labels[version]"</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">["v2"]</span></span><br></pre></td></tr></table></figure>

<h4 id="特定源授权"><a href="#特定源授权" class="headerlink" title="特定源授权"></a>特定源授权</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">binding-advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">source.ip:</span> <span class="string">"1.1.0.0/16"</span></span><br><span class="line">  <span class="attr">roleRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>istio Sidecar 机制</title>
    <url>/2020/04/03/istio-sidecar/</url>
    <content><![CDATA[<h2 id="Sidecar-注入"><a href="#Sidecar-注入" class="headerlink" title="Sidecar 注入"></a>Sidecar 注入</h2><p>在 Kubernetes 中,Sidecar 容器与应用容器共存于同一个 Pod 中,共享同一个 Network Namespaces,因此Sidecar容器与应用容器共享同一个网络协议栈,这是 Sidecar 能够通过 iptables 拦截应用进出口流量的根本原因</p>
<p>在 istio 进行 sidecar 注入有两种方式,一种是通过 istioctl 命令行注入,另一种是通过 Sidecar Injector 自动注入.这两种方式的最终目的都是在应用 Pod 中注入 init 和 istio-proxy 这两个 Sidecar 容器.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Sidecar Injector 是 Istio 中实现自动注入 Sidecar 的组件,它是以 Kubernetes 准入控制器 Admission Controller 的形式运行的.Admission Controller 的基本工作原理是拦截 Kube-apiserver 的请求,在对象持久化之前,认证鉴权之后进行拦截.Kubernetes 允许用户以 Webhook 的方式自定义准入控制器,Sidecar Injector 就是这样一种特殊的 MutatingAdmissionWebhook</p>
<p>Sidecar Injector 只在创建 Pod 时进行 Sidecar 容器注入,在 Pod 的创建请求到达 kube-apiserver 后,首先进行认证鉴权,然后在准入控制阶段,kube-apiserver 以 REST 的方式同步调用 Sidecar Injector Webhook 服务进行 init 与 istio-proxy 容器的注入,最后将 Pod 对象持久化存储到 etcd 中</p>
<p>Istio中的 MutatingWebhook 配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sidecar-injector</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">istio</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sidecar-injector.istio.io</span></span><br><span class="line">    <span class="attr">clientConfig:</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">istiod</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/inject"</span></span><br><span class="line">      <span class="attr">caBundle:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">operations:</span> <span class="string">[</span> <span class="string">"CREATE"</span> <span class="string">]</span></span><br><span class="line">        <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">        <span class="attr">apiVersions:</span> <span class="string">["v1"]</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="string">["pods"]</span></span><br><span class="line">    <span class="attr">failurePolicy:</span> <span class="string">Fail</span></span><br><span class="line">    <span class="attr">namespaceSelector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">istio-injection:</span> <span class="string">enabled</span></span><br></pre></td></tr></table></figure>

<p>由以上配置可见, Sidecar Injector 只对标签匹配 <code>istio-injection：enabled</code> 的命名空间下的Pod资源对象的创建生效</p>
<h2 id="Sidecar-流量拦截"><a href="#Sidecar-流量拦截" class="headerlink" title="Sidecar 流量拦截"></a>Sidecar 流量拦截</h2><p>Sidecar 流量拦截基于 iptables 规则(init 容器启动时设置规则),拦截应用容器 Inbound/Outbound 的流量</p>
<p><img src="/images/istio_traffic_flow.png" alt="istio 流量流向"></p>
<ol>
<li>Inbound 流量在进入 Pod 的网络协议栈时首先被 iptables 规则拦截</li>
<li>iptables 规则将数据包转发给 Envoy</li>
<li>Envoy 再根据自身监听器的配置,将流量转发给应用进程</li>
<li>Outbound流量由应用发出,首先被 iptables 规则拦截</li>
<li>iptables 规则将出口数据包转发给Envoy</li>
<li>Envoy 再根据自身配置决定是否将流量转发到容器外</li>
</ol>
<h3 id="流量拦截原理"><a href="#流量拦截原理" class="headerlink" title="流量拦截原理"></a>流量拦截原理</h3><p>Istio中,流量拦截的实现依赖 initContainer iptables 规则的设置,目前有 <code>REDIRECT</code> 和 <code>TPROXY</code> 两种流量拦截模式.</p>
<p><code>REDIRECT</code> 模式虽然会进行源地址转换,但依旧是默认的设置.原因如下:</p>
<ul>
<li>配合 Istio 提供的遥测数据依然可以进行调用链分析</li>
<li>Kubernetes 平台上 Pod 及其 IP 地址并不是持久不变的</li>
</ul>
<p>istio 流量拦截的规则通过 initContainer 进行设置,initContainer 的启动参数及镜像如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-p"</span>  <span class="comment"># 指定 Envoy 转发 TCP 流量的端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">15001</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-z"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15006"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-u"</span>  <span class="comment"># 指定用户 id,由该用户发出的数据包不被 iptables 转发,防止死循环</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1337</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-m"</span>  <span class="comment"># 指定 iptables 拦截模式,默认为REDIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"REDIRECT"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-i"</span>  <span class="comment"># 目的地址在此范围内的数据包将会被转发到 Envoy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"*"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-x"</span>  <span class="comment"># 目的地址在此范围内的数据包不会被转发</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-b"</span>  <span class="comment"># 入口端口,进入目标端口的数据包会被转发到 Envoy,默认为应用服务监听端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"9080"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-d"</span>  <span class="comment"># 入口端口,进入目标端口的数据包不会被转发到Envoy,默认为 15020,这是 Sidecar 容器的健康检查端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15020"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>istio非侵入的流量治理</title>
    <url>/2020/04/03/istio-traffic-control/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>以基础设施的方式提供给用户非侵入的流量治理能力,用户只需关注自己的业务逻辑开发,无须关注服务访问管理</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>管理员通过命令行或 API 创建流量规则</li>
<li>Pilot 将流量规则转换为 Envoy 的标准格式,并下发给 Envoy(转向数据面)</li>
<li>Envoy 拦截 Pod 上本地容器的 Inbound 流量和 Outbound 流量</li>
<li>在流量经过 Envoy 时执行对应的流量规则,对流量进行治理</li>
</ol>
<h3 id="应用场景和功能"><a href="#应用场景和功能" class="headerlink" title="应用场景和功能"></a>应用场景和功能</h3><ul>
<li>负载均衡</li>
</ul>
<p>服务注册: 各服务将服务名和服务实例的对应信息注册到服务注册中心<br>服务发现: 在客户端发起服务访问时,以同步或者异步的方式从服务注册中心获取服务对应的实例列表<br>负载均衡: 据配置的负载均衡算法从实例列表中选择一个服务实例.目前支持的负载均衡算法有轮询,随机和最小连接数算法</p>
<ul>
<li>服务熔断</li>
</ul>
<p>故障检测和处理逻辑,防止临时故障或意外导致系统整体不可用.最典型的场景是防止网络和服务调用故障级联发生,限制故障的影响范围,防止故障蔓延导致系统整体性能下降或雪崩</p>
<ul>
<li>故障注入</li>
</ul>
<p>主要用于测试其健壮性和应对故障的能力,例如异常处理,故障恢复等Istio 的故障注入是在网格中对特定的应用层协议进行故障注入,可以模拟出应用的故障场景.</p>
<p>如注入 HTTP Code 503(服务端异常),请求延时(模拟响应慢)</p>
<ul>
<li>灰度发布</li>
</ul>
<p>新老版本同时在线,新版本只切分少量流量出来,在确认新版本没有问题后,再逐步加大流量比例</p>
<p>其中灰度发布主要有金丝雀发布,蓝绿发布,AB 测试 3 种方式</p>
<ul>
<li>服务访问入口</li>
</ul>
<p>Istio 中通过 Ingress Gateway 访问网格内的服务,做四层到六层的端口,TLS配置等基本功能,VirtualService则定义七层路由等丰富内容</p>
<ul>
<li>外部接入服务治理</li>
</ul>
<p>Istio 通过 ServiceEntry 资源对象将网格外的服务注册到网格上,然后像对网格内的普通服务一样对网格外的服务访问进行治理.有时需<br>要有一个专门的 Egress Gateway 来提供统一的出口网关</p>
<h2 id="VirtualService-路由规则配置"><a href="#VirtualService-路由规则配置" class="headerlink" title="VirtualService 路由规则配置"></a>VirtualService 路由规则配置</h2><p>VirtualService 定义了对特定目标服务的一组流量规则,它将满足条件的流量都转发到对应的服务后端,这个服务后端可以是一个服务,也可以是在 DestinationRule 中定义的服务的子集</p>
<h3 id="HTTP路由-HTTPRoute"><a href="#HTTP路由-HTTPRoute" class="headerlink" title="HTTP路由(HTTPRoute)"></a>HTTP路由(HTTPRoute)</h3><p>满足 <code>HTTPMatchRequest</code> 条件的流量都被路由到 <code>HTTPRouteDestination</code>,执行重定向 <code>HTTPRedirect</code>,重写 <code>HTTPRewrite</code>,重试 <code>HTTPRetry</code>,故障注入 <code>HTTPFaultInjection</code>,跨站 <code>CorsPolicy</code> 等策略</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">location:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">north</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">forecast</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>

<h4 id="HTTPMatchRequest-定义匹配规则"><a href="#HTTPMatchRequest-定义匹配规则" class="headerlink" title="HTTPMatchRequest 定义匹配规则"></a>HTTPMatchRequest 定义匹配规则</h4><p>关键字: <code>match</code>,支持如下定义方式</p>
<ul>
<li><code>uri,scheme,method,authority,headers</code>: 支持 <code>exact(精确),prefix(前缀),regex(正则)</code> 方式的匹配</li>
<li><code>port</code>: 端口</li>
<li><code>sourceLabels</code>: 支持以特定的标签进行匹配,匹配满足该标签的 Pod 发送出来的流量</li>
</ul>
<h4 id="HTTPRouteDestination-定义路由目标"><a href="#HTTPRouteDestination-定义路由目标" class="headerlink" title="HTTPRouteDestination 定义路由目标"></a>HTTPRouteDestination 定义路由目标</h4><p>关键字: <code>route</code>,支持如下定义方式</p>
<ul>
<li><code>destination</code>: 表示请求的目标,最终的流量要被送到这个目标上.通过 <code>host,subnet,port</code> 三个属性来描述<ul>
<li><code>host</code>: 必选字段,表示 istio 中注册的服务名.建议写全服务的全名 <code>&lt;hostname&gt;.&lt;namspace&gt;.svc.cluster.local</code></li>
<li><code>subset</code>: 表示 host 上定义的一个子集,用于表示不同版本的服务</li>
</ul>
</li>
<li><code>weight</code>: 表示请求流量分配的比例,当指定多个 destination 时需要配置,且weight 总和要求是 100</li>
<li><code>headers</code>: 对请求和响应的请求头进行修改</li>
</ul>
<h4 id="HTTPRedirect-定义重定向规则"><a href="#HTTPRedirect-定义重定向规则" class="headerlink" title="HTTPRedirect 定义重定向规则"></a>HTTPRedirect 定义重定向规则</h4><p>关键字: <code>redirect</code>,需要设置重定向的目标 <code>uri</code>.这里需要注意的是重定向的 <code>uri</code> 会替换原请求中完整的 uri 路径</p>
<h4 id="HTTPRewrite-定义-url-重写规则"><a href="#HTTPRewrite-定义-url-重写规则" class="headerlink" title="HTTPRewrite 定义 url 重写规则"></a>HTTPRewrite 定义 url 重写规则</h4><p>关键字: <code>rewrite</code>,需要设置重写的 <code>uri</code>.这里需要注意,与重定向不同,重写的 <code>uri</code> 只会会替换原请求中匹配部分的 uri</p>
<h4 id="HTTPRetry-定义请求失败时重试策略"><a href="#HTTPRetry-定义请求失败时重试策略" class="headerlink" title="HTTPRetry 定义请求失败时重试策略"></a>HTTPRetry 定义请求失败时重试策略</h4><p>关键字 <code>retries</code>,需要设置重试次数(attempts),超时(perTryTimeout),重试条件(retryOn)等.</p>
<ul>
<li><code>attempts</code>: 必选字段,定义重试次数</li>
<li><code>perTryTimeout</code>: 每次重试的超时时间,单位可以是 ms,s,m,h</li>
<li><code>retryOn</code>: 进行重试的条件,以逗号分割.重试条件包含如下:<ul>
<li>5xx: 上游服务返回5xx应答,或没有返回时</li>
<li>gateway-error: 只对502,503和504应答码进行重试</li>
<li>connect-failure：在连接上游服务失败时重试</li>
<li>retriable-4xx：在上游服务返回可重试的4xx应答码时执行重试</li>
<li>refused-stream：在上游服务使用REFUSED_STREAM错误码重置时执行重试</li>
<li>cancelled：在gRPC应答的Header中状态码是cancelled时执行重试</li>
<li>deadline-exceeded：在gRPC应答的Header中状态码是deadline-exceeded时执行重试</li>
<li>internal：在gRPC应答的Header中状态码是internal时执行重试</li>
<li>resource-exhausted：在gRPC应答的Header中状态码是resource-exhausted时执行重试</li>
<li>unavailable：在gRPC应答的Header中状态码是unavailable时执行重试</li>
</ul>
</li>
</ul>
<h4 id="Mirror-流量镜像"><a href="#Mirror-流量镜像" class="headerlink" title="Mirror 流量镜像"></a>Mirror 流量镜像</h4><p>关键字 <code>mirror</code>,指在将流量转发到原目标地址的同时将流量给另外一个目标地址镜像一份,用于真实流量请求</p>
<h4 id="HTTPFaultInjection-故障注入"><a href="#HTTPFaultInjection-故障注入" class="headerlink" title="HTTPFaultInjection 故障注入"></a>HTTPFaultInjection 故障注入</h4><p>关键字 <code>fault</code>,支持 <code>delay</code> 和 <code>abort</code> 两个字段配置延时和中止两种故障</p>
<ul>
<li><code>delay</code>: 用于延迟故障注入,主要设置如下两个字段<ul>
<li><code>fixedDelay</code>: 必选字段,表示延迟时间,单位可以是 ms,s,m,h</li>
<li><code>percentage</code>: 延迟故障作用的请求比例</li>
</ul>
</li>
<li><code>abort</code>: 用于中止故障注入,主要设置如下两个字段<ul>
<li><code>httpStatus</code>: 必选字段,中止的 HTTP 状态码</li>
<li><code>percentage</code>: 延迟故障作用的请求比例</li>
</ul>
</li>
</ul>
<h4 id="CorsPolicy-跨域资源共享"><a href="#CorsPolicy-跨域资源共享" class="headerlink" title="CorsPolicy 跨域资源共享"></a>CorsPolicy 跨域资源共享</h4><p>关键字 <code>corsPolicy</code>,用于通过跨域资源共享(Cross<br>Origin Resource Sharing)机制可允许 Web 应用服务器进行跨域访问控制,使跨域数据传输安全进行</p>
<ul>
<li><code>allowMethods</code>: 允许访问资源的 HTTP 方法列表,内容被序列化到 Access-Control-Allow-Methods 的<br>Header上</li>
<li><code>allowHeaders</code>: 请求资源的 HTTP Header 列表,内容被序列化到 Access-Control-Allow-Headers 的 Header 上</li>
<li><code>exposeHeaders</code>: 浏览器允许访问的 HTTP Header 的白名单,内容被序列化到 Access-Control-Expose-Headers 的 Header 上</li>
<li><code>maxAge</code>: 请求缓存的时长,被转化为 Access-Control-Max-Age 的 Header</li>
<li><code>allowCredentials</code>: 是否允许服务调用方使用凭据发起实际请求,被转化为 Access-Control-Allow-Credentials 的 Header</li>
</ul>
<h3 id="TLS路由-TLSRoute"><a href="#TLS路由-TLSRoute" class="headerlink" title="TLS路由(TLSRoute)"></a>TLS路由(TLSRoute)</h3><p>满足 <code>TLSMatchAttributes</code> 条件的 TLS 和 HTTPS 流量都被路由到 <code>RouteDestination</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">total-weather-tls</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"*.weather.com"</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"ingress-gateway"</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">sniHosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend.weather.com</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">frontend</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">sniHosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">recommendation.weather.com</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">recommendation</span></span><br></pre></td></tr></table></figure>

<h4 id="TLSMatchAttributes-TLS匹配规则"><a href="#TLSMatchAttributes-TLS匹配规则" class="headerlink" title="TLSMatchAttributes TLS匹配规则"></a>TLSMatchAttributes TLS匹配规则</h4><p>关键字 <code>match</code>,表示 TLS的匹配条件,支持如下定义方式:</p>
<ul>
<li><code>sniHosts</code>: 必选字段，用来匹配 TLS 请求的 SNI ,SNI 的值必须是 VirtualService 的 hosts 的子集</li>
<li><code>port</code>: 访问的目标端口</li>
<li><code>destinationSubnets</code>: 目标IP地址匹配的IP子网</li>
<li><code>sourceLabels</code>: 匹配来源负载的标签</li>
</ul>
<p>一般用法是匹配 <code>sniHosts</code> 和 <code>port</code></p>
<h4 id="RouteDestination-定义路由目标"><a href="#RouteDestination-定义路由目标" class="headerlink" title="RouteDestination 定义路由目标"></a>RouteDestination 定义路由目标</h4><p>关键字: <code>route</code>,包含如下两个属性,用法和约束同 <code>HTTPRouteDestination</code> 的对应字段</p>
<ul>
<li><code>destination</code>: 表示请求的目标,最终的流量要被送到这个目标上.通过 <code>host,subnet,port</code> 三个属性来描述<ul>
<li><code>host</code>: 必选字段,表示 istio 中注册的服务名.建议写全服务的全名 <code>&lt;hostname&gt;.&lt;namspace&gt;.svc.cluster.local</code></li>
<li><code>subset</code>: 表示 host 上定义的一个子集,用于表示不同版本的服务</li>
</ul>
</li>
<li><code>weight</code>: 表示请求流量分配的比例,当指定多个 destination 时需要配置,且weight 总和要求是 100</li>
</ul>
<h3 id="TCP路由-TCPRoute"><a href="#TCP路由-TCPRoute" class="headerlink" title="TCP路由(TCPRoute)"></a>TCP路由(TCPRoute)</h3><p>所有不满足以上HTTP和TLS条件的流量都会应用TCP流量规则</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">tcp:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">23003</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">inner-forecast</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">3003</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>满足 TCP 特有的 4 层匹配规则 <code>L4MatchAttribute</code> 条件的流量转发到对应的目标后端</p>
</blockquote>
<h4 id="L4MatchAttribute-四层匹配规则"><a href="#L4MatchAttribute-四层匹配规则" class="headerlink" title="L4MatchAttribute 四层匹配规则"></a>L4MatchAttribute 四层匹配规则</h4><p>关键字 <code>match</code>,支持以下匹配属性</p>
<ul>
<li><code>destinationSubnets</code>: 目标IP地址匹配的 IP 子网</li>
<li><code>port</code>: 访问的目标端口</li>
<li><code>sourceLabels</code>：源工作负载标签</li>
</ul>
<h4 id="RouteDestination-目标后端-与-TLS-定义方式相同"><a href="#RouteDestination-目标后端-与-TLS-定义方式相同" class="headerlink" title="RouteDestination 目标后端 与 TLS 定义方式相同"></a>RouteDestination 目标后端 与 TLS 定义方式相同</h4><h3 id="三种协议路由规则汇总"><a href="#三种协议路由规则汇总" class="headerlink" title="三种协议路由规则汇总"></a>三种协议路由规则汇总</h3><table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">路由规则</th>
<th align="center">支持的流量匹配条件</th>
<th align="center">条件属性</th>
<th align="center">支持的流量操作</th>
<th align="center">目标路由定义</th>
<th align="center">目标路由属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HTTP</td>
<td align="center">HTTPRoute</td>
<td align="center">HTTPMatchRequest</td>
<td align="center">uri,scheme,method,port,sourceLabels</td>
<td align="center">route,redirect,rewrite,retry,timeout,faultInjection,corsPolicy</td>
<td align="center">HTTPRouteDestination</td>
<td align="center">destination,weight,headers</td>
</tr>
<tr>
<td align="center">TLS</td>
<td align="center">TLSRoute</td>
<td align="center">TLSMatchAttribute</td>
<td align="center">sniHost,port,destinationSubnets,sourceLabels</td>
<td align="center">route</td>
<td align="center">RouteDestination</td>
<td align="center">destination,weight</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">TCPRoute</td>
<td align="center">L4MatchAttribute</td>
<td align="center">destinationSubnets,port,sourceLabels</td>
<td align="center">route</td>
<td align="center">RouteDestination</td>
<td align="center">destination,weight</td>
</tr>
</tbody></table>
<h2 id="DestinationRule-目标规则配置"><a href="#DestinationRule-目标规则配置" class="headerlink" title="DestinationRule 目标规则配置"></a>DestinationRule 目标规则配置</h2><p>DestinationRule 定义了满足路由规则的流量到达后端后的访问策略.在 Istio 中可以配置目标服务的负载均衡策略,连接池大小,异常实例驱除规则等功能.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alph3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">subnet:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">RANDON</span></span><br></pre></td></tr></table></figure>

<p>DestinationRule 重要属性如下:</p>
<ul>
<li><code>host</code>: 必选字段,表示使用规则的对象,取值是在服务注册中心注册的服务名.host如果取短域名,则会根据规则所在的命名空间进行解析.所以尽量填写全名</li>
<li><code>trafficPolicy</code>: 规则内容的定义,包括负载均衡,连接池策略,异常点检查等</li>
<li><code>PortTrafficPolicy</code>: 需设定关键字 port 表示流量策略要应用的服务端口,其余和 TrafficPolicy 没有很大差别</li>
<li><code>subsets</code>: 定义服务的一个子集,经常用来定义一个服务版本.包含如下重要属性<ul>
<li><code>name</code>: 必选字段,subnet 名称</li>
<li><code>labels</code>: Subset 上的标签,通过一组标签定义了属于这个 Subset 的服务实例</li>
</ul>
</li>
<li><code>exportTo</code>: 控制 DestinationRule 跨名称空间的可见性.可选值为 “.” 或 “*”,表示当前名称空间或所有名称空间</li>
</ul>
<h3 id="TrafficPolicy-流量策略"><a href="#TrafficPolicy-流量策略" class="headerlink" title="TrafficPolicy 流量策略"></a>TrafficPolicy 流量策略</h3><p>流量策略包含以下 4 种重要配置</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">loadBalancer</td>
<td align="center">LoadBalancerSettings</td>
<td align="center">描述服务的负载均衡算法</td>
</tr>
<tr>
<td align="center">connectionPool</td>
<td align="center">ConnectionPoolSettings</td>
<td align="center">描述服务的连接池配置</td>
</tr>
<tr>
<td align="center">outlierDetection</td>
<td align="center">OutlierDetection</td>
<td align="center">描述服务的异常点检查</td>
</tr>
<tr>
<td align="center">tls</td>
<td align="center">TLSSettings</td>
<td align="center">描述服务的TLS连接设置</td>
</tr>
</tbody></table>
<h4 id="loadBalancer-负载均衡设置"><a href="#loadBalancer-负载均衡设置" class="headerlink" title="loadBalancer 负载均衡设置"></a>loadBalancer 负载均衡设置</h4><p>负载均衡设置支持 <code>simple(简单)</code> 和 <code>consistentHash(一致性 hash)</code> 两个字段.其中,一致性哈希是一种高级的负载均衡策略,只对 HTTP 有效</p>
<ul>
<li><code>simple</code> 字段定义了 <code>ROUND_ROBIN(轮询,默认)</code>,<code>LEAST_CONN(最小连接)</code>,<code>RANDOM(随机)</code>,<code>PASSTHROUGH(直接转发)</code> 等几种负载均衡算法</li>
<li><code>consistentHash</code> 定义了 <code>httpHeaderName(请求头)</code>,<code>httpCookie(cookie)</code>,<code>useSourceIp(源 IP)</code> 等几种负载均衡算法.还提供 <code>minimumRingSize(哈希环上虚拟节点数的最小值)</code> 属性,用于增加 hash 节点数量(节点数越多则负载均衡越精细)</li>
</ul>
<h4 id="connectionPool-连接池设置"><a href="#connectionPool-连接池设置" class="headerlink" title="connectionPool 连接池设置"></a>connectionPool 连接池设置</h4><p>Istio 连接池管理支持 <code>tcp(TCP流量)</code> 和 <code>http(HTTP流量)</code> 两个字段.</p>
<p><code>tcp</code> 字段定义了如下属性:</p>
<ul>
<li><code>maxConnections</code>: 表示为上游服务的所有实例建立的最大连接数,默认1024</li>
<li><code>connectTimeout</code>: TCP连接超时,表示主机网络连接超时</li>
<li><code>tcpKeepalive</code>: 设置TCP keepalives(TCP keepalive).它包含三个字段,如下<ul>
<li><code>probes</code> 表示多少次探测没有应答则断开,默认是9</li>
<li><code>time</code> 表示在发送探测前连接空闲了多长时间,默认2h</li>
<li><code>interval</code> 表示探测间隔,默认 75s</li>
</ul>
</li>
</ul>
<p><code>http</code> 字段定义了如下属性:</p>
<ul>
<li><code>http1MaxPendingRequests</code>: 最大等待 HTTP 请求数,默认1024</li>
<li><code>http2MaxRequests</code>: 最大请求数,默认1024</li>
<li><code>maxRequestsPerConnection</code>: 每个连接的最大请求数</li>
<li><code>maxRetries</code>: 最大重试次数,默认3</li>
<li><code>idleTimeout</code>: 空闲超时,在多长时间内没有活动请求则关闭连接</li>
</ul>
<h4 id="outlierDetection-异常实例检查"><a href="#outlierDetection-异常实例检查" class="headerlink" title="outlierDetection 异常实例检查"></a>outlierDetection 异常实例检查</h4><p>异常点检查就是定期考察被访问的服务实例的工作情况,如果连续出现访问异常,则将服务实例标记为异常并进行隔离,在一段时间内不为其分配流量,待恢复后重新恢复流量.可用于熔断模型</p>
<p>异常实例检查可通过如下字段来控制检查驱逐的逻辑:</p>
<ul>
<li><code>consecutiveErrors</code>: 实例被驱逐前的连续错误次数,默认5</li>
<li><code>interval</code>: 驱逐的时间间隔,默认 10s</li>
<li><code>baseEjectionTime</code>: 最小驱逐时间,默认30s.实例被驱逐的时间等于这个最小驱逐时间乘以驱逐的次数</li>
<li><code>maxEjectionPercent</code>: 负载均衡池中可以被驱逐的故障实例的最大比例,默认是10%.避免太多实例被驱逐而导致整体服务能力下降</li>
<li><code>minHealthPercent</code>: 最小健康比例,当可用实例数的比例小于这个比例时,异常点检查功能将被禁用.默认 50%</li>
</ul>
<h4 id="tls-TLS连接设置"><a href="#tls-TLS连接设置" class="headerlink" title="tls TLS连接设置"></a>tls TLS连接设置</h4><p>istio TLS 连接设置支持以下字段属性:</p>
<ul>
<li><code>mode</code>: tls 认证方式.支持如下4种模式<ul>
<li><code>Disable</code>: 不使用 TLS 认证</li>
<li><code>SIMPLE</code>: 单向认证</li>
<li><code>MUTUAL</code>: 双向认证.需要应用程序提供客户端证书,在配置中指定证书文件路径</li>
<li><code>ISTIO_MUTUAL</code>: 双向认证.证书由Istio自动生成,不用指定证书路径</li>
</ul>
</li>
<li><code>privateKey</code>: 客户端私钥路径</li>
<li><code>clientCertificate</code>: 客户端证书路径</li>
<li><code>caCertificates</code>: 验证服务端证书的 CA 文件路径</li>
</ul>
<h2 id="Gateway-服务网关配置"><a href="#Gateway-服务网关配置" class="headerlink" title="Gateway 服务网关配置"></a>Gateway 服务网关配置</h2><p>Gateway 在网格边缘接收外部访问,并将流量转发到网格内的服务.Istio 通过 Gateway 将网格内的服务发布成外部可访问的服务,还可以通过 Gateway 配置外部访问的端口,协议及与内部服务的映射关系</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istio.gateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mesh</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">location:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">north</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destionation:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">frontend</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destionation:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">frontend</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>

<p>Gateway 定义了 <code>selector(标签选择)</code> 和 <code>servers(开放的服务列表)</code> 两个关键必选字段.</p>
<h3 id="server-后端服务"><a href="#server-后端服务" class="headerlink" title="server 后端服务"></a>server 后端服务</h3><p>server 真正定义了服务的访问入口,可通过如下字段来配置多个 server</p>
<ul>
<li><code>port</code>: 必选字段,描述服务在哪个端口开放,是对外监听的端口</li>
<li><code>hosts</code>: 为 gateway 发布的服务地址,是一个 FQDN 域名</li>
<li><code>defaultEndpoint</code>: 表示流量默认转发的后端</li>
<li><code>tls</code>: 安全服务接口相关内容.可通过如下字段进行配置<ul>
<li><code>httpsRedirect</code>: 是否要做 HTTPS 重定向</li>
<li><code>mode</code>: TLS 模式,<code>PASSTHROUGH(不做处理,直接转发,TLS证书相关设置在后端负载),SIMPLE(单向认证),MUTUAL(双向认证),AUTO_PASSTHROUGH</code></li>
<li><code>serverCertificate</code>: 服务端证书路径,在 SIMPLE,MUTUAL 时必须配置</li>
<li><code>privateKey</code>: 服务端密钥路径,在 SIMPLE,MUTUAL 时必须配置</li>
<li><code>caCertificates</code>: CA证书路径,在 MUTUAL 时必须配置</li>
<li><code>credentialName</code>: Gateway 使用 <code>credentialName</code> 从远端的凭据存储(Kubernetes-Secrets)中获取证书和密钥,而不是挂载</li>
<li><code>subjectAltNames</code>: SAN 列表</li>
<li><code>minProtocolVersion</code>,<code>maxProtocolVersion</code>: TLS 协议最小,最大版本</li>
<li><code>cipherSuites</code>: 指定加密套件,默认使用 Envoy 支持的加密套件</li>
</ul>
</li>
</ul>
<h3 id="Gateway-典型应用"><a href="#Gateway-典型应用" class="headerlink" title="Gateway 典型应用"></a>Gateway 典型应用</h3><h4 id="将网格内的-HTTPS-服务发布为-HTTPS-外部访问"><a href="#将网格内的-HTTPS-服务发布为-HTTPS-外部访问" class="headerlink" title="将网格内的 HTTPS 服务发布为 HTTPS 外部访问"></a>将网格内的 HTTPS 服务发布为 HTTPS 外部访问</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">PASSTHROUGH</span></span><br></pre></td></tr></table></figure>

<p>这种场景下,后端服务需要配置证书,协议为 HTTPS.istio 只是提供了通道和机制,通过 Gateway 将一个内部的 HTTPS 服务发布出去.</p>
<h4 id="将网格内的-HTTP-服务发布为-HTTPS-外部访问"><a href="#将网格内的-HTTP-服务发布为-HTTPS-外部访问" class="headerlink" title="将网格内的 HTTP 服务发布为 HTTPS 外部访问"></a>将网格内的 HTTP 服务发布为 HTTPS 外部访问</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="comment"># 指定服务端证书路径,需要将证书文件挂载在 ingressgateway pod 中.可以通过证书文件创建 k8s-secrets 后进行挂载</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.key</span></span><br><span class="line">      <span class="comment"># 直接指定 k8s-secrets 名称,istio 会自动配置对应的证书及密钥(推荐)</span></span><br><span class="line">      <span class="comment"># credentialName: weather-com-secrets</span></span><br></pre></td></tr></table></figure>

<p>这种场景下,后端服务不需要配置证书,协议为 HTTP.istio 将证书配置在 Gateway 上,并通过 Gateway 将一个内部的 HTTP 服务以 HTTPS 方式发布出去.</p>
<h4 id="将网格内的-HTTP-服务发布为双向-HTTPS-外部访问"><a href="#将网格内的-HTTP-服务发布为双向-HTTPS-外部访问" class="headerlink" title="将网格内的 HTTP 服务发布为双向 HTTPS 外部访问"></a>将网格内的 HTTP 服务发布为双向 HTTPS 外部访问</h4><p>在某些场景下,比如调用入口服务的是另一个服务,在服务端需要对客户端进行身份校验,这就需要用到 TLS 的双向认证.应用场景如银行 APP</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">MUTUAL</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.key</span></span><br><span class="line">      <span class="comment"># 用于验证客户端证书</span></span><br><span class="line">      <span class="attr">caCertificates:</span> <span class="string">/etc/istio/gateway-weather-certs/ca.crt</span></span><br></pre></td></tr></table></figure>

<h4 id="将网格内的-HTTP-服务发布为-HTTPS-外部访问-和HTTPS-内部访问"><a href="#将网格内的-HTTP-服务发布为-HTTPS-外部访问-和HTTPS-内部访问" class="headerlink" title="将网格内的 HTTP 服务发布为 HTTPS 外部访问 和HTTPS 内部访问"></a>将网格内的 HTTP 服务发布为 HTTPS 外部访问 和HTTPS 内部访问</h4><p>此场景与场景2 中 Gateway 的 Manifest 完全相同,我们只需知道 istio 可以透明地给网格内的服务启用双向 TLS,并且自动维护证书和密钥.</p>
<p>网关 Gateway 服务和后端 frontend 在这种场景下的工作机制如下</p>
<ul>
<li>frontend 服务自身还是HTTP,不涉及证书密钥的事情</li>
<li>流量进入网格前,Gateway 作为 frontend 服务的入口网关,对外提供 HTTPS 的访问.外部访问到的是在 Gateway 上发布的 HTTPS 服务,使用 Gateway 上的配置提供服务端证书和密钥</li>
<li>流量进入网格后,Gateway 作为客户端访问 frontend 服务的代理(Envoy,Sidecar),对 frontend 服务发起另一个 HTTPS 请求,使用的是 Citadel 分发和维护的客户端证书和密钥,与 frontend 服务代理(Envoy,Sidecar)的服务端证书和密钥进行双向 TLS 认证和通信.(该过程称为 mTLS 双向认证)</li>
</ul>
<h2 id="ServiceEntry-外部服务配置"><a href="#ServiceEntry-外部服务配置" class="headerlink" title="ServiceEntry 外部服务配置"></a>ServiceEntry 外部服务配置</h2><p>ServiceEntry 用于将网格外的服务加入网格中,并像网格内的服务一样进行管理,在实现上就是把外部服务加入 istio 的服务发现</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">weather-external</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure>

<p>ServiceEntry 主要包含如下几个字段</p>
<ul>
<li><code>hosts</code>: 必选字段,表示与 ServiceEntry 相关的主机名.当 resolution 被设置为 DN S类型并且没有指定 endpoints 时,这个字段将用作后端的域名来进行路由</li>
<li><code>ports</code>: 必选字段,表示与外部服务关联的端口</li>
<li><code>resolution</code>: 必选字段,表示服务发现的模式,有以下3种模式可选<ul>
<li><code>NONE</code>: 用于当连接的目标地址已经是一个明确 IP 的场景</li>
<li><code>STATIC</code>: 用在已经用 endpoints 设置了服务实例的地址场景中,即不用解析</li>
<li><code>DNS</code>: 表示用查询环境中的 DNS 进行解析.如果没有设置 endpoints,代理就会使用在<code>hosts</code>中指定的 DNS 地址进行解析</li>
</ul>
</li>
<li><code>addresses</code>: 与服务关联的虚拟IP地址</li>
<li><code>location</code>: <code>MESH_EXTERNAL</code>(网格外部) 或 <code>MESH_INTERNAL</code>(网格内部).当和网格外部服务通信时,mTLS 双向认证将被禁用,并且策略只能在客户端执行,不能在服务端执行.对于外部服务,我们不可能注入一个 Sidecar 来进行双向认证等操作</li>
<li><code>endpoints</code>:表示与网格服务关联的网络地址,可以是一个IP,也可以是一个主机名.包含如下字段<ul>
<li><code>address</code>: 必选字段,表示网络后端的地址.当 resolution 设置为 DNS 时,可以使用域名</li>
<li><code>ports</code>: 端口列表</li>
<li><code>labels</code>: 后端标签</li>
<li><code>weight</code>: 权重</li>
</ul>
</li>
</ul>
<h3 id="ServiceEntry-典型应用"><a href="#ServiceEntry-典型应用" class="headerlink" title="ServiceEntry 典型应用"></a>ServiceEntry 典型应用</h3><h4 id="通过配置-ServiceEntry-Egressgateway-VirtualService-访问外部服务"><a href="#通过配置-ServiceEntry-Egressgateway-VirtualService-访问外部服务" class="headerlink" title="通过配置 ServiceEntry + Egressgateway + VirtualService 访问外部服务"></a>通过配置 ServiceEntry + Egressgateway + VirtualService 访问外部服务</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 www.weatherdb.com 外部服务</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">weather-external</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br><span class="line"><span class="comment"># 定义 www.weatherdb.com 服务的 egress-gateway 网关出口</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">egress-gateway</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">egressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">egress-wearthdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">egress-gateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mesh</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">gateways:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mesh</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">egress-gateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">gateways:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">egress-gateway.istio-system.svc.cluster.local</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">www.weatherdb.com</span></span><br></pre></td></tr></table></figure>

<p>在此场景中,定义了两个 route</p>
<ul>
<li>网格内流量: 这个 route 的 gateways 是 mesh,表示来自网格内的流量在访问 <a href="http://www.weatherdb.com" target="_blank" rel="noopener">www.weatherdb.com</a> 这个外部地址时,将被路由到 egressgateway 网关上</li>
<li>网格外流量: 这个 route 的 gateways 是 egress,表示来自 egress 的流量在访问 <a href="http://www.weatherdb.com" target="_blank" rel="noopener">www.weatherdb.com</a> 这个外部地址时,将被路由到外部服务 <a href="http://www.weatherdb.com" target="_blank" rel="noopener">www.weatherdb.com</a> 上</li>
</ul>
<h2 id="Sidecar-代理规则配置"><a href="#Sidecar-代理规则配置" class="headerlink" title="Sidecar 代理规则配置"></a>Sidecar 代理规则配置</h2><p>用于对 istio 数据面的行为进行更精细的控制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">SideCar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"istio-system/*"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"news/*"</span></span><br></pre></td></tr></table></figure>

<p>在Sidecar上主要通过三个字段来描述规则</p>
<ul>
<li><code>workloadSelector</code>: 表示工作负载的选择器(pod 标签选择器),如果为空,则应用到整个命名空间</li>
<li><code>egress</code>: 配置 sidecar 对网格内其它服务的访问.如果没有配置,则只要名称空间可见,服务就可见<ul>
<li><code>hosts</code>: 监听的服务,为 <code>namespace/dnsName</code> 格式,</li>
<li><code>port</code>: 监听器关联的端口</li>
<li><code>bind</code>: 监听器绑定的地址</li>
<li><code>captureMode</code>: 配置如何捕获监听器的流量.有 <code>DEFAULT(默认),IPTABLES(基于 iptables 的流量拦截),NONE(没有流量拦截)</code>.</li>
</ul>
</li>
<li><code>ingress</code>: 配置 Sidecar 对应工作负载的 Inbound流量.<ul>
<li><code>port</code>: 必选字段,监听器关联的端口</li>
<li><code>defaultEndpoint</code>: 必选字段,为流量转发的目标地址</li>
<li><code>bind</code>: 监听器绑定的地址</li>
<li><code>captureMode</code>: 配置如何捕获监听器的流量</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 相关错误及其解决</title>
    <url>/2020/04/03/k8s-errors-and-resolve/</url>
    <content><![CDATA[<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/etcd-io/etcd/issues/10174" target="_blank" rel="noopener">执行命令时间太长</a></li>
</ul>
</blockquote>
<p>日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-07-22 03:33:16.621867 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;namespaces&#x2F;kube-system\&quot; &quot; with result &quot;range_response_count:1 size:177&quot; took too long (265.312097ms) to execute</span><br><span class="line">2019-07-22 03:33:16.622103 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;health\&quot; &quot; with result &quot;range_response_count:0 size:4&quot; took too long (255.015614ms) to execute</span><br><span class="line">2019-07-22 03:33:16.622848 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;clusterroles&#x2F;\&quot; range_end:\&quot;&#x2F;registry&#x2F;clusterroles0\&quot; &quot; with result &quot;range_response_count:0 size:4&quot; took too long (266.165829ms) to execute</span><br><span class="line">2019-07-22 03:33:16.625493 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;health\&quot; &quot; with result &quot;range_response_count:0 size:4&quot; took too long (231.260569ms) to execute</span><br></pre></td></tr></table></figure>

<p>原因</p>
<ul>
<li><a href="https://github.com/etcd-io/etcd/blob/master/Documentation/faq.md#what-does-the-etcd-warning-apply-entries-took-too-long-mean" target="_blank" rel="noopener">磁盘IO瓶颈</a></li>
</ul>
<blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/etcd-io/etcd/issues/5154" target="_blank" rel="noopener">负载过高</a></li>
</ul>
</blockquote>
<p>环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># etcd 二进制启动</span></span><br><span class="line">etcd --name vm1 --initial-advertise-peer-urls http://192.168.2.3:12380 \</span><br><span class="line">  --listen-peer-urls http://192.168.2.3:12380 \</span><br><span class="line">  --listen-client-urls http://192.168.2.3:12379,http://127.0.0.1:12379 \</span><br><span class="line">  --advertise-client-urls http://192.168.2.3:12379 \</span><br><span class="line">  --initial-cluster-token etcd-cluster-bin \</span><br><span class="line">  --initial-cluster vm1=http://192.168.2.3:12380,vm2=http://192.168.2.4:12380 \</span><br><span class="line">  --initial-cluster-state new</span><br></pre></td></tr></table></figure>

<p>日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-08-20 16:58:45.366953 W | etcdserver: failed to send out heartbeat on time (exceeded the 100ms timeout for 154.491083ms, to 7ceb206ff2a779a3)</span><br><span class="line">2019-08-20 16:58:45.366979 W | etcdserver: server is likely overloaded</span><br><span class="line">2019-08-20 16:59:14.442020 W | etcdserver: failed to send out heartbeat on time (exceeded the 100ms timeout for 44.374276ms, to 7ceb206ff2a779a3)</span><br><span class="line">2019-08-20 16:59:14.442049 W | etcdserver: server is likely overloaded</span><br><span class="line">2019-08-20 16:59:38.078540 W | etcdserver: failed to send out heartbeat on time (exceeded the 100ms timeout for 380.617868ms, to 7ceb206ff2a779a3)</span><br></pre></td></tr></table></figure>

<p>解决: 添加<code>--heartbeat-interval 250 --election-timeout 1250</code>启动参数</p>
<h2 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h2><blockquote>
<ul>
<li><input disabled type="checkbox"> <a href="https://github.com/kubernetes/kubernetes/issues/76956" target="_blank" rel="noopener">unknow</a></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E0722 03:32:55.266253       1 prometheus.go:55] failed to register depth metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266276       1 prometheus.go:68] failed to register adds metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266294       1 prometheus.go:82] failed to register latency metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266308       1 prometheus.go:96] failed to register workDuration metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266330       1 prometheus.go:112] failed to register unfinished metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266346       1 prometheus.go:126] failed to register unfinished metric admission_quota_controller: duplicate metrics collector registration attempted</span><br></pre></td></tr></table></figure>

<h2 id="metrics-server"><a href="#metrics-server" class="headerlink" title="metrics-server"></a>metrics-server</h2><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/kubernetes-incubator/metrics-server/issues/247" target="_blank" rel="noopener">metrics 不可用</a></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E0821 01:20:44.192985       1 reststorage.go:128] unable to fetch node metrics for node &quot;vm1&quot;: no metrics known for node</span><br><span class="line">E0821 01:20:44.193003       1 reststorage.go:128] unable to fetch node metrics for node &quot;vm2&quot;: no metrics known for node</span><br><span class="line">E0821 01:25:06.254119       1 reststorage.go:147] unable to fetch pod metrics for pod default&#x2F;bbox: no metrics known for pod</span><br><span class="line">E0821 01:25:06.254143       1 reststorage.go:147] unable to fetch pod metrics for pod default&#x2F;nginx: no metrics known for pod</span><br><span class="line">E0821 01:25:43.654288       1 manager.go:111] unable to fully collect metrics: [unable to fully scrape metrics from source kubelet_summary:vm2: unable to fetch metrics from Kubelet vm2 (vm2): Get https:&#x2F;&#x2F;vm2:10250&#x2F;stats&#x2F;summary&#x2F;: x509: certificate signed by unknown authority, unable to fully scrape metrics from source kubelet_summary:vm1: unable to fetch metrics from Kubelet vm1 (vm1): Get https:&#x2F;&#x2F;vm1:10250&#x2F;stats&#x2F;summary&#x2F;: x509: certificate signed by unknown authority]</span><br></pre></td></tr></table></figure>

<p>解决: 在<code>metrics-server-deployment.yaml</code>文件中的容器参数中添加<code>args: [ &quot;--kubelet-insecure-tls&quot; ]</code></p>
<blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://www.cnblogs.com/vincenshen/p/9638162.html" target="_blank" rel="noopener">权限问题</a></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E1218 10:26:36.104471       1 manager.go:111] unable to fully collect metrics: [unable to fully scrape metrics from source kubelet_summary:master: unable to fetch metrics from Kubelet master (10.168.67.6): request failed - &quot;403 Forbidden&quot;, response: &quot;Forbidden (user&#x3D;system:serviceaccount:kube-system:metrics-server, verb&#x3D;get, resource&#x3D;nodes, subresource&#x3D;stats)&quot;]</span><br></pre></td></tr></table></figure>

<p>原因</p>
<ul>
<li>clusterrole<code>system:metrics-server</code>对<code>nodes/stats</code>资源没有相关权限</li>
</ul>
<p>解决: 在资源中添加对<code>nodes/stats</code>资源的 get 权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get clusterrole system:metrics-server -o yaml &gt; metrics-server-clusterrole.yaml</span><br><span class="line">kubectl apply -f metrics-server-clusterrole.yaml</span><br></pre></td></tr></table></figure>

<h2 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h2><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/kubernetes/kubernetes/issues/60987#issuecomment-529107444" target="_blank" rel="noopener">已被删除的容器还在磁盘上</a></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;var&#x2F;log&#x2F;kubernetes&#x2F;kubelet.log</span><br><span class="line">E0214 17:00:33.187665    1547 kubelet_volumes.go:154] Orphaned pod &quot;8d73e524-fb7c-4b25-a907-3c18b78f587d&quot; found, but volume paths are still present on disk : There were a total of 1 errors similar to this. Turn up verbosity to see them.</span><br><span class="line">E0214 17:00:35.188258    1547 kubelet_volumes.go:154] Orphaned pod &quot;8d73e524-fb7c-4b25-a907-3c18b78f587d&quot; found, but volume paths are still present on disk : There were a total of 1 errors similar to this. Turn up verbosity to see them.</span><br></pre></td></tr></table></figure>

<p>解决: 找到出现问题的Pod的id后,删除该目录即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -fu kubelet | awk -F<span class="string">'"'</span> <span class="string">'&#123; print $2&#125;'</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/kubelet/pods</span><br><span class="line">rm -rf &lt;pod id<span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h2><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://www.orchome.com/1977" target="_blank" rel="noopener">helm 连接 tiller 报错</a></li>
</ul>
</blockquote>
<p>环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f - &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">EOF</span><br><span class="line">helm init --service-account tiller</span><br><span class="line">helm version</span><br></pre></td></tr></table></figure>

<p>报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client: &amp;version.Version&#123;SemVer:&quot;v2.12.0&quot;, GitCommit:&quot;d325d2a9c179b33af1a024cdb5a4472b6288016a&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br><span class="line">E0311 14:30:57.739137    2268 portforward.go:331] an error occurred forwarding 37108 -&gt; 44134: error forwarding port 44134 to pod 656c9a0a94968a3ef99a17bba846c4617d8afd1b6f9a375890a86b965cd9fa5f, uid : unable to do port forwarding: socat not found</span><br><span class="line">Error: cannot connect to Tiller</span><br></pre></td></tr></table></figure>

<p>解决: 所有设备上安装<code>socat</code>包</p>
<h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><blockquote>
<ul>
<li><input checked disabled type="checkbox"> 虚拟机关机重启后,不同节点间的 Pod 不能互 ping</li>
</ul>
</blockquote>
<p>环境: 检查发现 node 节点的 flannel.1 网卡 down,与该<a href="https://www.oschina.net/question/2344660_2286913" target="_blank" rel="noopener">博客</a>描述基本相符</p>
<p>解决: 删除 cni0,flannel.1 网桥后重新启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><input checked disabled type="checkbox"> kubernetes无法删除Terminating状态的namespace</li>
</ul>
</blockquote>
<p>解决: 删除对应namespace json文件的<code>spec</code>字段后,重新发起请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get namespace &lt;namespace-name&gt; -o json &gt; tmp.json</span><br><span class="line"><span class="comment"># 编辑 tmp.json,删除 "spec" 字段部分</span></span><br><span class="line">curl -k -XPUT -H <span class="string">"Content-Type: application/json"</span> --data-binary @tmp.json http://127.0.0.1:8001/api/v1/namespaces/istio-system/finalize</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义kube-prometheus添加etcd监控</title>
    <url>/2020/04/03/monitor-etcd-with-kube-prometheus/</url>
    <content><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y go</span><br><span class="line">go get github.com/jsonnet-bundler/jsonnet-bundler/cmd/jb <span class="comment"># jsonnet 的包管理器</span></span><br><span class="line">go get github.com/brancz/gojsontoyaml <span class="comment"># go 语言编写的 json 转化为 yaml 工具</span></span><br><span class="line"><span class="comment"># 安装好的二进制包在 ~/go/bin/ 目录下</span></span><br><span class="line"><span class="built_in">cd</span> ~/go/bin/</span><br><span class="line">cp jb gojsontoyaml /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure>

<h2 id="自定义-jsonnet"><a href="#自定义-jsonnet" class="headerlink" title="自定义 jsonnet"></a>自定义 jsonnet</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-kube-prometheus <span class="comment"># 在 自定义 kube-prometheus</span></span><br><span class="line">jb init  <span class="comment"># 创建初始化空文件 jsonnetfile.json</span></span><br><span class="line"><span class="comment"># 安装 kube-prometheus 依赖.花费时间较长</span></span><br><span class="line"><span class="comment"># 该版本较老,推荐使用 github.com/coreos/kube-prometheus/jsonnet/kube-prometheus@master</span></span><br><span class="line">jb install github.com/coreos/kube-prometheus/jsonnet/kube-prometheus@release-0.1</span><br><span class="line">jb update</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>使用 <code>build.sh</code> 进行编译,以 <code>etcd.jsonnet</code> 为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line">rm -rf manifests</span><br><span class="line">mkdir -p manifests/setup</span><br><span class="line"></span><br><span class="line">jsonnet -J vendor -m manifests <span class="string">"<span class="variable">$&#123;1-etcd.jsonnet&#125;</span>"</span> | xargs -I&#123;&#125; sh -c <span class="string">'cat &#123;&#125; | gojsontoyaml &gt; &#123;&#125;.yaml; rm -f &#123;&#125;'</span> -- &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;coreos&#x2F;kube-prometheus&#x2F;blob&#x2F;master&#x2F;examples&#x2F;etcd.jsonnet</span><br><span class="line">local kp &#x3D; (import &#39;kube-prometheus&#x2F;kube-prometheus.libsonnet&#39;) +</span><br><span class="line">           (import &#39;kube-prometheus&#x2F;kube-prometheus-static-etcd.libsonnet&#39;) + &#123;</span><br><span class="line">  _config+:: &#123;</span><br><span class="line">    namespace: &#39;monitoring&#39;,</span><br><span class="line">    etcd+:: &#123;</span><br><span class="line">      &#x2F;&#x2F; 配置 etcd 集群的 IP 地址,使用 逗号 隔开</span><br><span class="line">      ips: [&#39;10.168.67.6&#39;, &#39;10.168.67.7&#39;, &#39;10.168.67.8&#39;],</span><br><span class="line">      clientCA: importstr &#39;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt&#39;,</span><br><span class="line">      clientCert: importstr &#39;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt&#39;,</span><br><span class="line">      clientKey: importstr &#39;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key&#39;,</span><br><span class="line">      &#x2F;&#x2F; 指定 serverName 或 insecureSkipVerify 其中一个.</span><br><span class="line">      &#x2F;&#x2F; 若指定 serverName,你应该指定 openssl.cnf 中填写的 etcd 的包含证书的 DNS名称,否则会报 x509 错误.且 serverName 可以被 nslookup 解析</span><br><span class="line">      &#x2F;&#x2F; 若指定 insecureSkipVerify,会跳过认证</span><br><span class="line">      serverName: &#39;etcd.kube-system.svc.cluster.local&#39;,</span><br><span class="line">      &#x2F;&#x2F;insecureSkipVerify: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123; [&#39;00namespace-&#39; + name]: kp.kubePrometheus[name] for name in std.objectFields(kp.kubePrometheus) &#125; +</span><br><span class="line">&#123; [&#39;0prometheus-operator-&#39; + name]: kp.prometheusOperator[name] for name in std.objectFields(kp.prometheusOperator) &#125; +</span><br><span class="line">&#123; [&#39;node-exporter-&#39; + name]: kp.nodeExporter[name] for name in std.objectFields(kp.nodeExporter) &#125; +</span><br><span class="line">&#123; [&#39;kube-state-metrics-&#39; + name]: kp.kubeStateMetrics[name] for name in std.objectFields(kp.kubeStateMetrics) &#125; +</span><br><span class="line">&#123; [&#39;alertmanager-&#39; + name]: kp.alertmanager[name] for name in std.objectFields(kp.alertmanager) &#125; +</span><br><span class="line">&#123; [&#39;prometheus-&#39; + name]: kp.prometheus[name] for name in std.objectFields(kp.prometheus) &#125; +</span><br><span class="line">&#123; [&#39;grafana-&#39; + name]: kp.grafana[name] for name in std.objectFields(kp.grafana) &#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>重新应用编译后产生的 <code>manifests</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f manifests/setup</span><br><span class="line">kubectl apply -f manifests/</span><br></pre></td></tr></table></figure>

<p>如果想要在已有 <code>kube-prometheus</code> 的基础上作出修改,只需要执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jb init</span><br><span class="line">jb update</span><br><span class="line">build.sh</span><br><span class="line">kubectl apply -f manifests/setup</span><br><span class="line">kubectl apply -f manifests/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>Kubernetes</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构</title>
    <url>/2020/05/17/data-structure/</url>
    <content><![CDATA[<blockquote>
<p>数据结构</p>
</blockquote>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合.我们可以将数据结构分为逻辑结构和物理结构.</p>
<ul>
<li>逻辑结构是指数据对象中数据元素之间存在逻辑上的相互关系.如集合,线性结构,树形结构,图形结构等</li>
<li>物理结构是指数据的在计算机中的存储形式.如顺序存储,链式存储.其中,顺序存储时把数据元素存放在地址连续的存储单元中,链式存储是把数据元素存放在任意存储单元中,再通过逻辑上的指针将各个元素串联起来</li>
</ul>
<blockquote>
<p>算法</p>
</blockquote>
<p>算法是解决特定问题求解步骤的描述,具有如下 5 个特性:</p>
<ul>
<li>输入输出: 算法具有零个或多个输入,至少有一个或多个输出</li>
<li>有穷性: 算法在执行有限步骤后,自动结束而不会出现无线循环,且每个步骤在可接收的时间内完成</li>
<li>确定性: 算法的每个步骤都有确定的含义,不会出现分歧</li>
<li>可行性: 算法的每一步都是可行的</li>
</ul>
<blockquote>
<p>算法的时间复杂度</p>
</blockquote>
<p>算法的时间复杂度可使用大 O 阶进行表示,我们按照如下方式推导大 O 阶:</p>
<ol>
<li>用常数 1 表示运行时间中所有加法常数</li>
<li>在修改后的运行次数函数中,只保留最高阶项</li>
<li>如果最高阶项存在且不是 1,则去除与这个项相乘的常数,得到的结果就是大 O 阶</li>
</ol>
<p>常用时间复杂度所耗费的时间从小到大是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n^2) &lt; O(2^n)  &lt; O(n!) &lt; O(n^n)</span><br></pre></td></tr></table></figure>

<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是一个序列,元素之间是有顺序的.若元素存在多个,则第一个元素无前驱,最后一个元素无后继,其它每个元素有且仅有一个前驱和后继.常见的表示形式是数组和链表</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组具有如下性质</p>
<ul>
<li>具有连续的内存,有上界和下界</li>
<li>数据是连续的,随机访问速度快(查找较快),时间复杂度为 O(1)</li>
<li>增删元素较慢,需要重新分配内存空间并将元素进行平移,时间复杂度为 O(n)</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表具有有如下性质:</p>
<ul>
<li>节点的链接方向是单向的</li>
<li>相对于数组来说,单链表的的随机访问速度较慢,只能从链表开头进行依次查找)</li>
<li>删除/添加数据的效率很高,只需要修改插入/删除位置的 next 指针即可</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈具有有如下性质:</p>
<ul>
<li>栈中数据是按照”后进先出(LIFO, Last In First Out)”方式进出栈的</li>
<li>向栈中添加/删除数据时,只能从栈顶进行操作</li>
</ul>
<p>栈通常包括的三种操作: push(向栈中添加元素), peek(返回栈顶元素), pop(返回并弹出栈顶元素)</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列具有有如下性质:</p>
<ul>
<li>队列中数据是按照”先进先出(FIFO, First-In-First-Out)”方式进出队列的</li>
<li>队列只允许在”队首”进行删除操作,而在”队尾”进行插入操作</li>
</ul>
<p>队列通常包括的两种操作: 入队列和出队列</p>
<h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是每个结点最多有两个子树的树形结构,通常子树被称作”左子树(left subtree)”和”右子树(right subtree)”.二叉树常被用于实现二叉查找树和二叉堆</p>
<blockquote>
<p>满二叉树: 所有层都是满的.即深度为 k,且有 2^k - 1 个节点的二叉树<br>完全二叉树: 除最后一层外,若其余层都是满的,并且最后一层或者是满的,或者是在右边缺少连续若干节点</p>
</blockquote>
<p>先序遍历 = 根-&gt;左子树-&gt;右子树</p>
<p>中序遍历 = 左子树-&gt;根-&gt;右子树</p>
<p>后序遍历 = 左子树-&gt;右子树-&gt;根</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树具有有如下性质:</p>
<ul>
<li>左子树上所有结点的值均小于它的根结点的值,右子树上所有结点的值均大于它的根结点的值</li>
<li>任意节点的左,右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<blockquote>
<p>局限: 如果我们的根节点选择是最小或者最大的数,那么二叉查找树就完全退化成了线性结构(链表)</p>
</blockquote>
<h3 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h3><p>带有平衡条件的二叉查找树,所有节点的左右子树高度差不超过 1.只要不满足这个条件,就要通过旋转来保持平衡,而旋转是非常耗时的.因此 AVL 树适合用于插入删除次数比较少,但查找多的情况.</p>
<blockquote>
<p>维护这种高度平衡所付出的代价比从中获得的效率收益还大,实际的应用不多</p>
</blockquote>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色,非黑即红</p>
<ul>
<li>每个节点非红即黑</li>
<li>根节点是黑的</li>
<li>每个叶子节点(叶子节点即树尾端 NULL 指针或 NULL 节点)都是黑的</li>
<li>如果一个节点是红的,那么它的两儿子都是黑的</li>
<li>对于任意节点而言,其到叶子节点的 NULL 指针的每条路径都包含相同数目的黑节点</li>
<li>每条路径都包含相同的黑节点</li>
</ul>
<h4 id="红黑树应用"><a href="#红黑树应用" class="headerlink" title="红黑树应用"></a>红黑树应用</h4><ul>
<li>广泛用于 C++ 的 STL 中,Map 和 Set 都是用红黑树实现的</li>
<li>著名的 Linux 进程调度 Completely Fair Scheduler,用红黑树管理进程控制块,进程的虚拟内存区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址虚拟存储区域,右指针指向相邻的高地址虚拟地址空间</li>
<li>IO 多路复用 epoll 的实现采用红黑树组织管理 sockfd,以支持快速的增删改查</li>
<li>Nginx 中用红黑树管理 timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器</li>
<li>Java 中 TreeMap 的实现</li>
</ul>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆是完全二元树或者是近似完全二元树,按照数据的排列方式可以分为两种: 最大堆和最小堆</p>
<ul>
<li>最大堆: 父结点的键值总是大于或等于任何一个子节点的键值</li>
<li>最小堆: 父结点的键值总是小于或等于任何一个子节点的键值</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>B 树是一种多路搜索树,它的每个节点可以拥有多于两个孩子节点,M 路的 B 树最多能拥有 M 个孩子节点.</p>
<p>一个 m 阶的 B 树具有如下几个特征:</p>
<ul>
<li>根结点的孩子节点数为 [2, m]</li>
<li>每个中间节点包含 k-1 个元素和 k 孩子.其中 m/2 &lt;= k &lt;= m</li>
<li>每一个叶子节点都包含k - 1个元素，其中 m/2 &lt;= k &lt;= m</li>
<li>所有的叶子节点都位于同一层</li>
<li>每个节点中的元素从小到大排列,节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划</li>
</ul>
<blockquote>
<p>多路是为了降低树的高度,但是无线多路会退化成有序数组</p>
</blockquote>
<h4 id="B-树应用"><a href="#B-树应用" class="headerlink" title="B 树应用"></a>B 树应用</h4><p>B 树多用于文件系统索引.</p>
<p>文件系统和数据库的索引都是存在硬盘上的,并且如果数据量大的话,不一定能一次性加载到内存中.这时候,B 树的多路存储威力就出来了,可以每次加载 B 数的一个节点,然后一步一步往下找</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p><a href="https://blog.csdn.net/jiang_wang01/article/details/113739230" target="_blank" rel="noopener">什么是B+树</a></p>
<ul>
<li>有 k 个子树的中间节点包含有 k 个元素(B 树中是 k-1 个元素),每个元素不保存数据,只用来索引,所有数据都保存在叶子节点</li>
<li>所有的叶子结点中包含了全部元素的信息,及指向含这些元素记录的指针,且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>B+ 树中带有重复元素,每一个父节点的元素都同时存在于叶子节点,在叶子节点元素中是最大(或最小)元素</li>
</ul>
<h4 id="B-树应用-1"><a href="#B-树应用-1" class="headerlink" title="B+ 树应用"></a>B+ 树应用</h4><ul>
<li>MySQL 数据库索引</li>
</ul>
<h4 id="MySQL-索引为什么使用-B-树"><a href="#MySQL-索引为什么使用-B-树" class="headerlink" title="MySQL 索引为什么使用 B+ 树"></a>MySQL 索引为什么使用 B+ 树</h4><ul>
<li>B+ 树中父节点元素都出现在子节点,所有叶子节点包含了全量元素信息,每个叶子节点都带有指向下一个节点的指针,形成了一个有序链表.相比于 B 树,更易于范围查找</li>
<li>B 树中的每个节点带有卫星数据(所谓卫星数据,指的是索引元素指向的数据记录,比如数据库中的一行).而 B+ 树中只有叶子节点带有卫星数据(中间节点仅仅是索引),因此相同的磁盘页可以容纳更多的节点元素.这就意味着,相同数据量的情况下,B+ 树比 B 树更加”矮胖”,查询 IO 次数更少.</li>
</ul>
<blockquote>
<p>需要补充的是,数据库的聚簇索引中,叶子节点直接包含卫星数据,非聚簇索引中,叶子节点带有指向卫星数据的指针.</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参见 <a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener">Github</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 之技术总览</title>
    <url>/2020/05/22/ELK-Stack/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">ELK Stack</a> 是以 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch</a>, <a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">Logstash</a>, <a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">Kibana</a> 三个开源软件为主的数据处理工具链,是目前比较流行的开源实时日志数据分析解决方案.随着技术的演进,Logstash 由于其量级过重而被逐渐被人们替换为更轻量的 <a href="https://www.elastic.co/guide/en/beats/libbeat/current/beats-reference.html" target="_blank" rel="noopener">Beats</a> 或 <a href="https://www.fluentd.org/" target="_blank" rel="noopener">Fluentd</a>. ELK Stack 也逐渐演变为 EFK Stack.</p>
<p>在 ELK/EFK 栈中,</p>
<ul>
<li>Elasticsearch 是整个技术栈的核心,主要负责将数据转化为内部的数据以指定的方式保存起来,它提供了对其中数据增删查改的 API 使用户可以对数据进行操作</li>
<li>Logstash 负责数据的收集,过滤处理和格式化.它提供了多种 <code>input</code>, <code>filter</code> 和 <code>output</code> 插件分别对数据进行输入,分析过滤及输出.它多用于对数据进行过滤或格式化处理.</li>
<li>Beats 主要负责数据的收集,它提供了多种数据的输入类型,包括日志数据,指标数据,网络数据,审计数据,心跳数据等.它多用于将数据收集汇总后,输出到消息队列或 Logstash 中.</li>
<li>Fluentd 与 Logstash 类似,负责数据的收集,处理和过滤.它提供了多种插件对数据进行输入,过滤,路由或输出.它多用于对数据进行过滤或格式化处理.</li>
<li>Kibana 主要对 Elasticsearch 中数据的统计展示和可视化,它提供了 UI 界面,并将用户在界面上的操作转化为 Elasticsearch API 的请求,查询后再显示在 UI 界面中.</li>
</ul>
<h2 id="常见架构"><a href="#常见架构" class="headerlink" title="常见架构"></a>常见架构</h2><h3 id="最简单架构"><a href="#最简单架构" class="headerlink" title="最简单架构"></a>最简单架构</h3><p>Logstash 通过输入插件从多种数据源获取数据,经过过滤插件对数据进行筛选,格式化,然后通过输出插件输出到 Elasticsearch 中,通过 Kibana 展示.</p>
<p><img src="/images/the-simplest-architecture.png" alt="最简单架构"></p>
<p>这种架构十分简单,使用场景也有限.初学者可以通过此架构了解 ELK 如何工作</p>
<h3 id="多个-LogStash-用于数据收集"><a href="#多个-LogStash-用于数据收集" class="headerlink" title="多个 LogStash 用于数据收集"></a>多个 LogStash 用于数据收集</h3><p><img src="/images/multi-logstash.png" alt="多个 LogStash 用于数据收集"></p>
<p>这种架构需要在各个服务器上部署 Logstash,而 Logstash 比较重量级,服务器性能会有所下降,甚至可能导致应用无法正常工作</p>
<h3 id="Beats-作为日志收集器"><a href="#Beats-作为日志收集器" class="headerlink" title="Beats 作为日志收集器"></a>Beats 作为日志收集器</h3><p>Beats 将搜集到的数据发送到 Logstash,经 Logstash 解析,过滤后，将其发送到 Elasticsearch 存储,并由 Kibana 呈现给用户.</p>
<p><img src="/images/beat-for-data-collection.png" alt="Beats 作为日志收集器"></p>
<p>这种方式解决了 Logstash 在各个服务器上占用系统资源过高的情况,相比于 Logstash,Beats 更加轻量,系统资源占用也比较低.且支持 SSL 加密传输,保证通信安全</p>
<h3 id="引入消息队列机制"><a href="#引入消息队列机制" class="headerlink" title="引入消息队列机制"></a>引入消息队列机制</h3><p>无论是 Beat 还是 Logstash 均支持消息队列的输入输出,目前支持 Kafka,Redis,RabbitMQ 等常见消息队列.可以由 Beats 收集数据后,通过消息队列输出插件将数据写入到消息队列中,然后 Logstash 通过消息队列输入插件从消息队列中读取数据进行处理后传入到 Elasticsearch 存储,并由 Kibana 呈现给用户.</p>
<p><img src="/images/introduce-message-queue.png" alt="引入消息队列机制"></p>
<p>当数据量较大时,可在合适的位置添加消息队列,减少 Logstash 的负荷.引入消息队列,可以降低由于数据量过大而导致某些组件的性能瓶颈,降低了数据丢失的可能性.同时,Elasticsearch 可以做成集群模式或增加节点数量,以便增加其性能.</p>
<h2 id="部署-Elasticsearch"><a href="#部署-Elasticsearch" class="headerlink" title="部署 Elasticsearch"></a>部署 Elasticsearch</h2><h3 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.7.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xzf elasticsearch-7.7.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> elasticsearch-7.7.0/</span><br></pre></td></tr></table></figure>

<h3 id="必须的系统配置"><a href="#必须的系统配置" class="headerlink" title="必须的系统配置"></a>必须的系统配置</h3><ul>
<li>禁用 <code>swap</code>.可在 <code>/etc/fstab</code> 种永久关闭</li>
<li>设置文件描述符至少为 65535.可在 <code>/etc/security/limits.conf</code> 设置<code>nofile</code> 的值</li>
<li>设置线程数量至少为 4096.可在 <code>/etc/security/limits.conf</code> 设置 <code>nproc</code> 的值</li>
<li>设置虚拟内存至少为 262144.可在 <code>/etc/sysctl.conf</code> 中永久设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line"><span class="built_in">ulimit</span> -n 65535</span><br><span class="line"><span class="built_in">ulimit</span> -u 4096</span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>

<h3 id="重要的-Elasticsearch-配置"><a href="#重要的-Elasticsearch-配置" class="headerlink" title="重要的 Elasticsearch 配置"></a>重要的 Elasticsearch 配置</h3><p>Elasticsearch 的配置文件在 <code>config</code> 目录下,其中</p>
<ul>
<li><code>elasticsearch.yml</code> 包含 Elasticsearch 配置信息</li>
<li><code>jvm.options</code> 包含 Elasticsearch JVM 配置信息</li>
<li><code>log4j2.properties</code> 包含 Elasticsearch 日志信息</li>
</ul>
<p>下面列出了 <code>elasticsearch.yml</code> 中一些重要的 Elasticsearch 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">elasticsearch</span> <span class="comment"># 集群名称,默认为 elasticsearch</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">$&#123;HOSTNAME&#125;</span> <span class="comment"># elasticsearch 节点名称,默认为节点主机名</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">["/es-data1",</span> <span class="string">"es-data2"</span><span class="string">]</span> <span class="comment"># 数据目录,默认为解压目录中的 data 目录,可以指定多个,相同分片会保存到统一目录下</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/log/elasticsearch</span> <span class="comment"># 日志目录,,默认为解压目录中的 logs 目录</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">"0.0.0.0"</span>  <span class="comment"># elasticsearch 监听地址,默认为 127.0.0.1</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span> <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">discovery.send_hosts:</span> <span class="string">["vm1:9300",</span> <span class="string">"vm2:9300"</span><span class="string">,</span> <span class="string">"vm3:9300"</span><span class="string">]</span> <span class="comment"># 广播发现集群的地址列表,默认在 9300 端口进行广播通信</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["vm1:9200",</span> <span class="string">"vm2:9200"</span><span class="string">,</span> <span class="string">"vm3:9200"</span><span class="string">]</span> <span class="comment"># 集群主节点列表,首次启动时生效</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span> <span class="comment"># 是否启用 xpack-security 安全认证插件</span></span><br></pre></td></tr></table></figure>

<p>下面列出了 <code>jvm.options</code> 中一些重要的 Elasticsearch JVM 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure>

<p>默认情况下,Elasticsearch JVM 设置为使用 1G 的堆内存.但是在生产环境中,需要遵循如下配置:</p>
<ul>
<li>设置两个配置参数相等</li>
<li>将 <code>Xmx</code> 和 <code>Xms</code> 设置为不超过物理内存的 <code>50%</code></li>
<li>一般来说,配置参数越大,性能越好,但不超过 32G</li>
</ul>
<h3 id="启动-Elasticsearch"><a href="#启动-Elasticsearch" class="headerlink" title="启动 Elasticsearch"></a>启动 Elasticsearch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">bin/elasticsearch -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定启动过程中的参数</span></span><br><span class="line">-E &lt;KeyValuePair&gt;</span><br><span class="line"><span class="comment"># -Epath.data=data -Epath.logs=log</span></span><br></pre></td></tr></table></figure>

<p>可通过 <code>curl http://localhost:9200</code> 查看 Elasticsearch 的启动信息</p>
<h2 id="部署-Kibana"><a href="#部署-Kibana" class="headerlink" title="部署 Kibana"></a>部署 Kibana</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://artifacts.elastic.co/downloads/kibana/kibana-7.7.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xzf kibana-7.7.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kibana-7.7.0-linux-x86_64/</span><br><span class="line">bin/kibana</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"192.168.2.3"</span></span><br><span class="line"><span class="comment"># server.name: "your-hostname"</span></span><br><span class="line"><span class="attr">elasticsearch.url:</span> <span class="string">"http://localhost:9200"</span></span><br><span class="line"><span class="attr">kibana.index:</span> <span class="string">".kibana"</span></span><br><span class="line"><span class="comment"># xpack.security.enabled: false</span></span><br><span class="line"><span class="comment"># elasticsearch.username: "user"</span></span><br><span class="line"><span class="comment"># elasticsearch.password: "pass"</span></span><br><span class="line"><span class="comment"># server.ssl.enabled: false</span></span><br><span class="line"><span class="comment"># server.ssl.certificate: /path/to/your/server.crt</span></span><br><span class="line"><span class="comment"># server.ssl.key: /path/to/your/server.key</span></span><br><span class="line"><span class="comment"># elasticsearch.ssl.certificate: /path/to/your/client.crt</span></span><br><span class="line"><span class="comment"># elasticsearch.ssl.key: /path/to/your/client.key</span></span><br><span class="line"><span class="comment"># elasticsearch.ssl.certificateAuthorities: [ "/path/to/your/CA.pem" ]</span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html" target="_blank" rel="noopener">ELK 架构和 Filebeat 工作原理详解</a></li>
</ul>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 之 Logstash 插件介绍</title>
    <url>/2020/05/22/ELK-Stack-Logstash-plugins/</url>
    <content><![CDATA[<p>Logstash 是高度插件化的日志数据收集工具,常用插件包括 <code>input</code>, <code>filter</code>, <code>output</code></p>
<p>Logstash 的工作流程 <code>input &gt; filter &gt; output</code>.如无需要对数据进行额外处理,则 <code>filter</code> 可省略</p>
<h2 id="input-插件"><a href="#input-插件" class="headerlink" title="input 插件"></a><code>input</code> 插件</h2><p><a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="noopener"><code>input</code></a> 插件用于设置 Logstash 获取数据的数据源.</p>
<p>它包含一些通用的字段,用于配置进入 Logstash 数据的属性,用于后续的处理过程.常用字段如下:</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add_field</td>
<td align="center">为数据内容添加字段键值对映射</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">设置 input 插件的唯一标识</td>
</tr>
<tr>
<td align="center">tags</td>
<td align="center">设置数据属性标签数组</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">设置数据类型</td>
</tr>
</tbody></table>
<h3 id="beats"><a href="#beats" class="headerlink" title="beats"></a><code>beats</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-beats.html" target="_blank" rel="noopener"><code>beats</code></a> 输入插件用于从 Beats 中接收数据</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">port</td>
<td align="center">Logstash 监听的端口</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">host</td>
<td align="center">Logstash 监听的地址</td>
<td align="center">否</td>
<td align="center">“0.0.0.0”</td>
</tr>
<tr>
<td align="center">ssl</td>
<td align="center">是否启用 ssl 加密相关</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">ssl_certificate</td>
<td align="center">ssl 证书</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">ssl_key</td>
<td align="center">ssl 密钥文件</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    host =&gt; <span class="string">"0.0.0.0"</span></span><br><span class="line">    port =&gt; <span class="number">5044</span></span><br><span class="line">    ssl =&gt; <span class="literal">true</span></span><br><span class="line">    ssl_certificate =&gt; <span class="string">"/path/to/ssl/cert"</span></span><br><span class="line">    ssl_key =&gt; <span class="string">"/path/to/ssl/key"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="file"><a href="#file" class="headerlink" title="file"></a><code>file</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html" target="_blank" rel="noopener"><code>file</code></a> 输入插件用于读取文件数据.它使用一个名为 sincedb 的单独文件中来跟踪每个文件中的当前位置,这样就可以停止或重新启动 Logstash,并使它从中断处开始读取,而不会丢失 Logstash 停止时读取数据的位置.</p>
<ul>
<li>支持多文件读取</li>
<li>支持 <code>tail</code> 模式(没有 EOF)或直接读取 <code>read</code> 模式(有EOF)</li>
</ul>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">path</td>
<td align="center">指定要读取的文件列表或模式匹配</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">close_older</td>
<td align="center">指定多少秒无新数据则关闭文件,检测到新数后重新打开</td>
<td align="center">否</td>
<td align="center">“1 hour”</td>
</tr>
<tr>
<td align="center">delimiter</td>
<td align="center">换行符</td>
<td align="center">否</td>
<td align="center">“\n”</td>
</tr>
<tr>
<td align="center">exclude</td>
<td align="center">当 path 为模式匹配时,排除读取指定文件</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">file_chunk_count</td>
<td align="center">读取文件块数量</td>
<td align="center">否</td>
<td align="center">4611686018427387903</td>
</tr>
<tr>
<td align="center">file_chunk_size</td>
<td align="center">读取文件块大小</td>
<td align="center">否</td>
<td align="center">32KB</td>
</tr>
<tr>
<td align="center">file_completed_action</td>
<td align="center">读取文件 EOF 后的操作,delete, log, log_and_delete</td>
<td align="center">否</td>
<td align="center">“delete”</td>
</tr>
<tr>
<td align="center">file_completed_log_path</td>
<td align="center">读取文件 EOF 后记录的文件位置</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">file_sort_direction</td>
<td align="center">排序方式,asc,desc</td>
<td align="center">否</td>
<td align="center">“asc”</td>
</tr>
<tr>
<td align="center">ignore_older</td>
<td align="center">忽略指定修改时间前的文件</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">mode</td>
<td align="center">指定文件的读取模式, tail, read</td>
<td align="center">否</td>
<td align="center">“tail”</td>
</tr>
<tr>
<td align="center">sincedb_path</td>
<td align="center">指定保存 sincedb 文件的目录,默认会在 <code>&lt;path.data&gt;/plugins/inputs/file/</code></td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">start_position</td>
<td align="center">指定从何处开始读取,start, end</td>
<td align="center">否</td>
<td align="center">“end”</td>
</tr>
<tr>
<td align="center">stat_interval</td>
<td align="center">指定读取时间间隔</td>
<td align="center">否</td>
<td align="center">“1 second”</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<ul>
<li>以 <code>read</code> 模式读取昨天新产生的文件,而不读取 “*.gz” 文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [<span class="string">"/path/to/nginx-80-*.log"</span>,<span class="string">"/path/to/nginx-443-*.log"</span>]</span><br><span class="line">    exclude =&gt; <span class="string">"*.gz"</span></span><br><span class="line">    mode =&gt; <span class="string">"read"</span></span><br><span class="line">    file_sort_direction =&gt; <span class="string">"desc"</span></span><br><span class="line">    ignore_older =&gt; <span class="string">"1d"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以 <code>tail</code> 模式实时读取文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [<span class="string">"/path/to/nginx-80.log"</span>,<span class="string">"/path/to/nginx-443.log"</span>]</span><br><span class="line">    mode =&gt; <span class="string">"tail"</span></span><br><span class="line">    stat_interval =&gt; <span class="string">"5 second"</span></span><br><span class="line">    close_older =&gt; <span class="string">"5"</span></span><br><span class="line">    start_position =&gt; <span class="string">"end"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a><code>kafka</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html" target="_blank" rel="noopener">kafka</a> 输入插件用于从 Kafka 集群中读取事件数据.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bootstrap_servers</td>
<td align="center">kafka 实例的列表</td>
<td align="center">否</td>
<td align="center">“localhost:9092”</td>
</tr>
<tr>
<td align="center">client_id</td>
<td align="center">客户端标识</td>
<td align="center">否</td>
<td align="center">“logstash”</td>
</tr>
<tr>
<td align="center">connections_max_idle_ms</td>
<td align="center">空闲连接释放的超时时间</td>
<td align="center">否</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">consumer_threads</td>
<td align="center">消费者线程数,一般配置为 kafka 的分区数</td>
<td align="center">否</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">decorate_events</td>
<td align="center">是否在事件中添加 kafka 元数据,如 topic,消息大小</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">group_id</td>
<td align="center">kafka 消费者所属组的 id</td>
<td align="center">否</td>
<td align="center">“logstash”</td>
</tr>
<tr>
<td align="center">topics</td>
<td align="center">订阅的 topic</td>
<td align="center">否</td>
<td align="center">[“logstash”]</td>
</tr>
<tr>
<td align="center">topics_pattern</td>
<td align="center">以正则表达式方式订阅 topic</td>
<td align="center">否</td>
<td align="center">-</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    bootstrap_servers =&gt; [<span class="string">"10.237.64.46:9094"</span>]</span><br><span class="line">    group_id =&gt; <span class="string">"es-transfer"</span></span><br><span class="line">    topics =&gt; [<span class="string">"JSON_PRODUCE_TOPIC"</span>]</span><br><span class="line">    consumer_threads =&gt; <span class="number">5</span></span><br><span class="line">    decorate_events =&gt; <span class="literal">true</span></span><br><span class="line">    codec =&gt; <span class="string">"json"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a><code>redis</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-redis.html" target="_blank" rel="noopener"><code>redis</code></a> 输入插件用于从 Redis 实例中读取事件数据,支持 Redis channels 和 lists.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">Redis 数据库主机地址</td>
<td align="center">否</td>
<td align="center">“127.0.0.1”</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">Redis 数据库监听端口</td>
<td align="center">否</td>
<td align="center">6379</td>
</tr>
<tr>
<td align="center">passwd</td>
<td align="center">Redis 数据库连接密码</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">db</td>
<td align="center">Redis 的数据库</td>
<td align="center">否</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">data_type</td>
<td align="center">指定从 Redis 指定对象中读取数据, list, channel, pattern_channel</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">Redis list 或 channel 的名称</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">batch_count</td>
<td align="center">从 Redis 返回的事件数</td>
<td align="center">否</td>
<td align="center">125</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    host =&gt; <span class="string">"192.168.1.2"</span></span><br><span class="line">    port =&gt; <span class="number">6379</span></span><br><span class="line">    passwd =&gt; <span class="string">"passwd"</span></span><br><span class="line">    db =&gt; <span class="number">0</span></span><br><span class="line">    data_type =&gt; <span class="string">"list"</span></span><br><span class="line">    key =&gt; <span class="string">"logstash"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a><code>stdin</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html" target="_blank" rel="noopener"><code>stdin</code></a> 输入插件从标准输入读取数据,多用于测试</p>
<h2 id="filter-插件"><a href="#filter-插件" class="headerlink" title="filter 插件"></a><code>filter</code> 插件</h2><p><a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="noopener"><code>filter</code></a> 插件用于过滤或处理进入 Logstash 的数据.</p>
<p>它包含一些通用的字段,用于配置从 Logstash 输出数据的属性,用于后续的处理过程.常用字段如下</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add_field</td>
<td align="center">为数据内容添加字段键值对映射</td>
</tr>
<tr>
<td align="center">add_tag</td>
<td align="center">为数据属性添加标签属性</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">设置 filter 插件的唯一标识</td>
</tr>
<tr>
<td align="center">remove_field</td>
<td align="center">删除数据内容中指定字段</td>
</tr>
<tr>
<td align="center">remove_tag</td>
<td align="center">删除数据属性中指定标签</td>
</tr>
</tbody></table>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a><code>date</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html" target="_blank" rel="noopener"><code>date</code></a> 过滤插件用于解析字段中的日期,然后使用该日期或时间戳作为时间戳</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">match</td>
<td align="center">指定字段及日期格式</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">当解析失败时添加列表中标签</td>
<td align="center">否</td>
<td align="center">[“_dateparsefailure”]</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">解析成功后保存的字段名</td>
<td align="center">否</td>
<td align="center">“@timestamp”</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  date &#123;</span><br><span class="line">    <span class="comment"># log_time 变量包含 dd/MMM/yyyy:HH:mm:ss Z 格式的日期</span></span><br><span class="line">    match =&gt; [<span class="string">"log_time"</span>,<span class="string">"dd/MMM/yyyy:HH:mm:ss Z"</span>]</span><br><span class="line">    target =&gt; <span class="string">"@log_time"</span></span><br><span class="line">    tag_on_failure =&gt; [<span class="string">"_dateparsefailure"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a><code>drop</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-drop.html" target="_blank" rel="noopener"><code>drop</code></a> 过滤插件用于删除事件数据</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  <span class="keyword">if</span> [loglevel] == <span class="string">"debug"</span> &#123;</span><br><span class="line">    drop &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="geoip"><a href="#geoip" class="headerlink" title="geoip"></a><code>geoip</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-geoip.html" target="_blank" rel="noopener"><code>geoip</code></a> 过滤插件用于根据来自 Maxmind GeoLite2 数据库的数据添加有关 IP 地址地理位置的信息</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">database</td>
<td align="center">指定 Maxmind GeoLite2 数据库地址</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">source</td>
<td align="center">指定要解析的 IP 地址或主机名</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">指定解析后数据存储到的字段名称</td>
<td align="center">否</td>
<td align="center">“geoip”</td>
</tr>
<tr>
<td align="center">fields</td>
<td align="center">指定解析后数据要保留的字段列表</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">当解析失败时添加列表中标签</td>
<td align="center">否</td>
<td align="center">[“_geoip_lookup_failure”]</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  geoip &#123;</span><br><span class="line">    <span class="comment"># remote_addr 变量表示 IP 地址,用于对</span></span><br><span class="line">    source =&gt; <span class="string">"remote_addr"</span></span><br><span class="line">    target =&gt; <span class="string">"geoip"</span></span><br><span class="line">    database =&gt; <span class="string">"/home/elk/logstash-6.4.2/config/GeoLite2-City.mmdb"</span></span><br><span class="line">    fields =&gt; [<span class="string">"city_name"</span>,<span class="string">"country_name"</span>,<span class="string">"region_name"</span>,<span class="string">"location"</span>]</span><br><span class="line">    tag_on_failure =&gt; [<span class="string">"_geoip_lookup_failure"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grok"><a href="#grok" class="headerlink" title="grok"></a><code>grok</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html" target="_blank" rel="noopener"><code>grok</code></a> 过滤插件基于正则表达式解析任意文本并将其结构化,是将非结构化日志数据解析为结构化和可查询内容的好方法.</p>
<p><code>grok</code> 默认包含 120 种的模式,您可以在 <a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns" target="_blank" rel="noopener">Github</a> 或 <code>${LOGSTASH_HOME}/vendor/bundle/jruby/2.3.0/gems/logstash-patterns-core-4.1.2/patterns/</code> 找到对应的正则表达式</p>
<p><code>grok</code> 的基本语法为 <code>%{SYNTAX:SEMANTIC}</code>.<code>SYNTAX</code> 是指定用于匹配文本的模式名称,正则表达式的内容可以在如上位置找到.<code>SEMANTIC</code> 为匹配到的文本提供标识符,将匹配到的文本写入到变量中,后续可以直接使用此标识符引用文本.</p>
<p>另外,我们可以按照 <code>PATTERN_NAME PATTERN</code> 的方式自定义匹配模式,并在 <code>pattern_definitions</code> 选项字段中进行引用.或将匹配模式定义写入到文件中,通过 <code>pattern_dir</code> 和 <code>patterns_files_glob</code> 字段对该文件进行引用.</p>
<p>可以在 <a href="http://grokdebug.herokuapp.com/" target="_blank" rel="noopener">http://grokdebug.herokuapp.com/</a> 查看文本与模式是否匹配.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">match</td>
<td align="center">定义了待匹配的文本和匹配模式的映射,匹配模式可以以列表形式定义多个</td>
<td align="center">否</td>
<td align="center">{}</td>
</tr>
<tr>
<td align="center">overwrite</td>
<td align="center">指定模式匹配后的字段覆盖列表中的字段</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">pattern_definitions</td>
<td align="center">自定义模式的名称和内容的映射</td>
<td align="center">否</td>
<td align="center">{}</td>
</tr>
<tr>
<td align="center">patterns_dir</td>
<td align="center">自定义模式文件的目录</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">patterns_files_glob</td>
<td align="center">使用 glob 匹配 patterns_dir 目录下文件用于自定义模式匹配</td>
<td align="center">否</td>
<td align="center">“*”</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">匹配失败后添加的标签</td>
<td align="center">否</td>
<td align="center">[“_grokparsefailure”]</td>
</tr>
<tr>
<td align="center">tag_on_timeout</td>
<td align="center">匹配超时时添加的标签</td>
<td align="center">否</td>
<td align="center">“_groktimeout”</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">定义匹配到的文本保存的字段名称,类似于 <code>geoip.target</code></td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">break_on_match</td>
<td align="center">是否在首次匹配成功后则跳出匹配,如果想让尝试所有的模式匹配,则设置为 false</td>
<td align="center">否</td>
<td align="center">true</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    <span class="comment"># "message" 为 nginx 数据</span></span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"\[%&#123;HTTPDATE:log_time&#125;\] - %&#123;NUMBER:timestamp&#125; - (%&#123;IP_X:remote_addr&#125;|-) - %&#123;USER:remote_user&#125; \"%&#123;WORD:request_method&#125; %&#123;URIHOST:server_host&#125;(%&#123;URIPATH:request_uri&#125;|-)(%&#123;NOTSPACE:request_param&#125;)? HTTP\/%&#123;NUMBER:http_version&#125;\" %&#123;NUMBER:response_code&#125; %&#123;NUMBER:response_body_bytes&#125; - %&#123;DATA:ssl_protocol&#125; %&#123;NUMBER:request_time&#125; - (%&#123;HOSTPORT:upstream_addr&#125;|-) (%&#123;NUMBER:upstream_response_time&#125;|-) %&#123;GREEDYDATA:other&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    remove_field =&gt; [ <span class="string">"@version"</span>, <span class="string">"host"</span>, <span class="string">"path"</span>, <span class="string">"type"</span>, <span class="string">"message"</span>, <span class="string">"remote_user"</span>, <span class="string">"request_method"</span>, <span class="string">"http_version"</span>, <span class="string">"request_param"</span>, <span class="string">"ssl_protocol"</span>, <span class="string">"request_time"</span>, <span class="string">"upstream_addr"</span>, <span class="string">"upstream_response_time"</span>, <span class="string">"other"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[19&#x2F;May&#x2F;2020:16:40:04 +0800] - 1589877604.781 - 42.236.82.156 - - &quot;GET reg.cntv.cn&#x2F; HTTP&#x2F;1.1&quot; 302 0 - - 0.003 - 192.168.2.3:8082 0.003 - 100148273 - 1 - Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;46.0.2490.86 Safari&#x2F;537.36 &quot;-&quot;</span><br></pre></td></tr></table></figure>

<h3 id="json"><a href="#json" class="headerlink" title="json"></a><code>json</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-json.html" target="_blank" rel="noopener"><code>json</code></a> 过滤插件将 JSON 格式的数据解析为 Logstash 内部格式的数据</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">source</td>
<td align="center">指定要解析的字段</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">解析后数据存储到的字段名称</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">解码失败后添加的标签</td>
<td align="center">否</td>
<td align="center">[“_jsonparsefailure”]</td>
</tr>
<tr>
<td align="center">skip_on_invalid_json</td>
<td align="center">是否跳过无效的 JSON</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    <span class="comment"># "message 变量为 json 格式数据</span></span><br><span class="line">    source =&gt; <span class="string">"message"</span></span><br><span class="line">    skip_on_invalid_json =&gt; <span class="string">"true"</span></span><br><span class="line">    target =&gt; <span class="string">"doc"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;method&quot;:[&quot;user.getName&quot;],&quot;client&quot;:[&quot;client&quot;],&quot;snap&quot;:[&quot;120x120&quot;],&quot;userid&quot;:[&quot;12345678&quot;]&#125;</span><br><span class="line">解析为</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot; &#x3D;&gt; &#123;</span><br><span class="line">    &quot;snap&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;120x120&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;client&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;client&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;userid&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;12345678&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;method&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;user.getName&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="urldecode"><a href="#urldecode" class="headerlink" title="urldecode"></a><code>urldecode</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-urldecode.html" target="_blank" rel="noopener"><code>urldecode</code></a> 过滤插件用于对 urlencoded 的字段解码</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">field</td>
<td align="center">指定要解码的字段</td>
<td align="center">否</td>
<td align="center">“message”</td>
</tr>
<tr>
<td align="center">charset</td>
<td align="center">指定字符编码</td>
<td align="center">否</td>
<td align="center">“UTF-8”</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">解码失败后添加的标签</td>
<td align="center">否</td>
<td align="center">[“_urldecodefailure”]</td>
</tr>
<tr>
<td align="center">all_field</td>
<td align="center">是否对所有字段进行解码</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  urldecode &#123;</span><br><span class="line">    <span class="comment"># request_url 包含已经编码或未编码的信息</span></span><br><span class="line">    field =&gt; <span class="string">"request_url"</span></span><br><span class="line">    charset =&gt; <span class="string">"UTF-8"</span></span><br><span class="line">    tag_on_failure =&gt; [<span class="string">"_urldecodefailure"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;client&#x3D;6&amp;data&#x3D;%7B%22uid%22%3A73023332%2C%22vid%22%3A%2264d68733bd5343d2bc69334e804ce036%22%2C%22position%22%3A%220%22%7D&amp;method&#x3D;videoformobile.setVideoPosition&quot;</span><br><span class="line"></span><br><span class="line">解析为</span><br><span class="line"></span><br><span class="line">&quot;client&#x3D;6&amp;data&#x3D;&#123;\&quot;uid\&quot;:73023332,\&quot;vid\&quot;:\&quot;64d68733bd5343d2bc69334e804ce036\&quot;,\&quot;position\&quot;:\&quot;0\&quot;&#125;&amp;method&#x3D;videoformobile.setVideoPosition\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="output-插件"><a href="#output-插件" class="headerlink" title="output 插件"></a><code>output</code> 插件</h2><p><a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="noopener"><code>output</code></a>插件将事件数据发送到指定的目的地,是事件管道中的最后阶段.</p>
<p>它包含一些通用的字段,用于配置 Logstash 输出数据的属性.常用字段如下:</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">codec</td>
<td align="center">指定输出数据的解码器.默认值为 “rubydebug”,可选做 “json”</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">设置 output 插件的唯一标识</td>
</tr>
</tbody></table>
<h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a><code>elasticsearch</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html" target="_blank" rel="noopener"><code>elasticsearch</code></a> 输出插件将 Logstash 数据导入到 Elasticsearch.</p>
<p>此插件尝试通过单个请求发送批量事件数据.如果一个请求超过 <code>20MB</code>,我们会将其分解为多个批处理请求.如果单个文档超过<code>20MB</code>,它将作为单个请求发送.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hosts</td>
<td align="center">指定 Elasticsearch 服务的地址,支持指定多个协议和端口</td>
<td align="center">否</td>
<td align="center">[“127.0.0.1:9200”]</td>
</tr>
<tr>
<td align="center">user, password</td>
<td align="center">指定 Elasticsearch 服务的用户名密码</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">指定索引</td>
<td align="center">否</td>
<td align="center">“logstash-%{+yyyy.MM.dd}”</td>
</tr>
<tr>
<td align="center">action</td>
<td align="center">Elasticsearch 内部执行的操作,index,delete,create,update</td>
<td align="center">否</td>
<td align="center">“index”</td>
</tr>
<tr>
<td align="center">document_id</td>
<td align="center">指定文档索引,会自动生成</td>
<td align="center">否 “”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ssl</td>
<td align="center">是否使用 ssl</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">cacert</td>
<td align="center">证书文件路径</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
</tbody></table>
<h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a><code>mongodb</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-mongodb.html" target="_blank" rel="noopener"><code>mongodb</code></a> 输出插件将事件数据写入到 MongoDB.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bulk</td>
<td align="center">是否启用批量插入</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">bulk_interval</td>
<td align="center">批量插入的时间间隔</td>
<td align="center">否</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">bulk_size</td>
<td align="center">批量插入的事件数据数</td>
<td align="center">否</td>
<td align="center">900</td>
</tr>
<tr>
<td align="center">collection</td>
<td align="center">数据写入 MongoDB 的集合名称,支持动态选择</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">database</td>
<td align="center">数据写入 MongoDB 的数据库名称</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">uri</td>
<td align="center">指定连接 MongoDB 的地址</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">generateId</td>
<td align="center">是否生成 “_id” 字段插入到 MongoDB 文档中.如果设置为 true,则使用事件数据的时间戳,且覆盖现有 “_id” 字段</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">retry_delay</td>
<td align="center">失败后重试的等待时间</td>
<td align="center">否</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">isodate</td>
<td align="center">是否将 @timestamp 作为 ISODate 类型保存在 MongoDB 中</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
</tbody></table>
<h3 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a><code>redis</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-redis.html" target="_blank" rel="noopener"><code>redis</code></a> 输出插件将事件数据写入到 Redis.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">Redis 数据库主机地址</td>
<td align="center">否</td>
<td align="center">[“127.0.0.1”]</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">Redis 数据库监听端口</td>
<td align="center">否</td>
<td align="center">6379</td>
</tr>
<tr>
<td align="center">passwd</td>
<td align="center">Redis 数据库连接密码</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">db</td>
<td align="center">Redis 的数据库</td>
<td align="center">否</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">data_type</td>
<td align="center">指定向 Redis 写入数据的对象, list, channel</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">Redis list 或 channel 的名称,可以使用动态名称</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">batch</td>
<td align="center">是否使用 RPUSH 向 Redis list 中批量写入数据</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">batch_events</td>
<td align="center">RPUSH 默认向 Redis list 中写入的数据量</td>
<td align="center">否</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">batch_timeout</td>
<td align="center">RPUSH 的超时时间</td>
<td align="center">否</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">reconnect_interval</td>
<td align="center">重试连接的时间间隔</td>
<td align="center">否</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">连接的超时时间</td>
<td align="center">否</td>
<td align="center">5</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a><code>stdout</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-stdout.html" target="_blank" rel="noopener"><code>stdout</code></a> 输出插件将事件数据打印到标准输出,多用于测试.</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab CI/CD 管道配置详解</title>
    <url>/2020/05/22/gitlab-ci-pipeline-configuration/</url>
    <content><![CDATA[<p>在每个 GitLab 项目中,使用名为 <code>.gitlab-ci.yml</code> 的 YAML 文件配置 GitLab CI/CD  pipelines (管道).</p>
<p><code>.gitlab-ci.yml</code> 文件定义 pipeline 的结构和执行顺序,并确定了如下内容</p>
<ul>
<li>GitLab Runner(负责运行管道的实例)执行什么任务</li>
<li>GitLab Runner 的高级配置,可用于配置 GitLab Runner</li>
</ul>
<p>有关 <code>.gitlab-ci.yml</code> 文件示例参考可从如下位置找到</p>
<ul>
<li><a href="https://docs.gitlab.com/ee/ci/examples/README.html" target="_blank" rel="noopener">GitLab CI/CD Examples</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab/blob/master/.gitlab-ci.yml" target="_blank" rel="noopener">gitlab 的 .gitlab-ci.yml 文件</a></li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>pipeline 配置从 job(作业)开始.作业是组成 <code>.gitlab-ci.yml</code> 的最基本元素.它主要有下功能或特性</p>
<ul>
<li>定义约束,指出应在什么条件下执行它们</li>
<li>任意名称的顶级元素,至少包含 <code>script</code> 子句</li>
<li>可以定义多个</li>
</ul>
<p>简单示例如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">"execute-script-for-job1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">"execute-script-for-job2"</span></span><br></pre></td></tr></table></figure>

<p>以上两个示例是具有两个单独作业的 CI/CD 配置,每个作业执行一个命令.当然,此命令可以在存储库中直接执行代码或运行脚本.</p>
<p>作业由 Runner 提取并在 Runner 系统环境中运行.每个作业彼此独立运行.</p>
<h3 id="验证-gitlab-ci-yml"><a href="#验证-gitlab-ci-yml" class="headerlink" title="验证 .gitlab-ci.yml"></a>验证 <code>.gitlab-ci.yml</code></h3><p>每个 GitLab CI/CD 实例都有一个成为 Lint 的嵌入式调试工具,该工具可验证 <code>.gitlab-ci.yml</code> 文件的内容,您可以在项目名称空间的 <code>$PATH_TO_PROJECT/-/ci/lint</code>($PATH_TO_PROJECT=$GitLab_URL/user_or_group_name/project_name)路径下找到.如 <code>https://gitlab.example.com/gitlab-org/project-123/-/ci/lint</code>.</p>
<h3 id="作业命名规范"><a href="#作业命名规范" class="headerlink" title="作业命名规范"></a>作业命名规范</h3><p>每个作业都有唯一的名称,且以下保留关键字不能作为作业的名称:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image</span><br><span class="line">services</span><br><span class="line">stages</span><br><span class="line">types</span><br><span class="line">before_script</span><br><span class="line">after_script</span><br><span class="line">variables</span><br><span class="line">cache</span><br><span class="line">include</span><br></pre></td></tr></table></figure>

<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>作业通过一系列参数定义作业的行为.以下列出了作业的可用参数:</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>script</code></td>
<td align="center">由 Runner 执行的脚本</td>
</tr>
<tr>
<td align="center"><code>image</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>services</code></td>
<td align="center">使用 docker 服务镜像.也可用 <code>services:name</code>, <code>services:alias</code>, <code>services:entrypoint</code>, <code>services:command</code></td>
</tr>
<tr>
<td align="center"><code>before_script</code></td>
<td align="center">包含执行作业之前的一组命令</td>
</tr>
<tr>
<td align="center"><code>after_script</code></td>
<td align="center">包含执行作业之后的一组命令</td>
</tr>
<tr>
<td align="center"><code>stage</code></td>
<td align="center">定义作业的阶段(默认值为 <code>test</code>)</td>
</tr>
<tr>
<td align="center"><code>only</code></td>
<td align="center">限定作业何时创建.也可用 <code>only:refs</code>, <code>only:kubernetes</code>, <code>only:variables</code>, <code>only:changes</code></td>
</tr>
<tr>
<td align="center"><code>except</code></td>
<td align="center">限定作业不创建.也可用  <code>except:refs</code>, <code>except:kubernetes</code>, <code>except:variables</code>, <code>except:changes</code></td>
</tr>
<tr>
<td align="center"><code>rules</code></td>
<td align="center">根据作业的属性评估确定是否创建工作的条件列表.不得与 <code>only/except</code> 一起使用</td>
</tr>
<tr>
<td align="center"><code>tags</code></td>
<td align="center">用于选择 Runner(运行器) 的标签列表</td>
</tr>
<tr>
<td align="center"><code>allow_failure</code></td>
<td align="center">是否允许作业失败</td>
</tr>
<tr>
<td align="center"><code>when</code></td>
<td align="center">限定什么时候开始作业.也可用<code>when:manual</code>, <code>when:delayed</code></td>
</tr>
<tr>
<td align="center"><code>environment</code></td>
<td align="center">作业部署到的环境名称.也可用 <code>environment:name</code>, <code>environment:url</code>, <code>environment:on_stop</code>, <code>environment:auto_stop_in</code>, <code>environment:action</code></td>
</tr>
<tr>
<td align="center"><code>cache</code></td>
<td align="center">缓存文件列表,以备在后续的作业中使用.也可用 <code>cache:paths</code>, <code>cache:key</code>, <code>cache:untracked</code>, <code>cache:policy</code></td>
</tr>
<tr>
<td align="center"><code>artifacts</code></td>
<td align="center">成功时附加到作业的文件和目录列表</td>
</tr>
<tr>
<td align="center"><code>dependencies</code></td>
<td align="center">指定本次作业的依赖作业列表,该列表中作业由 <code>artifacts</code> 附加的文件或目录会作为本次作业的依赖</td>
</tr>
<tr>
<td align="center"><code>coverage</code></td>
<td align="center">提供正则表达式,从作业输出中提取指定的内容</td>
</tr>
<tr>
<td align="center"><code>retry</code></td>
<td align="center">出现问题时可自动重试作业的条件和次数</td>
</tr>
<tr>
<td align="center"><code>timeout</code></td>
<td align="center">定义作业级别的超时时间</td>
</tr>
<tr>
<td align="center"><code>parallel</code></td>
<td align="center">可并行运行的作业实例个数</td>
</tr>
<tr>
<td align="center"><code>trigger</code></td>
<td align="center">定义下游管道触发器</td>
</tr>
<tr>
<td align="center"><code>include</code></td>
<td align="center">此作业包含的外部 yaml 文件.也可用 <code>include:local</code>, <code>include:file</code>, <code>include:template</code>, <code>include:remote</code></td>
</tr>
<tr>
<td align="center"><code>extends</code></td>
<td align="center">该作业要继承的配置条目</td>
</tr>
<tr>
<td align="center"><code>pages</code></td>
<td align="center">上传作业结果,用于在 GitLab Pages 展示</td>
</tr>
<tr>
<td align="center"><code>variables</code></td>
<td align="center">定义作业级别的变量</td>
</tr>
<tr>
<td align="center"><code>interruptible</code></td>
<td align="center">定义新的作业运行是否可以取消作业</td>
</tr>
<tr>
<td align="center"><code>resource_group</code></td>
<td align="center">限制作业并发</td>
</tr>
</tbody></table>
<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><p>可以在全局级别定义一些参数,这会影响管道中的所有作业.</p>
<p>以下参数可以使用 <code>default</code> 关键字配置块将某些全局参数设置为所有作业的默认值.作业可以覆盖这些默认值.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image</span><br><span class="line">services</span><br><span class="line">before_script</span><br><span class="line">after_script</span><br><span class="line">tags</span><br><span class="line">cache</span><br><span class="line">artifacts</span><br><span class="line">retry</span><br><span class="line">timeout</span><br><span class="line">interruptible</span><br></pre></td></tr></table></figure>

<p>示例如下,默认使用 <code>image: ruby:2.5</code> 镜像,而 <code>rspec 2.6</code> 作业使用 <code>image: ruby:2.6</code> 镜像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ruby:2.5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec 2.6:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ruby:2.6</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a><code>stages</code></h3><p><code>stages</code> 用于定义使用的阶段作业,且是全局的</p>
<p><code>stages</code> 允许具有灵活的多级管道,<code>stages</code> 中的元素定义了作业执行的顺序:</p>
<ul>
<li>同一阶段的作业并行运行</li>
<li>前一阶段的作业成功运行后,才运行下一阶段作业</li>
</ul>
<p>还有两种情况需要注意:</p>
<ul>
<li>如果 <code>.gitlab-ci.yml</code> 中未定义 <code>stages</code>,默认运行 <code>build</code>, <code>test</code>, <code>deploy</code> 阶段的作业</li>
<li>如果作业没有指定阶段,则默认将该作业分配为 <code>test</code> 阶段</li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h3><p><code>include</code> 关键字用于包含外部 YAML 文件,可将 CI/CD 配置分解为多个文件,提高配置文件的可读性.</p>
<p><code>include</code> 要求外部 YAML 文件具有 <code>.yml</code> 或 <code>.yaml</code> 后缀名,否则不会被导入</p>
<p><code>include</code> 支持如下方法,默认方法是 <code>local</code>.在进行 include 配置时支持直接引入对应文件路径,<code>include</code> 会自动分析方法. <a href="https://docs.gitlab.com/ee/ci/yaml/includes.html" target="_blank" rel="noopener">示例</a></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>local</code></td>
<td align="left">本项目代码库中的文件</td>
</tr>
<tr>
<td align="center"><code>file</code></td>
<td align="left">其它项目代码库中的文件</td>
</tr>
<tr>
<td align="center"><code>remote</code></td>
<td align="left">远程 URL 的文件</td>
</tr>
<tr>
<td align="center"><code>template</code></td>
<td align="left">GitLab 提供的模版</td>
</tr>
</tbody></table>
<h4 id="include-local"><a href="#include-local" class="headerlink" title="include:local"></a><code>include:local</code></h4><p><code>include:local</code> 用于引入与 <code>.gitlab-ci.yml</code> 来自同一代码库同一分支的文件,请确保 <code>.gitlab-ci.yml</code> 与要引入的文件在同一分支上</p>
<p><code>include:local</code> 使用代码仓库 <code>/</code> 根路径进行引用.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">local:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">include:</span> <span class="string">'.gitlab-ci-production.yml'</span></span><br></pre></td></tr></table></figure>

<h4 id="include-file"><a href="#include-file" class="headerlink" title="include:file"></a><code>include:file</code></h4><p><code>include:file</code> 支持引入同一个 GitLab 实例中另一个代码仓库中的文件. 并使用代码仓库 <code>/</code> 根路径进行引用.</p>
<p>您也可以通过 <code>ref</code> 指定代码仓库的分支或 <code>HEAD</code> 以确保引入正确仓库分支中的文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">'my-group/my-project'</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">'my-group/my-project'</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">'my-group/my-project'</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">787123b47f14b552955ca2786bc9542ae66fee5b</span> <span class="comment"># Git SHA</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br></pre></td></tr></table></figure>

<h4 id="include-remote"><a href="#include-remote" class="headerlink" title="include:remote"></a><code>include:remote</code></h4><p><code>include:remote</code> 支持通过 HTTP/HTTPS 引入来自其他位置中的文件,远程文件必须可通过 GET 请求公开访问</p>
<p>远程文件使用完整 URL 引用.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">remote:</span> <span class="string">'https://gitlab.com/awesome-project/raw/master/.gitlab-ci-template.yml'</span></span><br></pre></td></tr></table></figure>

<h4 id="include-template"><a href="#include-template" class="headerlink" title="include:template"></a><code>include:template</code></h4><p><code>include:template</code> 支持引入 GitLab 提供的 <code>.gitlab-ci.yml</code> 模版文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">Auto-DevOps.gitlab-ci.yml</span></span><br></pre></td></tr></table></figure>

<h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3><p>指定一个 Docker 镜像来运行作业.详见<a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml" target="_blank" rel="noopener">使用 Docker 镜像</a></p>
<h3 id="script"><a href="#script" class="headerlink" title="script"></a><code>script</code></h3><p><code>script</code> 是脚本所必须的关键字,它是由 Runner 执行的 shell 脚本.支持使用包含多个命令的数组以便顺序执行命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<p>如果有命令的退出代码不为 0,则作业将失败,且不会执行其他命令.通过将退出代码存储在变量中,可以避免这种情况:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">false</span> <span class="string">||</span> <span class="string">exit_code=$?</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">$exit_code</span> <span class="string">-ne</span> <span class="number">0</span> <span class="string">];</span> <span class="string">then</span> <span class="string">echo</span> <span class="string">"Previous command failed"</span><span class="string">;</span> <span class="string">fi;</span></span><br></pre></td></tr></table></figure>

<h3 id="before-script-和-after-script"><a href="#before-script-和-after-script" class="headerlink" title="before_script 和 after_script"></a><code>before_script</code> 和 <code>after_script</code></h3><p><code>before_script</code> 用于定义在每个作业(包括部署作业)之前运行的命令,<code>after_script</code> 用于定义在每个作业(包括失败的作业)之后运行的命令.它们都是一个数组</p>
<p><code>before_script</code> 中指定的脚本与主脚本中指定的脚本串联在一起,并在单个 shell 中一起执行</p>
<p><code>after_script</code> 中指定的脚本在新的shell中执行,与任何 <code>before_script</code> 或 <code>script</code> 定义的命令分开.</p>
<p>它们有如下需要注意的地方:</p>
<ul>
<li>当前工作目录设置为默认目录</li>
<li>无法访问 <code>before_script</code> 或 <code>script</code> 定义的脚本完成的修改.<ul>
<li><code>script</code> 中定义的命令别名和变量</li>
<li>由 before_script 或 <code>script</code> 安装的软件</li>
</ul>
</li>
<li>独立的超时时间,默认为 5 分钟</li>
<li>不影响作业的退出代码.如果 <code>script</code> 成功,但 <code>after_script</code> 超时或失败,作业将标记为成功作业</li>
</ul>
<h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a><code>stage</code></h3><p><code>stage</code> 是按照每个作业定义的,且依赖于全局定义的 <code>stages</code>. 它将作业分为不同的阶段,同一阶段的作业可以并行执行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 0:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">.pre</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">something</span> <span class="string">useful</span> <span class="string">before</span> <span class="string">build</span> <span class="string">stage</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 1:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">dependencies</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 2:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">artifacts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 3:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 4:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 5:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">.post</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">something</span> <span class="string">useful</span> <span class="string">at</span> <span class="string">the</span> <span class="string">end</span> <span class="string">of</span> <span class="string">pipeline</span></span><br></pre></td></tr></table></figure>

<p>默认情况下,GitLab Runner 一次仅运行一个作业.可通过设置作业在不同的 Runner 上运行或修改 Runner 的 <code>concurrent</code> 配置来使作业并行运行.</p>
<blockquote>
<p>(GitLab 12.4 新增)无论在 <code>stages</code> 中 顺序如何,<code>.per</code> 始终是管道中的第一个阶段.<code>.post</code> 始终是管道中的最后一个阶段.用户定义的阶段在这两个阶段之间运行</p>
</blockquote>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a><code>extends</code></h3><p><code>extends</code> 定义使用 <code>extends</code> 关键字的作业(子作业)要继承的作业(父作业).<code>extends</code> 会将子作业内容递归合并到父作业中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.tests:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">branches</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.tests</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$RSPEC</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">rspec</span>  <span class="comment"># 作业中相同关键字的 key 已经被重写</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span>             <span class="comment"># 子作业中没有的关键字会继承父作业中关键字及其值</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">branches</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$RSPEC</span></span><br></pre></td></tr></table></figure>

<p>且如果 <code>extends</code> 包含多个值,则会按照 <code>extends</code> 中定义的作业列表顺序进行继承.如果作业列表有相同的关键字,则后面作业中关键字的值会覆盖前面作业关键字的值.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.only-important:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"><span class="string">.in-docker:</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">extends:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.only-important</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.in-docker</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rake</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a><code>rules</code></h3><blockquote>
<p>GitLab 12.3 新增</p>
</blockquote>
<p><code>rules</code> 将按照顺序评估列表中的规则,直到有规则匹配到,实现为作业动态提供属性的功能.<code>rules</code> 不能与 <code>only/except</code> 同时使用,它旨在替换该功能</p>
<p>可用的规则字句字段包括</p>
<ul>
<li><code>if</code>(与 <code>only:variables</code> 类似)</li>
<li><code>changes</code> (与 <code>only:changes</code> 类似)</li>
<li><code>exists</code></li>
</ul>
<h4 id="rules-if"><a href="#rules-if" class="headerlink" title="rules:if"></a><code>rules:if</code></h4><p><code>rules:if</code> 使用定义的 if 规则设置作业执行的时机</p>
<p><code>rules:if</code> 与 <code>only:variables</code> 略有不同.<code>only:variables</code> 仅接收单个表达式字符串,而 <code>rules:if</code> 支持表达式字符串数组形式,支持多个条件判断.支持使用 <code>&amp;&amp;</code> 或 <code>||</code> 将表达式集合组合为一个表达式,且支持使用变量匹配语法.</p>
<p>如果提供的规则均不匹配,则作业将被默认设置为 <code>when:never</code>,且不包含在执行作业的管道中.如果配置中不包含 <code>rules:when</code>,则继承 <code>job:when</code> 的值,默认为 <code>on_success</code>.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">"echo Hello, Rules!"</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$NAME =~ /^always/ # 如果变量 NAME 匹配 always,则设置 when: always</span></span><br><span class="line"><span class="string">      when: always</span></span><br><span class="line"><span class="string">    - if: '</span><span class="string">$NAME</span> <span class="string">=~</span> <span class="string">/^manual/</span> <span class="comment"># 如果变量 NAME 匹配 manual,则设置为 when: manual</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">manual</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$NAME'</span>  <span class="comment"># 如果变量 NAME 设置了,且不为空,则设置为 when: on_success</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果以上均没有匹配,则设置 when: never</span></span><br></pre></td></tr></table></figure>

<h4 id="rules-changes"><a href="#rules-changes" class="headerlink" title="rules:changes"></a><code>rules:changes</code></h4><p><code>rules:changes</code> 与 <code>only:changes</code> 和 <code>except:changes</code> 工作方式相同,它接受路径的数组,并监控它.如果没有对监控中的文件路径做修改,则不会返回 true</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker build:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">my-image:$CI_COMMIT_REF_SLUG</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">changes:</span> <span class="comment"># 如果 Dockerfile 文件被修改,则将其设置为 `when: manual`</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>

<h4 id="rules-exists"><a href="#rules-exists" class="headerlink" title="rules:exists"></a><code>rules:exists</code></h4><blockquote>
<p>GitLab 12.4 新增</p>
</blockquote>
<p><code>rules:exists</code> 接受文件路径或文件路径匹配的数组.如果其中任何一个文件路径在代码仓库中存在,则将匹配,作业将在管道中运行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">exists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spec/**.rb</span></span><br></pre></td></tr></table></figure>

<h4 id="rules-allow-failure"><a href="#rules-allow-failure" class="headerlink" title="rules:allow_failure"></a><code>rules:allow_failure</code></h4><blockquote>
<p>GitLab 12.8 新增</p>
</blockquote>
<p>您可以在规则中使用 <code>allow_failure: true</code>,在不停止作业管道的情况下允许作业失败或手动作业等待操作.所有使用规则的作业默认为 <code>allow_failure: false</code>.</p>
<h3 id="only-except"><a href="#only-except" class="headerlink" title="only/except"></a><code>only/except</code></h3><p><code>only</code> 和 <code>except</code> 是用于限制什么时候创建作业的两个参数.<code>only</code> 用于定义要运行的作业的分支和标签.<code>except</code> 恰好相反,用于定义不运行的作业的分支和标签.</p>
<ul>
<li>它支持正则表达式匹配.</li>
<li>它支持直接指定存储库路径以便于过滤仓库 fork 的作业</li>
</ul>
<p><code>only</code> 和 <code>except</code> 允许使用如下关键字,且如果有作业没有关键字限定,则 <code>only</code> 默认为 <code>[&#39;branches&#39;, &#39;tags&#39;]</code>,<code>except</code> 默认为空.</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>branches</code></td>
<td align="left">当管道的 git 引用是分支时</td>
</tr>
<tr>
<td align="center"><code>tags</code></td>
<td align="left">当管道的 git 引用是标签时</td>
</tr>
<tr>
<td align="center"><code>external</code></td>
<td align="left">当时用 GitLab 以外的 CI 服务时</td>
</tr>
<tr>
<td align="center"><code>pushes</code></td>
<td align="left">由用户的 git push 触发</td>
</tr>
<tr>
<td align="center"><code>schedules</code></td>
<td align="left">用于自动调度的管道</td>
</tr>
<tr>
<td align="center"><code>triggers</code></td>
<td align="left">使用触发令牌创建的管道</td>
</tr>
<tr>
<td align="center"><code>web</code></td>
<td align="left">对于在 GitLab UI 中使用 “Run” 按钮创建的管道</td>
</tr>
<tr>
<td align="center"><code>merge_requests</code></td>
<td align="left">在创建或更新合并请求时</td>
</tr>
</tbody></table>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/^issue-.*$/i</span>  <span class="comment"># 使用正则表达式,`i` 表示忽略大小写</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches</span>  <span class="comment"># 使用关键字,所有的分支都将被跳过</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches@gitlab-org/gitlab</span>  <span class="comment"># 仅对 branches 仓库执行作业,而不对其 fork 执行</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master@gitlab-org/gitlab</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/^release/.*$/@gitlab-org/gitlab</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>only:refs/except:refs</code>: 语法与上述一致</li>
<li><code>only:kubernetes/except:kubernetes</code>: 仅接受 <code>active</code> 参数,表示仅当 kubernetes 服务启动时才执行此作业</li>
<li><code>only:variables/except:variables</code>: 接受自定义变量表达式,以此决定是否创建作业</li>
<li><code>only:changes/except:changes</code>: 接受文件路径,并监控是否改变,以此决定是否创建作业</li>
</ul>
<p>单个关键字中定义的条件列表是<strong>或</strong>的关系,有一个条件满足,则可以认为该关键字表示为 true.</p>
<p>对于 <code>only</code> 创建作业来说,以上关键字之间是<strong>与</strong>的关系,当定义的以上关键字均为 true 时候,才会创建作业.对于 <code>except</code> 不创建作业来说,以上关键字之间是<strong>或</strong>的关系,当定义的以上关键字任意一个为 true 时候,则不会创建作业.</p>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该作业在以下条件均满足时创建</span></span><br><span class="line"><span class="comment"># - 管道是被调度的或在 `master` 分支上运行</span></span><br><span class="line"><span class="comment"># - $CI_COMMIT_MESSAGE 变量正则匹配 /run-end-to-end-tests/</span></span><br><span class="line"><span class="comment"># - kubernetes 服务运行</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">schedules</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$CI_COMMIT_MESSAGE</span> <span class="string">=~</span> <span class="string">/run-end-to-end-tests/</span></span><br><span class="line">    <span class="attr">kubernetes:</span> <span class="string">active</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该作业任意条件满足时不创建</span></span><br><span class="line"><span class="comment"># - 管道是被调度的或在 `master` 分支上运行</span></span><br><span class="line"><span class="comment"># - README.md 文件被修改</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">changes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"README.md"</span></span><br></pre></td></tr></table></figure>

<h3 id="needs"><a href="#needs" class="headerlink" title="needs"></a><code>needs</code></h3><p><code>needs</code> 关键字允许不按照 stages 顺序执行作业,而按照依赖顺序执行作业.这样无需考虑阶段顺序,可以让多个阶段同时运行.</p>
<p>示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">linux:build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mac:build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">lint:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">[]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linux:rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["linux:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linux:rubocop:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["linux:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mac:rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["mac:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mac:rubocop:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["mac:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Linux 作业线: <code>linux:build</code> 作业完成后,将立即运行 <code>linux:rspec</code> 和 <code>linux:rubocop</code> 作业,而无需等待 <code>mac:build</code> 结束</li>
<li>macOS 作业线: <code>mac:build</code> 作业完成后,将立即运行 <code>mac:rspec</code> 和 <code>mac:rubocop</code> 作业,而无需等待 <code>linux:build</code> 结束</li>
<li>production 作业会等待 <code>deploy</code> 阶段之前的作业完成后再运行</li>
</ul>
<h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a><code>tags</code></h3><p><code>tags</code> 用于从允许运行该项目的所有 Runner 列表中选择特定的 Runner.在注册 Runner 时,您可以指定 Runner 的标签,例如 ruby,postgres,development 等.</p>
<p><code>tags</code> 也是在不同平台上运行不同作业的好方法.例如，给定带有 <code>osx</code> 标签的 OS X Runner 和带有 <code>windows</code> 标签的 Windows Runner,以下作业将在各自的平台上运行:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">windows job:</span></span><br><span class="line">  <span class="attr">stage:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">windows</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">Hello,</span> <span class="string">%USERNAME%!</span></span><br><span class="line"></span><br><span class="line"><span class="attr">osx job:</span></span><br><span class="line">  <span class="attr">stage:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">osx</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"Hello, $USER!"</span></span><br></pre></td></tr></table></figure>

<h3 id="allow-failure"><a href="#allow-failure" class="headerlink" title="allow_failure"></a><code>allow_failure</code></h3><p><code>allow_failure</code> 关键字用于指定作业可以失败,而不会影响其余的作业.</p>
<p>设置为 true 后,如果该作业失败，该作业将在用户界面中显示橙色警告,管道的逻辑流程将认为作业成功/通过,并且不会被阻塞</p>
<h3 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h3><p><code>when</code> 关键字用于在发生故障或发生故障时运行的作业.支持以下值</p>
<ul>
<li><code>on_success</code>: 前面阶段的所有作业都成功时,才执行作业.是默认值</li>
<li><code>on_failure</code>: 仅在前面阶段至少一个作业失败时才执行作业.</li>
<li><code>always</code>: 总是执行作业,不管前面作业的执行状态</li>
<li><code>manual</code>: 手动执行作业时才执行此作业</li>
<li><code>delayed</code>: 一段时间后执行此作业.需要设置 <code>start_in</code> 关键字,并设置 <strong>1 周</strong>之内的延迟时间,用于表示在指定延迟时间后开始作业.支持 seconds,minutes,hours,days,week 单位,默认单位是 seconds</li>
</ul>
<h3 id="其它常用"><a href="#其它常用" class="headerlink" title="其它常用"></a>其它常用</h3><ul>
<li><code>retry</code> 允许你在失败的情况下重试作业的次数.重试值必须是一个整数,等于或大于0,但小于等于2</li>
<li><code>timeout</code> 设置指定作业的超时时间,</li>
<li><code>parallel</code> 配置并行运行的作业实例,名称为 <code>job_name 1/N</code> 到 <code>job_name N/N</code> (2&lt;=N&lt;=50)</li>
<li><code>trigger</code> 用于定义触发的下游管道的触发器.当定义 <code>trigger</code> 的作业完成时,将触发下一个作业的执行</li>
<li><code>variables</code> 用于在 <code>.gitlab-ci.yml</code> 中定义变量,然后在作业中使用.</li>
</ul>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 x509 包</title>
    <url>/2020/05/22/go-study-notes-package-x509/</url>
    <content><![CDATA[<p><code>crypto/x509</code> 包主要用于解析 X.509 编码的密钥和证书.</p>
<p><code>crypto/x509/pkix</code> 包含用于 X.509 证书,CRL 和 OCSP 的 ASN.1 解析和序列化的共享低级结构</p>
<p>在 Unix 系统上,可使用环境变量 SSL_CERT_FILE 和 SSL_CERT_DIR 覆盖系统证书文件和证书文件目录的默认位置</p>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// certificates 证书的集合</span></span><br><span class="line"><span class="keyword">type</span> CertPool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X509 证书</span></span><br><span class="line"><span class="keyword">type</span> Certificate <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 证书的 subject 信息,包含 CN,O,L,S,C等字段</span></span><br><span class="line">    Subject pkix.Name</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key 的扩展用法</span></span><br><span class="line"><span class="keyword">type</span> ExtKeyUsage <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Key 的用法</span></span><br><span class="line"><span class="keyword">type</span> KeyUsage <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 证书签署请求</span></span><br><span class="line"><span class="keyword">type</span> CertificateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 签名</span></span><br><span class="line">    Signature          []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 签名算法</span></span><br><span class="line">    SignatureAlgorithm SignatureAlgorithm</span><br><span class="line">    <span class="comment">// 私钥算法</span></span><br><span class="line">    PublicKeyAlgorithm PublicKeyAlgorithm</span><br><span class="line">    <span class="comment">// 私钥</span></span><br><span class="line">    PublicKey          <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 证书签署请求的 subject</span></span><br><span class="line">    Subject pkix.Name</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证的选项</span></span><br><span class="line"><span class="keyword">type</span> VerifyOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    DNSName       <span class="keyword">string</span></span><br><span class="line">    Intermediates *CertPool</span><br><span class="line">    Roots         *CertPool <span class="comment">// 默认使用系统根证书</span></span><br><span class="line">    CurrentTime   time.Time <span class="comment">// 当前时间</span></span><br><span class="line">    KeyUsages []ExtKeyUsage</span><br><span class="line">    MaxConstraintComparisions <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 私钥算法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UnknownPublicKeyAlgorithm PublicKeyAlgorithm = <span class="literal">iota</span></span><br><span class="line">    RSA</span><br><span class="line">    DSA</span><br><span class="line">    ECDSA</span><br><span class="line">    Ed25519</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 签名算法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UnknownSignatureAlgorithm SignatureAlgorithm = <span class="literal">iota</span></span><br><span class="line">    MD2WithRSA</span><br><span class="line">    MD5WithRSA</span><br><span class="line">    SHA1WithRSA</span><br><span class="line">    SHA256WithRSA</span><br><span class="line">    SHA384WithRSA</span><br><span class="line">    SHA512WithRSA</span><br><span class="line">    DSAWithSHA1</span><br><span class="line">    DSAWithSHA256</span><br><span class="line">    ECDSAWithSHA1</span><br><span class="line">    ECDSAWithSHA256</span><br><span class="line">    ECDSAWithSHA384</span><br><span class="line">    ECDSAWithSHA512</span><br><span class="line">    SHA256WithRSAPSS</span><br><span class="line">    SHA384WithRSAPSS</span><br><span class="line">    SHA512WithRSAPSS</span><br><span class="line">    PureEd25519</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 扩展 Key 用法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ExtKeyUsageAny ExtKeyUsage = <span class="literal">iota</span></span><br><span class="line">    ExtKeyUsageServerAuth</span><br><span class="line">    ExtKeyUsageClientAuth</span><br><span class="line">    ExtKeyUsageCodeSigning</span><br><span class="line">    ExtKeyUsageEmailProtection</span><br><span class="line">    ExtKeyUsageIPSECEndSystem</span><br><span class="line">    ExtKeyUsageIPSECTunnel</span><br><span class="line">    ExtKeyUsageIPSECUser</span><br><span class="line">    ExtKeyUsageTimeStamping</span><br><span class="line">    ExtKeyUsageOCSPSigning</span><br><span class="line">    ExtKeyUsageMicrosoftServerGatedCrypto</span><br><span class="line">    ExtKeyUsageNetscapeServerGatedCrypto</span><br><span class="line">    ExtKeyUsageMicrosoftCommercialCodeSigning</span><br><span class="line">    ExtKeyUsageMicrosoftKernelCodeSigning</span><br><span class="line">)</span><br><span class="line"><span class="comment">// key 用法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    KeyUsageDigitalSignature KeyUsage = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">    KeyUsageContentCommitment</span><br><span class="line">    KeyUsageKeyEncipherment</span><br><span class="line">    KeyUsageDataEncipherment</span><br><span class="line">    KeyUsageKeyAgreement</span><br><span class="line">    KeyUsageCertSign</span><br><span class="line">    KeyUsageCRLSign</span><br><span class="line">    KeyUsageEncipherOnly</span><br><span class="line">    KeyUsageDecipherOnly</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="x509-包函数"><a href="#x509-包函数" class="headerlink" title="x509 包函数"></a><code>x509</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 template 创建一个新的由 parent 签署的 X509 v3 证书.返回 DER 编码的证书</span></span><br><span class="line"><span class="comment">// 如果 parent=template,则该证书是自签证书.</span></span><br><span class="line"><span class="comment">// 如果是自签证书生成证书的 AuthorityKeyId 会从父级的 SubjectKeyId 中获取,否则使用 template 中的值</span></span><br><span class="line"><span class="comment">// pub,priv 分别为签署人的公钥和私钥, priv 必须是实现 `crypto.Signal` 接口的 `PrivateKey` 类型.当前支持的类型为 *rsa.PublicKey,*ecdsa.PublicKey 和 *ed25519.PublicKey.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateCertificate</span><span class="params">(rand io.Reader, template, parent *Certificate, pub, priv <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(cert []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 基于 template 创建一个证书签署请求</span></span><br><span class="line"><span class="comment">// priv 是用于签署 CSR 的私钥,并将其公钥放在 CSR 中,priv 必须实现 `crypto.Signal` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateCertificateRequest</span><span class="params">(rand io.Reader, template *CertificateRequest, priv <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(csr []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 使用 password 对 PEM 块进行解密,返回 DER 编码的字节切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptPEMBlock</span><span class="params">(b *pem.Block, password []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 使用指定 alg 和 password 对给定 DER 编码的 data 进行加密.返回加密后的 PEM 块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptPEMBlock</span><span class="params">(rand io.Reader, blockType <span class="keyword">string</span>, data, password []<span class="keyword">byte</span>, alg PEMCipher)</span> <span class="params">(*pem.Block, error)</span></span></span><br><span class="line"><span class="comment">// 判断 PEM 块是否使用密码加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsEncryptedPEMBlock</span><span class="params">(b *pem.Block)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个空的 CertPool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCertPool</span><span class="params">()</span> *<span class="title">CertPool</span></span></span><br><span class="line"><span class="comment">// 返回系统证书池的副本.CertPool 的任何变动都不会写入磁盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemCertPool</span><span class="params">()</span> <span class="params">(*CertPool, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 ASN.1 数据中解析证书.返回证书或证书列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseCertificate</span><span class="params">(asn1Data []<span class="keyword">byte</span>)</span> <span class="params">(*Certificate, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseCertificates</span><span class="params">(asn1Data []<span class="keyword">byte</span>)</span> <span class="params">([]*Certificate, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="CertPool-结构体方法"><a href="#CertPool-结构体方法" class="headerlink" title="CertPool 结构体方法"></a><code>CertPool</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向证书池中添加证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CertPool)</span> <span class="title">AddCert</span><span class="params">(cert *Certificate)</span></span></span><br><span class="line"><span class="comment">// 尝试解析 PEM 编码的证书,并将其添加到证书池中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CertPool)</span> <span class="title">AppendCertsFromPEM</span><span class="params">(pemCerts []<span class="keyword">byte</span>)</span> <span class="params">(ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回证书池中所有证书的 DER 编码的 subject 的列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CertPool)</span> <span class="title">Subjects</span><span class="params">()</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Certificate-结构体方法"><a href="#Certificate-结构体方法" class="headerlink" title="Certificate 结构体方法"></a><code>Certificate</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查 crl 中签名是否来自 c</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CheckCRLSignature</span><span class="params">(crl *pkix.CertificateList)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用指定签名算法 algo 验证 signature 是否是通过 c 的私钥签署了 signed 签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CheckSignature</span><span class="params">(algo SignatureAlgorithm, signed, signature []<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 验证 c 上的签名是否是来自 parent 的有效签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CheckSignatureFrom</span><span class="params">(parent *Certificate)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回证书签名的 DER 编码的 CRL 证书吊销列表,包含指定的的吊销证书列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CreateCRL</span><span class="params">(rand io.Reader, priv <span class="keyword">interface</span>&#123;&#125;, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time)</span> <span class="params">(crlBytes []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 使用 opts.Roots 中的证书,验证 c</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">Verify</span><span class="params">(opts VerifyOptions)</span> <span class="params">(chains [][]*Certificate, err error)</span></span></span><br><span class="line"><span class="comment">// 验证 c 是否是指定主机的有效证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">VerifyHostname</span><span class="params">(h <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="生成自签书-并使用自签证书签署"><a href="#生成自签书-并使用自签证书签署" class="headerlink" title="生成自签书,并使用自签证书签署"></a>生成自签书,并使用自签证书签署</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/x509"</span></span><br><span class="line">    <span class="string">"crypto/x509/pkix"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"math/big"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ca 证书</span></span><br><span class="line">    ca := &amp;x509.Certificate&#123;</span><br><span class="line">        SerialNumber: big.NewInt(<span class="number">1653</span>),</span><br><span class="line">        Subject: pkix.Name&#123;</span><br><span class="line">            Country:            []<span class="keyword">string</span>&#123;<span class="string">"China"</span>&#125;,</span><br><span class="line">            Organization:       []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">            OrganizationalUnit: []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        NotBefore:             time.Now(),</span><br><span class="line">        NotAfter:              time.Now().AddDate(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        SubjectKeyId:          []<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        BasicConstraintsValid: <span class="literal">true</span>,</span><br><span class="line">        IsCA:                  <span class="literal">true</span>,</span><br><span class="line">        ExtKeyUsage:           []x509.ExtKeyUsage&#123;x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth&#125;,</span><br><span class="line">        KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私钥及公钥 rsa 格式</span></span><br><span class="line">    caSelfSignedPrivateKey, _ := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line">    caSelfSignedPublicKey := &amp;caSelfSignedPrivateKey.PublicKey</span><br><span class="line">    <span class="comment">// 自签证书 []byte</span></span><br><span class="line">    caSelfSigned, err := x509.CreateCertificate(rand.Reader, ca, ca, caSelfSignedPublicKey, caSelfSignedPrivateKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"create ca failed"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    caSelfSignedFile := <span class="string">"ca.pem"</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, caSelfSignedFile)</span><br><span class="line">    ioutil.WriteFile(caSelfSignedFile, caSelfSigned, <span class="number">0777</span>) <span class="comment">// 将自签证书写入文件</span></span><br><span class="line"></span><br><span class="line">    caSelfSignedPrivateKeyFile := <span class="string">"ca.key"</span></span><br><span class="line">    caSelfSignedPrivateKeyDER := x509.MarshalPKCS1PrivateKey(caSelfSignedPrivateKey) <span class="comment">// 将私钥转换为 DER 格式</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, caSelfSignedPrivateKeyFile)</span><br><span class="line">    ioutil.WriteFile(caSelfSignedPrivateKeyFile, caSelfSignedPrivateKeyDER, <span class="number">0777</span>) <span class="comment">// 将 DER 编码私钥写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待签署证书及其私钥公钥</span></span><br><span class="line">    cert := &amp;x509.Certificate&#123;</span><br><span class="line">        SerialNumber: big.NewInt(<span class="number">1658</span>),</span><br><span class="line">        Subject: pkix.Name&#123;</span><br><span class="line">            Country:            []<span class="keyword">string</span>&#123;<span class="string">"China"</span>&#125;,</span><br><span class="line">            Organization:       []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">            OrganizationalUnit: []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        NotBefore:    time.Now(),</span><br><span class="line">        NotAfter:     time.Now().AddDate(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        SubjectKeyId: []<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        ExtKeyUsage:  []x509.ExtKeyUsage&#123;x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth&#125;,</span><br><span class="line">        KeyUsage:     x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,</span><br><span class="line">    &#125;</span><br><span class="line">    certPrivateKey, _ := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line">    certPublicKey := &amp;certPrivateKey.PublicKey</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自签CA 对 证书签署</span></span><br><span class="line">    certSigned, err2 := x509.CreateCertificate(rand.Reader, cert, ca, certPublicKey, caSelfSignedPrivateKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"create cert2 failed"</span>, err2)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    certFile := <span class="string">"cert.pem"</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, certFile)</span><br><span class="line">    ioutil.WriteFile(certFile, certSigned, <span class="number">0777</span>) <span class="comment">// cert 写入文件</span></span><br><span class="line"></span><br><span class="line">    certPrivateKeyFile := <span class="string">"cert.key"</span></span><br><span class="line">    certPrivateKeyDER := x509.MarshalPKCS1PrivateKey(certPrivateKey) <span class="comment">// 将私钥转换为 DER 编码格式</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, certPrivateKeyFile)</span><br><span class="line">    ioutil.WriteFile(certPrivateKeyFile, certPrivateKeyDER, <span class="number">0777</span>) <span class="comment">// 私钥写入文件</span></span><br><span class="line"></span><br><span class="line">    ca_tr, _ := x509.ParseCertificate(caSelfSigned)</span><br><span class="line">    cert_tr, _ := x509.ParseCertificate(certSigned)</span><br><span class="line">    err = cert_tr.CheckSignatureFrom(ca_tr)</span><br><span class="line">    log.Println(<span class="string">"check signature"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 tls 包</title>
    <url>/2020/05/22/go-study-notes-package-tls/</url>
    <content><![CDATA[<p>tls 包定义并提供了 TLS 1.2 及 TLS 1.3 传输层安全协议通信过程中使用的对象,函数,方法及加密算法等,为通信双方提供了安全的通信连接.</p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tls 证书</span></span><br><span class="line"><span class="keyword">type</span> Certificate <span class="keyword">struct</span> &#123;</span><br><span class="line">    Certificate [][]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// PrivateKey 包含与 Leaf 中公钥对应的私钥.该对象必须以 RSA,ECDSA 或 Ed25519 算法实现 crypto.Signer 接口</span></span><br><span class="line">    <span class="comment">// 对于 TLS1.2 以下的服务,它可以使用 RSA PublicKey 实现 crypto.Decrypter 接口</span></span><br><span class="line">    PrivateKey crypto.PrivateKey</span><br><span class="line">    <span class="comment">// PrivateKey 可使用的签名算法列表</span></span><br><span class="line">    SupportedSignatureAlgorithms []SignatureScheme <span class="comment">// Go 1.14</span></span><br><span class="line">    <span class="comment">// 客户端请求的 OCSP 响应</span></span><br><span class="line">    OCSPStaple []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 请求它的客户端的证书时间戳列表</span></span><br><span class="line">    SignedCertificateTimestamps [][]<span class="keyword">byte</span> <span class="comment">// Go 1.5</span></span><br><span class="line">    <span class="comment">// 叶子证书的解析形式,可使用 x509.ParseCertificate 对其进行初始化,以减少每次握手的过程.如果为 nil,则根据需要解析叶子证书</span></span><br><span class="line">    Leaf *x509.Certificate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来自服务端的 CertificateRequest 消息的信息,该消息用于向客户端索取证书协商协议</span></span><br><span class="line"><span class="keyword">type</span> CertificateRequestInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含0个或多个 DER 编码的 X.501 专有名称.</span></span><br><span class="line">    <span class="comment">// 这些是服务端希望返回的由其根或中间 CA 签名的证书名称</span></span><br><span class="line">    <span class="comment">// 空切片表示服务端没有首选项</span></span><br><span class="line">    AcceptableCAs [][]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 服务端支持的验证签名方案</span></span><br><span class="line">    SignatureSchemes []SignatureScheme</span><br><span class="line">    <span class="comment">// 为此连接协商的 TLS 版本.</span></span><br><span class="line">    Version <span class="keyword">uint16</span> <span class="comment">// Go 1.14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端 TLS 连接状态</span></span><br><span class="line"><span class="keyword">type</span> ClientSessionState <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器遵循的 TLS 客户端身份验证策略</span></span><br><span class="line"><span class="keyword">type</span> ClientAuthType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 ClientHello 消息信息</span></span><br><span class="line"><span class="keyword">type</span> ClientHelloInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端支持的加密套件</span></span><br><span class="line">    CipherSuites []<span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// 客户端请求的 ServerName</span></span><br><span class="line">    ServerName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    SupportedCurves []CurveID</span><br><span class="line">    SupportedPoints []<span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端支持的签名和哈希方案</span></span><br><span class="line">    SignatureSchemes []SignatureScheme <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 客户端支持的应用层协议</span></span><br><span class="line">    SupportedProtos []<span class="keyword">string</span> <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 客户端支持的 TLS 版本</span></span><br><span class="line">    SupportedVersions []<span class="keyword">uint16</span> <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 底层连接对象,net.Conn 实例</span></span><br><span class="line">    Conn net.Conn <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 包含过滤或未导出的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientSessionState 对象的缓存</span></span><br><span class="line"><span class="keyword">type</span> ClientSessionCache <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Get搜索与给出的键相关联的*ClientSessionState并用ok说明是否找到</span></span><br><span class="line">    Get(sessionKey <span class="keyword">string</span>) (session *ClientSessionState, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// Put将*ClientSessionState与给出的键关联并写入缓存中</span></span><br><span class="line">    Put(sessionKey <span class="keyword">string</span>, cs *ClientSessionState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tls 相关配置</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 随机数生成,默认使用 `crypto/rand` 包中加密随机数生成器</span></span><br><span class="line">    <span class="comment">// 必须可以安全地被多个 goroutine  使用</span></span><br><span class="line">    Rand io.Reader</span><br><span class="line">    <span class="comment">// 返回当前时间的函数.默认使用 time.Now</span></span><br><span class="line">    Time <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line">    <span class="comment">// 一个或多个证书链以呈现给连接另一端.将自动选择与之匹配的证书</span></span><br><span class="line">    <span class="comment">// 服务端必须设置 Certificates,GetCertificate 或 GetConfigForClient 之一</span></span><br><span class="line">    <span class="comment">// 客户端可以设置 Certificates 或 GetCertificate</span></span><br><span class="line">    <span class="comment">// 注意: 如果有多个证书,且没有设置可选的 Leaf 字段,选择证书过程可能会导致大量的握手成本</span></span><br><span class="line">    Certificates []Certificate</span><br><span class="line">    <span class="comment">// 证书名称到 Certificates 的映射</span></span><br><span class="line">    NameToCertificate <span class="keyword">map</span>[<span class="keyword">string</span>]*Certificate</span><br><span class="line">    <span class="comment">// 返回基于给定 ClientHelloInfo 的证书.当客户端提供 SNI 信息或 Certificates 为空时,才会调用该方法</span></span><br><span class="line">    GetCertificate <span class="function"><span class="keyword">func</span><span class="params">(*ClientHelloInfo)</span> <span class="params">(*Certificate, error)</span> // <span class="title">Go</span> 1.4</span></span><br><span class="line">    <span class="comment">// 服务端从客户端请求证书时,调用该函数获取客户端证书.如果定义了此成员变量,Certificates 内容将被忽略</span></span><br><span class="line">    GetClientCertificate <span class="function"><span class="keyword">func</span><span class="params">(*CertificateRequestInfo)</span> <span class="params">(*Certificate, error)</span> // <span class="title">Go</span> 1.8</span></span><br><span class="line">    <span class="comment">// 收到客户端 ClientHello 后调用此函数为获取客户端配置</span></span><br><span class="line">    GetConfigForClient <span class="function"><span class="keyword">func</span><span class="params">(*ClientHelloInfo)</span> <span class="params">(*Config, error)</span> // <span class="title">Go</span> 1.8</span></span><br><span class="line">    <span class="comment">// TLS 客户端或服务端进行常规证书验证后,调用该函数进行 TLS 握手验证</span></span><br><span class="line">    VerifyPeerCertificate <span class="function"><span class="keyword">func</span><span class="params">(rawCerts [][]<span class="keyword">byte</span>, verifiedChains [][]*x509.Certificate)</span> <span class="title">error</span> // <span class="title">Go</span> 1.8</span></span><br><span class="line">    <span class="comment">// 客户端验证服务端证书 CA</span></span><br><span class="line">    <span class="comment">// 如果为 nil,则使用主机的 CA 集合</span></span><br><span class="line">    RootCAs *x509.CertPool</span><br><span class="line">    <span class="comment">// 按优先级顺序列出支持的应用层协议</span></span><br><span class="line">    NextProtos []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// TLS 服务端主机名称,用于验证证书的主机名.除非使用 InsecureSkipVerify 跳过主机名认证</span></span><br><span class="line">    ServerName <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// TLS 服务端对客户端身份验证的策略,默认为 NoClientCert,不对客户端做身份验证</span></span><br><span class="line">    ClientAuth ClientAuthType</span><br><span class="line">    <span class="comment">// 客户端证书颁发机构,如果 ClientAuth 设置需要验证客户端证书,服务端将使用这些证书颁发机构</span></span><br><span class="line">    ClientCAs *x509.CertPool</span><br><span class="line">    <span class="comment">// 客户端是否跳过验证服务端证书和主机名</span></span><br><span class="line">    InsecureSkipVerify <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 直到 TLS1.2 版本支持的密码套件列表</span></span><br><span class="line">    CipherSuites []<span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// 是否优先选择服务端密码套件</span></span><br><span class="line">    PreferServerCipherSuites <span class="keyword">bool</span> <span class="comment">// Go 1.1</span></span><br><span class="line">    <span class="comment">// 是否禁用 ticket 会话和 PSK 会话支持</span></span><br><span class="line">    SessionTicketsDisabled <span class="keyword">bool</span> <span class="comment">// Go 1.1</span></span><br><span class="line">    <span class="comment">// 使用 SessionTicketKey 提供会话恢复</span></span><br><span class="line">    SessionTicketKey [<span class="number">32</span>]<span class="keyword">byte</span> <span class="comment">// Go 1.1</span></span><br><span class="line">    <span class="comment">// 客户端 ClientSessionState 缓存</span></span><br><span class="line">    ClientSessionCache ClientSessionCache <span class="comment">// Go 1.3</span></span><br><span class="line">    <span class="comment">// 支持的最低版本,TLs 1.0 为最小值</span></span><br><span class="line">    MinVersion <span class="keyword">uint16</span> <span class="comment">// Go 1.2</span></span><br><span class="line">    <span class="comment">// 支持的最高版本,TLS 1.3 为最大值</span></span><br><span class="line">    MaxVersion <span class="keyword">uint16</span> <span class="comment">// Go 1.2</span></span><br><span class="line"></span><br><span class="line">    CurvePreferences []CurveID <span class="comment">// Go 1.3</span></span><br><span class="line">    DynamicRecordSizingDisabled <span class="keyword">bool</span> <span class="comment">// Go 1.7</span></span><br><span class="line">    Renegotiation RenegotiationSupport <span class="comment">// Go 1.7</span></span><br><span class="line">    KeyLogWriter io.Writer <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 包含其它过滤或未导出的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全连接.实现了 `net.Conn` 接口</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接状态信息</span></span><br><span class="line"><span class="keyword">type</span> ConnectionState <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 连接使用的 TLS 版本</span></span><br><span class="line">    Version <span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// TLS 握手是否完成</span></span><br><span class="line">    HandshakeComplete <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 是否连接恢复先前的TLS连接</span></span><br><span class="line">    DidResume <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 使用的加密套件</span></span><br><span class="line">    CipherSuite <span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// 协商的协议</span></span><br><span class="line">    NegotiatedProtocol <span class="keyword">string</span></span><br><span class="line">    NegotiatedProtocolIsMutual <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 客户端请求的主机名</span></span><br><span class="line">    ServerName <span class="keyword">string</span></span><br><span class="line">    PeerCertificates []*x509.Certificate</span><br><span class="line">    VerifiedChains [][]*x509.Certificate</span><br><span class="line">    SignedCertificateTimestamps [][]<span class="keyword">byte</span></span><br><span class="line">    OCSPResponse []<span class="keyword">byte</span></span><br><span class="line">    TLSUnique []<span class="keyword">byte</span> <span class="comment">// Go 1.4</span></span><br><span class="line">    <span class="comment">// 包含过滤或未导出的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 签名算法</span></span><br><span class="line"><span class="keyword">type</span> SignatureScheme <span class="keyword">uint16</span></span><br></pre></td></tr></table></figure>

<h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密套件</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// TLS 1.0 - 1.2 cipher suites.</span></span><br><span class="line">    TLS_RSA_WITH_RC4_128_SHA                      <span class="keyword">uint16</span> = <span class="number">0x0005</span></span><br><span class="line">    TLS_RSA_WITH_3DES_EDE_CBC_SHA                 <span class="keyword">uint16</span> = <span class="number">0x000a</span></span><br><span class="line">    TLS_RSA_WITH_AES_128_CBC_SHA                  <span class="keyword">uint16</span> = <span class="number">0x002f</span></span><br><span class="line">    TLS_RSA_WITH_AES_256_CBC_SHA                  <span class="keyword">uint16</span> = <span class="number">0x0035</span></span><br><span class="line">    TLS_RSA_WITH_AES_128_CBC_SHA256               <span class="keyword">uint16</span> = <span class="number">0x003c</span></span><br><span class="line">    TLS_RSA_WITH_AES_128_GCM_SHA256               <span class="keyword">uint16</span> = <span class="number">0x009c</span></span><br><span class="line">    TLS_RSA_WITH_AES_256_GCM_SHA384               <span class="keyword">uint16</span> = <span class="number">0x009d</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA              <span class="keyword">uint16</span> = <span class="number">0xc007</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA          <span class="keyword">uint16</span> = <span class="number">0xc009</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA          <span class="keyword">uint16</span> = <span class="number">0xc00a</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_RC4_128_SHA                <span class="keyword">uint16</span> = <span class="number">0xc011</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA           <span class="keyword">uint16</span> = <span class="number">0xc012</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA            <span class="keyword">uint16</span> = <span class="number">0xc013</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA            <span class="keyword">uint16</span> = <span class="number">0xc014</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256       <span class="keyword">uint16</span> = <span class="number">0xc023</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256         <span class="keyword">uint16</span> = <span class="number">0xc027</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256         <span class="keyword">uint16</span> = <span class="number">0xc02f</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256       <span class="keyword">uint16</span> = <span class="number">0xc02b</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         <span class="keyword">uint16</span> = <span class="number">0xc030</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384       <span class="keyword">uint16</span> = <span class="number">0xc02c</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   <span class="keyword">uint16</span> = <span class="number">0xcca8</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 <span class="keyword">uint16</span> = <span class="number">0xcca9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS 1.3 cipher suites.</span></span><br><span class="line">    TLS_AES_128_GCM_SHA256       <span class="keyword">uint16</span> = <span class="number">0x1301</span></span><br><span class="line">    TLS_AES_256_GCM_SHA384       <span class="keyword">uint16</span> = <span class="number">0x1302</span></span><br><span class="line">    TLS_CHACHA20_POLY1305_SHA256 <span class="keyword">uint16</span> = <span class="number">0x1303</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator</span></span><br><span class="line">    <span class="comment">// that the client is doing version fallback. See RFC 7507.</span></span><br><span class="line">    TLS_FALLBACK_SCSV <span class="keyword">uint16</span> = <span class="number">0x5600</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Legacy names for the corresponding cipher suites with the correct _SHA256</span></span><br><span class="line">    <span class="comment">// suffix, retained for backward compatibility.</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305   = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</span><br><span class="line">)</span><br><span class="line"><span class="comment">// TLS 版本</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    VersionTLS10 = <span class="number">0x0301</span></span><br><span class="line">    VersionTLS11 = <span class="number">0x0302</span></span><br><span class="line">    VersionTLS12 = <span class="number">0x0303</span></span><br><span class="line">    VersionTLS13 = <span class="number">0x0304</span></span><br><span class="line">    <span class="comment">// 过时</span></span><br><span class="line">    VersionSSL30 = <span class="number">0x0300</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 客户端认证类别</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    NoClientCert ClientAuthType = <span class="literal">iota</span></span><br><span class="line">    RequestClientCert</span><br><span class="line">    RequireAnyClientCert</span><br><span class="line">    VerifyClientCertIfGiven</span><br><span class="line">    RequireAndVerifyClientCert</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 签名算法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// RSASSA-PKCS1-v1_5 algorithms.</span></span><br><span class="line">    PKCS1WithSHA256 SignatureScheme = <span class="number">0x0401</span></span><br><span class="line">    PKCS1WithSHA384 SignatureScheme = <span class="number">0x0501</span></span><br><span class="line">    PKCS1WithSHA512 SignatureScheme = <span class="number">0x0601</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RSASSA-PSS algorithms with public key OID rsaEncryption.</span></span><br><span class="line">    PSSWithSHA256 SignatureScheme = <span class="number">0x0804</span></span><br><span class="line">    PSSWithSHA384 SignatureScheme = <span class="number">0x0805</span></span><br><span class="line">    PSSWithSHA512 SignatureScheme = <span class="number">0x0806</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.</span></span><br><span class="line">    ECDSAWithP256AndSHA256 SignatureScheme = <span class="number">0x0403</span></span><br><span class="line">    ECDSAWithP384AndSHA384 SignatureScheme = <span class="number">0x0503</span></span><br><span class="line">    ECDSAWithP521AndSHA512 SignatureScheme = <span class="number">0x0603</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// EdDSA algorithms.</span></span><br><span class="line">    Ed25519 SignatureScheme = <span class="number">0x0807</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Legacy signature and hash algorithms for TLS 1.2.</span></span><br><span class="line">    PKCS1WithSHA1 SignatureScheme = <span class="number">0x0201</span></span><br><span class="line">    ECDSAWithSHA1 SignatureScheme = <span class="number">0x0203</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="tls-包函数"><a href="#tls-包函数" class="headerlink" title="tls 包函数"></a><code>tls</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定 Network 和 addr 创建 TLS 监听器, config 必须至少包含一个证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, laddr <span class="keyword">string</span>, config *Config)</span> <span class="params">(net.Listener, error)</span></span></span><br><span class="line"><span class="comment">// 通过 inner 监听器创建一个新监听器,并包装与服务端的每个连接.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewListener</span><span class="params">(inner net.Listener, config *Config)</span> <span class="title">net</span>.<span class="title">Listener</span></span></span><br><span class="line"><span class="comment">// 读取并解析一对文件获取公钥私钥.这些文件必须是  pem 编码的.返回文件中包含的证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadX509KeyPair</span><span class="params">(certFile, keyFile <span class="keyword">string</span>)</span> <span class="params">(cert Certificate, err error)</span></span></span><br><span class="line"><span class="comment">// 解析一对 pem 编码格式的数据获取公钥私钥.返回数据中包含的证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">X509KeyPair</span><span class="params">(certPEMBlock, keyPEMBlock []<span class="keyword">byte</span>)</span> <span class="params">(cert Certificate, err error)</span></span></span><br><span class="line"><span class="comment">// 创建 LRU(最近最少使用) 缓存策略的 ClientSessionState.如果 capacity&lt;1 会使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUClientSessionCache</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">ClientSessionCache</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 conn 作为下层传输接口返回一个 TL S连接的客户端.config 必须是非 nil 的且必须设置了 ServerName 或者 InsecureSkipVerify 字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Client</span><span class="params">(conn net.Conn, config *Config)</span> *<span class="title">Conn</span></span></span><br><span class="line"><span class="comment">// 使用 conn 作为下层传输接口返回一个 TLS 连接的服务端.config 必须是非 nil 的且必须含有至少一个证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Server</span><span class="params">(conn net.Conn, config *Config)</span> *<span class="title">Conn</span></span></span><br><span class="line"><span class="comment">// 使用 net.Dial 连接指定 network(协议)和 addr(地址),然后根据 config 发起 TLS 握手.返回生成的 TLS 连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, addr <span class="keyword">string</span>, config *Config)</span> <span class="params">(*Conn, error)</span></span></span><br><span class="line"><span class="comment">// 使用 net.Dialer 连接指定地址,然后发起 TLS 握手,返回生成的 TLS 连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialWithDialer</span><span class="params">(dialer *net.Dialer, network, addr <span class="keyword">string</span>, config *Config)</span> <span class="params">(*Conn, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Conn-结构体方法"><a href="#Conn-结构体方法" class="headerlink" title="Conn 结构体方法"></a><code>Conn</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回当前连接的状态信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">ConnectionState</span><span class="params">()</span> <span class="title">ConnectionState</span></span></span><br><span class="line"><span class="comment">// 握手.本包大多数不需要显示调用,第一次 Read 或 Write 会自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Handshake</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回本地网络地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">LocalAddr</span><span class="params">()</span> <span class="title">net</span>.<span class="title">Addr</span></span></span><br><span class="line"><span class="comment">// 从 TLS 服务器返回装订的 OCSP 响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">OCSPResponse</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="comment">// 从连接中读取数据到 b.可能会超时返回一个 net.Error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// 远程网络地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">RemoteAddr</span><span class="params">()</span> <span class="title">net</span>.<span class="title">Addr</span></span></span><br><span class="line"><span class="comment">// 设置与连接关联的读写期限.t=0表示完全不会超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetReadDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetWriteDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 检查连接的证书链对于 host 是否有效.返回问题的描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">VerifyHostname</span><span class="params">(host <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 将数据写入连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 之 Elasticsearch 查询介绍</title>
    <url>/2020/05/22/ELK-Stack-Elasticsearch-search/</url>
    <content><![CDATA[<p>Elasticsearch(ES)是一个基于 <a href="https://lucene.apache.org/" target="_blank" rel="noopener">Apache Lucene(TM)</a> 构建的开源分布式全文搜索引擎.它通过 RESTful API 来隐藏 Lucene 的复杂性,从而让全文搜索变得简单.它作为分布式文档数据库,其中存储的每个字段及值均可被索引.</p>
<p>Elasticsearch 有如下特性:</p>
<ul>
<li>分布式的数据存储工具,实时分析搜索引擎.存储在其中的每个字段都被索引并可被搜索</li>
<li>提供 RESTful 风格的 API 接口,简单易用</li>
<li>易扩展.它可以扩展到上百台服务器,处理 PB 级结构化或非结构化数据</li>
</ul>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><code>index</code> 索引</li>
</ul>
<p>索引是多个具有相似特性的文档集合.ES 中可以创建任意数量的索引,但索引名必须使用小写字母</p>
<ul>
<li><code>type</code> 类型</li>
</ul>
<p>类型是索引内部的逻辑分区.一般来说,类型定义为具有公共字段集的文档</p>
<ul>
<li><code>document</code> 文档</li>
</ul>
<p>文档是可以被搜索的基本单位,它基于 JSON 格式表示,一般包含多个字段.</p>
<p>可以简单的将 ES 中基本概念与关系型数据库概念对应起来:</p>
<table>
<thead>
<tr>
<th align="center">Elasticsearch</th>
<th align="center">关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">index 索引</td>
<td align="center">database 数据库</td>
</tr>
<tr>
<td align="center">type 类型</td>
<td align="center">table 表</td>
</tr>
<tr>
<td align="center">document 文档</td>
<td align="center">row 数据行</td>
</tr>
<tr>
<td align="center">field 字段</td>
<td align="center">column 数据列</td>
</tr>
<tr>
<td align="center">mapping 映射</td>
<td align="center">data_type 数据类型</td>
</tr>
</tbody></table>
<h3 id="集群概念"><a href="#集群概念" class="headerlink" title="集群概念"></a>集群概念</h3><ul>
<li><code>node</code> 节点</li>
</ul>
<p>节点是运行 Elasticsearch 实例的主机.它用于存储数据,参与集群索引及搜索操作.同一个集群内的节点名必须唯一,通过 <code>node.name</code> 进行设置</p>
<ul>
<li><code>cluster</code> 集群</li>
</ul>
<p>集群是一个或多个 Elasticsearch 节点的集合.这些节点共同存储整个数据,并在所有节点上提供联合索引和搜索功能.一个节点只能加入一个集群</p>
<ul>
<li><code>shard</code> 分片</li>
</ul>
<p>Elasticsearch 将索引切为多个小的片段,每一个片段都是一个分片.分片都是独立且完整的小索引,提供分布式读写负载均衡功能</p>
<p>用户可以通过 <code>index.number_of_shards</code> 设定分片数量,设定后不可更改.默认为 5</p>
<ul>
<li><code>replica</code> 副本</li>
</ul>
<p>ES 将分片保存为多个副本,提供冗余高可用.副本之间为主从机制,可能存在主从数据不同步的问题.主读写,从只读</p>
<p>用户可以通过 <code>index.number_of_replicas</code> 设置副本数量,设置后可进行更改</p>
<h2 id="ES-Cluster-工作原理"><a href="#ES-Cluster-工作原理" class="headerlink" title="ES Cluster 工作原理"></a>ES Cluster 工作原理</h2><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><ol>
<li>ES 启动时,通过多播(默认)或单播的方式在 tcp/9300 查找同一集群中的其它节点,并与之建立通信</li>
<li>集群中选举出一个主节点负责管理整个集群状态,以及在集群范围内决定各个分片的分配方式.站在用户角度而言,每个节点均可接收并响应用户的各类请求</li>
<li>假如集群中某一节点故障,主节点会读取集群状态信息,并启动修复过程,进入修复模式.此时,集群处于 yellow 状态,所有的副本分片处于为未分配状态.</li>
<li>在此时模式中,主节点会检查所有可用分片,并确定各主分片及其对应的副本数量是否满足配额.假如故障节点包含某一主分片,则需要从各个副本分片中选举出一个作为主分片.假如故障节点包含某一副本分片,则集群会启动处理过程,为之重新建立副本,直到满足配额.</li>
</ol>
<p>集群状态: green(健康), yellow(亚健康,修复模式), red(故障)</p>
<h3 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h3><p>在搜索过程中,由于不知道哪个分片中的文档会匹配到搜索条件,所以一个搜索请求不得不通过查询每一个我们感兴趣的索引的分片副本来查看是否含有任何匹配的文档.该过程称为<code>查询</code>.</p>
<p>但是,找到所有匹配的文档只完成了这件事的一半.在搜索 <code>_search</code> API 返回结果前,来自多个分片的结果必须被组合放到一个有序列表中.该过程称为<code>取回</code></p>
<blockquote>
<ul>
<li>查询阶段</li>
</ul>
</blockquote>
<p>当搜索请求被发送到 ES 节点,这个节点就变成了协调节点.这个节点的工作是向指定索引的所有分片广播搜索请求并且把它们的响应整合成一个全局的有序结果集.</p>
<p>在初始化查询阶段,查询请求会向索引中的每个分片副本广播,每个分片在本地执行搜索并建立匹配文档的优先队列.一个优先队列只是一个存有前 n 个匹配文档的有序列表.这个优先队列的大小由分页参数 <code>from</code> 和 <code>size</code> 决定,一般为 <code>from + size</code></p>
<blockquote>
<ul>
<li>取回阶段</li>
</ul>
</blockquote>
<p>协调节点辨别出哪个文档需要取回,并且向相关分片发出 GET 请求.每个分片加载文档并且根据需要处理它们,然后再将文档返回协调节点.等到所有符合条件的文档都被取回,协调节点会将结果返回给客户端.</p>
<h2 id="Document-APIs"><a href="#Document-APIs" class="headerlink" title="Document APIs"></a>Document APIs</h2><p>文档由元数据和内容组成.一般来说,元数据包括文档的 <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code> 等字段组成, 其中 <code>_index</code>, <code>_type</code>, <code>_id</code> 可用于唯一确定一个文档.<code>_version</code> 用于标识该文档的版本信息.文档内容由 <code>_source</code> 字段组成,其中包含我们存储文档时提交的 JSON 信息.</p>
<h3 id="通用请求路径参数"><a href="#通用请求路径参数" class="headerlink" title="通用请求路径参数"></a>通用请求路径参数</h3><p>以下是通用的路径请求参数,在不同 API 中可能有不同的选填或必填需求.</p>
<ul>
<li><code>index</code>: 指定索引名称.必填参数</li>
<li><code>_id</code>: 文档的唯一标识.PUT,GET,HEAD,DELETE 请求必填.POST 请求可以省略,会自动生成.</li>
</ul>
<h3 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h3><p>将 JSON 文档添加到指定索引并使其可搜索,如果文档已存在,更新文档并增加其版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;&lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_doc&#x2F;</span><br><span class="line">PUT &#x2F;&lt;index&gt;&#x2F;_create&#x2F;&lt;_id&gt;</span><br><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_create&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Get-API"><a href="#Get-API" class="headerlink" title="Get API"></a>Get API</h3><p>使用 Get 请求从特定索引中检索文档或字段,使用 HEAD 请求验证文档是否存在. 使用 <code>_source</code> 对文档内容操作.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br><span class="line">HEAD &lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br><span class="line">GET &lt;index&gt;&#x2F;_source&#x2F;&lt;_id&gt;</span><br><span class="line">HEAD &lt;index&gt;&#x2F;_source&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求参数</p>
</blockquote>
<ul>
<li><code>routing</code>: 只在指定分片中进行搜索.我们可以在建立索引时提供一个自定义的 <code>routing</code> 参数来保证所有相关的文档(如属于单个用户的文档)被存放在一个单独的分片中.在搜索时,我们可以指定一个或多个 <code>routing</code> 值来限制只搜索指定的分片.</li>
<li><code>_source</code>: 是否返回 _source 文档内容,默认为 true</li>
<li><code>_source_excludes</code>: 从返回的 _source 字段中排除的字段列表</li>
<li><code>_source_includes</code>: 从 _source 字段提取并返回的字段列表</li>
</ul>
<h3 id="Delete-API"><a href="#Delete-API" class="headerlink" title="Delete API"></a>Delete API</h3><p>从指定的索引中删除指定的文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;&lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Delete-by-query-API"><a href="#Delete-by-query-API" class="headerlink" title="Delete by query API"></a>Delete by query API</h3><p>删除与指定查询匹配的文档,<code>&lt;index&gt;</code> 为选填参数,且支持使用逗号指定多个,默认为 <code>_all</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_delete_by_query</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求参数</p>
</blockquote>
<ul>
<li><code>from</code>: 文档的开始位置.默认为 0</li>
<li><code>max_docs</code>: 要处理的最大文档数,默认为所有</li>
<li><code>q</code>: 使用 Lucene 查询语法查询</li>
<li><code>routing</code>: 只在指定分片中进行搜索</li>
<li><code>scroll_size</code>: 操作滚动的大小,默认 100</li>
<li><code>sort</code>: 排序,以逗号分隔的 <code>&lt;field&gt;:&lt;direction&gt;</code> 列表</li>
<li><code>_source</code>: 是否返回 _source 文档内容,默认为 true</li>
<li><code>_source_excludes</code>: 从返回的 _source 字段中排除的字段列表</li>
<li><code>_source_includes</code>: 从 _source 字段提取并返回的字段列表</li>
</ul>
<blockquote>
<p>请求体</p>
</blockquote>
<ul>
<li><code>query</code>: <code>Query DSL</code> 格式的请求,用于筛选文档</li>
</ul>
<h3 id="Update-API"><a href="#Update-API" class="headerlink" title="Update API"></a>Update API</h3><p>使用指定内容或脚本更新指定文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_update&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible 用户指南</title>
    <url>/2020/06/10/ansible-user-guide/</url>
    <content><![CDATA[<h2 id="基本部署"><a href="#基本部署" class="headerlink" title="基本部署"></a>基本部署</h2><p>ansible依赖于Python 2.6或更高的版本,paramiko,PyYAML及Jinja2</p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install python-jinja2 PyYAML python-paramiko python-babel python-crypto</span></span><br><span class="line"><span class="comment"># tar xf ansible-1.5.4.tar.gz</span></span><br><span class="line"><span class="comment"># cd ansible-1.5.4</span></span><br><span class="line"><span class="comment"># python setup.py build</span></span><br><span class="line"><span class="comment"># python setup.py install</span></span><br><span class="line"><span class="comment"># mkdir /etc/ansible</span></span><br><span class="line"><span class="comment"># cp -r examples/* /etc/ansible</span></span><br></pre></td></tr></table></figure>

<h3 id="rpm-包安装"><a href="#rpm-包安装" class="headerlink" title="rpm 包安装"></a>rpm 包安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install epel-release</span></span><br><span class="line"><span class="comment"># yum install ansible</span></span><br></pre></td></tr></table></figure>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>ansible 通过 ssh 实现配置管理,应用部署,任务执行等功能.因此,需要事先配置 ansible 端能基于密钥认证的方式联系各被管理节点</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如下为 <code>/etc/ansible/ansible.cfg</code> 配置文件常用选项及含义</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[defaults]</span></span><br><span class="line"><span class="comment">#inventory      = /etc/ansible/hosts    # 主机列表清单文件</span></span><br><span class="line"><span class="comment">#remote_tmp     = ~/.ansible/tmp    # 远程主机的工作目录,相关文件会被复制过来,等执行结束后删除</span></span><br><span class="line"><span class="comment">#local_tmp      = ~/.ansible/tmp    # 本地工作目录</span></span><br><span class="line"><span class="comment">#forks          = 5 # 默认并发数</span></span><br><span class="line"><span class="comment">#sudo_user      = root  # 默认 sudo 用户</span></span><br><span class="line"><span class="comment">#ask_sudo_pass = True   # 是否需要询问sudo 用户密码</span></span><br><span class="line"><span class="comment">#ask_pass      = True</span></span><br><span class="line"><span class="comment">#transport      = smart # 传输/连接模式</span></span><br><span class="line"><span class="comment">#remote_port    = 22    # 远程主机默认 ssh 端口</span></span><br><span class="line"><span class="comment">#roles_path    = /etc/ansible/roles  # 默认的 roles 目录</span></span><br><span class="line"><span class="comment">#timeout = 10 # 默认的 SSH 登录超时时间</span></span><br><span class="line"><span class="attr">log_path</span> = /var/log/ansible.log <span class="comment"># 日志文件</span></span><br><span class="line"><span class="comment">#deprecation_warnings = True # 是否输出选项/模块/功能过期信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启用 SSH 连接管道,开启此选项可以减少在远程服务器上执行模块所需要的 SSH 连接数量,可以提升性能.</span></span><br><span class="line"><span class="comment"># 若开启,使用 sudo 时,需要在 `/etc/sudoers` 禁用 "requiretty"</span></span><br><span class="line"><span class="attr">pipelining</span> = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否检查主机的 host_key,如果设置为 True,则需要在登录时输入 yes</span></span><br><span class="line"><span class="attr">host_key_checking</span> = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># facts 收集配置</span></span><br><span class="line"><span class="comment"># - smart 表示默认收集,但是如果已经收集了,则不再进行收集.此选项可将 facts 缓存到文件或 redis 中,而不用每次都进行收集</span></span><br><span class="line"><span class="comment"># - implicit 表示始终收集,除非使用 `gather_facts: False`</span></span><br><span class="line"><span class="comment"># - explicit 表示不进行收集,除非显示指定 `gather_facts: True`</span></span><br><span class="line"><span class="comment">#gathering = implicit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># facts 缓存配置,默认保存在内存中.也可设置为可持久化的配置(需要同时设置 `fact_caching_connection` 配置),如下</span></span><br><span class="line"><span class="comment"># - redis: 保存到 redis 中(需要安装 redis 连接工具 `pip install redis`)</span></span><br><span class="line"><span class="comment"># - jsonfile: 保存到 json 文件中</span></span><br><span class="line"><span class="comment">#fact_caching = memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存/读取缓存的位置</span></span><br><span class="line"><span class="comment"># redis: `host:port:database`</span></span><br><span class="line"><span class="comment"># jsonfile: `/path/to/jsonfile`</span></span><br><span class="line"><span class="comment">#fact_caching_connection = /tmp</span></span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><code>ansible-doc</code>: ansible 模块的帮助文档</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible-doc</span><br><span class="line">    -l: 列出所有可用的模块</span><br><span class="line">    -s &lt;module_name&gt;: 查看指定模块的使用帮助</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ansible</code>: ansible 执行单个任务,</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt; [-m module_name] [-a args] [options]</span><br><span class="line">  &lt;host-pattern&gt;  这次命令对主机清单中哪些主机生效,以下均支持正则表达式匹配,以 &#96;~&#96; 开头</span><br><span class="line">    &#96;all&#96; 或 &#96;*&#96;: 清单文件中所有主机</span><br><span class="line">    &#96;host&#96;: 单个主机,使用 &#96;,&#96; 或 &#96;:&#96; 分割可指定多个主机</span><br><span class="line">    &#96;group&#96;: 单个主机组,使用 &#96;,&#96; 或 &#96;:&#96; 分割可指定多个主机组</span><br><span class="line">    &#96;group[index]&#96;: 表示主机组中指定索引的主机,与 Python 中列表使用方式相同</span><br><span class="line">    &#96;group_1:!group_2&#96;: 使用 &#96;!&#96; 表示在主机组 group_1 中,而不在主机组 group_2 中</span><br><span class="line">    &#96;group_1:&amp;group_2&#96;: 使用 &#96;&amp;&#96; 表示 group_1,group_2 主机组中共同包含的主机</span><br><span class="line"></span><br><span class="line">    -m module_name  要使用的模块</span><br><span class="line">    -a args         模块特有的参数</span><br><span class="line"></span><br><span class="line">  [options]</span><br><span class="line">    --ask-vault-pass    询问加密后的密码</span><br><span class="line">    --vault-password-file   加密后的密码文件</span><br><span class="line">    -e EXTRA_VARS, --extra-vars EXTRA_VARS  传入 &#96;key&#x3D;value&#96; 或 json 格式的变量.或包含变量的 YAML&#x2F;JSON 文件,需要在指定的文件名前加上 &#96;@&#96; 符号</span><br><span class="line">    -f FORKS, --forks FORKS     一次处理多少个主机,默认为 5</span><br><span class="line">    -i INVENTORY, --inventory INVENTORY     指定主机清单文件,默认为 &#96;&#x2F;etc&#x2F;ansible&#x2F;hosts&#96;</span><br><span class="line">    -k, --ask-pass  指定连接密码</span><br><span class="line">    -u REMOTE_USER, --user&#x3D;REMOTE_USER  指定连接的远程用户,默认为当前用户</span><br><span class="line">    -T TIMEOUT, --timeout&#x3D;TIMEOUT   指定连接的超时时间,默认为 10</span><br><span class="line">    -b, --become    指定执行命令的用户</span><br><span class="line">    -K, --ask-become-pass   指定改变用户的密码</span><br><span class="line">    --become-method&#x3D;BECOME_METHOD   指定变更用户的方式,可使用 &#96;ansible-doc -t become -l&#96; 查看.默认 sudo</span><br><span class="line">    --become-user&#x3D;USER   指定执行命令的用户,默认 root</span><br><span class="line"></span><br><span class="line">    -l SUBSET, --limit&#x3D;SUBSET 指定部分主机运行模块</span><br><span class="line">    --list-hosts    列出匹配的主机列表</span><br><span class="line">    --check     以检查模式运行,不做任何修改,尝试预测发生的改变</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ansible-playbook</code>: 运行 Ansible playbools,在目标主机上执行已定义的任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible-playbook [options] &lt;playbook.yml&gt; [playbook2 ...]</span><br><span class="line"></span><br><span class="line">  [options] 支持以上 ansible 的列出的所有选项</span><br><span class="line">  --list-tags       列出 Playbook 中所有 Tag</span><br><span class="line">  --list-tasks      列出 Playbook 中所有 Tasks</span><br><span class="line">  --skip-tags SKIP_TAGS     执行 Playbook 时,跳过带有指定 Tag 的 Task</span><br><span class="line">  -t TAGS, --tags TAGS      只执行指定 Tag 的 Task</span><br><span class="line">  --vault-id VAULT_IDS      指定要使用的 vault id</span><br><span class="line">  --vault-password-file     指定 vault 密码文件</span><br></pre></td></tr></table></figure>

<p>更多命令及参数,详见官方文档 - <a href="https://docs.ansible.com/ansible/latest/user_guide/command_line_tools.html" target="_blank" rel="noopener">Working with command line tools</a>.</p>
<h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><p>模块执行是幂等的,这意味着多次执行是安全的,因为其结果均一致</p>
<ul>
<li><code>command</code> 命令模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (默认模块)用于在远程主机执行命令;不能使用变量,管道等</span></span><br><span class="line"><span class="comment"># ansible all -a 'date'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>archive</code> 打包模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path    远程绝对路径,指定要打包的文件路径</span><br><span class="line">exclude_path    排除的远程绝对路径</span><br><span class="line">format  打包的方式,bz2, gz, tar, xz, zip,默认 gz</span><br><span class="line">dest    打包后的文件路径</span><br><span class="line">mode</span><br></pre></td></tr></table></figure>

<ul>
<li><code>copy</code> 复制文件模块(复制本地文件到远程主机的指定位置)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src     定义本地源文件路径</span><br><span class="line">dest    定义远程目录文件路径(绝对路径)</span><br><span class="line">owner   属主</span><br><span class="line">group   属组</span><br><span class="line">mode    权限</span><br><span class="line"></span><br><span class="line">content 将内容直接输入到文件中</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible all -m copy -a 'src=/etc/fstab dest=/tmp/fstab.ansible owner=root mode=640'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cron</code> 计划任务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置计划任务,其中job为必须参数</span></span><br><span class="line"><span class="comment"># 如果其它不写,默认为*</span></span><br><span class="line">name    指定名称,最好指定,方便移除</span><br><span class="line">minute  指定分钟</span><br><span class="line">hour    指定小时</span><br><span class="line">day     指定天</span><br><span class="line">month   指定月份</span><br><span class="line">weekday 表示周几</span><br><span class="line">job     指定任务,必须</span><br><span class="line">state   表示是添加还是删除</span><br><span class="line">    present：创建计划任务</span><br><span class="line">    absent：移除</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible webserver -m cron -a 'minute="10" job="/bin/echo hello" name="job_name"' # 创建任务,每小时的10分钟执行</span></span><br><span class="line"><span class="comment"># ansible webserver -m cron -a 'name="job_name" state=absent'  # 移除任务</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>debug</code> 执行时打印信息模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msg     要打印的信息</span><br><span class="line">var     要打印的变量名,与 msg 互斥</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fail</code> 自定义失败信息模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msg     自定义的失败信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般与 when 一起使用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>file</code> 文件管理模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path    指定远程主机上被管理的文件</span><br><span class="line">group   指定文件属组</span><br><span class="line">user    指定文件属组</span><br><span class="line">mode    指定文件权限</span><br><span class="line">state   表示添加/删除/创建链接文件</span><br><span class="line">    absent: 递归删除文件/目录,并取消符号链接</span><br><span class="line">    directory: 创建文件夹,相当于 mkdir -p &lt;path&gt;</span><br><span class="line">    file: 返回文件的当前状态</span><br><span class="line">    hard: 创建硬链接</span><br><span class="line">    link: 创建软链接</span><br><span class="line">    touch: 相当于 touch 命令</span><br><span class="line"></span><br><span class="line">src     当state为hard或link时指定的链接文件位置</span><br><span class="line">force   强制进行操作</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible all -m file -a 'path=/tmp/link_file src=/tmp/source_file state=link'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>get_url</code> 从指定 url 下载文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">url     下载文件路径</span><br><span class="line">dest    下载文件保存路径</span><br><span class="line"></span><br><span class="line">mode    权限</span><br><span class="line">timeout 连接超时时间</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible localhost -m get_url -a 'url=http://get_some_files dest=/tmp/ timeout=10 mode=+x'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>group</code> 组管理模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gid     gid</span><br><span class="line">name    组名</span><br><span class="line">state   状态,默认为present创建,使用absent删除</span><br><span class="line">system  是否是系统组</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible webserver -m group -a 'name=mysql gid=306 system=yes'</span></span><br><span class="line"><span class="comment"># ansible webserver -m user -a 'name=mysql uid=306 system=yes group=mysql'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ini_file</code> 创建/修改 ini 文件中的配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dest    ini 文件路径</span><br><span class="line">section ini 文件内中部分的概念 <span class="string">"[]"</span> 内内容</span><br><span class="line">option  ini 文件配置</span><br><span class="line">value   ini 文件配置值</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible localhost -m ini_file -a 'dest=/tmp/my.ini section=mysqlclient option=port value=3306'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>lineinfile</code> 修改行格式的配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path    指定配置文件路径</span><br><span class="line">state   指定行的状态</span><br><span class="line">regexp  指定行格式的正则表达式,使用正则表达式匹配需要修改的行</span><br><span class="line">line    指定匹配行的字符串</span><br><span class="line"></span><br><span class="line">backup  备份原有文件</span><br><span class="line">create  如果指定文件不存在则创建</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible all -m lineinfile -a 'path=/tmp/sshd_config  regexp="^#UseDNS" line="UseDNS no"'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>mount</code> 挂载管理模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path    指定挂载路径</span><br><span class="line">state   指定带挂载路径的状态</span><br><span class="line">src     指定待挂载设备</span><br><span class="line">opts    挂载的选项</span><br><span class="line"></span><br><span class="line">backup  备份原有文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible all -m mount -a 'path=/mnt state=present fstype=ext4 src=/dev/sda2 opts="rw"'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>service</code> 服务管理模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name    指定服务名</span><br><span class="line">enabled 是否开机自动启动</span><br><span class="line">state   指定服务状态</span><br><span class="line">    started     启动服务</span><br><span class="line">    stoped      停止服务</span><br><span class="line">    restarted   重启服务</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible webserver -m service -a 'name=httpd enabled=true state=started'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>shell</code> 复杂命令模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与command基本一致,支持管道,重定向等复杂命令</span></span><br><span class="line"><span class="comment"># ansible all -m shell -a 'echo magedu | passwd --stdin user1'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>script</code> 脚本模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使远程主机执行本地指定脚本</span></span><br><span class="line"><span class="comment"># ansible all -m script -a '/tmp/test.sh'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>timezone</code> 设置时区</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name    指定时区名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible all -m -a 'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>user</code> 用户管理模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name    用户名</span><br><span class="line">uid     uid</span><br><span class="line">state   状态,默认为present创建,使用absent删除</span><br><span class="line">group   属于哪个组</span><br><span class="line">groups  附加组</span><br><span class="line">home    家目录</span><br><span class="line">createhome  是否创建家目录</span><br><span class="line">comment 注释信息</span><br><span class="line">system  是否是系统用户</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible all -m user -a 'name="user1"'</span></span><br><span class="line"><span class="comment"># ansible all -m user -a 'name="user1" state=absent'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>yum</code> yum管理模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name    程序包名称(不指定版本就安装最新的版本latest)</span><br><span class="line">state   present,latest表示安装,absent表示卸载</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible webserver -m yum -a 'name=httpd'</span></span><br><span class="line"><span class="comment"># ansible all -m yum -a 'name=httpd state=absent'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>setup</code> 信息收集模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每个被管理节点在接受并运行管理命令之前,会将自己主机相关信息,如操作系统版本,IP地址等报告给远程的 ansible 主机</span></span><br><span class="line"><span class="comment"># ansible all -m setup</span></span><br></pre></td></tr></table></figure>

<p>更多模块及其参数,详见官方文档 - <a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html" target="_blank" rel="noopener">Module Index</a></p>
<h2 id="Inventory-主机清单"><a href="#Inventory-主机清单" class="headerlink" title="Inventory 主机清单"></a>Inventory 主机清单</h2><p>ansible 的主要用于批量主机操作,为了便捷地使用其中的部分主机,可以在 inventory file 中将其分组命名.默认的 inventory file 为<code>/etc/ansible/hosts</code></p>
<p>inventory file 可以有多个,且也可以通过 Dynamic Inventory 来动态生成</p>
<h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>inventory 文件遵循INI文件风格,中括号中的字符为组名,可以将同一个主机同时归并到多个不同的组中.此外,当如若目标主机使用了非默认的SSH端口,还可以在主机名称之后使用冒号加端口号来标明.示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ungrouped_host</span><br><span class="line"></span><br><span class="line">[group1]</span><br><span class="line">host1</span><br><span class="line">host2:222</span><br></pre></td></tr></table></figure>

<h3 id="主机和组"><a href="#主机和组" class="headerlink" title="主机和组"></a>主机和组</h3><p>ansible 中有两个默认的组,<code>all</code> 和 <code>ungrouped</code></p>
<ul>
<li><code>all</code> 表示所有主机组</li>
<li><code>ungrouped</code> 表示不在自定义分组中的主机组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntp.magedu.com <span class="comment"># 该主机在ungrouped分组中</span></span><br><span class="line"></span><br><span class="line">[webserver] <span class="comment"># webserver组</span></span><br><span class="line">www1.magedu.com:2222 <span class="comment"># 指定端口为2222</span></span><br><span class="line">www2.magedu.com</span><br><span class="line"></span><br><span class="line">[dbserver]</span><br><span class="line">db1.magedu.com</span><br><span class="line">db2.magedu.com</span><br><span class="line">db3.magedu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果主机名遵循相似的命名模式,可使用列表的方式标识多个主机</span></span><br><span class="line">[webserver]</span><br><span class="line">www[01:50].example.com</span><br><span class="line"></span><br><span class="line">[databases]</span><br><span class="line">db-[a:f].example.com</span><br></pre></td></tr></table></figure>

<h3 id="组嵌套"><a href="#组嵌套" class="headerlink" title="组嵌套"></a>组嵌套</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[apache]</span><br><span class="line">httpd1.magedu.com</span><br><span class="line">httpd2.magedu.com</span><br><span class="line"></span><br><span class="line">[nginx]</span><br><span class="line">ngx1.magedu.com</span><br><span class="line">ngx2.magedu.com</span><br><span class="line"></span><br><span class="line">[webserver:children]</span><br><span class="line">apache</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line">[webserver:vars]</span><br><span class="line">ntp_server=ntp.magedu.com</span><br></pre></td></tr></table></figure>

<h3 id="主机变量与组变量"><a href="#主机变量与组变量" class="headerlink" title="主机变量与组变量"></a>主机变量与组变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># - 主机变量</span></span><br><span class="line">[webserver]</span><br><span class="line">www1.magedu.com http_port=80 maxRequestsPerChild=808</span><br><span class="line">www2.magedu.com http_port=8080 maxRequestsPerChild=909</span><br><span class="line"></span><br><span class="line">[webserver]</span><br><span class="line">www1.magedu.com</span><br><span class="line">www2.magedu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># - 组变量</span></span><br><span class="line">[webserver:vars]</span><br><span class="line">ntp_server=ntp.magedu.com</span><br><span class="line">nfs_server=nfs.magedu.com</span><br></pre></td></tr></table></figure>

<p>除了在主机清单文件中定义变量外,ansible 还支持在如下位置定义变量</p>
<ul>
<li>在 <code>/etc/ansible/group_vars/</code> 目录下以 ‘.yml’, ‘.yaml’ 或 ‘.json’ 格式定义组变量</li>
<li>在 <code>/etc/ansible/host_vars/</code> 目录下以 ‘.yml’, ‘.yaml’ 或 ‘.json’ 格式定义主机变量</li>
</ul>
<blockquote>
<p>主机清单中变量优先级从低到高为 <code>all group -&gt; parent group -&gt; child group -&gt; host</code></p>
</blockquote>
<h3 id="inventory-参数"><a href="#inventory-参数" class="headerlink" title="inventory 参数"></a>inventory 参数</h3><p>ansible 连接主机时,可指定连接主机的相关参数.</p>
<ul>
<li><code>ansible_connection</code>: 连接主机方式,可选为 <code>smart</code>, <code>ssh</code> 或 <code>paramiko</code>.默认是 <code>smart</code></li>
<li><code>ansible_host</code>: 连接主机名</li>
<li><code>ansible_port</code>: 连接端口,默认 22</li>
<li><code>ansible_user</code>: 连接用户</li>
<li><code>ansible_password</code>: 连接密码(不要以明文方式存储,使用 vault 进行存储,详见 <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#best-practices-for-variables-and-vaults" target="_blank" rel="noopener">Variables and Vaults</a></li>
</ul>
<p>当连接方式为 <code>ssh</code> 时,可指定如下 SSH 参数:</p>
<ul>
<li><code>ansible_ssh_private_key_file</code>: ssh 私钥文件</li>
<li><code>ansible_ssh_pipelining</code>: 是否使用 ssh pipelining</li>
</ul>
<p>权限升级相关参数如下:</p>
<ul>
<li><code>ansible_become</code>: 允许强制特权升级</li>
<li><code>ansible_become_user</code>: 使用指定用户执行模块</li>
<li><code>ansible_become_method</code>: 使用指定方法变为指定用户</li>
<li><code>ansible_become_password</code>: 变为指定用户过程中需要的用户密码</li>
</ul>
<p>远程主机相关参数如下:</p>
<ul>
<li><code>ansible_shell_type</code>: 目标系统的 shell 类型</li>
<li><code>ansible_python_interpreter</code>: 目标系统的python路径</li>
</ul>
<h4 id="No-SSH-连接参数"><a href="#No-SSH-连接参数" class="headerlink" title="No-SSH 连接参数"></a>No-SSH 连接参数</h4><ul>
<li><code>local</code>: 仅在设备本地执行模块</li>
</ul>
<h2 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Playbook 是由一个或多个 “play”(剧本) 组成的列表,剧本的主要功能在于将事先归并为一组的主机装扮成事先通过 ansible 中的 task 定义好的角色.</p>
<p>从根本上来讲,所有 task 无非是调用 ansible 的一个 module,将多个剧本组织在一个 Playbook 中,即可以让他们连同起来按事先编排的机制去完成某些任务.</p>
<p>Playbook 使用 yaml 编写.示例如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># playbook示例</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">max_clients:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">pkg=httpd</span> <span class="string">state=latest</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">write</span> <span class="string">the</span> <span class="string">apache</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=/srv/httpd.j2</span> <span class="string">dest=/etc/httpd.conf</span></span><br><span class="line">    <span class="attr">notify:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>

<h4 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h4><h5 id="主机与用户"><a href="#主机与用户" class="headerlink" title="主机与用户"></a>主机与用户</h5><p>ansible会使用 <code>&lt;remote_user&gt;</code> 定义的用户对 <code>&lt;hosts&gt;</code> 中的主机进行特定的Task操作.</p>
<p><code>&lt;hosts&gt;</code> 用于指定要执行指定任务的主机,其可以是一个或多个由冒号分隔主机组;<code>&lt;remote_user&gt;</code>则用于指定远程主机上的执行任务的用户</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span> <span class="comment"># 是一个由冒号分割的一个或多个主机组</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> <span class="comment"># 远程帐户</span></span><br><span class="line">  <span class="attr">sudo:</span> <span class="literal">yes</span> <span class="comment"># 支持sudo执行命令</span></span><br><span class="line">  <span class="attr">sudo_user:</span> <span class="string">postgres</span> <span class="comment"># 支持sudo到不通用户身份执行命令</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span> <span class="comment"># 是否支持切换用户</span></span><br><span class="line">  <span class="attr">become_user:</span> <span class="string">postgres</span> <span class="comment"># 切换为指定用户</span></span><br><span class="line">  <span class="attr">become_method:</span> <span class="string">su</span> <span class="comment"># 切换用户使用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要注意的是,我们在指定sudo密码时,需要使用 `ansible-playbook --ask-become-pass 或 -K` 指定密码</span></span><br></pre></td></tr></table></figure>

<p>在每一个 task 中,也可以单独定义远程用户</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span></span><br><span class="line">      <span class="attr">remote_user:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">sudo:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<h5 id="Task-列表"><a href="#Task-列表" class="headerlink" title="Task 列表"></a>Task 列表</h5><p>每一个play中包含了一个 Task 列表,所有的 host 会获取到相同顺序(按照定义的顺序)的 Task 指令.</p>
<blockquote>
<p>一个 Task 在其所对应的所有主机上执行完毕之后,下一个 Task 才会执行</p>
</blockquote>
<p>当运行 Playbook 时,具有失败任务的主机将从整个 Playbook 的调度轮询中删除.如果有失败,所有已执行任务都将回滚,所以只需要更正 Playbook 并重新运行即可.且模块执行是幂等的,多次运行的结果一致,这意味着多次执行是安全的.</p>
<p>每个任务的目标都是执行一个带有非常具体参数的模块,常见的有 <code>shell, serivce, script, copy</code> 等</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;task_name&gt;</span></span><br><span class="line">    <span class="string">&lt;module_name&gt;:</span> <span class="string">key=value</span> <span class="comment"># 这是是在 ansible 中指定的模块名及其子选项的名称及参数</span></span><br><span class="line">    <span class="attr">ignore_errors:</span> <span class="literal">True</span> <span class="comment"># 使用ignore_errors忽略错误</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;task_name&gt;</span></span><br><span class="line">    <span class="string">&lt;module_name&gt;:</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure>

<h4 id="Handlers-事件处理机制"><a href="#Handlers-事件处理机制" class="headerlink" title="Handlers 事件处理机制"></a>Handlers 事件处理机制</h4><p>Handler 用于当关注的资源发生变化时采取一定的操作.</p>
<p>当带有 <code>notify</code> 关键字的 Task 执行前后状态发生改动时,<code>notify</code> 关键字指定的 handlers 将被被触发,且只会被触发一次.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如在名为 "write the apache config file" 的 Task 执行完成后会启动 notify 机制,触发名为 "restart apache" 的 handlers 来进行下一步处理任务</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">write</span> <span class="string">the</span> <span class="string">apache</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=/srv/httpd.j2</span> <span class="string">dest=/etc/httpd.conf</span></span><br><span class="line">    <span class="attr">notify:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>

<p>在 Ansible 2.2 版本之后,handlers 可以使用 <code>listen</code> 关键字监听普通主题,任务等.只需要 tasks中 <code>notify</code> 的内容与 handlers 中 <code>listen</code> 的的内容一致即可.(可一次性触发多个 handlers)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">handlers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">memcached</span></span><br><span class="line">      <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line">      <span class="attr">listen:</span> <span class="string">"restart web services"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">apache</span></span><br><span class="line">      <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line">      <span class="attr">listen:</span> <span class="string">"restart web services"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">everything</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">echo</span> <span class="string">"this task will restart the web services"</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">"restart web services"</span></span><br></pre></td></tr></table></figure>

<h3 id="创建可复用的-Playbook"><a href="#创建可复用的-Playbook" class="headerlink" title="创建可复用的 Playbook"></a>创建可复用的 Playbook</h3><h4 id="include-和-import"><a href="#include-和-import" class="headerlink" title="include 和 import"></a><code>include</code> 和 <code>import</code></h4><p><code>include</code> 和 <code>import</code>(在 Ansible 2.4 版中添加)允许用户将大的剧本拆分成较小的剧本文件.使用 <code>include</code> 和 <code>import</code> 使得剧本文件分工更加明确,重用性更高.</p>
<ul>
<li>所有 <code>include*</code> 语句均在执行 Playbook 时进行处理</li>
<li>所有 <code>import*</code> 语句均在解析 Playbook 时进行处理,就好像它本身就是定义在那里一样.</li>
</ul>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支持使用 import 或 include 直接导入 playbook 或 tasks</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">import_playbook:</span> <span class="string">common_playbook.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">import_playbook:</span> <span class="string">common_playbook.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">import_tasks:</span> <span class="string">common_tasks.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">common_tasks.yml</span></span><br></pre></td></tr></table></figure>

<h4 id="Role-角色"><a href="#Role-角色" class="headerlink" title="Role 角色"></a>Role 角色</h4><p>Role 是 ansilbe 1.2 版本引入的新特性,用于层次性,结构化地组织 Playbook</p>
<p>简单来讲,roles 就是通过分别将变量,文件,任务,模块及处理器放置于单独的目录中,并根据层次型结构自动装载它们.</p>
<p>Ansible 将通过以下方式搜索我们定义的 Roles</p>
<ul>
<li>Playbook 同级的 <code>roles/</code> 目录下</li>
<li>默认的 <code>/etc/ansible/roles</code> 目录下</li>
</ul>
<p>Role 的结构大概如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># roles 的目录结构</span></span><br><span class="line">├── site.yml        <span class="comment"># `ansible-playbook` 命令执行的主文件,其中定义了主机及其角色</span></span><br><span class="line">└── roles           <span class="comment"># roles 目录,定义了角色目录</span></span><br><span class="line">    ├── fooservers  <span class="comment"># fooserver 角色目录,目录名即为角色名</span></span><br><span class="line">    │   ├── files   <span class="comment"># 静态文件位置,可以包括 copy 或 script 中定义的文件</span></span><br><span class="line">    │   ├── handlers <span class="comment"># 至少有 main.yml 定义事件触发/处理机制</span></span><br><span class="line">    │   ├── tasks   <span class="comment"># 至少有 main.yml 定义task相关</span></span><br><span class="line">    │   ├── templates <span class="comment"># 动态模版文件位置</span></span><br><span class="line">    |   |—— defaults <span class="comment"># 定义默认变量</span></span><br><span class="line">    |   |—— vars <span class="comment"># 自定义变量位置</span></span><br><span class="line">    │   └── meta    <span class="comment"># 定义该角色的元数据信息</span></span><br><span class="line">    └── webservers</span><br><span class="line">        ├── files</span><br><span class="line">        ├── handlers</span><br><span class="line">        ├── tasks</span><br><span class="line">        ├── templates</span><br><span class="line">        └── vars</span><br></pre></td></tr></table></figure>

<p>以下是 roles 的一个使用示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># site.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">&lt;host_pattern&gt;</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">&lt;user&gt;</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">webservers</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># roles/fooservers/files/httpd.conf 保存静态文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># roles/fooservers/tasks/main.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">httpd</span> <span class="string">service</span></span><br><span class="line">  <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">httpd.conf</span></span><br><span class="line">  <span class="attr">copy:</span> <span class="string">src=httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span></span><br><span class="line">  <span class="attr">notify:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">httpd</span> <span class="string">service</span></span><br><span class="line">  <span class="attr">serivce:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># roles/fooservers/handlers/main.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># roles/fooservers/vars/main.yml</span></span><br><span class="line"><span class="attr">var_name:</span> <span class="string">var_value</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量命名仅能由字母,数字和下划线组成,且只能以字母开头</p>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>以下是变量定义的几种方式</p>
<h5 id="在-Inventory-文件中定义变量"><a href="#在-Inventory-文件中定义变量" class="headerlink" title="在 Inventory 文件中定义变量"></a>在 Inventory 文件中定义变量</h5><p>详见<a href="#主机变量与组变量">主机变量与组变量</a>小节</p>
<h5 id="在-PlayBook-中使用-var-关键字定义的变量"><a href="#在-PlayBook-中使用-var-关键字定义的变量" class="headerlink" title="在 PlayBook 中使用 var 关键字定义的变量"></a>在 PlayBook 中使用 var 关键字定义的变量</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># site.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h5 id="facts-变量发现"><a href="#facts-变量发现" class="headerlink" title="facts 变量发现"></a>facts 变量发现</h5><p>facts 是由正在通信的远程目标主机发回的信息,这些信息被保存在 <code>ansible_facts</code> 变量中.可使用 <code>setup</code> 模块对 facts 变量进行查看获取 <code>ansible hostname -m setup</code></p>
<p>假如您不需要任何有关主机的 facts 变量,则可以在 Playbook 中禁用 facts 变量收集.如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>

<p>另外,可在<a href="#配置文件">配置文件</a>中查看有关变量缓存的相关配置.</p>
<h5 id="注册变量"><a href="#注册变量" class="headerlink" title="注册变量"></a>注册变量</h5><p>可在 Task 中运行命令并通过 <code>register</code> 关键字将该命令的结果注册为变量,供以后使用(多用于<a href="#when-条件判断">条件判断</a>中).</p>
<p>如下为注册变量使用示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">web_servers</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">/usr/bin/foo</span></span><br><span class="line">       <span class="attr">register:</span> <span class="string">foo_result</span></span><br><span class="line">       <span class="attr">ignore_errors:</span> <span class="literal">True</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">/usr/bin/bar</span></span><br><span class="line">       <span class="attr">when:</span> <span class="string">foo_result.rc</span> <span class="string">==</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>可通过注册变量的<a href="https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html" target="_blank" rel="noopener">返回值</a> 使用注册变量,以进行条件判断或命令执行结果保存.</p>
<p>以下列出注册变量常用的返回值:</p>
<ul>
<li><code>rc</code>: 命令执行的状态码,常用于保存注册变量所表示命令的执行状态码返回</li>
<li><code>stdout</code>: 命令执行的结果,常用于保存注册变量所表示命令的执行结果</li>
</ul>
<h5 id="通过命令行传递变量"><a href="#通过命令行传递变量" class="headerlink" title="通过命令行传递变量"></a>通过命令行传递变量</h5><p>在运行 Playbook 的时候也可以使用 <code>--extra-vars</code> 传递一些变量供 Playbook 使用.</p>
<p><code>--extra-vars</code> 参数支持如下格式</p>
<ul>
<li>键值对,如 <code>key=value</code></li>
<li>json</li>
<li>json 或 yaml 文件,需要在文件名前添加 <code>@</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook release.yml --extra-vars <span class="string">"version=1.23.45 other_variable=foo"</span></span><br><span class="line">ansible-playbook release.yml --extra-vars <span class="string">'&#123;"version":"1.23.45","other_variable":"foo"&#125;'</span></span><br><span class="line">ansible-playbook release.yml --extra-vars <span class="string">"@some_file.json"</span></span><br><span class="line">ansible-playbook release.yml --extra-vars <span class="string">"@some_file.yml"</span></span><br></pre></td></tr></table></figure>

<h5 id="通过-roles-传递变量"><a href="#通过-roles-传递变量" class="headerlink" title="通过 roles 传递变量"></a>通过 roles 传递变量</h5><p>当给一个主机应用角色的时候可以传递变量,然后在角色内使用这些变量.如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">  <span class="comment"># 对foo_app_instance创建 dir,port 变量</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">foo_app_instance,</span> <span class="attr">dir:</span> <span class="string">'/web/htdocs/a.com'</span><span class="string">,</span>  <span class="attr">port:</span> <span class="number">8080</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h4><h5 id="通过-Jinja2-及其-filter-使用"><a href="#通过-Jinja2-及其-filter-使用" class="headerlink" title="通过 Jinja2 及其 filter 使用"></a>通过 Jinja2 及其 filter 使用</h5><p>定义变量后,可使用 <a href="https://jinja.palletsprojects.com/" target="_blank" rel="noopener">Jinja2</a> (或<a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">中文文档地址</a>) 模版系统在 Playbook 中使用它们.</p>
<p>如下是一个简单示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">app_servers</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">app_path:</span> <span class="string">"<span class="template-variable">&#123;&#123; base_path &#125;&#125;</span>/22"</span></span><br></pre></td></tr></table></figure>

<p>更多使用方式,参见<a href="#模版jinja2">模版(Jinja2)</a>部分.</p>
<p>Jinja2 filter 可以在模版表达式中转换变量的值.Jinja2 包含了许多<a href="http://jinja.pocoo.org/docs/templates/#builtin-filters" target="_blank" rel="noopener">内置过滤器</a>,同时 Ansible 提供了更多过滤器,参见官方文档 - <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html" target="_blank" rel="noopener">Filters</a></p>
<h4 id="变量的优先级"><a href="#变量的优先级" class="headerlink" title="变量的优先级"></a>变量的优先级</h4><p>以下为常见变量的优先级(从低到高,高优先级会覆盖低优先级):</p>
<ol>
<li>环境变量</li>
<li>role default: 角色中定义的默认变量</li>
<li>inventory file or script group vars: 主机清单中定义的主机组变量</li>
<li>inventory group_vars/all: 主机清单目录下的 <code>group_vars/all</code></li>
<li>playbook group_vars/all: playbook 目录下的 <code>group_vars/all</code></li>
<li>inventory group_vars/: 主机清单目录下的 <code>group_vars/*</code></li>
<li>playbook group_vars/: playbook 目录下的 <code>group_vars/*</code></li>
<li>inventory file or script host vars: 主机清单中定义的主机变量</li>
<li>inventory host_vars/: 主机清单目录下的 <code>host_vars/*</code></li>
<li>playbook host_vars/: playbook 目录下的 <code>host_vars/*</code></li>
<li>host facts / cached set_facts: 主机 facts 或 facts 缓存中的变量</li>
<li>play vars: 在 play 中定义的全局变量,如 <code>roles/x/tasks/main.yml</code> 中全局 <code>vars</code></li>
<li>play vars_prompt: 在 play 中定义的全局变量,如 <code>roles/x/tasks/main.yml</code> 中全局 <code>vars_prompt</code></li>
<li>play vars_files: 在 play 中定义的全局变量,如 <code>roles/x/tasks/main.yml</code> 中全局 <code>vars_files</code></li>
<li>role vars (defined in role/vars/main.yml): 定义在 <code>roles/x/vars/main.yml</code> 的变量</li>
<li>block vars (only for tasks in block): 定义在 <code>roles/x/tasks/main.yml</code> 单个 <code>block</code> 中的变量,仅用于此 <code>block</code></li>
<li>task vars (only for the task): 定义在 <code>roles/x/tasks/main.yml</code> 单个 <code>task</code> 中的变量,仅用于此 <code>task</code></li>
<li>include_vars</li>
<li>set_facts / registered vars: 在 Task 中注册的变量</li>
<li>role (and include_role) params: 通过 playbook 传入的参数</li>
<li>include params</li>
<li>extra vars: 通过 <code>--extra-vars</code> 命令行参数传入的变量</li>
</ol>
<h3 id="模版-Jinja2"><a href="#模版-Jinja2" class="headerlink" title="模版(Jinja2)"></a>模版(Jinja2)</h3><p>正如<a href="#变量使用">变量使用</a>部分中已经介绍的那样,Ansible 使用 Jinja2 模板来启用动态表达式和访问变量.主要用于动态修改配置文件,动态配置相关参数等场景.</p>
<p>Jinja2 中使用 `{{ var_name }}` 来引用变量,包括 <a href="#变量定义">变量定义</a> 小节中介绍的所有方式定义的变量.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 template 关键字指定模版文件,并将变量替换后的文件复制到远程主机上</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">httpd.conf</span></span><br><span class="line">  <span class="attr">template:</span> <span class="string">src=httpd.conf.j2</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span></span><br><span class="line">  <span class="attr">notify:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">restart</span> <span class="string">httpd</span></span><br></pre></td></tr></table></figure>

<p>同时,Jinja2 中变量支持过滤(Filter),条件测试(Tests),循环引用(Lookups)等高级用法.</p>
<h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h4><p>详见官方文档 - <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html" target="_blank" rel="noopener">Filters</a></p>
<h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>支持使用 <code>match</code>, <code>search</code>, <code>regex</code> 关键字将字符串与子字符串或正则表达式进行匹配:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vars:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">"http://example.com/users/foo/resources/bar"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"matched pattern 1"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">url</span> <span class="string">is</span> <span class="string">match("http://example.com/users/.*/resources/.*")</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"matched pattern 2"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">url</span> <span class="string">is</span> <span class="string">search("/users/.*/resources/.*")</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"matched pattern 3"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">url</span> <span class="string">is</span> <span class="string">search("/users/")</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"matched pattern 4"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">url</span> <span class="string">is</span> <span class="string">regex("example.com/\w+/foo")</span></span><br></pre></td></tr></table></figure>

<h5 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h5><p>支持使用 <code>version</code>(ansible 2.5 之后版本,之前使用 <code>version_compare</code>) 对版本号进行检查.如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">ansible_facts['distribution_version']</span> <span class="string">is</span> <span class="string">version('12.04',</span> <span class="string">'&gt;='</span><span class="string">)</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如吓是版本比较支持的操作符:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;, lt, &lt;&#x3D;, le, &gt;, gt, &gt;&#x3D;, ge, &#x3D;&#x3D;, &#x3D;, eq, !&#x3D;, &lt;&gt;, ne</span><br></pre></td></tr></table></figure>

<h5 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h5><p>支持使用 <code>subset</code>, <code>superset</code> 查看一个集合是否是另一个集合的子集或包含另一个子集.如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vars:</span></span><br><span class="line">  <span class="attr">a:</span> <span class="string">[1,2,3,4,5]</span></span><br><span class="line">  <span class="attr">b:</span> <span class="string">[2,3]</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">      <span class="attr">msg:</span> <span class="string">"A includes B"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">a</span> <span class="string">is</span> <span class="string">superset(b)</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">      <span class="attr">msg:</span> <span class="string">"B is included in A"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">b</span> <span class="string">is</span> <span class="string">subset(a)</span></span><br></pre></td></tr></table></figure>

<h5 id="all-any-判断"><a href="#all-any-判断" class="headerlink" title="all/any 判断"></a>all/any 判断</h5><p>支持对列表进行 <code>all, any</code> 判断(所有值均为 True,或任意值为 True)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vars:</span></span><br><span class="line">  <span class="attr">mylist:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"<span class="template-variable">&#123;&#123; 3 == 3 &#125;&#125;</span>"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">True</span></span><br><span class="line">  <span class="attr">myotherlist:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">False</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">      <span class="attr">msg:</span> <span class="string">"all are true!"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">mylist</span> <span class="string">is</span> <span class="string">all</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">      <span class="attr">msg:</span> <span class="string">"at least one is true"</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">myotherlist</span> <span class="string">is</span> <span class="string">any</span></span><br></pre></td></tr></table></figure>

<h5 id="路径判断"><a href="#路径判断" class="headerlink" title="路径判断"></a>路径判断</h5><p>支持对指定路径进行判断</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"path is a directory"</span></span><br><span class="line">  <span class="comment"># 路径是 目录,文件,链接,是否存在,挂载点</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">mypath</span> <span class="string">is</span> <span class="string">directory</span> <span class="string">|</span> <span class="string">file</span> <span class="string">|</span> <span class="string">link</span> <span class="string">|</span> <span class="string">exists</span> <span class="string">|mount</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"path is <span class="template-variable">&#123;&#123; (mypath is abs)|ternary('absolute','relative')&#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"path is the same file as path2"</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">mypath</span> <span class="string">is</span> <span class="string">same_file(path2)</span></span><br></pre></td></tr></table></figure>

<h5 id="结果判断"><a href="#结果判断" class="headerlink" title="结果判断"></a>结果判断</h5><p>支持对结果进行判断</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">/usr/bin/foo</span></span><br><span class="line">    <span class="attr">register:</span> <span class="string">result</span></span><br><span class="line">    <span class="attr">ignore_errors:</span> <span class="literal">True</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">      <span class="attr">msg:</span> <span class="string">"it failed"</span></span><br><span class="line">    <span class="comment"># 结果是 失败,改变(用于触发),成功,跳过</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">failed</span> <span class="string">|</span> <span class="string">changed</span> <span class="string">|</span> <span class="string">succeeded</span> <span class="string">|</span> <span class="string">success</span> <span class="string">|</span> <span class="string">skipped</span></span><br></pre></td></tr></table></figure>

<h5 id="变量定义判断"><a href="#变量定义判断" class="headerlink" title="变量定义判断"></a>变量定义判断</h5><p>支持对指定变量是否定义进行判断</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">"I've got '<span class="template-variable">&#123;&#123; foo &#125;&#125;</span>' and am not afraid to use it!"</span></span><br><span class="line">      <span class="comment"># 判断变量 foo 定义或没有定义</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">foo</span> <span class="string">is</span> <span class="string">defined</span> <span class="string">|</span> <span class="string">undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="查找与迭代"><a href="#查找与迭代" class="headerlink" title="查找与迭代"></a>查找与迭代</h4><p>当有需要重复性执行的任务时,可以使用迭代机制.其使用格式为将需要迭代的内容定义为变量,并通过 <code>with_&lt;lookup&gt;</code> 语句来指明迭代的元素列表即可.<code>with_&lt;lookup&gt;</code> 中支持 hashes(字典) 元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span> <span class="string">groups=wheel</span></span><br><span class="line">  <span class="attr">with_items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">testuser1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">testuser2</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item.name</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span> <span class="string">groups=&#123;&#123;</span> <span class="string">item.groups</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">with_items:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser1'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'wheel'</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser2'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'root'</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 ansible 2.5 之后,引入了 <code>loop</code> 关键字,并作为官方推荐的迭代关键字选择.</p>
</blockquote>
<p>关于迭代的高级功能,详见官方文档 - <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html" target="_blank" rel="noopener">Loops</a>,或后面的章节 <a href="#循环与迭代-loops">循环与迭代 Loops</a></p>
<h3 id="when-条件判断"><a href="#when-条件判断" class="headerlink" title="when 条件判断"></a><code>when</code> 条件判断</h3><p><code>when</code> 条件判断句用于在特定条件下做某些操作.如</p>
<ul>
<li>执行一个 Task</li>
<li>导入一个 Task 文件</li>
<li>将角色分配给主机</li>
</ul>
<p><code>when</code> 条件判断句支持使用 <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html" target="_blank" rel="noopener">Filters</a> 或 <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html" target="_blank" rel="noopener">Tests</a> <a href="#条件测试">条件测试</a>作为条件判断的依据,当结果为 True 时,执行某些 Tasks.</p>
<p><code>when</code> 条件判断句支持 <code>and</code>, <code>or</code> 或 <code>not</code> 关键字作为条件子句间逻辑关系的判断.同时支持以列表形式指定多个条件子句.列表形式子句间的逻辑关系为 <code>and</code>.</p>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">debian_stock_config</span></span><br><span class="line">       <span class="attr">when:</span> <span class="string">ansible_facts['os_family']</span> <span class="string">==</span> <span class="string">'Debian'</span></span><br><span class="line"><span class="comment"># 多条件子句</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"shut down CentOS 6 and Debian 7 systems"</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/sbin/shutdown</span> <span class="string">-t</span> <span class="string">now</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">(ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">"CentOS"</span> <span class="string">and</span> <span class="string">ansible_facts['distribution_major_version']</span> <span class="string">==</span> <span class="string">"6"</span><span class="string">)</span> <span class="string">or</span></span><br><span class="line">          <span class="string">(ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">"Debian"</span> <span class="string">and</span> <span class="string">ansible_facts['distribution_major_version']</span> <span class="string">==</span> <span class="string">"7"</span><span class="string">)</span></span><br><span class="line"><span class="comment"># 列表形式指定多个条件子句</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"shut down CentOS 6 systems"</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/sbin/shutdown</span> <span class="string">-t</span> <span class="string">now</span></span><br><span class="line">    <span class="attr">when:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">"CentOS"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ansible_facts['distribution_major_version']</span> <span class="string">==</span> <span class="string">"6"</span></span><br><span class="line"><span class="comment"># 使用 Tests 条件测试中结果判断,是否 import 或 include 这个 tasks</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">import_tasks:</span> <span class="string">other_tasks.yml</span> <span class="comment"># note "import"</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">x</span> <span class="string">is</span> <span class="string">not</span> <span class="string">defined</span></span><br></pre></td></tr></table></figure>

<p>Ansible 提供了一些常用的条件判断 facts,如下</p>
<ul>
<li><code>ansible_facts[&#39;distribution&#39;]</code>: 系统发行版,可能的值为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alpine, Altlinux, Amazon, Archlinux, ClearLinux, Coreos, CentOS, Debian, Fedora, Gentoo,</span><br><span class="line">Mandriva, NA, OpenWrt, OracleLinux, RedHat, Slackware, SMGL, SUSE, Ubuntu, VMwareESX</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ansible_facts[&#39;distribution_major_version&#39;]</code>: 系统发行版主版本号</li>
<li><code>ansible_facts[&#39;os_family&#39;]</code>: 系统发行版类型,可能值为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AIX, Alpine, Altlinux, Archlinux, Darwin, Debian, FreeBSD, Gentoo,</span><br><span class="line">HP-UX, Mandrake, RedHat, SGML, Slackware, Solaris, Suse, Windows</span><br></pre></td></tr></table></figure>

<h3 id="循环与迭代-Loops"><a href="#循环与迭代-Loops" class="headerlink" title="循环与迭代 Loops"></a>循环与迭代 Loops</h3><p>对于需要重复执行的任务,Ansible 提供了两个用于创建循环的关键字 <code>loop</code> 和 <code>with_&lt;lookup&gt;</code>.</p>
<blockquote>
<p><code>loop</code> 关键字是在 2.5 之后的版本中引入的,而且在以后的版本会优化相关语法.并作为官方推荐的迭代方式;<code>with_&lt;lookup&gt;</code> 后续版本也会继续支持.</p>
</blockquote>
<h4 id="loop-vs-with"><a href="#loop-vs-with" class="headerlink" title="loop vs with_*"></a><code>loop</code> vs <code>with_*</code></h4><ul>
<li><code>with_&lt;lookup&gt;</code> 关键字依赖于 <a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html#lookup-plugins" target="_blank" rel="noopener">Lookup Plugins</a></li>
<li><code>loop</code> 关键字等价于 <code>with_list</code>,是简单循环最好的选择</li>
<li><code>loop</code> 关键字不支持字符串作为输入,参见 <a href="#loop-中-query-与-lookup-函数比较">loop 中 query 与 lookup 函数比较</a>或官方文档 - <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#query-vs-lookup" target="_blank" rel="noopener">Ensuring list input for loop: query vs. lookup</a> 或.</li>
<li>一般来说,<a href="#with_x-转换为-loop">后文</a>(官方文档 - <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#migrating-from-with-x-to-loop" target="_blank" rel="noopener">Migrating from with_X to loop</a>)中包含的 <code>with_*</code> 均可以转换为 <code>loop</code>.</li>
<li>对于 <code>with_items</code> 带有列表嵌套的场景,需要对 <code>loop</code> 内容使用 <code>flatten(1)</code> 过滤器来得到相同的结果.如 <code>with_items: [1, [2, 3], 4]</code> 可转换为 `loop: "{{ [1, [2,3] ,4] | flatten(1) }}"`.</li>
</ul>
<h4 id="loop-中-query-与-lookup-函数比较"><a href="#loop-中-query-与-lookup-函数比较" class="headerlink" title="loop 中 query 与 lookup 函数比较"></a>loop 中 query 与 lookup 函数比较</h4><ul>
<li><code>lookup</code> 函数默认返回逗号分割的字符串.可以使用 <code>wantlist=True</code> 参数强制该函数返回列表.</li>
<li><code>query</code> 函数总是返回列表,当使用 <code>loop</code> 关键字时,可以提供一个更简单的接口.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('inventory_hostnames', 'all') &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('inventory_hostnames', 'all', wantlist=True) &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure>

<h4 id="with-X-转换为-loop"><a href="#with-X-转换为-loop" class="headerlink" title="with_X 转换为 loop"></a>with_X 转换为 loop</h4><h5 id="with-list"><a href="#with-list" class="headerlink" title="with_list"></a>with_list</h5><p><code>with_list</code> 可直接转换为 <code>loop</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with_list</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">with_list:</span></span><br><span class="line">  <span class="comment"># loop:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">one</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">two</span></span><br></pre></td></tr></table></figure>

<h4 id="with-items"><a href="#with-items" class="headerlink" title="with_items"></a>with_items</h4><p><code>with_items</code> 可以转换为 <code>loop</code> 和 <code>flatten</code> 过滤器</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with_items</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">with_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line">  <span class="comment"># loop: "&#123;&#123; items|flatten(levels=1) &#125;&#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="with-indexed-items"><a href="#with-indexed-items" class="headerlink" title="with_indexed_items"></a>with_indexed_items</h4><p><code>with_indexed_items</code> 可以转换为 <code>loop</code>, <code>flatten</code> 过滤器和 <code>loop_control.index_var</code>.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with_indexed_items</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">with_indexed_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with_indexed_items</span> <span class="string">-&gt;</span> <span class="string">loop</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; index &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; items|flatten(levels=1) &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">loop_control:</span></span><br><span class="line">    <span class="attr">index_var:</span> <span class="string">index</span></span><br></pre></td></tr></table></figure>

<h4 id="with-flattened"><a href="#with-flattened" class="headerlink" title="with_flattened"></a>with_flattened</h4><p><code>with_flattened</code> 可以转换为 <code>loop</code> 和 <code>flatten</code> 过滤器</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with_flattened</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">with_flattened:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line">  <span class="comment"># loop: "&#123;&#123; items|flatten &#125;&#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="with-fileglob"><a href="#with-fileglob" class="headerlink" title="with_fileglob"></a>with_fileglob</h4><p><code>with_fileglob</code> 可以转换为 <code>loop</code> 和 <code>lookup</code> 或 <code>query</code> 函数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with_flattened</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">with_fileglob:</span> <span class="string">'*.txt'</span></span><br><span class="line">  <span class="comment"># loop: "&#123;&#123; query('fileglob', '*.txt') &#125;&#125;"</span></span><br><span class="line">  <span class="comment"># loop: "&#123;&#123; lookup('fileglob', '*.txt', wantlist=True) &#125;&#125;"</span></span><br></pre></td></tr></table></figure>

<h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>Blocks 允许对 Task 进行逻辑分组并进行错误处理.除循环外,单个任务的大多数内容均可用于 Block.</p>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install,</span> <span class="string">configure,</span> <span class="string">and</span> <span class="string">start</span> <span class="string">Apache</span></span><br><span class="line">    <span class="attr">block:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">httpd</span> <span class="string">and</span> <span class="string">memcached</span></span><br><span class="line">        <span class="attr">yum:</span></span><br><span class="line">          <span class="attr">name:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">httpd</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">memcached</span></span><br><span class="line">          <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apply</span> <span class="string">the</span> <span class="string">foo</span> <span class="string">config</span> <span class="string">template</span></span><br><span class="line">        <span class="attr">template:</span></span><br><span class="line">          <span class="attr">src:</span> <span class="string">templates/src.j2</span></span><br><span class="line">          <span class="attr">dest:</span> <span class="string">/etc/foo.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">service</span> <span class="string">bar</span> <span class="string">and</span> <span class="string">enable</span> <span class="string">it</span></span><br><span class="line">        <span class="attr">service:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">          <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">True</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">'CentOS'</span></span><br><span class="line">    <span class="attr">become:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">become_user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>除了单个任务的大多数常用内容外,Block 还支持如下关键字:</p>
<ul>
<li><code>rescue</code>: 用于错误处理,相当于 <code>try...catch</code> 语句</li>
<li><code>always</code>: 此关键字定义的内容总是执行,相当于 <code>finally</code> 语句</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Attempt</span> <span class="string">and</span> <span class="string">graceful</span> <span class="string">roll</span> <span class="string">back</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">block:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">'I execute normally'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">/bin/false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">'I never execute, due to the above task failing, :-('</span></span><br><span class="line">  <span class="attr">rescue:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">'I caught an error'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span> <span class="string">in</span> <span class="string">middle</span> <span class="string">of</span> <span class="string">recovery!</span> <span class="string">&gt;:-)</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">/bin/false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">'I also never execute :-('</span></span><br><span class="line">  <span class="attr">always:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">"This always executes"</span></span><br></pre></td></tr></table></figure>

<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><h4 id="Tags-标签"><a href="#Tags-标签" class="headerlink" title="Tags 标签"></a>Tags 标签</h4><p>ansible playbook 应用于有一个大型的 playbook,但仅仅运行指定的 tasks 的场景.在执行 playbook 时,可以使用 <code>--tags</code> 或 <code>--skip-tags</code> 运行或不运行带有指定标签的 tasks</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">yum:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">  <span class="attr">loop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpd</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">memcached</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">packages</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">template:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">templates/httpd.j2</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">/etc/httpd.conf</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">config</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">template:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">templates/memcached.j2</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">/etc/memcached.conf</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">config</span> <span class="comment"># tags 支持复用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>always</code> 标签默认每次都会执行,除非使用 <code>--skip-tags always</code> 特别指定跳过该 tag 标记的 task</li>
<li><code>never</code>标签默认每次都不会执行,除非使用 <code>--tags never</code> 特别指定运行该 tag 标记的 task</li>
</ul>
<h4 id="其它常用关键字"><a href="#其它常用关键字" class="headerlink" title="其它常用关键字"></a>其它常用关键字</h4><ul>
<li><code>debugger</code>: 显示 debug 信息,可选项为 <code>always | never | on_failed | on_unreachable | on_skipped</code>.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Execute</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line">  <span class="attr">command:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">debugger:</span> <span class="string">on_failed</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>serial</code>: 一次性多少个主机并行执行任务,多用于滚动更新.支持数字,百分比以及它们的列表.若指定为列表,则每次执行的主机数等于列表中元素.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span> <span class="string">play</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">serial:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">task</span> <span class="string">one</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">hostname</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">task</span> <span class="string">two</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">hostname</span></span><br></pre></td></tr></table></figure>

<p>假设有 4 台主机,执行过程将如下所示</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">PLAY</span> <span class="string">[webservers]</span> <span class="string">****************************************</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[task</span> <span class="string">one]</span> <span class="string">******************************************</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web2]</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web1]</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[task</span> <span class="string">two]</span> <span class="string">******************************************</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web1]</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web2]</span></span><br><span class="line"></span><br><span class="line"><span class="string">PLAY</span> <span class="string">[webservers]</span> <span class="string">****************************************</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[task</span> <span class="string">one]</span> <span class="string">******************************************</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web3]</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web4]</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[task</span> <span class="string">two]</span> <span class="string">******************************************</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web3]</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[web4]</span></span><br><span class="line"></span><br><span class="line"><span class="string">PLAY</span> <span class="string">RECAP</span> <span class="string">***********************************************</span></span><br><span class="line"><span class="attr">web1      :</span> <span class="string">ok=2</span>    <span class="string">changed=2</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span></span><br><span class="line"><span class="attr">web2      :</span> <span class="string">ok=2</span>    <span class="string">changed=2</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span></span><br><span class="line"><span class="attr">web3      :</span> <span class="string">ok=2</span>    <span class="string">changed=2</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span></span><br><span class="line"><span class="attr">web4      :</span> <span class="string">ok=2</span>    <span class="string">changed=2</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>run_once</code>: 尝试仅在主机列表的第一台主机上运行一次,然后将运行结果和 facts 应用到其他主机上.</li>
<li><code>ignore_errors</code>: 尝试忽略执行过程中的错误</li>
<li><code>failed_when</code>: 定义 playbook 执行失败的条件.当该关键字指定的条件判断句为 True 时,playbook 执行失败并退出执行.等价于 <code>fail</code> 模块与 <code>when</code> 条件判断使用.</li>
<li><code>any_errors_fatal</code>: 只要有错误发生,则终止整个 Playbook 的执行</li>
<li><code>vars_prompt</code>, <code>prompt</code>: 由 <code>vars_prompt</code> 包含的多个 <code>prompt</code> 列表用于交互式定义变量.<ul>
<li><code>private</code>: 是否定义为私有变量.</li>
<li><code>default</code>: 为交互式变量设置默认值</li>
<li><code>encrypt</code>: 设置加密方式.可选值为参见<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_prompts.html#prompts" target="_blank" rel="noopener">官方文档</a></li>
<li><code>confirm</code>: 是否需要确认,再次输入</li>
<li><code>salt_size</code>: 加密过程中加盐大小</li>
<li><code>unsafe</code>: 输入变量中可能包含导致创建模版失败的特殊字符(如 <code>%</code>).使用该参数进行转义</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">vars_prompt:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">username</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">"What is your username?"</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">"mike"</span></span><br><span class="line">      <span class="attr">private:</span> <span class="literal">no</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">password</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">"What is your password?"</span></span><br><span class="line">      <span class="attr">unsafe:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">private:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">encrypt:</span> <span class="string">"sha512_crypt"</span></span><br><span class="line">      <span class="attr">confirm:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">salt_size:</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">'Logging in as <span class="template-variable">&#123;&#123; username &#125;&#125;</span>'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>connection</code>: 指定连接的主机.多用于指定为 <code>local</code>.</li>
</ul>
<p>更多关键字,详见官方文档 - <a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html" target="_blank" rel="noopener">Playbook Keywords</a>.</p>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>ants 快速开始</title>
    <url>/2021/11/11/ants-quick-start/</url>
    <content><![CDATA[<p><a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener"><code>ants</code></a> 实现了一个高性能的 <code>goroutine</code> 池,实现了对大规模 goroutine 的调度管理及复用.它允许使用者在开发并发程序的时候限制 goroutine 数量,复用资源,以便达到更高效执行任务的效果</p>
<p>ants 有以下特性:</p>
<ul>
<li>自动调度海量的 goroutine, 复用 goroutine</li>
<li>定期清理过期的 goroutine, 节省资源</li>
<li>提供了任务提交、获取运行中的 goroutine 数量、动态调整 Pool 大小、释放 Pool、重启 Pool 等常用 API</li>
<li>优雅处理 panic, 防止程序崩溃</li>
<li>在大规模批量并发任务场景下比原生 goroutine 并发具有<a href="https://github.com/panjf2000/ants/blob/master/README_ZH.md#-性能小结" target="_blank" rel="noopener">更高的性能</a></li>
<li>非阻塞机制</li>
</ul>
<p>可通过 <a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener">panjf2000/ants(github.com)</a> 了解它是如何工作的</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>我们可以通过 <a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener">panjf2000/ants(github.com)</a>  中提供的一些示例来快速了解该库的使用方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"sync"</span></span><br><span class="line"> <span class="string">"time"</span></span><br><span class="line"> </span><br><span class="line"> <span class="string">"github.com/panjf2000/ants/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 执行结束后,需要释放 ants goroutine 池</span></span><br><span class="line"> <span class="keyword">defer</span> ants.Release()</span><br><span class="line"> runTimes := <span class="number">1000</span></span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> doSomthing := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">  fmt.Println(<span class="string">"Hello World!"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; runTimes; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// Use the default pool.</span></span><br><span class="line">  _ = ants.Submit(doSomthing)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line"> fmt.Printf(<span class="string">"running goroutines: %d\n"</span>, ants.Running())</span><br><span class="line"> fmt.Printf(<span class="string">"finish all tasks.\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上示例中,使用包提供的默认的 goroutine 池提交任务.通过直接调用 <code>Submit()</code> 函数,并传入一个自定义 <code>func()</code> 作为参数来向 goroutine 池提交任务.</p>
<p>我们也可以通过 <code>ants.NewPool</code> 创建自定义大小 goroutine 池,同样通过调用其 <code>Submit()</code> 函数来提交任务.其实与上面代码一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// ... 省略部分代码</span></span><br><span class="line"> <span class="comment">// 创建一个自定义大小的 goroutine 池</span></span><br><span class="line">p, _ := ants.NewPool(<span class="number">10</span>)</span><br><span class="line"> <span class="keyword">defer</span> p.Release()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; runTimes; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  _ = p.Submit(doSomthing)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line"> fmt.Printf(<span class="string">"running goroutines: %d\n"</span>, p.Running())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如 <code>doSomthing</code> 函数需要传入参数,又该怎么办呢? <code>ants</code> 包提供了 <code>NewPoolWithFunc(size int, pf func(interface{}), options ...Option) (*PoolWithFunc, error)</code> 来解决这个问题. 示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"sync"</span></span><br><span class="line"> <span class="string">"sync/atomic"</span></span><br><span class="line"> </span><br><span class="line"> <span class="string">"github.com/panjf2000/ants/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomthing</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"> n, _ := i.(<span class="keyword">int32</span>)</span><br><span class="line"> atomic.AddInt32(&amp;sum, n)</span><br><span class="line"> fmt.Printf(<span class="string">"run with %d\n"</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> runTimes := <span class="number">1000</span></span><br><span class="line"> <span class="comment">// 创建一个带参数的 goroutine 池</span></span><br><span class="line"> p, _ := ants.NewPoolWithFunc(<span class="number">10</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  doSomthing(i)</span><br><span class="line">  wg.Done()</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">defer</span> p.Release()</span><br><span class="line"> <span class="comment">// 提交任务</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; runTimes; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  _ = p.Invoke(<span class="keyword">int32</span>(i))</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line"> fmt.Printf(<span class="string">"running goroutines: %d\n"</span>, p.Running())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时, <code>NewPool</code> 与 <code>NewPoolWithFunc</code> 支持传入各种 <code>Option</code> 来实现不同的初始化属性.见下面的内容</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>下面总结一下,<code>ants</code>包及其对象中常用的函数/方法.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 goroutine 池</span></span><br><span class="line"><span class="comment">// 创建一个指定大小的 goroutine 池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(size <span class="keyword">int</span>, options ...Option)</span> <span class="params">(*Pool, error)</span></span></span><br><span class="line"><span class="comment">// 创建一个指定大小的 goroutine 池,支持通过 Invoke 传入参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPoolWithFunc</span><span class="params">(size <span class="keyword">int</span>, pf <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>, <span class="title">options</span> ...<span class="title">Option</span>) <span class="params">(*PoolWithFunc, error)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面函数可以创建 Option 对象,传入到创建 goroutine 池的函数中,设置一些初始化属性</span></span><br><span class="line"><span class="comment">// 指定 logger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(logger Logger)</span> <span class="title">Option</span></span></span><br><span class="line"><span class="comment">// 是否应该为 worker 动态分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPanicHandler</span><span class="params">(panicHandler <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>) <span class="title">Option</span></span></span><br><span class="line"><span class="comment">// 指定发生 `panic` 时的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPanicHandler</span><span class="params">(panicHandler <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>) <span class="title">Option</span></span></span><br><span class="line"><span class="comment">// 当没有可用 worker 时, pool 返回 nil.非阻塞方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithNonblocking</span><span class="params">(nonblocking <span class="keyword">bool</span>)</span> <span class="title">Option</span></span></span><br><span class="line"><span class="comment">// 设置清理 goroutine 的时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithExpiryDuration</span><span class="params">(expiryDuration time.Duration)</span> <span class="title">Option</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 对象与 PoolWithFunc 的一些方法,简单介绍</span></span><br><span class="line"><span class="comment">// 总容量,剩余容量,正在运行的 goroutine,是否已经关闭</span></span><br><span class="line"><span class="comment">// Cap(),Free(),Running(),IsClosed()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重启,释放,调整大小,</span></span><br><span class="line"><span class="comment">// Reboot(),Release(),Tune(size int)</span></span><br><span class="line"><span class="comment">// 向 Pool 提交无参数的任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Submit</span><span class="params">(task <span class="keyword">func</span>()</span>) <span class="title">error</span></span></span><br><span class="line"><span class="comment">// PoolWithFunc 传入参数,调用其任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PoolWithFunc)</span> <span class="title">Invoke</span><span class="params">(args <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考:</p>
<ul>
<li><a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener">panjf2000/ants (github.com)</a></li>
<li><a href="https://pkg.go.dev/github.com/panjf2000/ants/v2" target="_blank" rel="noopener">ants - pkg.go.dev</a></li>
<li><a href="https://strikefreedom.top/high-performance-implementation-of-goroutine-pool" target="_blank" rel="noopener">GMP 并发调度器深度解析之手撸一个高性能 goroutine pool - Strike Freedom</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goroutine</tag>
        <tag>3rd</tag>
      </tags>
  </entry>
  <entry>
    <title>awesome-go</title>
    <url>/2021/10/29/awesome-go/</url>
    <content><![CDATA[<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="Standard-CLI"><a href="#Standard-CLI" class="headerlink" title="Standard CLI"></a>Standard CLI</h3><ul>
<li><a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a> - Commander for modern Go CLI interactions. 跳转 <a href="/2020/06/23/cobra-quick-start/" title="cobra 快速开始">cobra 快速开始</a></li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li><a href="https://github.com/Sirupsen/logrus" target="_blank" rel="noopener">logrus</a> - Structured logger for Go.跳转 <a href="/2021/11/02/logrus-quick-start/" title="logrus 快速开始">logrus 快速开始</a></li>
<li><a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">zap</a> - Fast, structured, leveled logging in Go.跳转 <a href="/2021/11/17/zap/" title="高性能日志库 zap">高性能日志库 zap</a></li>
</ul>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><ul>
<li><a href="https://github.com/go-kit/kit" target="_blank" rel="noopener">go-kit</a> - Microservice toolkit with support for service discovery, load balancing, pluggable transports, request tracking, etc.</li>
<li><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">grpc-go</a> The Go language implementation of gRPC. HTTP/2 based RPC.</li>
</ul>
<h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><ul>
<li><a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener">ants</a> - A high-performance and low-cost goroutine pool in Go. 跳转 <a href="/2021/11/11/ants-quick-start/" title="ants 快速开始">ants 快速开始</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash 特性</title>
    <url>/2020/12/07/bash-features/</url>
    <content><![CDATA[<h2 id="Shell-语法"><a href="#Shell-语法" class="headerlink" title="Shell 语法"></a>Shell 语法</h2><h3 id="复合命令"><a href="#复合命令" class="headerlink" title="复合命令"></a>复合命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(list) <span class="comment"># 表示在子 shell 中运行命令</span></span><br><span class="line">&#123; list; &#125; <span class="comment"># 表示仅在本 shell 中运行命令.且命令必须以 `;` 结尾,命令与 `&#123;&#125;` 之间必须有空格</span></span><br><span class="line">((expression)) <span class="comment"># 多用于算术运算</span></span><br><span class="line">[[ expression ]] <span class="comment"># 多用于条件判断</span></span><br></pre></td></tr></table></figure>

<h3 id="带有空格的文件名处理"><a href="#带有空格的文件名处理" class="headerlink" title="带有空格的文件名处理"></a>带有空格的文件名处理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">"*[[:space:]]*"</span> -<span class="built_in">print</span> | </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> name ;<span class="keyword">do</span></span><br><span class="line">  new=`<span class="built_in">echo</span> <span class="variable">$name</span> | sed s<span class="string">'@[[:space:]]@_@'</span>g`;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"mv <span class="variable">$name</span> <span class="variable">$new</span>"</span> ;</span><br><span class="line">  mv <span class="string">"<span class="variable">$name</span>"</span> <span class="variable">$new</span>;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rename</span></span><br></pre></td></tr></table></figure>

<h2 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$* <span class="comment"># 参数列表</span></span><br><span class="line"><span class="variable">$@</span> <span class="comment"># 参数列表</span></span><br><span class="line"><span class="variable">$#</span> <span class="comment"># 参数个数</span></span><br><span class="line">$? <span class="comment"># 最后运行命令的结束代码</span></span><br><span class="line">$$ <span class="comment"># shell 本身的 processID. () 中运行的子 shell 返回值也为本 shell 的 processID</span></span><br><span class="line"><span class="variable">$0</span> <span class="comment"># shell 脚本或命令本身的文件名</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="参数扩展"><a href="#参数扩展" class="headerlink" title="参数扩展"></a>参数扩展</h3><p><code>$</code> 符号用于参数扩展,命令替换或算术扩展.可以使用花括号(<code>{}</code>)将要扩展的参数名称或符号括起来,该括号是可选的,但要保证扩展的变量不受紧随其后字符的影响.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;parameter&#125;</span> <span class="comment"># 原始格式,表示变量值.如果第一个字符是感叹号(!),则会引入变量间接访问.如 name=admin;admin=pass,则 $&#123;!name&#125; 的值为 pass</span></span><br><span class="line"><span class="variable">$&#123;parameter:-word&#125;</span> <span class="comment"># 如果 parameter 没有设置或为空,则使用默认值为 word.(parameter 值不变)</span></span><br><span class="line"><span class="variable">$&#123;parameter:=word&#125;</span> <span class="comment"># 如果 parameter 没有设置或为空,则将 parameter 的值设置为 word</span></span><br><span class="line"><span class="variable">$&#123;parameter:?word&#125;</span> <span class="comment"># 如果 parameter 没有设置或为空,则将 word 作为错误信息输出</span></span><br><span class="line"><span class="variable">$&#123;parameter:+word&#125;</span> <span class="comment"># 如果 parameter 不为空,则输出 word 的值.(parameter 值不变)</span></span><br><span class="line"><span class="variable">$&#123;parameter:offset&#125;</span> <span class="comment"># 子字符串, offset 从 0 开始</span></span><br><span class="line"><span class="variable">$&#123;parameter:offset:length&#125;</span> <span class="comment"># 子字符串, offset 从 0 开始,子字符串长度为 length</span></span><br><span class="line"><span class="variable">$&#123;#parameter&#125;</span> <span class="comment"># parameter 变量值的长度</span></span><br><span class="line"><span class="variable">$&#123;parameter/pattern/string&#125;</span> <span class="comment"># 使用 string 替换 parameter 中 pattern 的模式匹配</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;parameter^pattern&#125;</span> <span class="comment"># ^ 表示将模式匹配的内容转换为大写.</span></span><br><span class="line"><span class="variable">$&#123;parameter^^pattern&#125;</span> <span class="comment"># $&#123;parameter^^&#125; 将所有内容转换为大写输出 </span></span><br><span class="line"><span class="variable">$&#123;parameter,pattern&#125;</span> <span class="comment"># ,表示将模式匹配的内容转换为小写</span></span><br><span class="line"><span class="variable">$&#123;parameter,,pattern&#125;</span> <span class="comment"># $&#123;parameter,,&#125; 将所有内容转换为小写输出</span></span><br></pre></td></tr></table></figure>

<h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$((expression))</span><br><span class="line">sum=$[ <span class="variable">$&#123;v1&#125;</span> + <span class="variable">$&#123;v2&#125;</span> ]</span><br><span class="line">(( sum=<span class="variable">$&#123;v1&#125;</span> + <span class="variable">$&#123;v2&#125;</span> ))</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$&#123;v1&#125;</span>+<span class="variable">$&#123;v2&#125;</span>     <span class="comment"># 这里运算符两端必须没有空格</span></span><br><span class="line">`expr <span class="variable">$&#123;v1&#125;</span> + <span class="variable">$&#123;v2&#125;</span>`    <span class="comment"># 这里运算符号两端必须要有空格</span></span><br></pre></td></tr></table></figure>

<h2 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h2><p>Bash 中的条件判断语句使用 <code>[[ 复合命令 ]]</code>,<code>test</code> 和 <code>[ 内置命令 ]</code> 对文件属性,字符串进行判断或进行算术比较.</p>
<h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><p>下面是常用的文件属性进行条件判断语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a file <span class="comment"># 文件存在,则返回 True</span></span><br><span class="line">-b file <span class="comment"># 文件存在且是块文件,则返回 True</span></span><br><span class="line">-c file <span class="comment"># 文件存在且是字符文件,则返回 True</span></span><br><span class="line">-d file <span class="comment"># 文件存在且是目录,则返回 True</span></span><br><span class="line">-e file <span class="comment"># 文件存在,则返回 True</span></span><br><span class="line">-f file <span class="comment"># 文件存在且是文本文件,则返回 True</span></span><br><span class="line">-h file <span class="comment"># 文件存在且是链接文件,则返回 True</span></span><br><span class="line">-p file <span class="comment"># 文件存在且是管道文件,则返回 True</span></span><br><span class="line">-r file <span class="comment"># 文件存在且可读,则返回 True</span></span><br><span class="line">-s file <span class="comment"># 文件存在且大小不为0,则返回 True</span></span><br><span class="line">-w file <span class="comment"># 文件存在且可写,则返回 True</span></span><br><span class="line">-x file <span class="comment"># 文件存在且可执行,则返回 True</span></span><br><span class="line">-L file <span class="comment"># 文件存在且是链接文件,则返回 True</span></span><br><span class="line">-S file <span class="comment"># 文件存在且是套接字文件,则返回 True</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串与算术运算相关"><a href="#字符串与算术运算相关" class="headerlink" title="字符串与算术运算相关"></a>字符串与算术运算相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v varname <span class="comment"># 设置了 varname 变量,则返回 True</span></span><br><span class="line">-z string <span class="comment"># 字符串长度为 0,则返回 True</span></span><br><span class="line">-n string <span class="comment"># 字符串长度不为 0,则返回 True</span></span><br><span class="line">string1 == string2 <span class="comment"># 两个字符串相等,则返回 True</span></span><br><span class="line">string1 != string2</span><br><span class="line">string1 &lt; string2</span><br><span class="line">string1 &gt; string2</span><br><span class="line"></span><br><span class="line">arg1 OP arg2 <span class="comment"># OP 支持的方式为 -eq, -ne, -lt, -le, -gt, -ge</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>cobra-quick-start</title>
    <url>/2020/06/23/cobra-quick-start/</url>
    <content><![CDATA[<p><a href="https://github.com/spf13/cobra" target="_blank" rel="noopener"><code>Cobra</code></a> 是一个可以创建功能强大的现代 CLI 应用程序的库,又是一个可以用于生成应用程序和命令文件的程序.</p>
<p>Cobra 被应用于很多项目中,如 <a href="http://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>, <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>, 和 <a href="https://github.com/cli/cli" target="_blank" rel="noopener">Github CLI</a> 等.<a href="https://github.com/spf13/cobra/blob/master/projects_using_cobra.md" target="_blank" rel="noopener">此列表</a> 包含了使用 Cobra 项目的列表.</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Cobra 是一个库,它提供了简单易用的接口,用于创建功能强大的现代 CLI 接口,如 git &amp; go tool.</p>
<p>Cobra 也是一个程序(工具),它可以生成基于 Cobra 的应用程序的代码结构以便于快速开发.</p>
<p>Cobra 提供了以下功能:</p>
<ul>
<li>简单的子命令行模式: <code>app server</code>, <code>app fetch</code> 等</li>
<li>完全兼容 POSIX 标志(长短版本均支持)</li>
<li>嵌套子命令</li>
<li>全局,局部和级联标志</li>
<li>使用 <code>cobra init appname</code> 或 <code>cobra add cmdname</code> 轻松生成应用程序或命令</li>
<li>智能建议(如, <code>app srver</code>… 您是指 <code>app server</code>)</li>
<li>自动生成命令和标志的帮助</li>
<li>自动帮助标志识别,如 <code>-h</code>, <code>--help</code> 等</li>
<li>自动为您的应用生成 bash 自动完成</li>
<li>自动为您的应用生成帮助手册</li>
<li>支持命令别名</li>
<li>灵活地自定义帮助,用法等.</li>
<li>可选的与 viper 紧密集成,可用于 12-factor 应用.</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Cobra 建立在 commands(命令), arguments(参数), flags(标志) 之上.</p>
<p><strong>Commands</strong> 表示要执行的操作, <strong>Args</strong> 和 <strong>Flags</strong> 是这些操作的修饰符.</p>
<p>应用程序遵循的命令行模式应该是 <code>APPNAME COMMAND ARG --FLAG</code>.</p>
<p>如下示例中, <code>server</code> 是一个命令,<code>port</code> 是一个标志, <code>1313</code> 是参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hugo server --port=1313</span><br></pre></td></tr></table></figure>

<h3 id="Commands-命令"><a href="#Commands-命令" class="headerlink" title="Commands 命令"></a>Commands 命令</h3><p>命令是应用程序的核心.应用程序支持的每个交互动作都将包含在命令中.命令可以有子命令,还可以执行操作.</p>
<p>在如上示例中,<code>server</code> 是一个命令.</p>
<p>有关命令的更多内容,请参见 <a href="https://godoc.org/github.com/spf13/cobra#Command" target="_blank" rel="noopener">cobra.Command</a>.</p>
<h3 id="Flags-标志"><a href="#Flags-标志" class="headerlink" title="Flags 标志"></a>Flags 标志</h3><p>标志是一种改变命令行为的方法.Cobra 支持 POSIX 风格的标志以及 Go <a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener">flag</a>.Cobra 命令可以定义子命令同样适用的标志和仅用于该命令的标志.</p>
<p>在上面的示例中,<code>port</code> 是一个标志</p>
<p>标志相关功能由 <a href="https://github.com/spf13/pflag" target="_blank" rel="noopener"><code>pflag</code></a> 库提供,该库是 flag 标准库的一个分支,它包含相同的接口,并添加了 POSIX 风格标志的兼容性.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Cobra 的使用非常简单.首先,使用 <code>go get</code> 安装最新版的库.如下命令将安装 <code>cobra</code> 及其依赖项并生成可执行文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#export GO111MODULE=on</span></span><br><span class="line"><span class="comment">#export GOPROXY=https://goproxy.cn</span></span><br><span class="line">go get -u github.com/spf13/cobra</span><br></pre></td></tr></table></figure>

<p>然后,在你的应用中导入 Cobra</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/spf13/cobra"</span></span><br></pre></td></tr></table></figure>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="使用-cobra-命令行工具生成代码"><a href="#使用-cobra-命令行工具生成代码" class="headerlink" title="使用 cobra 命令行工具生成代码"></a>使用 cobra 命令行工具生成代码</h3><p>安装 <code>cobra</code> 后会在 <code>$GOPATH/bin</code> 中生成 <code>cobra</code> 可执行文件,可以使用它来生成大体代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cobra -h</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cobra [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  add         Add a command to a Cobra Application  # 添加子命令</span><br><span class="line">  help        Help about any command    # 帮助信息</span><br><span class="line">  init        Initialize a Cobra Application    # 初始化一个命令</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -a, --author string    author name for copyright attribution (default &quot;YOUR NAME&quot;)    # 指定作者</span><br><span class="line">      --config string    config file (default is $HOME&#x2F;.cobra.yaml) # 指定配置文件</span><br><span class="line">  -h, --help             help for cobra</span><br><span class="line">  -l, --license string   name of license for the project    # 指定项目的 license,默认基于 Apache 2.0</span><br><span class="line">      --viper            use Viper for configuration (default true)</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>cobra init &lt;appName&gt;</code> 自动创建应用程序.如 <code>cobra init cli</code>. 基于 Cobra 的应用程序通常会遵循以下组织结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">▾ cli&#x2F;</span><br><span class="line">▾ cmd&#x2F;</span><br><span class="line">    root.go</span><br><span class="line">  main.go</span><br></pre></td></tr></table></figure>

<p>在 Cobra 应用程序中,通常 <code>main.go</code> 文件非常简单,它只有一个目的: 初识化 Cobra.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"&#123;pathToYourApp&#125;/cmd"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>cmd/root.go</code> 可以发现由 <code>cobra</code> 自动生成的代码, 其中包含自动生成的帮助信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rootCmd represents the base command when called without any subcommands</span></span><br><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">"cli"</span>,</span><br><span class="line">    Short: <span class="string">"A brief description of your application"</span>,</span><br><span class="line">    Long: <span class="string">`A longer description that spans multiple lines and likely contains</span></span><br><span class="line"><span class="string">examples and usage of using your application.`</span>,</span><br><span class="line">    <span class="comment">// Uncomment the following line if your bare application</span></span><br><span class="line">    <span class="comment">// has an action associated with it:</span></span><br><span class="line">    <span class="comment">// Run: func(cmd *cobra.Command, args []string) &#123; &#125;,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute adds all child commands to the root command and sets flags appropriately.</span></span><br><span class="line"><span class="comment">// This is called by main.main(). It only needs to happen once to the rootCmd.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cobra.CheckErr(rootCmd.Execute())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过 <code>cobra add &lt;subcommand&gt;</code> 添加子命令,如 <code>cobra add app</code>.</p>
<p>cobra 会自动生成 app 子命令的相关代码.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> appCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"app"</span>,</span><br><span class="line">  Short: <span class="string">"A brief description of your command"</span>,</span><br><span class="line">  Long: <span class="string">`A longer description that spans multiple lines and likely contains examples</span></span><br><span class="line"><span class="string">and usage of using your command.`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"app called"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 init() 中 rootCmd 添加了 appCmd 子命令. AddCommand 可以在父命令中添加子命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rootCmd.AddCommand(appCmd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面,我们在 app 子命令下继续添加子命令 remove, 结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli</span><br><span class="line">|----app</span><br><span class="line">      |----remove</span><br></pre></td></tr></table></figure>

<p>而 <code>cobra add remove</code> 实际生成的代码将会是如下结构,因此需要手动修改 <code>remove.go</code> 里的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli</span><br><span class="line">|----app</span><br><span class="line">|----remove</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rootCmd.AddCommand(removeCmd)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要修改为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  appCmd.AddCommand(removeCmd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时,可以看到 remove 子命令在 app 命令下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  cli app [flags]</span><br><span class="line">  cli app [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  remove      A brief description of your command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help   help for app</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --config string   config file (default is $HOME&#x2F;.cli.yaml)</span><br><span class="line"></span><br><span class="line">Use &quot;cli app [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure>

<p>此时,文件目录结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">▾ cli&#x2F;</span><br><span class="line">▾ cmd&#x2F;</span><br><span class="line">    app.go</span><br><span class="line">    remove.go</span><br><span class="line">    root.go</span><br><span class="line">  main.go</span><br></pre></td></tr></table></figure>

<p>为了规范化,命令及子命令的目录结构,将子命令放在同一包下,如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">▾ cli&#x2F;</span><br><span class="line">▾ cmd&#x2F;</span><br><span class="line">    ▾ app1&#x2F;</span><br><span class="line">        app1.go</span><br><span class="line">        remove.go</span><br><span class="line">    ▾ app2&#x2F;</span><br><span class="line">        app2.go</span><br><span class="line">        remove.go</span><br><span class="line">    root.go</span><br><span class="line">  main.go</span><br></pre></td></tr></table></figure>

<p>则需要进行如下操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 将 app 声明为其他包可访问的变量. var appCmd 变更为 var AppCmd</span><br><span class="line">2. 在 app.go 中的 init() 函数中使用 AppCmd.AddCommand() 函数添加 remove 子命令</span><br><span class="line">3. 在 root.go 中的 init() 函数中使用 rootCmd.AddCommand() 函数添加多个 app 子命令</span><br></pre></td></tr></table></figure>

<h4 id="Command的常见字段"><a href="#Command的常见字段" class="headerlink" title="Command的常见字段"></a>Command的常见字段</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">    Use       <span class="keyword">string</span>   <span class="comment">// 单行的用法信息,可以理解为为命令名称</span></span><br><span class="line">    Aliases   []<span class="keyword">string</span> <span class="comment">// 命令别名</span></span><br><span class="line">    Short     <span class="keyword">string</span>   <span class="comment">// 短帮助信息</span></span><br><span class="line">    Long      <span class="keyword">string</span>   <span class="comment">// 长帮助信息</span></span><br><span class="line">    Example   <span class="keyword">string</span>   <span class="comment">// 命令的用法示例</span></span><br><span class="line">    ValidArgs []<span class="keyword">string</span> <span class="comment">// 命令行中传入非标志位参数的有效列表</span></span><br><span class="line">    <span class="comment">// ValidArgsFunction 用于判断命令行中传入非标志位参数是否有效</span></span><br><span class="line">    ValidArgsFunction      <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="keyword">string</span>, toComplete <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, ShellCompDirective)</span></span></span><br><span class="line">    Args                   PositionalArgs <span class="comment">// 限定命令行参数,见 Args 小节</span></span><br><span class="line">    BashCompletionFunction <span class="keyword">string</span>         <span class="comment">// 生成命令行补全命令的函数</span></span><br><span class="line">    Deprecated             <span class="keyword">string</span>         <span class="comment">// 过期命令执行时打印的内容</span></span><br><span class="line">    Version                <span class="keyword">string</span>         <span class="comment">// 定义命令版本内容,一般使用 cmd.SetVersionTemplate() 设置版本信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *Run func(cmd *cobra.Command, args []string)</span></span><br><span class="line">    <span class="comment">// The *Run functions are executed in the following order:</span></span><br><span class="line">    <span class="comment">//   * PersistentPreRun()</span></span><br><span class="line">    <span class="comment">//   * PreRun()</span></span><br><span class="line">    <span class="comment">//   * Run()</span></span><br><span class="line">    <span class="comment">//   * PostRun()</span></span><br><span class="line">    <span class="comment">//   * PersistentPostRun()</span></span><br><span class="line">    <span class="comment">// All functions get the same args, the arguments after the command name.</span></span><br><span class="line"></span><br><span class="line">    TraverseChildren   <span class="keyword">bool</span> <span class="comment">// 是否继承父命令的标志位</span></span><br><span class="line">    Hidden             <span class="keyword">bool</span> <span class="comment">// 是否隐藏此命令</span></span><br><span class="line">    SilenceErrors      <span class="keyword">bool</span> <span class="comment">// 是否静默错误</span></span><br><span class="line">    SilenceUsage       <span class="keyword">bool</span> <span class="comment">// 是否在错误发生时静默用法信息,默认在发生错误时会打印用法信息</span></span><br><span class="line">    DisableSuggestions <span class="keyword">bool</span> <span class="comment">// 是否禁用命令建议</span></span><br><span class="line">    SuggestionsMinimumDistance  <span class="keyword">int</span> <span class="comment">// 最小 levenshtein 距离以显示建议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Command的常见方法"><a href="#Command的常见方法" class="headerlink" title="Command的常见方法"></a>Command的常见方法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">AddCommand</span><span class="params">(cmds ...*Command)</span>  // 添加子命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">error</span> // 运行命令树,并解析标志位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">Flags</span><span class="params">()</span> *<span class="title">flag</span>.<span class="title">FlagSet</span> // 获取命令的标志位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">GenBashCompletion</span><span class="params">(w io.Writer)</span> <span class="title">error</span>  // 生成 <span class="title">bash</span> 自动完成文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印帮助,用法,版本等信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">Help</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">HelpFunc</span><span class="params">()</span> <span class="title">func</span><span class="params">(*Command, []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">HelpTemplate</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">Usage</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">UsageFunc</span><span class="params">()</span> <span class="params">(f <span class="keyword">func</span>(*Command)</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">UsageTemplate</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">VersionTemplate</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置帮助,用法,版本等信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">SetHelpFunc</span><span class="params">(f <span class="keyword">func</span>(*Command, []<span class="keyword">string</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">SetHelpTemplate</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">SetUsageFunc</span><span class="params">(f <span class="keyword">func</span>(*Command)</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">SetUsageTemplate</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">SetVersionTemplate</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span> <span class="title">ValidateArgs</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Flags"><a href="#使用-Flags" class="headerlink" title="使用 Flags"></a>使用 Flags</h3><p>Flags 提供修饰符用于控制命令操作的方式.标志有两种不同的指配方式.</p>
<h4 id="全局标志位与局部标志位"><a href="#全局标志位与局部标志位" class="headerlink" title="全局标志位与局部标志位"></a>全局标志位与局部标志位</h4><p>一个标志是 <code>persistent</code>,意味着该标志可用于指配给它的命令及该命令下的每个子命令.即全局标志.对于全局标志,将标志指配为 <code>rootcmd</code> 根命令上的持久标志.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, <span class="string">"verbose"</span>, <span class="string">"v"</span>, <span class="literal">false</span>, <span class="string">"verbose output"</span>)   <span class="comment">// 全局标志位</span></span><br><span class="line">localCmd.Flags().StringVarP(&amp;Source, <span class="string">"source"</span>, <span class="string">"s"</span>, <span class="string">""</span>, <span class="string">"Source directory to read from"</span>)   <span class="comment">// 仅限于该命令使用的</span></span><br></pre></td></tr></table></figure>

<h4 id="标志位参数获取"><a href="#标志位参数获取" class="headerlink" title="标志位参数获取"></a>标志位参数获取</h4><p>由于标志位是不同位置定义和使用的,因此我们需要在外部定义一个具有正确作用域的变量以分配要使用的标志位.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Verbose <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> Source <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">localCmd.Flags().StringVarP(&amp;Source, <span class="string">"source"</span>, <span class="string">"s"</span>, <span class="string">""</span>, <span class="string">"Source directory to read from"</span>)</span><br></pre></td></tr></table></figure>

<p>其中,添加选项参数都是在 <code>init()</code> 函数里使用 <code>cmd.Flags()</code> 或者 <code>cmd.PersistentFlags()</code> 的方法,且具有以下使用规律</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type    typeP</span><br><span class="line">typeVar typeVarP</span><br></pre></td></tr></table></figure>

<p>有如下区别:</p>
<ul>
<li><code>typeP</code>,<code>typeVarP</code> 相对于 <code>type</code>, <code>typeVar</code> 多了一个短选项,而没有 P 的只能使用类似于 <code>--long-iotion</code> 格式的长选项.</li>
<li><code>typeVar</code>, <code>typeVarP</code> 支持传入一个变量地址,从而将标志位传入的值直接传入到该变量中.而不需要使用 <code>GetType(&quot;optionName&quot;)</code>.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">String(name <span class="keyword">string</span>, value <span class="keyword">string</span>, usage <span class="keyword">string</span>)</span><br><span class="line">StringP(name, shorthand <span class="keyword">string</span>, value <span class="keyword">string</span>, usage <span class="keyword">string</span>)</span><br><span class="line">StringVar(p *<span class="keyword">string</span>, name <span class="keyword">string</span>, value <span class="keyword">string</span>, usage <span class="keyword">string</span>)</span><br><span class="line">StringVarP(p *<span class="keyword">string</span>, name, shorthand <span class="keyword">string</span>, value <span class="keyword">string</span>, usage <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// name: 标志位名称</span></span><br><span class="line"><span class="comment">// value: 默认值</span></span><br><span class="line"><span class="comment">// usage: 帮助信息</span></span><br><span class="line"><span class="comment">// shorthand: 短标志位名称</span></span><br><span class="line"><span class="comment">// p: 标志位获取到的值传入该参数</span></span><br></pre></td></tr></table></figure>

<h4 id="标志位继承"><a href="#标志位继承" class="headerlink" title="标志位继承"></a>标志位继承</h4><p>默认情况下,Cobra 仅解析目标命令上的局部标志,而忽略父命令上的任何局部标志.通过启用 <code>Command.TraverseChildren</code>,Cobra 将在执行目标命令之前解析每个命令上的局部标志.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">command := cobra.Command&#123;</span><br><span class="line">    Use: <span class="string">"print [OPTIONS] [COMMANDS]"</span>,</span><br><span class="line">    TraverseChildren: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标志与配置绑定"><a href="#标志与配置绑定" class="headerlink" title="标志与配置绑定"></a>标志与配置绑定</h4><p>您还可以通过 <a href="https://github.com/spf13/viper" target="_blank" rel="noopener"><code>viper</code></a> 绑定标志:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> author <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rootCmd.PersistentFlags().StringVar(&amp;author, <span class="string">"author"</span>, <span class="string">"YOUR NAME"</span>, <span class="string">"Author name for copyright attribution"</span>)</span><br><span class="line">    viper.BindPFlag(<span class="string">"author"</span>, rootCmd.PersistentFlags().Lookup(<span class="string">"author"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在如上示例中,持久标志 <code>author</code> 被 <code>viper</code> 绑定.注意,当用户没有指定 <code>--author</code> 标志时,<code>author</code> 变量不会被赋值.</p>
<h4 id="必须的标志位"><a href="#必须的标志位" class="headerlink" title="必须的标志位"></a>必须的标志位</h4><p>标志默认是可选的.如果您希望命令在未设置标志时报错,请将其标记为 <code>required</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rootCmd.Flags().StringVarP(&amp;Region, <span class="string">"region"</span>, <span class="string">"r"</span>, <span class="string">""</span>, <span class="string">"AWS region (required)"</span>)</span><br><span class="line">rootCmd.MarkFlagRequired(<span class="string">"region"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Args-自定义参数"><a href="#Args-自定义参数" class="headerlink" title="Args 自定义参数"></a>Args 自定义参数</h3><p>可以使用 <code>Command</code> 的 <code>Args</code> 字段指定参数的校验规则.</p>
<p>Cobra 内置了如下校验规则:</p>
<ul>
<li><code>NoArgs</code> - 如果有任何参数,该命令将报错</li>
<li><code>ArbitraryArgs</code> - 该命令接受任何参数</li>
<li><code>OnlyValidArgs</code> - 如果有任何参数不在 <code>Command</code> 的 <code>ValidArgs</code> 字段中,则该命令将报错</li>
<li><code>MinimumNArgs(int)</code> - 至少需要 N 个参数,否则将报错</li>
<li><code>MaximumNArgs(int)</code> - 最多传入 N 个参数,否则将报错</li>
<li><code>ExactArgs(int)</code> - 传入参数个数为 N,否则将报错</li>
<li><code>ExactValidArgs(int)</code> - 传入参数个数为 N,且每个参数都在 <code>Command</code> 的 <code>ValidArgs</code> 字段中,否则将报错</li>
<li><code>RangeArgs(min, max)</code> - 参数的数量在 min 和 max 之间,否则将报错</li>
</ul>
<p>如下是自定义参数验证的示例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cmd = &amp;cobra.Command&#123;</span><br><span class="line">  Short: <span class="string">"hello"</span>,</span><br><span class="line">  Args: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">"requires a color argument"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> myapp.IsValidColor(args[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid color specified: %s"</span>, args[<span class="number">0</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义帮助-用法-版本信息"><a href="#自定义帮助-用法-版本信息" class="headerlink" title="自定义帮助,用法,版本信息"></a>自定义帮助,用法,版本信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义帮助信息</span></span><br><span class="line">cmd.SetHelpCommand(cmd *Command)</span><br><span class="line">cmd.SetHelpFunc(f <span class="function"><span class="keyword">func</span><span class="params">(*Command, []<span class="keyword">string</span>)</span>)</span></span><br><span class="line">cmd.SetHelpTemplate(s <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义用法信息</span></span><br><span class="line">cmd.SetUsageFunc(f <span class="function"><span class="keyword">func</span><span class="params">(*Command)</span> <span class="title">error</span>)</span></span><br><span class="line">cmd.SetUsageTemplate(s <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义版本信息</span></span><br><span class="line">cmd.setVersionTemplate(s <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>

<h3 id="PreRun-and-PostRun-Hooks"><a href="#PreRun-and-PostRun-Hooks" class="headerlink" title="PreRun and PostRun Hooks"></a>PreRun and PostRun Hooks</h3><p>可以在根命令的 <code>Run</code> 函数之前或之后运行函数.其中, <code>PersistentPreRun</code> 和 <code>PreRun</code> 函数将在 <code>Run</code> 函数之前执行.<code>PersistentPostRun</code> 和 <code>PostRun</code> 将在 <code>Run</code> 函数之后执行.</p>
<p>如果子命令没有定义 <code>Persistent*Run</code> 函数,它们将继承父命令的.这些函数按照以下顺序运行:</p>
<ul>
<li><code>PersistentPreRun</code></li>
<li><code>PreRun</code></li>
<li><code>Run</code></li>
<li><code>PostRun</code></li>
<li><code>PersistentPostRun</code></li>
</ul>
<p>下面是使用所有这些函数的两个命令的示例.子命令执行后,它将运行根命令的 <code>PersistentPreRun</code>,而不运行根命令的 <code>PersistentPostRun</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">"root [sub]"</span>,</span><br><span class="line">    Short: <span class="string">"My root command"</span>,</span><br><span class="line">    PersistentPreRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside rootCmd PersistentPreRun with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PreRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside rootCmd PreRun with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside rootCmd Run with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PostRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside rootCmd PostRun with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PersistentPostRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside rootCmd PersistentPostRun with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> subCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">"sub [no options!]"</span>,</span><br><span class="line">    Short: <span class="string">"My subcommand"</span>,</span><br><span class="line">    PreRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside subCmd PreRun with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside subCmd Run with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PostRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside subCmd PostRun with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PersistentPostRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"Inside subCmd PersistentPostRun with args: %v\n"</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rootCmd.AddCommand(subCmd)</span><br><span class="line"></span><br><span class="line">  rootCmd.SetArgs([]<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;)</span><br><span class="line">  rootCmd.Execute()</span><br><span class="line">  fmt.Println()</span><br><span class="line">  rootCmd.SetArgs([]<span class="keyword">string</span>&#123;<span class="string">"sub"</span>, <span class="string">"arg1"</span>, <span class="string">"arg2"</span>&#125;)</span><br><span class="line">  rootCmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inside rootCmd PersistentPreRun with args: []</span><br><span class="line">Inside rootCmd PreRun with args: []</span><br><span class="line">Inside rootCmd Run with args: []</span><br><span class="line">Inside rootCmd PostRun with args: []</span><br><span class="line">Inside rootCmd PersistentPostRun with args: []</span><br><span class="line"></span><br><span class="line">Inside rootCmd PersistentPreRun with args: [arg1 arg2]</span><br><span class="line">Inside subCmd PreRun with args: [arg1 arg2]</span><br><span class="line">Inside subCmd Run with args: [arg1 arg2]</span><br><span class="line">Inside subCmd PostRun with args: [arg1 arg2]</span><br><span class="line">Inside subCmd PersistentPostRun with args: [arg1 arg2]</span><br></pre></td></tr></table></figure>

<h3 id="Suggestions-when-“unknown-command”-happens"><a href="#Suggestions-when-“unknown-command”-happens" class="headerlink" title="Suggestions when “unknown command” happens"></a>Suggestions when “unknown command” happens</h3><p>出现 “unknown command” 错误时,Cobra 将打印建议.发生错字时,Cobra 的行为类似于 git 命令.例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hugo srever</span><br><span class="line">Error: unknown command &quot;srever&quot; for &quot;hugo&quot;</span><br><span class="line"></span><br><span class="line">Did you mean this?</span><br><span class="line">        server</span><br><span class="line"></span><br><span class="line">Run &#39;hugo --help&#39; for usage.</span><br></pre></td></tr></table></figure>

<p>根据注册的每个子命令,建议都是自动生成的,并使用 <a href="http://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank" rel="noopener">Levenshtein 距离</a>实现.每个匹配最小距离 2(忽略大小写)的已注册命令都将显示建议.</p>
<p>如果要禁用建议或在命令中调整字符串距离,请使用:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">command.DisableSuggestions = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">command.SuggestionsMinimumDistance = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>您还可以使用 <code>SuggestFor</code> 属性来显式设置为给定命令建议的名称,这样就可以针对字符串提出建议,对于您的命令集和不希望使用别名的命令都有意义.如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl remove</span><br><span class="line">Error: unknown command &quot;remove&quot; for &quot;kubectl&quot;</span><br><span class="line"></span><br><span class="line">Did you mean this?</span><br><span class="line">        delete</span><br><span class="line"></span><br><span class="line">Run &#39;kubectl help&#39; for usage.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>3rd</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中 __init__ 和 __new__ 的区别</title>
    <url>/2020/06/08/diffenerce-between-init-and-new-method-in-python/</url>
    <content><![CDATA[<ul>
<li><code>__new__</code> 是实例对象真正的创建函数,在实例对象创建之前被调用,用于创建实例并返回该实例对象</li>
<li><code>__init__</code> 是实例对象的初始化函数,在实例对象创建完成后被调用,用于设置实例对象的初始化属性</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center"><code>__new__</code></th>
<th align="center"><code>__init__</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">静态方法,但不用使用 <code>@staticmethod</code> 装饰器显示声明</td>
<td align="center">实例方法</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">至少包含 <code>cls</code>,代表当前类</td>
<td align="center">至少包含 <code>self</code>,代表当前实例</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">返回对象的实例</td>
<td align="center">禁止返回任何值</td>
</tr>
<tr>
<td align="center">调用顺序</td>
<td align="center">在对象创建前调用</td>
<td align="center">对象创建后初始化过程中调用</td>
</tr>
</tbody></table>
<p>说明</p>
<ul>
<li>如果 <code>__new__</code> 创建的是当前类的实例,会自动调用_ <code>__init__</code> 函数进行初始化,否则后面的 <code>__init__</code> 函数不会被调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'__new__ method in class A'</span>)</span><br><span class="line">        <span class="keyword">return</span> super(A, cls).__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__ method in class A'</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">a = A(<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.nowcoder.com/profile/701230/myFollowings/detail/5726157" target="_blank" rel="noopener">牛客网</a>上有关区别的一道题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__new__和__init__的区别，说法正确的是？ ABCD</span><br><span class="line"></span><br><span class="line">A. __new__ 是一个静态方法,而 __init__ 是一个实例方法</span><br><span class="line">B. __new__ 方法会返回一个创建的实例,而 __init__ 什么都不返回</span><br><span class="line">C. 只有在 __new__ 返回一个 cls 的实例时,后面的 __init__ 才能被调用</span><br><span class="line">D. 当创建一个新实例时调用 __new__,初始化一个实例时用 __init__</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义-new-函数对不可变类型-int-str-tuple-进行修改"><a href="#使用自定义-new-函数对不可变类型-int-str-tuple-进行修改" class="headerlink" title="使用自定义 __new__ 函数对不可变类型(int, str, tuple)进行修改"></a>使用自定义 <code>__new__</code> 函数对不可变类型(int, str, tuple)进行修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbsoluteValue</span><span class="params">(int)</span>:</span></span><br><span class="line">    <span class="comment"># 对 __new__ 函数进行重写,以 abs(value) 创建其实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super(AbsoluteValue, cls).__new__(cls, abs(value))</span><br><span class="line"></span><br><span class="line">abv = AbsoluteValue(<span class="number">-1</span>)</span><br><span class="line">print(abv)</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义-new-函数实现单例模式"><a href="#使用自定义-new-函数实现单例模式" class="headerlink" title="使用自定义 __new__ 函数实现单例模式"></a>使用自定义 <code>__new__</code> 函数实现单例模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: %s, age: %s"</span> % (self.name, self.age)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'instance'</span>):</span><br><span class="line">            cls.instance = super(Person, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'p1'</span>, <span class="number">20</span>)</span><br><span class="line">p2 = Person(<span class="string">'p2'</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(p1, p2)</span><br><span class="line">print(p1 <span class="keyword">is</span> p2) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中 is 与 == 的区别</title>
    <url>/2020/06/08/difference-between-is-and-double-equal-sign-in-python/</url>
    <content><![CDATA[<blockquote>
<p>Python 对象包含的三个基本要素,分别是: id(身份标识),type(数据类型)和value(值)</p>
</blockquote>
<p><code>is</code> 和 <code>==</code> 都是等值判断的.但对对象等值判断的内容并并不相同</p>
<ul>
<li><code>==</code> 用来比较两个对象的 value 值是否相同</li>
<li><code>is</code> 用来比较两个对象的 id 是否相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'hello world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'hello workd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">'cheese'</span>:<span class="number">1</span>,<span class="string">'zh'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">'cheese'</span>:<span class="number">1</span>,<span class="string">'zh'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>如上示例中,当 a,b 值为 [-5,257) 的整数值时,会返回 <code>True</code>.其原因是 Python 为了优化速度,内部维护了小整数对象池,避免整数频繁申请和销毁内存空间.此值的区间为 <code>[-5, 257)</code>.</p>
<p>同样的,对于字符串也有一个类似的对象池.但尚不了解字符串长度范围.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab CI 使用 SSH keys</title>
    <url>/2022/12/10/gitlab-ci-using-ssh-keys/</url>
    <content><![CDATA[<p>GitLab目前还没有在构建环境(GitLab Runner 运行的地方)中管理SSH密钥的内置支持。</p>
<p>在以下场景中，您可能需要使用 SSH密钥:</p>
<ul>
<li>使用包管理器下载私有包。如 Bundler</li>
<li>将应用程序部署到您自己的服务器上。如 Heroku</li>
<li>从构建环境向远程服务器执行SSH命令</li>
<li>将文件从构建环境 Rsync 到远程服务器</li>
</ul>
<p>目前使用最多的方法是通过扩展 <code>.gitlab-ci.yml</code> 将SSH密钥注入构建环境。它是一个适用于任何类型的 Runner (例如Docker或shell)的解决方案。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>使用 <code>ssh-keygen</code> 在本地创建新的 ssh 密钥对</li>
<li>添加 private key 中的内容到 Gitlab 仓库的环境变量中，将公钥复制到您想要访问的服务器上(一般为 <code>~/.ssh/authorized_keys</code> 文件中 )，或者如果您正在访问私有的GitLab存储库，则将其添加为<a href="https://docs.gitlab.com/ee/user/project/deploy_keys/index.html" target="_blank" rel="noopener">部署密钥</a>。</li>
<li>在 job 执行期间运行  <code>ssh-agent</code> 加载私钥</li>
</ol>
<p>可以在 <code>.gitlab-ci.yml</code> 中添加如下内容来运行 <code>ssh-agent</code> 加载私钥。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="comment">## 确认 ssh-agent 已经安装了，如果使用的是 rpm 格式的包，可以使用 yum 包管理器</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'command -v ssh-agent &gt;/dev/null || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )'</span></span><br><span class="line">  <span class="comment">#- 'command -v ssh-agent &gt;/dev/null || ( yum update -y &amp;&amp; yum install openssh-client -y )'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## 运行 ssh-agent (inside the build environment)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">eval</span> <span class="string">$(ssh-agent</span> <span class="string">-s)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## 将保存在 SSH_PRIVATE_KEY 变量中的 SSH 密钥添加到 ssh-agent 中</span></span><br><span class="line">  <span class="comment">## 我们使用 tr 删除行结束符，使 ed25519 加密密钥没有额外的 base64 编码: https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"$SSH_PRIVATE_KEY"</span> <span class="string">|</span> <span class="string">tr</span> <span class="string">-d</span> <span class="string">'\r'</span> <span class="string">|</span> <span class="string">ssh-add</span> <span class="bullet">-</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 创建 ~/.ssh 目录，并配置正确的权限</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="number">700</span> <span class="string">~/.ssh</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## 可选的 git 配置</span></span><br><span class="line">  <span class="comment"># - git config --global user.email "user@example.com"</span></span><br><span class="line">  <span class="comment"># - git config --global user.name "User name"</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## 如果配置了 SSH_KNOWN_HOSTS，则可以取消对下面两行的注释。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"$SSH_KNOWN_HOSTS"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="number">644</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## Alternatively, use ssh-keyscan to scan the keys of your private server.</span></span><br><span class="line">  <span class="comment">## Replace example.com with your private server's domain name. Repeat that</span></span><br><span class="line">  <span class="comment">## command if you have more than one server to connect to.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># - ssh-keyscan example.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line">  <span class="comment"># - chmod 644 ~/.ssh/known_hosts</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## You can optionally disable host key checking. Be aware that by adding that</span></span><br><span class="line">  <span class="comment">## you are susceptible to man-in-the-middle attacks.</span></span><br><span class="line">  <span class="comment">## WARNING: Use this only with the Docker executor, if you use it with shell</span></span><br><span class="line">  <span class="comment">## you will overwrite your user's SSH config.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># - '[[ -f /.dockerenv ]] &amp;&amp; echo -e "Host *\n\tStrictHostKeyChecking no\n\n" &gt;&gt; ~/.ssh/config'</span></span><br></pre></td></tr></table></figure>

<p>在 ssh 登录时有时需要对远程主机添加信任。GitLab 提供了以下3种方式，可以补充在 <code>.gitlab-ci.yml</code> 中以保证 ci 流程正确执行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="comment">## 方式1. 如果配置了 SSH_KNOWN_HOSTS，则可以使用如下方式完善 known_hosts 文件</span></span><br><span class="line">  <span class="comment">## 其中 SSH_KNOWN_HOSTS 变量内容可 通过 `ssh-keyscan remote-server` 获得</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"$SSH_KNOWN_HOSTS"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="number">644</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## 方式2. 直接执行 `ssh-keyscan remote-server` 将生成的密钥保存到 known_hosts 文件中</span></span><br><span class="line">  <span class="comment"># - ssh-keyscan example1.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line">  <span class="comment"># - ssh-keyscan example2.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line">  <span class="comment"># - chmod 644 ~/.ssh/known_hosts</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## 方式3. 可以直接禁用主机密钥的校验。要注意这种方式容易受到中间人攻击</span></span><br><span class="line">  <span class="comment">## 警告: 请只在 Docker executor 中使用这种方式，否则这种方式可能会修改本地的 ssh config</span></span><br><span class="line">  <span class="comment"># - '[[ -f /.dockerenv ]] &amp;&amp; echo -e "Host *\n\tStrictHostKeyChecking no\n\n" &gt;&gt; ~/.ssh/config'</span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://docs.gitlab.com/ee/ci/ssh_keys/" target="_blank" rel="noopener">Using SSH keys with GitLab CI/CD</a></li>
</ul>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>Filebeat 原理及使用</title>
    <url>/2021/04/03/filebeat-details-and-configuration/</url>
    <content><![CDATA[<h2 id="Filebeat-工作原理"><a href="#Filebeat-工作原理" class="headerlink" title="Filebeat 工作原理"></a>Filebeat 工作原理</h2><p>如<a href="https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html" target="_blank" rel="noopener">官方文档</a>所描述的那样,filebeat 包含两个主要的组件,<code>inputs</code> 和<code>harvesters</code>.</p>
<h3 id="harvesters-组件"><a href="#harvesters-组件" class="headerlink" title="harvesters 组件"></a>harvesters 组件</h3><p><code>harvester</code> 负责读取单个文件的内容.它逐行读取每个文件,将内容发送到 <code>output</code>.对于每个文件,filebeat 都会启动一个 harvester,负责打开和关闭文件.默认情况下 filebeat 会使文件处于打开状态,直到达到 <code>close_inactive</code> 配置的未读取到内容的超时时长.</p>
<blockquote>
<p>需要注意的是: 如果 harvester 在读取文件过程中,对该文件删除或重命名,filebeat 会继续读取该文件,直到 harvester 关闭为止.</p>
</blockquote>
<h3 id="inputs-组件"><a href="#inputs-组件" class="headerlink" title="inputs 组件"></a>inputs 组件</h3><p><code>input</code> 负责管理 harvesters 并查找所有可读取的输入源文件.</p>
<p>如果 input 类型为 <code>log</code>,则 input 将查找与定义的 glob 路径匹配的所有文件,并为每个文件启动 harvester.每个 intput 都在其自己的 goroutine 中运行.示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/path2/*.log</span></span><br></pre></td></tr></table></figure>

<p>input 支持多种类型,详见<a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-options.html#filebeat-input-types" target="_blank" rel="noopener">input types</a></p>
<h3 id="filebeat-如何保存文件状态"><a href="#filebeat-如何保存文件状态" class="headerlink" title="filebeat 如何保存文件状态"></a>filebeat 如何保存文件状态</h3><p>filebeat 会保存每个文件的读取状态,并将相关状态刷新到磁盘中的 <code>registry file</code>(注册表文件)中,用于记住 harvester 正在读取的文件的偏移量,并确保发送了所有的日志内容.重新启动 filebeat 时,会使用注册表文件中的数据来重建读取状态,并且 harvester 会在上一次读取到的位置继续进行读取.</p>
<p>由于在 harvester 读取文件过程中,可以重命名或移动文件,因此文件名和路径不足以标识文件.对于每个文件,filebeat 都存储唯一的标识符已检测文件是否被读取过</p>
<p>如果每天创建大量新文件,则可能会发现注册表文件变得太大.有关可以设置为解决此问题的配置选项的详细信息,请参阅<a href="https://www.elastic.co/guide/en/beats/filebeat/current/reduce-registry-size.html" target="_blank" rel="noopener">注册表文件太大</a>相关内容.主要是使用 <code>clean_removed</code> 和<code>clean_inactive</code> 配置,分别对被忽略的旧文件和删除旧文件的注册表信息进行删除.</p>
<h3 id="filebeat-如何保证事件至少一次被传递"><a href="#filebeat-如何保证事件至少一次被传递" class="headerlink" title="filebeat 如何保证事件至少一次被传递"></a>filebeat 如何保证事件至少一次被传递</h3><p>filebeat 之所以能够实现此行为,是因为它在注册表文件中存储了每个事件的传递状态.在定义的 output 无法访问且尚未确认所有事件的情况下,filebeat 将继续尝试发送事件,直到 output 确认它已经收到事件为止.</p>
<p>重新启动 filebeat 时,将再次发送之前发送到 output 但在未确认的所有事件.这样可以确保每个事件至少发送一次,但是最终可能会将重复的事件发送到 output.您可以通过 <code>shutdown_timeout</code> 配置项设置 filebeat 在关闭之前等待的时间.</p>
<h2 id="filebeat-配置"><a href="#filebeat-配置" class="headerlink" title="filebeat 配置"></a>filebeat 配置</h2><p>filebeat 配置文件默认为 <code>filebeat.yml</code>.官方给出了不同平台下 filebeat 配置文件的位置.详见<a href="https://www.elastic.co/guide/en/beats/filebeat/current/directory-layout.html" target="_blank" rel="noopener">官方文档</a></p>
<p>filebeat 支持对 input 等配置进行拆分,并以文件形式包含到主配置文件中</p>
<ul>
<li>可以使用 <code>filebeat.config.inputs</code> 将 inputs 相关配置拆分后,包含到主配置文件中.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.config.inputs:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">inputs.d/*.yml</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>filebeat.config.modules</code> 将 modules 相关配置拆分后,包含到主配置文件中.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.config.modules:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br></pre></td></tr></table></figure>

<h3 id="inputs"><a href="#inputs" class="headerlink" title="inputs"></a>inputs</h3><p>inputs 指定了 filebeat 如何查找和处理输入的数据.配置块为 <code>filebeat.inputs</code>.</p>
<p>inputs 支持多种输入类型,常用的主要如下:</p>
<ul>
<li><code>log</code>: 从日志文件中读取内容</li>
</ul>
<p>inputs 包含一些通用的配置,主要如下:</p>
<table>
<thead>
<tr>
<th align="left">通用配置</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">enabled</td>
<td align="left">是否启用该 input</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">tags</td>
<td align="left">filebeat 为每个事件添加的标签字段列表,主要用于过滤操作</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">fields</td>
<td align="left">添加额外的字段列表到 output.添加的额外字段默认会在 <code>fields</code> 字段下</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">fields_under_root</td>
<td align="left">将额外添加的字段直接添加到 output 中,而不在 <code>fields</code> 字段下</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">processors</td>
<td align="left">应用于输入数据的处理器列表</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">keep_null</td>
<td align="left">是否将值为 null 字段在 output 文档中发布</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">设置来自此输入事件的索引</td>
<td align="left">示例: <code>%{[agent.name]}-myindex-%{+ yyyy.MM.dd}</code>替换为 <code>filebeat-myindex-2019.11.01</code></td>
</tr>
</tbody></table>
<h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><p><code>log</code> 类型的 input 用于从日志文件中读取行,它包含如下参数:</p>
<ul>
<li><code>path</code>: input 读取文件的路径列表</li>
<li><code>recursive_glob.enabled</code>: 是否将 <code>**</code> 扩展为递归 glob 匹配.最多支持 8 级.默认为 true</li>
</ul>
<blockquote>
<p>以下为 <code>log</code>,<code>container</code> 类型共有的参数</p>
</blockquote>
<ul>
<li><code>encoding</code>: 用于读取字符数据的文件编码.如: <code>plain</code>,<code>utf-8</code>,<code>gbk</code>.</li>
<li><code>exclude_lines</code>: 删除与列表中正则表达式匹配的所有行</li>
<li><code>include_lines</code>: 仅保留与列表中正则表达式匹配的所有行</li>
<li><code>harvester_buffer_size</code>: harvester 读取文件时的缓冲区大小,单位字节.默认为 16384(16KB)</li>
<li><code>json</code>: 解码结构为 JSON 消息的日志.</li>
<li><code>exclude_files</code>: 忽略列表中正则表达式匹配的文件</li>
<li><code>ingore_older</code>: 忽略在指定时间之前修改的文件</li>
<li><code>close_inactive</code>: 若在指定时间内文件内容未更新,则关闭文件句柄.一般设置为比日志文件更新频率大的值.默认值为 5m.</li>
<li><code>close_renamed</code>: 是否在重命名文件后,关闭文件处理程序.默认为 false</li>
<li><code>close_removed</code>: 是否在文件删除后,关闭文件处理程序.默认为 false</li>
<li><code>close_eof</code>: 是否在达到文件末尾时,立即关闭文件.默认为 false</li>
<li><code>close_timeout</code>: 在指定的超时时间后,harvester 关闭文件.若文件仍在更新,可以在 <code>scan_frequency</code> 后在次启动新的 harvester.对于释放从磁盘上删除的文件特别有用.默认为 0,表示禁用</li>
<li><code>clean_inactive</code>: 若在指定时间内文件内容未更新,则删除注册表中文件的状态信息</li>
<li><code>clean_removed</code>: 是否在重命名文件后,则删除注册表中文件的状态信息.默认为 true.若文件在段时间内消息并再次出现,则将从头开始读取文件内容</li>
<li><code>scan_frequency</code>: 指定每隔多久扫描一次 path 路径中新文件的频率.默认为 10s</li>
<li><code>scan.sort</code>: 对扫描到的文件按指定字段进行排序.可选值为使用 <code>modtime</code> 修改文件和 <code>filename</code> 文件名称进行排序.默认为空值</li>
<li><code>scan.order</code>: 对扫描到的文件进行升序或降序排序.可选值为 <code>asc</code> 升序和 <code>desc</code> 降序.</li>
<li><code>tail_files</code>: 是否从文件末尾开始进行读取文件,默认值为 false</li>
<li><code>symlinks</code>: 是否除常规文件外还读取符号链接文件.默认为 false.如果符号链接与源文件都在 path 路径下,则可能会发送重复的数据.在处理 Kubernetes 日志文件时很有用.</li>
<li><code>harvester_limit</code>: 限制一个 input 并行启动 harvester 的数量.默认为 0,表示没有限制.</li>
</ul>
<h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><p><code>container</code> 类型的 input 用于从容器日志文件中读取日志文件,它包含如下参数:</p>
<ul>
<li><code>stream</code>: 仅从指定的数据流中读取,可选值为 <code>all</code>,<code>stdout</code> 或 <code>stderr</code>.默认值为 <code>all</code>.</li>
<li><code>format</code>: 使用给定格式读取日志文件.<code>auto</code>,<code>docker</code> 或 <code>cri</code>.默认为 <code>auto</code>,自动检测.</li>
</ul>
<blockquote>
<p>其余参数见 <a href="#log">log</a></p>
</blockquote>
<h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><p><code>kafka</code> 类型的 input 用于从 Kafka 集群中读取日志文件,主要支持的 kafka 集群版本为 <code>0.11 - 2.1.0</code>.它包含如下参数:</p>
<ul>
<li><code>hosts</code>: kafka 集群主机列表</li>
<li><code>topics</code>: 从指定 kafka 主题中读取消息</li>
<li><code>group_id</code>: kafka 消费者组的 id</li>
<li><code>client_id</code>: kafka 客户端 id.可选参数</li>
<li><code>version</code>: kafka 协议版本.默认为 <code>1.0.0</code></li>
<li><code>initial_offset</code>: 从主题读取的初始位置.可选值为 <code>oldest</code> 或 <code>newest</code>.默认为 <code>oldest</code>.</li>
<li><code>connect_backoff</code>: 出现错误后,重新连接 kafka 集群的等待时间.默认为 30s.</li>
<li><code>consume_backoff</code>: 读取失败后,重新读取数据的等待时间.默认为 2s.</li>
<li><code>max_wait_time</code>: 读取时等待最小输入字节数的时间.默认值为 250ms.</li>
<li><code>wait_close</code>: 关闭时,等待传输消息并确认的时间.</li>
<li><code>isolation_level</code>: 设置 kafka 的组隔离级别.默认为 <code>read_uncommitted</code><ul>
<li><code>read_uncommitted</code>: 返回消息通道中的所有消息</li>
<li><code>read_committed</code>: 隐藏作为中止的事务的一部分的消息</li>
</ul>
</li>
<li><code>fatch</code>: 从 kafka 获取数据的相关设置.<code>min</code>,<code>default</code>,<code>max</code> 分别设置获取数据的最小,默认,最大 bytes 数.默认分别为<code>1,1MB,0.</code></li>
<li><code>rebalance</code>: kafka 负载均衡设置<ul>
<li><code>strategy</code>: 负载均衡策略.<code>range</code> 遍历或 <code>roundrobin</code> 轮询.默认为 <code>range</code></li>
<li><code>timeout</code>: 负载均衡的超时时间.默认为 60s</li>
<li><code>max_retries</code>: 负载均衡失败后重启多少次.默认为 4</li>
<li><code>retry_backoff</code>: 负载均衡失败后要等待多长时间.默认为 2s.</li>
</ul>
</li>
</ul>
<h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p><code>redis</code>  类型的 input 用于从 redis 慢日志中读取数据.它包含如下参数:</p>
<ul>
<li><code>hosts</code>: redis 服务列表</li>
<li><code>password</code>: 连接 redis 的密码</li>
<li><code>scan_frequency</code>: 从 redis 慢日志中读取数据的频率.默认为 10s.</li>
<li><code>timeout</code>: 等待 redis 响应的超时时间.默认为 1s.</li>
<li><code>network</code>: redis 连接的网络类型.可选值为 <code>tcp</code>,<code>tcp4</code>,<code>tcp6</code>,<code>unix</code>.默认值为 <code>tcp</code>.</li>
<li><code>maxconn</code>: redis 客户端的最大连接数.默认为 10.</li>
</ul>
<h4 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h4><p><code>syslog</code> 类型的 input 用于从 TCP,UDP,Unix 套接字中读取事件.它包含如下参数:</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left"><code>protocol.udp</code></th>
<th align="left"><code>protocol.tcp</code></th>
<th align="left"><code>protocol.unix</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>max_message_size</code></td>
<td align="left">接收数据的最大大小</td>
<td align="left">10KiB</td>
<td align="left">20MiB</td>
<td align="left">20MiB</td>
</tr>
<tr>
<td align="left"><code>host</code></td>
<td align="left">监听事件流的主机和端口</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left"><code>path</code></td>
<td align="left">unix 套节点地址</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>socket_type</code></td>
<td align="left">unix 套接字类型</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left"><code>stream</code> 或 <code>datagram</code>,默认为 <code>stream</code></td>
</tr>
<tr>
<td align="left"><code>group</code></td>
<td align="left">unix 套接字的属组</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">运行 filebeat 程序的用户属组</td>
</tr>
<tr>
<td align="left"><code>mode</code></td>
<td align="left">unix 套接字的文件模式</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">默认为 <code>0755</code></td>
</tr>
<tr>
<td align="left"><code>read_buffer</code></td>
<td align="left">套接字上读取缓冲区的大小</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">套接字的读写超时时间</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>frame</code></td>
<td align="left">指定用于拆分传入事件的帧</td>
<td align="left">不支持</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>line_delimiter</code></td>
<td align="left">指定分割传入事件的字符</td>
<td align="left">不支持</td>
<td align="left">\n</td>
<td align="left">\n</td>
</tr>
<tr>
<td align="left"><code>max_connections</code></td>
<td align="left">指定任意时间点的最大连接数</td>
<td align="left">不支持</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">不活动的远程连接关闭之前的秒数</td>
<td align="left">不支持</td>
<td align="left">300s</td>
<td align="left">300s</td>
</tr>
<tr>
<td align="left"><code>ssl</code></td>
<td align="left">ssl 参数配置</td>
<td align="left">不支持</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<h4 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h4><p><code>redis</code>  类型的 input 用于从 stdin 中读取事件,它主要用于测试.</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>您可以通过设置 <code>filebeat.yml</code> 配置文件的 <code>output</code> 部分中的参数,将filebeat 中的事件写入到指定 output.filebeat 只能定义一个 output.</p>
<h4 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h4><p><code>elasticsearch</code> 类型的 output 将事件输出到 elasticsearch.它包含以下参数:</p>
<ul>
<li><code>api_key</code>: 使用 api_key 保护与 elasticsearch 的通信.</li>
<li><code>username</code>: elasticsearch 用户名</li>
<li><code>password</code>: elasticsearch 密码</li>
<li><code>parameters</code>: HTTP 参数字典</li>
<li><code>protocol</code>: elasticsearch 协议名称,<code>http</code> 或 <code>https</code>.默认为 <code>http</code></li>
<li><code>path</code>: HTTP API 调用之前的 HTTP 路径前缀.</li>
<li><code>headers</code>: 自定义 HTTP 请求头</li>
</ul>
<blockquote>
<p>以下为 <code>elasticsearch</code>,<code>logstash</code> 类型共有的参数</p>
</blockquote>
<ul>
<li><code>enabled</code>: 是否启用此输出,默认为 <code>true</code></li>
<li><code>hosts</code>: elasticsearch 的主机列表.</li>
<li><code>compression_level</code>: 事件的 gzip 压缩级别,<code>1-9</code> 压缩级别逐级递增.默认为 0,表示不压缩</li>
<li><code>escape_html</code>: 是否转义 html 为字符串.默认为 false</li>
<li><code>worker</code>: 向每个 elasticsearch 实例发送事件的工作程序数,最好在负载均衡模式下使用.默认为 1.</li>
<li><code>proxy_url</code>: 连接 elasticsearch 的代理 URL</li>
<li><code>index</code>: 写入事件事的索引名称.默认值为 <code>filebeat-%{[agent.version]}-%{+yyyy.MM.dd}</code></li>
<li><code>indices</code>: 索引选择器规则的数组.支持条件判断等复杂条件<ul>
<li><code>index</code>: 索引名称</li>
<li><code>mappings</code>: 一个字典,使用 index 返回的值,并将其映射到新名称</li>
<li><code>default</code>: 如果 mapping 没有找到匹配项,则使用默认的字符串</li>
<li><code>when</code>: 在何时使用此索引.见如下示例</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># when 条件判断示例</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["http://localhost:9200"]</span></span><br><span class="line">  <span class="attr">indices:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">index:</span> <span class="string">"warning-<span class="template-variable">%&#123;[agent.version]&#125;</span>-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>"</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">        <span class="attr">message:</span> <span class="string">"WARN"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">index:</span> <span class="string">"error-<span class="template-variable">%&#123;[agent.version]&#125;</span>-<span class="template-variable">%&#123;+yyyy.MM.dd&#125;</span>"</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">        <span class="attr">message:</span> <span class="string">"ERR"</span></span><br><span class="line"><span class="comment"># mapping,default 示例</span></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["http://localhost:9200"]</span></span><br><span class="line">  <span class="attr">indices:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">index:</span> <span class="string">"<span class="template-variable">%&#123;[fields.log_type]&#125;</span>"</span></span><br><span class="line">      <span class="attr">mappings:</span></span><br><span class="line">        <span class="attr">critical:</span> <span class="string">"sev1"</span></span><br><span class="line">        <span class="attr">normal:</span> <span class="string">"sev2"</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">"sev3"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>bulk_max_size</code>: 单个 elasticsearch 批量 API 索引请求中要批量处理的最大事件数.默认为 50.</li>
<li><code>backoff.init</code>: 网络错误后尝试重新连接到 elasticsearch 的等待时长.</li>
<li><code>backoff.max</code>: 网络错误后尝试重新连接到 elasticsearch 的最大等待时长.默认为 60s</li>
<li><code>timeout</code>: elasticsearch 请求的超时时长,默认为 90s.</li>
<li><code>ssl</code>: SSL 配置相关</li>
</ul>
<h4 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h4><p><code>logstash</code> 类型的 output 将事件输出到 logstash.它包含以下参数:</p>
<blockquote>
<p>其余参数见 <a href="#elasticsearch">elasticsearch</a></p>
</blockquote>
<ul>
<li><code>loadbalance</code>: 是否启用多个 logstash 的负载均衡.默认为 false,随机分发到主机上</li>
<li><code>ttl</code>: filebeat 与 logstash 连接的生存时间,之后将重新建立连接.默认为 0,表示禁用此功能</li>
</ul>
<h4 id="kafka-1"><a href="#kafka-1" class="headerlink" title="kafka"></a>kafka</h4><p><code>kafka</code> 类型的 output 将事件输出到 kafka.它包含以下参数:</p>
<ul>
<li><code>enabled</code>: 是否启用此 output</li>
<li><code>hosts</code>: kafka 集群主机列表</li>
<li><code>topic</code>: 从指定 kafka 主题中读取消息</li>
<li><code>topics</code>: topic 选择器规则的数组.支持条件判断等复杂条件<ul>
<li><code>topic</code>: topic 名称</li>
<li><code>mappings</code>: 一个字典,使用 topic 返回的值,并将其映射到新名称</li>
<li><code>default</code>: 如果 mapping 没有找到匹配项,则使用默认的字符串</li>
<li><code>when</code>: 在何时使用此 topic.见如下示例</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output.kafka:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["localhost:9092"]</span></span><br><span class="line">  <span class="attr">topic:</span> <span class="string">"logs-<span class="template-variable">%&#123;[agent.version]&#125;</span>"</span></span><br><span class="line">  <span class="attr">topics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">topic:</span> <span class="string">"critical-<span class="template-variable">%&#123;[agent.version]&#125;</span>"</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">        <span class="attr">message:</span> <span class="string">"CRITICAL"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">topic:</span> <span class="string">"error-<span class="template-variable">%&#123;[agent.version]&#125;</span>"</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">        <span class="attr">message:</span> <span class="string">"ERR"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>version</code>: kafka 协议版本.默认为 <code>1.0.0</code></li>
<li><code>username</code>: 连接 kafka 的用户名</li>
<li><code>password</code>: 连接 kafka 的密码</li>
<li><code>client_id</code>: kafka 客户端 id.可选参数</li>
<li><code>worker</code>: 向每个 kafka 实例发送事件的工作程序数,最好在负载均衡模式下使用.默认为 1.</li>
<li><code>codec</code>: 编码格式.默认为 json</li>
<li><code>metadata</code>: kafka 元数据信息设置.</li>
<li><code>bulk_max_size</code>: 单个 kafka 请求中要批量处理的最大事件数.默认值为 2048.</li>
<li><code>bulk_flush_frequency</code>: 向 kafka 发送请求之前需要等待的时间.默认为 0.表示没有延迟.</li>
<li><code>timeout</code>: kafka 响应超时时间.默认值为 30s</li>
<li><code>channel_buffer_size</code>: kafka 在 output 管道中缓冲的消息数.</li>
<li><code>keep_alive</code>: 活动连接的保持活动时长.默认为 0.表示禁用连接.</li>
<li><code>compression</code>: 压缩编码方式.可选值为 <code>none</code>,<code>snappy</code>,<code>lz4</code> 或 <code>gzip</code>.默认值为 <code>gzip</code>.</li>
<li><code>compression_level</code>: 压缩级别,0-9 依次升高.默认为 4.</li>
<li><code>max_message_bytes</code>: json 消息的最大大小.默认为 100 万字节</li>
</ul>
<h4 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a>redis</h4><p><code>redis</code>  类型的 output 用于将事件输出到 Redis list 或 channel 中.此插件与 logstash  的 redis 输入插件兼容.它包含如下参数:</p>
<ul>
<li><code>enabled</code>: 是否启用此插件</li>
<li><code>hosts</code>: redis 服务列表</li>
<li><code>password</code>: 连接 redis 的密码</li>
<li><code>db</code>: 连接 redis 的数据库.默认为 0.</li>
<li><code>key</code>: 发送事件到 redis 的 list 或 channel 的 key 的名称.若为空,则使用 <code>index</code> 设置的值.</li>
<li><code>index</code>: 添加到事件元数据中的索引名称,以供 logstash 使用.默认值为 <code>filebeat</code>.</li>
<li><code>keys</code>: key 选择器的规则的数组.支持条件判断等复杂条件<ul>
<li><code>key</code>: key 名称</li>
<li><code>mappings</code>: 一个字典,使用 key 返回的值,并将其映射到新名称</li>
<li><code>default</code>: 如果 mapping 没有找到匹配项,则使用默认的字符串</li>
<li><code>when</code>: 在何时使用此 key.见如下示例</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output.redis:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["localhost"]</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">"default_list"</span></span><br><span class="line">  <span class="attr">keys:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"info_list"</span>   <span class="comment"># send to info_list if `message` field contains INFO</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">        <span class="attr">message:</span> <span class="string">"INFO"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"debug_list"</span>  <span class="comment"># send to debug_list if `message` field contains DEBUG</span></span><br><span class="line">      <span class="attr">when.contains:</span></span><br><span class="line">        <span class="attr">message:</span> <span class="string">"DEBUG"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"<span class="template-variable">%&#123;[fields.list]&#125;</span>"</span></span><br><span class="line">      <span class="attr">mappings:</span></span><br><span class="line">        <span class="attr">http:</span> <span class="string">"frontend_list"</span></span><br><span class="line">        <span class="attr">nginx:</span> <span class="string">"frontend_list"</span></span><br><span class="line">        <span class="attr">mysql:</span> <span class="string">"backend_list"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>datatype</code>: 用于发布事件的 redis 数据类型.可选值为 <code>list</code>(使用 <code>rpush</code> 命令)或 <code>channel</code>(使用 <code>publish</code> 命令).默认为 <code>list</code>.</li>
<li><code>codec</code>: 发送到 redis 数据的编码格式.默认为 <code>json</code></li>
<li><code>worker</code>: redis 连接的网络类型.可选值为 <code>tcp</code>,<code>tcp4</code>,<code>tcp6</code>,<code>unix</code>.默认值为 <code>tcp</code>.</li>
<li><code>loadbalance</code>: redis 客户端的最大连接数.默认为 10.</li>
<li><code>timeout</code>: 连接 redis 的超时时间.默认为 5s.</li>
<li><code>backoff.init</code>: 网络错误后尝试重新连接到 redis 的等待时长.默认为 1s.</li>
<li><code>backoff.max</code>: 网络错误后尝试重新连接到 redis 的最大等待时长.默认为 60s.</li>
<li><code>max_retries</code>: 设置重试次数</li>
<li><code>bulk_max_size</code>: 单个 redis 请求或 pipeline 批量发送数据最大数据大小.默认为 2048.</li>
</ul>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p><code>file</code>  类型的 output 用于将事件输出到文件中.每个事件采用 json 格式,主要用于测试.它包含如下参数:</p>
<ul>
<li><code>enabled</code>: 是否启用此插件.默认为 true</li>
<li><code>path</code>: 文件位置.必选参数</li>
<li><code>filename</code>: 生成文件名称.默认设置为 Beat 的名称.如 <code>filebeat</code> 生成文件将是 <code>filebeat.1</code></li>
<li><code>rotate_every_kb</code>: 每个文件的最大大小,以 kb 为单位.超过此大小后,文件会自动滚动.默认值为 1024 kb.</li>
<li><code>number_of_files</code>: <code>path</code> 下保存的最大文件数.最早的文件将被删除.默认为 7.</li>
<li><code>permissions</code>: 指定创建文件的权限.默认值为 <code>0600</code>.</li>
<li><code>codec</code>: 输出事件的编码格式.默认为 json.</li>
</ul>
<h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><p><code>console</code> 类型的 output 用于将事件输出到标准输出.每个事件采用 json 格式,主要用于测试.它包含如下参数:</p>
<ul>
<li><code>pretty</code>: 是否以漂亮格式输出.默认为 false</li>
<li><code>enabled</code>: 是否启用此插件.默认为 true</li>
<li><code>bulk_max_size</code>: 输出缓冲区的最大事件数.默认为 1024.</li>
<li><code>codec</code>: 输出的编码格式</li>
</ul>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>配置文件 <code>filebeat.yml</code> 的 <code>logging</code> 部分包含用于配置日志输出的选项.日志系统可将日志写入 syslog 或滚动日志文件中.如果未显式配置,则使用滚动文件输出日志.它主要包含如下配置项:</p>
<ul>
<li><code>logging.to_stderr</code>: 如果为 true,则将所有日志写入到标准输出中.与使用 <code>-e</code> 选项相同.</li>
<li><code>logging.to_syslog</code>: 如果为 true,则将所有日志写入到 syslog 中.</li>
<li><code>logging.to_files</code>: 如果为 true,则将所有日志写入到滚动日志文件中,在日志文件大小到达一定大小后进行滚动</li>
<li><code>logging.level</code>: 设置日志级别.可选值为 <code>debug</code>,<code>info</code>,<code>warning</code>,<code>error</code>.默认值为 <code>info</code></li>
<li><code>logging.metrics.enabled</code>: 是否定期记录其内部数据指标.</li>
<li><code>logging.metrics.period</code>: 日志记录内部指标的时间间隔.默认为 30s.</li>
<li><code>logging.files.path</code>: 日志文件写入的目录.默认值为 <code>logs</code></li>
<li><code>logging.files.name</code>: 日志的文件名,默认值为 <code>filebeat</code>.</li>
<li><code>logging.files.rotateeverybytes</code>: 日志文件的最大大小.默认值为 10485760 (10 MB).</li>
<li><code>logging.files.keepfiles</code>: 日志保存的文件个数.默认值为 7.</li>
<li><code>logging.files.permissions</code>: 滚动日志时要使用的权限掩码.默认值为 0600.</li>
<li><code>logging.files.interval</code>: 除了基于大小的滚动外,filebeat 日志还支持基于日期的文件滚动.默认是禁用的</li>
<li><code>logging.files.rotateonstartup</code>: 如果日志文件启动时已存在,则立即滚动并写入新的文件中.</li>
<li><code>logging.json</code>: 是否以 json 格式写入文件.默认为 false.</li>
</ul>
<h3 id="HTTP-endpoint"><a href="#HTTP-endpoint" class="headerlink" title="HTTP endpoint"></a>HTTP endpoint</h3><ul>
<li><code>http.enabled</code>: 是否启用 HTTP endpoint.默认为 false</li>
<li><code>http.host</code>: 绑定地址,支持主机名,IP 地址, Unix 套接字.默认为 <code>localhost</code></li>
<li><code>http.port</code>: http endpoint 监听端口.默认为 <code>5066</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /stats 暴露了内部指标,如下</span></span><br><span class="line">curl -XGET <span class="string">'localhost:5066/stats?pretty'</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"beat"</span>: &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="filebeat-reference-yml"><a href="#filebeat-reference-yml" class="headerlink" title="filebeat.reference.yml"></a>filebeat.reference.yml</h3><p>参见<a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-reference-yml.html" target="_blank" rel="noopener">filebeat.reference.yml</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志处理</tag>
        <tag>Filebeat</tag>
      </tags>
  </entry>
  <entry>
    <title>go channel 详解</title>
    <url>/2021/03/11/go-channel-details/</url>
    <content><![CDATA[<h2 id="channel-介绍"><a href="#channel-介绍" class="headerlink" title="channel 介绍"></a>channel 介绍</h2><p>channel 通常与 goroutine 一起使用,是 goroutine 之间通信的一种方式</p>
<h3 id="创建并初始化"><a href="#创建并初始化" class="headerlink" title="创建并初始化"></a>创建并初始化</h3><p>channel 的创建使用内置的 <code>make</code> 函数创建并初始化,初始化方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化缓冲区容量为 cap 的 channel, 用于传递 Type 类型的对象.其中 cap 可省略,表示没有缓冲区</span></span><br><span class="line"><span class="keyword">var</span> chName = <span class="built_in">make</span>(<span class="keyword">chan</span> &lt;chanType&gt;, [<span class="built_in">cap</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如创建并初始化 struct&#123;&#125; 类型的 channel</span></span><br><span class="line"><span class="comment">// ch := make(chan struct&#123;&#125;, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chNil <span class="keyword">chan</span> &lt;chanType&gt;</span><br><span class="line"><span class="comment">// 因为还没有进行初始化,此时创建的 chNil 为 nil.</span></span><br><span class="line">fmt.Println(chNil == <span class="literal">nil</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>根据 channel 创建时 <code>cap</code> 值是否为 0,channel 可分为不带缓冲区的 channel 和带缓冲区的 channel.</p>
<p>对无缓冲区的 channel 发送/接收数据时,无缓冲区的 channel 会发送阻塞.当程序中只有对该 channel 发送或接收数据操作时,该程序会发生死锁.因此在程序中使用无缓冲区的 channel 时,必须同时存在发送和接收操作(可以在 goroutine 中实现),所以无缓冲区的 channel 又被称为同步 channel.</p>
<p>有缓冲区的 channel 类似于一个队列.当缓冲区未满时,向 channel 中发送数据不会阻塞.当缓冲区满时,发送数据操作将被阻塞,直到有其它 goroutine 从中读取消息.</p>
<h3 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h3><p>go 提供了内置的 <code>close</code> 函数对 channel 进行关闭操作.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>有关 channel 的关闭,有如下注意事项:</p>
<ul>
<li>关闭未初始化的 channel (nil) 会产生 panic</li>
<li>关闭已关闭的 channel 会产生 panic</li>
<li>向已关闭的 channel 中发送数据会产生 panic</li>
<li>从一个已关闭的 channel 中读取消息不会产生 panic 和阻塞.如果已关闭的 channel 的缓冲区还有数据,则可以正常读取,并返回值为 <code>true</code> 的 ok-idiom.否则,返回 channel 的默认值和 false 的 ok-idiom.</li>
<li>要将已关闭的 channel 中的数据全部读取出来,可以使用 for-range 方式进行读取.遍历结束后,channel 缓冲区数据为空.此时再进行读取,会返回 channel 的默认值和 false 的 ok-idiom.</li>
</ul>
<p>对已经关闭的 channel 进行遍历如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="keyword">for</span> value := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line">    val, ok := &lt;-ch</span><br><span class="line">    fmt.Println(val, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="goroutine-通信"><a href="#goroutine-通信" class="headerlink" title="goroutine 通信"></a>goroutine 通信</h4><p>看一个 effective go 中的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// Allocate a channel.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the sort in a goroutine; when it completes, signal on the channel.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list.Sort()</span><br><span class="line">    c &lt;- <span class="number">1</span>  <span class="comment">// Send a signal; value does not matter.</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">doSomethingForAWhile()</span><br><span class="line">&lt;-c</span><br></pre></td></tr></table></figure>

<p>主 goroutine 会阻塞,直到执行 sort 的 goroutine 完成.</p>
<h4 id="配合-select-形成多路复用"><a href="#配合-select-形成多路复用" class="headerlink" title="配合 select 形成多路复用"></a>配合 select 形成多路复用</h4><p>select 可以同时监听多个 channel 的消息状态.</p>
<p>当其中一个 <code>case</code> 语句非阻塞,则执行对应 <code>case</code> 语句中的内容.若有多个 <code>case</code> 语句非阻塞,则随机挑选一个 <code>case</code> 语句中的内容执行.</p>
<p>若所有 <code>case</code> 语句均处于阻塞状态且定义了 <code>default</code> 语句,则执行 <code>default</code> 语句中的内容.否则,一直阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    ach, bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            name <span class="keyword">string</span></span><br><span class="line">            x    <span class="keyword">int</span></span><br><span class="line">            ok   <span class="keyword">bool</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> x, ok = &lt;-a:</span><br><span class="line">                name = <span class="string">"a"</span></span><br><span class="line">            <span class="keyword">case</span> x, ok = &lt;-b:</span><br><span class="line">                name = <span class="string">"b"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="comment">// 如果没有数据发送,则跳出循环</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(name, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(&amp;wg, ach, bch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, a, b <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(a)</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(b)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> a &lt;- i:</span><br><span class="line">            <span class="keyword">case</span> b &lt;- i * <span class="number">10</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(&amp;wg, ach, bch)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码,分别创建了生产者和消费者的 goroutine,生产者会随机从 a b channel 中随机挑选一个发送消息,而消费者使用一个 for 循环来监控 a b channel,当 a b 其中一个接收到数据时,则指定对应内容.如果没有数据,则跳出循环,结束 goroutine.</p>
<h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><ul>
<li>设置超时时间</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// finish task while send msg to ch</span></span><br><span class="line"><span class="keyword">go</span> doTask(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序会在 5 s 内超时自动退出</span></span><br><span class="line">timeout := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">        fmt.Println(<span class="string">"task finished."</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">        fmt.Println(<span class="string">"task timeout."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置退出信号</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msgCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- msgCh:</span><br><span class="line">        doSomeWork()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quitCh:</span><br><span class="line">        finish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按指定顺序在 goroutine 中循环打印内容</li>
</ul>
<p>如下是启动了 3 个 goroutine 按顺序分别打印不同的内容,每个 goroutine 打印 n 次的代码实现.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(wg *sync.WaitGroup, counter, n <span class="keyword">int64</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">bool</span>, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// if 必须在 &lt;- in 之前进行判断,否则 return 时会发生死锁</span></span><br><span class="line">        <span class="keyword">if</span> counter &gt;= n &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// 别忘了 return</span></span><br><span class="line">        &#125;</span><br><span class="line">        x := &lt;-in <span class="comment">// 使用 x 作为启动函数的标志,信号进入到此函数</span></span><br><span class="line">        fmt.Println(message)</span><br><span class="line">        atomic.AddInt64(&amp;counter, <span class="number">1</span>) <span class="comment">// 原子操作,协程数据安全</span></span><br><span class="line">        out &lt;- x                     <span class="comment">// 信号离开此函数,并进入到下一个函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        dogCh   = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>) <span class="comment">// 必须定义为缓冲区为 1 的 channel,用于保存启动信号/标志</span></span><br><span class="line">        catCh   = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">        fishCh  = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">        wg      sync.WaitGroup</span><br><span class="line">        n       <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">        counter <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    dogCh &lt;- <span class="literal">true</span> <span class="comment">//启动的信号</span></span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> f(&amp;wg, <span class="number">0</span>, n, dogCh, catCh, <span class="string">"dog"</span>)</span><br><span class="line">    <span class="keyword">go</span> f(&amp;wg, <span class="number">0</span>, n, catCh, fishCh, <span class="string">"cat"</span>)</span><br><span class="line">    <span class="keyword">go</span> f(&amp;wg, <span class="number">0</span>, n, fishCh, dogCh, <span class="string">"fish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="channel-源码分析"><a href="#channel-源码分析" class="headerlink" title="channel 源码分析"></a>channel 源码分析</h2><p>channel 的实现主要在 <code>${GOROOT}/src/runtime/chan.go</code> 中.该文件包含 channel 的整个生命周期,包含 channel 的结构体定义,初始化函数,发送/接收数据函数以及 channel 的关闭函数.</p>
<p>主要可以概括为以下内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 初始化</span><br><span class="line">make(chann interface&#123;&#125;, size)  &#x3D;&gt;  runtime.makechan(interface&#123;&#125;, size)</span><br><span class="line">make(chann interface&#123;&#125;)        &#x3D;&gt;  runtime.makechan(interface&#123;&#125;, 0)</span><br><span class="line"></span><br><span class="line"># 2. 发送数据</span><br><span class="line">ch &lt;- v  &#x3D;&gt;  runtime.chansend1(ch, &amp;v)</span><br><span class="line"></span><br><span class="line"># 3. 接收数据</span><br><span class="line">v &lt;- ch      &#x3D;&gt;  runtime.chanrecv1(ch, &amp;v)</span><br><span class="line">v, ok &lt;- ch  &#x3D;&gt;  runtime.chanrecv2(ch, &amp;v)</span><br><span class="line"></span><br><span class="line"># 4. 关闭 channel</span><br><span class="line">close(ch)    &#x3D;&gt;  runtime.closechan(ch)</span><br></pre></td></tr></table></figure>

<h3 id="hchan-结构体"><a href="#hchan-结构体" class="headerlink" title="hchan 结构体"></a>hchan 结构体</h3><p>channel 的结构体定义为 <code>hchan</code>,其定义如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue 队列中所有数据的总数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue 环形队列的大小,由 make 初始化时的 size 决定</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements 指向大小为 dataqsiz 数组的指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span> <span class="comment">// 元素大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span> <span class="comment">// 是否关闭</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type 元素数据类型,由 make 初始化时的 元素类型决定</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index 发送索引</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index 接收索引</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters  recv 等待列表,即 &lt;-ch</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters  send 等待列表,即 ch&lt;-</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    <span class="comment">// Trans: lock 保护了 hchan 的所有字段,以及在此 channel 上阻塞的 sudog 的一些字段</span></span><br><span class="line">    <span class="comment">// 当持有此锁时不应改变其它 G 的状态,因为它在栈收缩时会发生死锁</span></span><br><span class="line">    lock mutex  <span class="comment">// 锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以理解为由封装了 goroutine 的 sudog 组成的双向环形链表,</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;GOROOT&#125;/src/runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// 双向环形链表的元素结构体,内部封装了 goroutine 的指针</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">    <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">    <span class="comment">// this for sudogs involved in channel ops. </span></span><br><span class="line">    g *g    <span class="comment">// goroutine 的指针</span></span><br><span class="line">    next *sudog  <span class="comment">// 链表的下一个节点</span></span><br><span class="line">    prev *sudog  <span class="comment">// 前一个节点</span></span><br><span class="line">    elem unsafe.Pointer <span class="comment">// 数据元素 data element (may point to stack) </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">    <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">    <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">    <span class="comment">// are only accessed when holding a semaRoot lock.  </span></span><br><span class="line">    acquiretime <span class="keyword">int64</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">    ticket      <span class="keyword">uint32</span>  </span><br><span class="line">    <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">    <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">    isSelect <span class="keyword">bool</span>   </span><br><span class="line">    parent   *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">    waitlink *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c        *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上结构体定义可以了解到 channel 内部的主要实现:</p>
<ul>
<li>一个环形数组实现的队列,用于存储消息元素.其中涉及的属性包括队列指针,队列容量,队列中元素类型,元素大小,队元素个数</li>
<li>两个元素为 <code>sudog</code> 的双向链表,<code>recvq</code> 和 <code>sendq</code>,表示接收/发送数据的等待队列.其中 <code>sudog</code> 封装了 goroutine 的指针及要传输的数据元素.</li>
<li>一个互斥锁,用于 channel 各个属性变动的同步</li>
<li>一个用于判断 channel 是否关闭的标志位 closed</li>
</ul>
<p><img src="/images/hchan-structure-visualization.png" alt="hchan 结构可视化"></p>
<h3 id="channel-初始化"><a href="#channel-初始化" class="headerlink" title="channel 初始化"></a>channel 初始化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 make 时指定元素类型及容量计算环形队列 buf 所需内存</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 环形队列容量大小为 0, make(chan interface&#123;&#125;)</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">        <span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">        <span class="comment">// 元素不包含指针时,分配连续的内存</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>)) <span class="comment">// 为 channel 和 环形队列分配连续的内存</span></span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Elements contain pointers.</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入相关属性值</span></span><br><span class="line">    c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>从以下代码可以看出, send 分为以下 3 种情况:</p>
<ol>
<li>有 receiver 的 goroutine 阻塞在 channel 的 recvq 队列上,此时 channel 的缓冲队列为空.若有数据发送,则直接将数据发送给 receiver 的 goroutine.Go 在此处做了优化,数据只产生一次复制.</li>
<li>当 channel 缓冲队列仍有剩余空间时,会将数据放到缓冲队列里,等待 receiver 的 goroutine接收.</li>
<li>当 channel 缓存队列已满时,将当前 goroutine 加入 sendq 队列并阻塞.</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断 c 是否为空,若为空,则执行 gopark,会进行锁定</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fastpath: 快速检测 channel 是否关闭或其元素已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// fastpath: 再次进行检测</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case1: 如果 channel 的接收队列中已经有 goroutine 等待接收,则直接发送到 receiver</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case2: 如果队列未满,则将其移动到队列中,并使 send 索引和队列中元素数加1</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case3: 缓存队列已满,将 goroutine 加入缓存队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 获取 sudog.这里点进去会发现,获取 sudog 的方式为 优先从全局拿,数量为本地缓存队列空间的一半.如果没有,则创建新的 sudog</span></span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将 sudog 添加到 队列中</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// Signal to anyone trying to shrink our stack that we're about</span></span><br><span class="line">    <span class="comment">// to park on a channel. The window between when this G's status</span></span><br><span class="line">    <span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line">    <span class="comment">// stack shrinking.</span></span><br><span class="line">    atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 阻塞,等待重新被调度后继续从此位置开始执行</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 释放 sudog</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>同样的,我们再来看接收数据.从以下代码可以看出, recv 分为以下 3 种情况:</p>
<ol>
<li>有 sender 的 goroutine 阻塞在 channel 的 recvq 队列上.<ol>
<li>若 channel 的缓冲队列不存在,则直接从 sender 的 goroutine 接收数据.</li>
<li>若 channel 的缓冲队列已满,则从 channel 的缓冲区队列头部获取数据,并复制发送者数据到缓冲队列中,并使得 send/recv 索引自增.</li>
<li>数据接收完成后释放锁,并使得 sender 的 goroutine 处于 ready 状态</li>
</ol>
</li>
<li>当 channel 缓冲队列仍有数据时,会直接将数据接收,并使得 recv 索引自增,qcount 元素个数自减</li>
<li>当 channel 缓存队列没有数据时,将 receiver 的 goroutine 加入 recvq 队列，并阻塞.</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    _, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">    <span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fastpath: 快速检测 channel 是否为 nil</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: 快速检查失败的非阻塞操作</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line">        <span class="comment">// channel 是否已经被关闭</span></span><br><span class="line">        <span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快速检查是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> empty(c) &#123;</span><br><span class="line">            <span class="comment">// The channel is irreversibly closed and empty.</span></span><br><span class="line">            <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">                raceacquire(c.raceaddr())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次进行检查</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case1: 如果 channel 的发送列中已经有 sender 的 goroutine 等待发送,则</span></span><br><span class="line">    <span class="comment">// 当没有缓冲队列时(c.dataqsiz == 0),直接从等待的 goroutine 中接收数据</span></span><br><span class="line">    <span class="comment">// 当缓冲队列已满,则从 channel 的缓冲区队列头部获取数据,并复制发送者数据到缓冲队列中,并使得 send/recv 索引自增.</span></span><br><span class="line">    <span class="comment">// 最终解锁并使得  sender 的 goroutine 处于 ready 状态</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">        <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">        <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">        <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case2: channel 缓冲队列不为空,则直接从缓冲队列中获取数据,并使得 recv 索引自增,qcount 元素个数自减</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Receive directly from queue</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">    <span class="comment">// case3: 缓存队列为空,将 receiver 的 goroutine 加入 recvq 队列，并阻塞.细节基本与发送数据的 case3 一致</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.recvq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// Signal to anyone trying to shrink our stack that we're about</span></span><br><span class="line">    <span class="comment">// to park on a channel. The window between when this G's status</span></span><br><span class="line">    <span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line">    <span class="comment">// stack shrinking.</span></span><br><span class="line">    atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closed := gp.param == <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>从以下代码片段可以看出,关闭 channel 时做了如下事情:</p>
<ul>
<li>channel 的 close 标志位置为 1,表示关闭状态</li>
<li>创建 glist,用于保存 recvq 和 sendq 中的 goroutine</li>
<li>保存完成后,释放锁.(这里先释放锁,避免使 glist 中 goroutine 处于 ready 状态时锁的消耗)</li>
<li>使得 glist 中的 goroutine 处于 ready 状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// fastpaht: 关闭 nil 的 channel 引发 panic</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁后判断,关闭已关闭 channel 引发 panic</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">        racerelease(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release all readers</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">            sg.elem = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/24ede9e90490" target="_blank" rel="noopener">由浅入深剖析 go channel</a></li>
<li><a href="https://www.bilibili.com/video/BV1g4411R7p5" target="_blank" rel="noopener">Go 夜读 - #56 channel &amp; select 源码分析</a></li>
<li><a href="https://github.com/talkgo/night/issues/450" target="_blank" rel="noopener">Go 夜读 - 第 56 期 channel &amp; select 源码分析</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>面试</tag>
        <tag>channel</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>go http 包处理请求过程分析</title>
    <url>/2020/07/06/go-http-package-process-request-analysis/</url>
    <content><![CDATA[<p>先上一个简单的通过 “net/http” 包编写的服务端程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 http.Handler 接口中的 ServeHTTP 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch CustomHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 CustomHandler 实例对象,传入 ListenAndServe 函数</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, CustomHandler&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来看一下 <code>http.ListenAndServe(&quot;:8080&quot;, CustomHandler{})</code> 这段代码是如何处理请求的</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="创建-http-Server-对象"><a href="#创建-http-Server-对象" class="headerlink" title="创建 http.Server 对象"></a>创建 <code>http.Server</code> 对象</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L3084</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过传入的 addr(监听地址),与 Handler 实例(CustomHandler&#123;&#125;),创建 Server 对象</span></span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="comment">// 并调用 Server 对象的 ListenAndServe 方法.</span></span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-net-Listener-对象-并监听指定地址"><a href="#创建-net-Listener-对象-并监听指定地址" class="headerlink" title="创建 net.Listener 对象,并监听指定地址"></a>创建 <code>net.Listener</code> 对象,并监听指定地址</h3><p><code>server.ListenAndServe()</code> 代码做了如下事情</p>
<ol>
<li>根据传入的参数创建 <code>net.ListenConfig</code> 对象,实际是创建了 <code>net.Listener</code> 对象.如 <code>TCPListener</code>,<code>UnixListener</code></li>
<li>使用创建的 <code>net.ListenConfig</code> 对象中的 <code>TCPListener</code> 成员实例监听指定地址.</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// // net/http/server.go#2818</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果 srv 关闭,则返回 ErrServerClosed = errors.New("http: Server closed") 错误</span></span><br><span class="line">    <span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 srv.Addr(我们传入的是 "8080") 地址是否为空</span></span><br><span class="line">    <span class="comment">// 若为空,则设置为 ":http",这里应该会默认监听 80 端口</span></span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">        addr = <span class="string">":http"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  创建 TCPListener 对象,用于后续监听端口,接收连接</span></span><br><span class="line">    ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中,<code>net.Listen()</code> 函数会根据传入的参数创建 <code>net.TCPListener</code> 或 <code>net.UnixListener</code> 对象,用于后续监听 TCP 端口或 Unix 套接字.源代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/dial.go#L705</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lc ListenConfig</span><br><span class="line">    <span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/dial.goL#623</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lc *ListenConfig)</span> <span class="title">Listen</span><span class="params">(ctx context.Context, network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span> &#123;</span><br><span class="line">    addrs, err := DefaultResolver.resolveAddrList(ctx, <span class="string">"listen"</span>, network, address, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"listen"</span>, Net: network, Source: <span class="literal">nil</span>, Addr: <span class="literal">nil</span>, Err: err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sl := &amp;sysListener&#123;</span><br><span class="line">        ListenConfig: *lc,</span><br><span class="line">        network:      network,</span><br><span class="line">        address:      address,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> l Listener</span><br><span class="line">    <span class="comment">// first 会调用传入的函数 isIPv4,判断调用者中元素是否是 ipv4 地址</span></span><br><span class="line">    la := addrs.first(isIPv4)</span><br><span class="line">    <span class="comment">// 判断 la 类型,如果是 `TCPAddr`,则调用 listenTCP 创建 `TCPListener`</span></span><br><span class="line">    <span class="comment">// 如果是 `UnixAddr`,则调用 listenUnix 创建 `UnixListener`</span></span><br><span class="line">    <span class="keyword">switch</span> la := la.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *TCPAddr:</span><br><span class="line">        <span class="comment">// 返回 TCPListener 实例,见下代码</span></span><br><span class="line">        l, err = sl.listenTCP(ctx, la)</span><br><span class="line">    <span class="keyword">case</span> *UnixAddr:</span><br><span class="line">        l, err = sl.listenUnix(ctx, la)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"listen"</span>, Net: sl.network, Source: <span class="literal">nil</span>, Addr: la, Err: &amp;AddrError&#123;Err: <span class="string">"unexpected address type"</span>, Addr: address&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"listen"</span>, Net: sl.network, Source: <span class="literal">nil</span>, Addr: la, Err: err&#125; <span class="comment">// l is non-nil interface containing nil pointer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下是创建 <code>TCPListener</code> 的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /net/tcpsock_posix.go#L167</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sysListener)</span> <span class="title">listenTCP</span><span class="params">(ctx context.Context, laddr *TCPAddr)</span> <span class="params">(*TCPListener, error)</span></span> &#123;</span><br><span class="line">    fd, err := internetSocket(ctx, sl.network, laddr, <span class="literal">nil</span>, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"listen"</span>, sl.ListenConfig.Control)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;TCPListener&#123;fd: fd, lc: sl.ListenConfig&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>代码跳转到 <code>srv.Serve(ln)</code>,这里是 Server 对象处理 <code>TCPListener</code> 接受连接的过程.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L2871</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... 跳过部分代码 ...</span></span><br><span class="line">    </span><br><span class="line">    origListener := l</span><br><span class="line">    <span class="comment">// 这里可以理解为仅仅关闭一次</span></span><br><span class="line">    l = &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 http2 协议的请求</span></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// accept 接收连接失败的睡眠时长,在未达到最大超时时长时,成倍数增长</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 net.Listener 的 Accept() 接受连接,返回 `TCPConn` TCP 连接</span></span><br><span class="line">        rw, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败后的睡眠时长,开始为 5ms,后续每次乘 2,直到为 1s</span></span><br><span class="line">            <span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, err, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        connCtx := ctx</span><br><span class="line">        <span class="keyword">if</span> cc := srv.ConnContext; cc != <span class="literal">nil</span> &#123;</span><br><span class="line">            connCtx = cc(connCtx, rw)</span><br><span class="line">            <span class="keyword">if</span> connCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"ConnContext returned nil"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span>   <span class="comment">// 建立连接后,接收连接失败的睡眠时长置为 0</span></span><br><span class="line">        c := srv.newConn(rw) <span class="comment">// Server 通过 `l.Accept()` 返回的 TCPConn 正式建立连接.</span></span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// 设置建立连接的状态为 StateNew</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(connCtx) <span class="comment">// 使用协程处理请求的上下文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h2><p><code>c.serve(connCtx)</code> 响应一个请求连接,这里也是真正处理请求的部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L1765</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置连接的远程地址</span></span><br><span class="line">    c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">    <span class="comment">// 连接出错时,关闭连接</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line">            <span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">            buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">            buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">            c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">            c.<span class="built_in">close</span>()</span><br><span class="line">            c.setState(c.rwc, StateClosed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 处理 tls 连接</span></span><br><span class="line">    <span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> d := c.server.ReadTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">            c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d := c.server.WriteTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">        c.rwc.SetWriteDeadline(time.Now().Add(d))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TLS 连接握手过程</span></span><br><span class="line">        <span class="keyword">if</span> err := tlsConn.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// If the handshake failed due to the client not speaking</span></span><br><span class="line">            <span class="comment">// TLS, assume they're speaking plaintext HTTP and write a</span></span><br><span class="line">            <span class="comment">// 400 response on the TLS conn's underlying net.Conn.</span></span><br><span class="line">            <span class="keyword">if</span> re, ok := err.(tls.RecordHeaderError); ok &amp;&amp; re.Conn != <span class="literal">nil</span> &amp;&amp;           tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) &#123;</span><br><span class="line">                io.WriteString(re.Conn, <span class="string">"HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n"</span>)</span><br><span class="line">                re.Conn.Close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            c.server.logf(<span class="string">"http: TLS handshake error from %s: %v"</span>, c.rwc.RemoteAddr(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.tlsState = <span class="built_in">new</span>(tls.ConnectionState)</span><br><span class="line">        *c.tlsState = tlsConn.ConnectionState()</span><br><span class="line">        <span class="keyword">if</span> proto := c.tlsState.NegotiatedProtocol; validNextProto(proto) &#123;</span><br><span class="line">            <span class="keyword">if</span> fn := c.server.TLSNextProto[proto]; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">                h := initALPNRequest&#123;ctx, tlsConn, serverHandler&#123;c.server&#125;&#125;</span><br><span class="line">                fn(c.server, tlsConn, h)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    c.cancelCtx = cancelCtx</span><br><span class="line">    <span class="keyword">defer</span> cancelCtx()</span><br><span class="line">    c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 读取请求</span></span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line">            <span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">            c.setState(c.rwc, StateActive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 错误请求</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> errorHeaders = <span class="string">"\r\nContent-Type: text/plain; charset=utf-8\r\nConnection:        close\r\n\r\n"</span></span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> err == errTooLarge:</span><br><span class="line">                <span class="comment">// Their HTTP client may or may not be</span></span><br><span class="line">                <span class="comment">// able to read this if we're</span></span><br><span class="line">                <span class="comment">// responding to them and hanging up</span></span><br><span class="line">                <span class="comment">// while they're still writing their</span></span><br><span class="line">                <span class="comment">// request. Undefined behavior.</span></span><br><span class="line">                <span class="keyword">const</span> publicErr = <span class="string">"431 Request Header Fields Too Large"</span></span><br><span class="line">                fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            <span class="keyword">case</span> isUnsupportedTEError(err):</span><br><span class="line">                <span class="comment">// Respond as per RFC 7230 Section 3.3.1 which says,</span></span><br><span class="line">                <span class="comment">//      A server that receives a request message with a</span></span><br><span class="line">                <span class="comment">//      transfer coding it does not understand SHOULD</span></span><br><span class="line">                <span class="comment">//      respond with 501 (Unimplemented).</span></span><br><span class="line">                code := StatusNotImplemented</span><br><span class="line">                <span class="comment">// We purposefully aren't echoing back the transfer-encoding's value,</span></span><br><span class="line">                <span class="comment">// so as to mitigate the risk of cross side scripting by an attacker.</span></span><br><span class="line">                fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 %d %s%sUnsupported transfer encoding"</span>, code,   StatusText(code), errorHeaders)</span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            <span class="keyword">case</span> isCommonNetReadError(err):</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// don't reply</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                publicErr := <span class="string">"400 Bad Request"</span></span><br><span class="line">                <span class="keyword">if</span> v, ok := err.(badRequestError); ok &#123;</span><br><span class="line">                    publicErr = publicErr + <span class="string">": "</span> + <span class="keyword">string</span>(v)</span><br><span class="line">                &#125;</span><br><span class="line">                fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Expect 100 Continue support</span></span><br><span class="line">        req := w.req</span><br><span class="line">        <span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line">            <span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">                req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">            w.sendExpectationFailed()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.curReq.Store(w)</span><br><span class="line">        <span class="keyword">if</span> requestBodyRemains(req.Body) &#123;</span><br><span class="line">            registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            w.conn.r.startBackgroundRead()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line">        <span class="comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line">        <span class="comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line">        <span class="comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line">        <span class="comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line">        <span class="comment">// But we're not going to implement HTTP pipelining because it</span></span><br><span class="line">        <span class="comment">// was never deployed in the wild and the answer is HTTP/2.</span></span><br><span class="line">        <span class="comment">// 调用 ServeHTTP() 方法,响应请求</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">        <span class="comment">// 处理请求完成的后续操作</span></span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        <span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        w.finishRequest()</span><br><span class="line">        <span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">            <span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.setState(c.rwc, StateIdle)    <span class="comment">// 响应请求后,连接置为空闲</span></span><br><span class="line">        c.curReq.Store((*response)(<span class="literal">nil</span>))</span><br><span class="line">        <span class="keyword">if</span> !w.conn.server.doKeepAlives() &#123;</span><br><span class="line">            <span class="comment">// We're in shutdown mode. We might've replied</span></span><br><span class="line">            <span class="comment">// to the user without "Connection: close" and</span></span><br><span class="line">            <span class="comment">// they might think they can send another</span></span><br><span class="line">            <span class="comment">// request, but such is life with HTTP/1.1.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> &#123;</span><br><span class="line">            c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">            <span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.rwc.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServeHTTP-方法"><a href="#ServeHTTP-方法" class="headerlink" title="ServeHTTP 方法"></a><code>ServeHTTP</code> 方法</h3><p><code>serverHandler{c.server}.ServeHTTP(w, w.req)</code> 是响应请求的方法.该方法会将响应写入响应体.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L2799</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里 handler 变量为我们传入的 Handler 实例 `CustomHandler&#123;&#125;`</span></span><br><span class="line">    <span class="comment">// 后续会分析 handler 为空的情况</span></span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">    handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 handler 的 ServeHTTP 方法,也就是会将 "hello" 写入响应体</span></span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码中会调用我们传入的 <code>Handler</code> 实例 <code>CustomHandler{}</code> 的 <code>ServeHTTP</code> 方法,写入响应体.</p>
<h2 id="使用-http-HandleFunc-又如何呢"><a href="#使用-http-HandleFunc-又如何呢" class="headerlink" title="使用 http.HandleFunc 又如何呢"></a>使用 <code>http.HandleFunc</code> 又如何呢</h2><p>先看如下代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/hello"</span>, Hello)</span><br><span class="line">    http.ListenAndServe(<span class="string">"8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码中使用 <code>http.HandleFunc</code> 函数定义了对 <code>/hello</code> URL 请求的处理函数为 <code>Hello</code> 函数.</p>
<p>那么 <code>http.HandleFunc</code> 函数做了什么呢?</p>
<h3 id="http-HandleFunc-函数"><a href="#http-HandleFunc-函数" class="headerlink" title="http.HandleFunc 函数"></a><code>http.HandleFunc</code> 函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L2451</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 DefaultServeMux 调用 HandleFunc.</span></span><br><span class="line">    <span class="comment">// 其中 DefaultServeMux = &amp;defaultServeMux 为默认的 ServeMux 对象</span></span><br><span class="line">    <span class="comment">// var defaultServeMux ServeMux</span></span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中,<code>ServeMux</code> 及 <code>muxEntry</code> 结构体如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex  <span class="comment">// 锁</span></span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry <span class="comment">// 保存注册的 URL 及其对应的 muxEntry</span></span><br><span class="line">    es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    h       Handler <span class="comment">// 保存 pattern 对应的 Handler</span></span><br><span class="line">    pattern <span class="keyword">string</span> <span class="comment">// 保存 pattern</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码跳转到 <code>ServeMux</code> 对象的 <code>HandleFunc</code> 方法,如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L2436</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 ServeMux 的 Handle 方法</span></span><br><span class="line">    <span class="comment">// 这里将我们自定义的 handler 强制转换为 HandlerFunc 类型</span></span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中,<code>HandlerFunc</code> 其实是形如 <code>func(ResponseWriter, *Request)</code> 的函数.调用 <code>HandlerFunc</code> 的 <code>ServeHTTP</code> 其实是调用了 <code>func(ResponseWriter, *Request)</code>.这里很重要!!!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /net/server.go#L2038</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码跳转到 <code>ServeMux</code> 对象的 <code>Handle</code> 方法,如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock() <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock() <span class="comment">// 最后解锁</span></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果注册的 url 已经在,则报错</span></span><br><span class="line">    <span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServeMux</code> 对象的 <code>Handle</code> 方法做了以下工作</p>
<ol>
<li>对 <code>mux.mu</code> 加锁</li>
<li>判断是否存在 mux.m[pattern],如果存在,则报错</li>
<li>新建 <code>e = muxEntry{h: handler, pattern: pattern}</code>,并设置 <code>mux.m[pattern] = e</code>. 将传入的 <code>HandlerFunc</code> 保存到 <code>mux.m</code>,也就是 <code>muxEntry</code> 对象中.</li>
<li>如果注册 <code>pattern</code> 最后一个字符为 ‘/‘,则将 <code>e</code> 添加到 <code>mux.es</code> 中,并进行排序,排序规则为路由从长到短</li>
<li>如果注册 <code>pattern</code> 开始字符为 ‘/‘,则设置 <code>mux.hosts</code> 为 <code>true</code></li>
<li>方法执行完毕对 <code>mux.mu</code> 解锁</li>
</ol>
<p>至此 <code>http.HandleFunc(&quot;/hello&quot;, Hello)</code> 函数执行完毕.</p>
<h3 id="再看响应请求的-ServeHTTP-方法"><a href="#再看响应请求的-ServeHTTP-方法" class="headerlink" title="再看响应请求的 ServeHTTP 方法"></a>再看响应请求的 <code>ServeHTTP</code> 方法</h3><p><code>http.ListenAndServe(&quot;8080&quot;, nil)</code> 前面过程与之前讨论过程基本一致.只需要看响应请求过程中的 <code>serverHandler{c.server}.ServeHTTP(w, w.req)</code> 方法.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L2799</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里 handler 为 nil,使用 DefaultServeMux</span></span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">    handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时再调用 ServeHTTP 为调用 DefaultServeMux 的 ServeHTTP 方法</span></span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码跳转到 <code>handler.ServeHTTP(rw, req)</code>,此时 handler 为 <code>ServeMux</code> 类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L2378</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 h 变量为我们在 http.HandleFunc 中为指定 url 定义的 handler func(ResponseWriter, *Request)</span></span><br><span class="line">    <span class="comment">// 该对象已经在传入时进行类型强转,转换为 HandlerFunc</span></span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    <span class="comment">// 此时,再调用 HandlerFunc 的 ServeHTTP 其实就是调用了它自己.形如 `func(ResponseWriter, *Request)` 的函数,通过自定义函数,将数据写入响应体.</span></span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次附上 <code>HandlerFunc</code> 的定义及其 <code>ServeHTTP</code> 方法,加深理解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /net/server.go#L2038</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码跳转到 <code>mux.Handler(r)</code>,如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go#L2322</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... some code ...</span></span><br><span class="line">    host := stripHostPort(r.Host)</span><br><span class="line">    path := cleanPath(r.URL.Path)</span><br><span class="line">    <span class="comment">// 我们只考虑最简单的情况</span></span><br><span class="line">    <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/http/server.go#L2359</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加锁解锁</span></span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终返回的是请求对应 HandlerFunc</span></span><br><span class="line">    <span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">        h, pattern = mux.match(host + path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 对请求url与路由规则进行匹配</span></span><br><span class="line">        h, pattern = mux.match(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在看 <code>mux.match</code> 方法之前应该先对 <code>http.HandleFunc(&quot;/&quot;,Hello)</code> 有一定的理解.</p>
</blockquote>
<p>按照最简单的情况,代码跳转到 <code>mux.match(path)</code>, <code>mux.match</code> 方法会为传入的的路径选择合适的 <code>Handler</code>.具体如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果 mux.m 中刚好有传入的路径,则直接返回其对应的 HandlerFunc.</span></span><br><span class="line">    <span class="comment">// 此时请求URL与注册的请求路由完全匹配,可以直接返回.时间复杂度为 O(1)</span></span><br><span class="line">    v, ok := mux.m[path]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查最长合法匹配路径. `mux.es` 中包含所有以从最长到最短排序的路由规则,pattern.</span></span><br><span class="line">    <span class="comment">// 此时返回的 handler 是我们自定义的 Hello(w http.ResponseWriter, r *http.Request) 函数</span></span><br><span class="line">    <span class="comment">// 此时需要遍历请求路由列表,找到请求路由匹配请求中的最长字串.时间复杂度为 O(n),n 为注册的请求路由长度</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是使用 <code>http</code> 包自定义服务并处理请求的全部过程.</p>
<p>通过 <code>http.HandlerFunc</code> 函数注册 <code>Handler</code> 与 直接向 <code>http.ListenAndServe</code> 函数传入 <code>Handler</code> 的区别在于</p>
<ul>
<li><code>http.HandleFunc</code> 函数实际上注册的是 <code>http.HandlerFunc</code>,其本质是一个形如 <code>func (http.ResponseWriter, *http.Request)</code> 的函数.在处理请求时调用 <code>ServeHTTP</code> 实际上是调用了自己.且 <code>http.HandleFunc</code> 可对不同的 URL 注册不同的 <code>http.HandleFunc</code>.</li>
<li><code>http.ListenAndServe</code> 函数实际上传入的是实现了 <code>Handler</code> 接口的实例.在处理请求时调用 <code>ServeHTTP</code> 实际上是实例的 <code>ServeHTTP</code>. 可能看起来较为直观.</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>源码阅读</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 项目结构</title>
    <url>/2020/06/24/golang-standards-project-layout/</url>
    <content><![CDATA[<p><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a> 项目是常见的 Go 项目代码的布局方式.我们在阅读或开发 Go 项目时,可以遵循此项目中的布局方式进行组织代码.</p>
<p>以下是 Go 项目中常见目录及其简单介绍.</p>
<h2 id="Go-目录"><a href="#Go-目录" class="headerlink" title="Go 目录"></a>Go 目录</h2><ul>
<li><code>/cmd</code>: 项目的主程序目录</li>
</ul>
<p>每个应用程序的目录名称应该与您的可执行文件名称一致.如 <code>/cmd/myapp</code>.</p>
<p>不要在此目录中放置很多代码.如果您任务该代码可以被导入并在其它项目中使用,则应将其放在 <code>/pkg</code> 目录中.如果代码不可导入或不希望其他人使用它,则应将代码放在 <code>/internal</code> 目录中.</p>
<p>此目录下通常有一个简单的 main 函数,并通过导入或调用 <code>/internal</code> 和 <code>/pkg</code> 目录中的代码,而没有其他的函数.</p>
<p>如,<a href="https://github.com/prometheus/prometheus/tree/master/cmd" target="_blank" rel="noopener">prometheus/cmd</a></p>
<ul>
<li><p><code>/internal</code>: 私有应用程序和代码库.放在该包中的代码,表明只希望在此项目内部使用,其它项目不能使用.</p>
</li>
<li><p><code>/pkg</code>: 外部应用程序可以使用的库代码.该目录与 <code>internal</code> 对应,是公开的.如 <a href="https://github.com/prometheus/prometheus/tree/master/pkg" target="_blank" rel="noopener">prometheus/pkg</a>.</p>
</li>
</ul>
<p>一般来说,放在该目录下的代码应该和具体业务无关,方便本项目或其他项目重用.当你决定将代码放入该包时,你应该对其负责,因为别人很可能使用它.</p>
<ul>
<li><code>/vendor</code>: 应用程序依赖项目录.</li>
</ul>
<p><code>go mod vendor</code> 命令将为您创建 <code>/vendor</code> 目录.注意,如果您使用的不是 Go 1.14 版本(1.14 版本默认开启),则可能需要在 <code>go build</code> 命令中添加 <code>-mod=vender</code> 标志.</p>
<p>注意,从 1.13 开始,Go 还启用了模块代码功能(默认情况下使用 <a href="https://proxy.golang.org" target="_blank" rel="noopener"><code>https://proxy.golang.org</code></a> 作为其模块的代理服务器).如果是这样,那么您根本不需要 <code>vendor</code> 目录.</p>
<h2 id="服务应用目录"><a href="#服务应用目录" class="headerlink" title="服务应用目录"></a>服务应用目录</h2><ul>
<li><code>/api</code>: 主要保存 OpenAPI/Swagger 规范, JSON 格式文件和协议定义文件.如 <a href="https://github.com/kubernetes/kubernetes/tree/master/api" target="_blank" rel="noopener">kubernetes/api</a></li>
</ul>
<h2 id="Web-应用目录"><a href="#Web-应用目录" class="headerlink" title="Web 应用目录"></a>Web 应用目录</h2><ul>
<li><code>/web</code>: Web 应用程序特定的组件,包含静态 Web 资源,服务端模版和 SPA.</li>
</ul>
<h2 id="常见应用目录"><a href="#常见应用目录" class="headerlink" title="常见应用目录"></a>常见应用目录</h2><ul>
<li><code>/configs</code>: 配置文件模版或默认配置目录.</li>
<li><code>/init</code>: 系统初始化(systemd, upstart,sysv)和进程管理/监控(runit, supervisord) 配置.</li>
<li><code>/scripts</code>: 用于执行构建,安装,分析等操作的各种脚本.</li>
</ul>
<p>这些脚本可使根目录下的 Makefile 变得简单.如 <a href="https://github.com/hashicorp/terraform/blob/master/Makefile" target="_blank" rel="noopener">terraform/Makefile</a>, <a href="https://github.com/helm/helm/tree/master/scripts" target="_blank" rel="noopener">helm/scripts</a>.</p>
<ul>
<li><code>/build</code>: 打包构建与持续集成.</li>
</ul>
<p>将您的容器,操作系统软件包配置和脚本放在 <code>/build/package</code> 目录中.将您的持续集成(travis, circle, drone)配置和脚本放在 <code>/build/ci</code> 目录中.注意,有些 CI 工具对于其配置文件的位置非常挑剔.尝试将其放在 <code>/build/ci</code> 目录中,并将其链接到工具期望的位置(如果可能).</p>
<ul>
<li><code>/deployments</code>: Iaas, Paas 系统和容器编排配置和模版目录.注意,有些代码仓库中,该目录为 <code>/deploy</code>.</li>
<li><code>/test</code>: 其它外部测试应用程序和测试数据目录.</li>
</ul>
<h2 id="其它目录"><a href="#其它目录" class="headerlink" title="其它目录"></a>其它目录</h2><ul>
<li><code>/docs</code>: 用户帮助文档.</li>
<li><code>/tools</code>: 此项目的工具.这些工具可以从 <code>/pkg</code> 和 <code>internal</code> 目录中导入代码</li>
<li><code>/examples</code>: 应用程序或公共库的示例</li>
<li><code>/third_party</code>: 第三方工具</li>
<li><code>/assets</code>: 仓库的其它资源.如,图片, logo 等</li>
<li><code>/website</code>: 项目的网站数据目录.</li>
</ul>
<h2 id="不应该包含的目录"><a href="#不应该包含的目录" class="headerlink" title="不应该包含的目录"></a>不应该包含的目录</h2><ul>
<li><code>/src</code>: 不要将 Java 项目的代码结构组织习惯应用到 Go 中</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine 与 GMP 模型介绍</title>
    <url>/2021/03/09/goroutine-and-GMP-model/</url>
    <content><![CDATA[<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go 为了提供更容易使用的并发方法,使用了 goroutine 和 channel.goroutine 来自协程的概念,让一组可复用的函数运行在一组线程之上,即使有协程阻塞,该线程的其他协程也可以被 <code>runtime</code> 调度,转移到其他可运行的线程上.</p>
<p>Go 中,协程被称为 goroutine,它非常轻量,一个 goroutine 只占几 KB,这就能在有限的内存空间内支持大量的 goroutine,支持了更多的并发.虽然一个 goroutine 的栈只有几 KB,但实际上是可伸缩的,如果需要更多资源,<code>runtime</code> 会自动为 goroutine 分配.</p>
<p>goroutine 具有占用内存小,调度灵活的特点:</p>
<ul>
<li>占用内存更小(几 kb)</li>
<li>调度更灵活(<code>runtime</code> 调度)</li>
</ul>
<h2 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h2><ul>
<li>G: goroutine 协程</li>
<li>M: thread 线程</li>
<li>P: Processor,包含了运行 goroutine 的资源.包含了可运行的 G 队列.如果线程想要运行 goroutine,则必须先获取 P.</li>
</ul>
<p><img src="/images/gmp-model.png" alt="GMP 模型"></p>
<p>GMP 模型中包含以下概念:</p>
<ul>
<li>全局队列(Global Queue):存放等待运行的 G.</li>
<li>P 的本地队列: 同全局队列类似,存放的也是等待运行的 G,存的数量有限,一般不超过256个.新建 G’ 时,G’ 优先加入到 P 的本地队列.如果队列满了,则会把本地队列中一半的 G 移动到全局队列.</li>
<li>P 的列表: 所有的 P 都在程序启动时创建,并保存在数组中,最多有 <code>GOMAXPROCS</code> 个.可通过环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS()</code> 进行修改.</li>
<li>M: 线程想运行任务就得获取 P,从 P 的本地队列中获取 G.当 P 的本地队列为空时,M 也会尝试从全局队列拿一批 G 放到 P 的本地队列,或从其他 P 的本地队列”偷”一半放到自己 P 的本地队列.M 运行 G,G 执行之后,M 会从 P 获取下一个 G,不断重复下去.</li>
</ul>
<h3 id="P-和-M-的数量与创建时机"><a href="#P-和-M-的数量与创建时机" class="headerlink" title="P 和 M 的数量与创建时机"></a>P 和 M 的数量与创建时机</h3><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><blockquote>
<p>P 的数量</p>
</blockquote>
<p>由环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS()</code> 进行指定.</p>
<blockquote>
<p>创建时机</p>
</blockquote>
<p>在确定了 P 的最大数量 n 后,运行时系统会根据这个数量创建 n 个 P.</p>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><blockquote>
<p>M 的数量</p>
</blockquote>
<ul>
<li>默认最大限制为 1000,但内核很难支持这么多线程,因此此限制可忽略.</li>
<li>该数量可通过 <code>runtime.SetMaxThreads()</code> 方法设置 M 的最大数量.</li>
<li>倘若一个 M 阻塞了,会创建新的 M.</li>
</ul>
<blockquote>
<p>创建时机</p>
</blockquote>
<p>没有足够的 M 来关联 P 并运行其中的可运行的 G 时会创建 M.</p>
<h2 id="go-func-调度流程"><a href="#go-func-调度流程" class="headerlink" title="go func() 调度流程"></a>go func() 调度流程</h2><p><img src="/images/go-func-process.jpeg" alt="go func() 调度流程"></p>
<p>如下是 go func() 的调度流程:</p>
<ol>
<li>首先通过 go func() 来创建一个 goroutine</li>
<li>有两个存储 G 的队列,一个是局部调度器 P 的本地队列,一个是全局 G 队列.新创建的 G 会先保存在 P 的本地队列中,如果 P 的本地队列已经满了就会保存在全局的队列中</li>
<li>M 与 P 绑定后,会从 P 的本地队列弹出一个可执行状态的 G 来执行.如果 P 的本地队列为空,就会尝试从其他的 MP组合”偷”取一个可执行的 G 来执行</li>
<li>当 M 执行某一个 G 时候如果发生了系统调用或则其余阻塞操作,M 会阻塞,如果当前有一些 G 在执行,<code>runtime</code> 会把这个线程 M 与 P 解绑(detach),然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个 P</li>
<li>当 M 系统调用结束时候,这个 M 会尝试获取一个空闲的 P 执行,并放入到这个 P 的本地队列.如果获取不到 P,那么这个线程 M 变成休眠状态,加入到空闲线程中,进入休眠队列中.</li>
<li>重复上述过程,直到 P 的本地队列与全局队列中 G 为空</li>
</ol>
<p>调度器的生命周期可表示如下:</p>
<p><img src="/images/life-cycle-of-scheduler.png" alt="调度器的生命周期"></p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://www.jianshu.com/p/fa696563c38a" target="_blank" rel="noopener">[典藏版]Golang调度器GPM原理与调度全分析</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goroutine</tag>
        <tag>GMP</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题之 Docker</title>
    <url>/2020/06/04/interview-questions-docker/</url>
    <content><![CDATA[<h2 id="docker-配置"><a href="#docker-配置" class="headerlink" title="docker 配置"></a>docker 配置</h2><p>dockerd 默认配置见官方文档 <a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">daemon.json</a> 示例.且提供了众多<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon" target="_blank" rel="noopener">命令行参数</a>.下面介绍一些常用配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进程相关</span><br><span class="line">--config-file string: 指定配置文件,默认是 &#96;&#x2F;etc&#x2F;docker&#x2F;daemon.json&#96;</span><br><span class="line">-p, --pidfile string: 指定 PID 文件.默认是 &#96;&#x2F;var&#x2F;run&#x2F;docker.pid&#96;</span><br><span class="line">--containerd string: 指定 grpc 地址</span><br><span class="line">--data-root string: 指定 docker 镜像和容器相关文件保存位置.默认是 &#96;&#x2F;var&#x2F;lib&#x2F;docker&#96;</span><br><span class="line">--log-driver string: 指定日志驱动.默认为 &#96;json-file&#96;</span><br><span class="line">--log-level string: 指定日志级别.可选值为 debug,info,warn,error,fatal.默认 &#96;info&#96;</span><br><span class="line"></span><br><span class="line">log-opts: 指定日志选项,只能用于配置文件中.&#96;max-size&#96; 指定日志文件大小,&#96;max-file&#96; 指定日志文件个数</span><br><span class="line"></span><br><span class="line"># 镜像相关</span><br><span class="line">--insecure-registry list: 指定不安全的镜像仓库地址</span><br><span class="line">--registry-mirror list: 指定安全的镜像仓库.配置文件中为 &#96;registry-mirrors&#96;</span><br><span class="line"></span><br><span class="line"># 网络相关</span><br><span class="line">--bip string: 指定 docker0 网桥 IP 地址</span><br><span class="line">--default-gateway string: 子网 IPv4 默认网关</span><br><span class="line">--default-gateway-v6 string: 子网 IPv6 默认网关</span><br><span class="line">--fixed-cidr string: 指定子网 IPv4 地址</span><br><span class="line">--fixed-cidr-v6 string: 指定子网 IPv6 地址</span><br><span class="line">--mtu int: 指定容器最大传输单元</span><br><span class="line">--dns list: 指定容器使用的 DNS 地址</span><br><span class="line"></span><br><span class="line"># 调试</span><br><span class="line">-D, --debug: 开启 debug 模式,多用于调试</span><br></pre></td></tr></table></figure>

<h2 id="docker-底层原理"><a href="#docker-底层原理" class="headerlink" title="docker 底层原理"></a>docker 底层原理</h2><p>docker 使用 Go 语言编写,并利用 Linux 内核的多个功能来实现其功能.</p>
<h3 id="Namespaces-名称空间"><a href="#Namespaces-名称空间" class="headerlink" title="Namespaces 名称空间"></a>Namespaces 名称空间</h3><p>docker 使用一种称为 <code>namespaces</code> 的技术来为容器提供运行环境的隔离.运行容器时,docker 引擎会为该容器创建一组如下的名称空间</p>
<table>
<thead>
<tr>
<th align="center">名称空间</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PID</td>
<td align="left">提供进程隔离.每个容器中都有独立的进程号</td>
</tr>
<tr>
<td align="center">Network</td>
<td align="left">提供网络资源隔离.每个容器都有独立的网络设备接口, IPv4, IPv6 协议栈,路由表,防火墙等</td>
</tr>
<tr>
<td align="center">IPC</td>
<td align="left">提供进程间通信资源隔离.容器中进程间通信仍然使用 Linux 进程间通信方法,信号量,消息队列,共享内存等</td>
</tr>
<tr>
<td align="center">Mount</td>
<td align="left">提供文件系统隔离.每个容器都有独立的 <code>/</code> 根文件系统</td>
</tr>
<tr>
<td align="center">UTS</td>
<td align="left">提供容器主机名和域名隔离.每个容器都有独立的主机名和域名,其主机名一般为容器 ID</td>
</tr>
<tr>
<td align="center">User</td>
<td align="left">提供用户及用户组隔离.每个容器都有独立的用户,用户组及其相关访问权限</td>
</tr>
</tbody></table>
<h3 id="Control-groups"><a href="#Control-groups" class="headerlink" title="Control groups"></a>Control groups</h3><p>控制组(cgroups)以一组进程为目标进行系统资源分配和控制,它提供了如下功能:</p>
<ul>
<li>Resource limitation,资源限制,如内存,CPU 等硬件资源</li>
<li>Prioritization,优先级控制</li>
<li>Accounting,审计或统计</li>
<li>Controll,进程控制,如进程挂起与恢复</li>
</ul>
<p>系统管理员可更具体地控制对系统资源的分配,优先顺序,拒绝,管理和监控.可更好地根据任务和用户分配硬件资源,提高总体效率.在实践中,系统管理员一般会利用 CGroup 做下面这些事:</p>
<ul>
<li>隔离进程集合,并限制他们所消耗的资源</li>
<li>为这组进程分配其足够使用的内存,网络带宽和磁盘存储限制</li>
<li>限制访问某些设备</li>
</ul>
<h3 id="Union-file-systems"><a href="#Union-file-systems" class="headerlink" title="Union file systems"></a>Union file systems</h3><p>Union file systems(联合文件系统)是通过创建层级进行操作的文件系统,它将对文件系统的修改作为一次提交来一层层的叠加.常用的包含 <code>overlay2</code>,<code>aufs</code>.</p>
<p>overlay2 采用三层结构:</p>
<ul>
<li>lowerdir: 只读层,镜像层</li>
<li>uperdir: 读写层.创建容器时创建,所有对容器的改动发生在这里</li>
<li>merged: 容器挂载点,将以上两层进行合并后看到的内容</li>
</ul>
<h2 id="docker-几种网络模型"><a href="#docker-几种网络模型" class="headerlink" title="docker 几种网络模型"></a>docker 几种网络模型</h2><p>可以使用 <code>docker run --net=xxx</code> 指定容器使用的网络类型</p>
<ul>
<li><code>bridge</code>: 桥接,默认的网络模型.为主机上的容器分配单独的网络名称空间,IP 等,并将容器中的网络接口连接到虚拟网桥上(docker0)</li>
<li><code>host</code>: 与宿主机共用网络名称空间,容器使用宿主机的 IP 和端口</li>
<li><code>overlay</code>: 与其它容器共用网络名称空间,使容器间能够通过 lo 进行通信</li>
<li><code>none</code>: 容器有独立的网络名称空间,但不进行任何网络配置,只有本地地址</li>
<li><code>macvlan</code>: 为容器分配 MAC 地址,使其在网络上显示为物理设备.可通过 MAC 地址直接将流量路由到容器.</li>
</ul>
<h2 id="docker-开发最佳实践"><a href="#docker-开发最佳实践" class="headerlink" title="docker 开发最佳实践"></a>docker 开发最佳实践</h2><h3 id="保持镜像尽可能的小"><a href="#保持镜像尽可能的小" class="headerlink" title="保持镜像尽可能的小"></a>保持镜像尽可能的小</h3><ul>
<li><p>尽量使用 <code>ENV</code> 和 <code>ARG</code> 让人不改或者少改 Dockerfile 即可做构建对应版本的镜像</p>
</li>
<li><p>尽量减少 Dockerfile 中单独的 <code>RUN</code> 命令的数量来减少镜像的层数.在一个 RUN 中清理编译生成文件,安装包的缓存等临时文件</p>
</li>
</ul>
<blockquote>
<p>Dockerfile 中指令 <code>RUN</code>,<code>COPY</code>,<code>ADD</code> 会创建新的镜像层,之后镜像层的操作不会影响上一层.因此即便 Dockerfile 中包含 <code>RUN rm -rf xxx</code> 镜像大小也不会减小.</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /data</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> touch /data/index.html</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /data &amp;&amp; touch /data/index.html</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从适当的基础镜像开始.例如,如果您需要 JDK,请考虑基于正式的 openjdk 镜像,而不是基于 ubuntu 镜像开始,再将 openjdk 的安装作为 Dockerfile 的一部分</li>
<li>可以在官方 Dockerfile 里添加一些常见的排错命令,也可以将二进制及其依赖库添加到镜像中,参见<a href="https://docs.lvrui.io/2018/10/19/%E4%B8%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%9A%E5%88%B6%E5%AE%89%E8%A3%85Linux%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">为容器镜像定制安装Linux工具</a>.如</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本示例仅作为示例演示,并没有实际意义</span></span><br><span class="line"><span class="comment"># 系统环境 CentOS 7.5.1804,发现 centos:centos7.5.1804 没有 lsof 工具.添加一下</span></span><br><span class="line"><span class="comment"># 首先在宿主机中安装 lsof 工具,并通过 ldd 查看其依赖库 `ldd $(which lsof)`</span></span><br><span class="line"><span class="comment"># 在 centos:centos7.5.1804 镜像启动的容器中查找 lsof 的依赖库,可看到都是存在的.因此直接将二进制文件复制进入即可</span></span><br><span class="line"><span class="keyword">FROM</span> centos:centos7.<span class="number">5.1804</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> lsof /usr/sbin/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用多阶段构建.例如,您可以使用 maven 镜像构建 Java 应用程序,然后使用 tomcat 镜像并将构建的 Java 程序复制到正确的位置.这意味着您最终构建的镜像不包括构建所引入的所有库和依赖项.见如下示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span>.<span class="number">6</span>-alpine3.<span class="number">10</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -o /demo</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./demo"</span>]</span></span><br><span class="line"><span class="comment"># 此时我们构建的镜像包括 go 的运行环境,相关源码或依赖文件,二进制可执行文件.镜像较大</span></span><br><span class="line"><span class="comment"># 其中运行环境与源码或依赖对于容器的运行来说都是多余的.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span>.<span class="number">6</span>-alpine3.<span class="number">10</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -o /demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /demo .</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./demo"</span>]</span></span><br><span class="line"><span class="comment"># 此时我们构建镜像仅包含二进制可执行文件.可以理解为 builder 构建完成后就将其丢弃了.镜像较小</span></span><br></pre></td></tr></table></figure>

<ul>
<li>尝试将共享的运行环境或依赖构建为独立的镜像,然后在此基础上构建其它镜像.Docker 只需要加载一次公共层,然后将它们缓存,可以更快的构建.如多个应用都需要自定义的 Tomcat 环境,可以将自定义 Tomcat 构建为单独镜像,而不需要每次构建应用时从最初始自定义 Tomcat 环境开始构建</li>
<li>容器时区问题可以在构建镜像的时候安装 <code>tzdate</code> 包，然后声明变量 <code>TZ</code> 即可声明容器运行的时区,或者构建的时候复制宿主机的<code>/etc/localtime</code>或者运行的时候挂载宿主机的<code>/etc/localtime</code></li>
</ul>
<h3 id="在何处以及如何保留数据"><a href="#在何处以及如何保留数据" class="headerlink" title="在何处以及如何保留数据"></a>在何处以及如何保留数据</h3><ul>
<li>避免将数据存储在容器的可写层中,这会增加容器大小,且效率不如使用 volumes 或 bind 挂载</li>
<li>bind 挂载多用于开发或测试过程中.对于生产环境,请使用 volumes</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -`</span><br></pre></td></tr></table></figure>

<p><code>docker build</code> 命令从 <code>Dockerfile</code> 及上下文构建镜像,构建的上下文是位于 <code>PATH</code> 或 <code>URL</code> 指定的位置的文件集合.<code>PATH</code> 是本地文件系统上的目录,<code>URL</code>是一个 Git 仓库位置.</p>
<p>上下文是递归处理的.因此 <code>PATH</code> 包括任何子目录,<code>URL</code> 包括仓库及其子模块.</p>
<p>构建过程是 Docker 守护进程进行的.构建的第一件事就是将整个上下文目录及其子目录发送到守护进程中.因此,最好以空目录作为上下文,仅包含 Dockerfile 及 Dockerfile 构建过程中所需要的文件.</p>
<h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><p>通过在上下文中添加 <code>.dockerignore</code> 文件可以排除构建上下文中包含的文件或目录.</p>
<p><code>.dockerignore</code> 文件使用 <code>#</code> 作为注释,每行包含一个忽略的文件或目录,支持使用 <code>*</code>,<code>?</code>,<code>**</code> 作为通配符匹配.分别表示所有文件,单个字符,目录递归.</p>
<p>在使用 <code>*</code> 忽略所有文件后,可以使用 <code>!</code> 向上下文中添加被忽略的文件</p>
<h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p><code>ARG</code> 定义一个变量,用户也可以在构建时使用 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 传入构建参数.如果该参数没有在 Dockerfile 中定义,则输出警告信息.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><code>FROM</code> 指定构建过程的基础镜像,一个有效的 Dockerfile 必须以 <code>FROM</code> 指令启动.它支持使用 <code>ARG</code> 定义的变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p><code>RUN</code> 指令从当前镜像最新层执行命令并提交结果.生成的镜像层用于 Dockerfile 中下一步.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> COMMAND</span></span><br></pre></td></tr></table></figure>

<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p><code>LABEL</code> 指令为镜像打标签</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>

<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE</code> 指令暴露 Docker 容器监听的端口</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>

<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p><code>ENV</code> 指令定义环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p><code>WORKDIR</code> 指令定义工作目录,相当于 <code>cd</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure>

<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p><code>USER</code> 指令指定运行镜像时使用的用户名及可选组</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p><code>VOLUME</code> 指定挂载点</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/path"</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><ul>
<li><code>ADD</code> 指令支持拷贝压缩文件到镜像中,并自动解压</li>
<li><code>ADD</code> 指令支持从源文件来自指定URL,构建容器时会自动下载到指定目录</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 指令设置容器启动后要执行的命令.使用 <code>--entrypoint</code> 指令进行替换.它有两种形式</p>
<p><code>--entrypoint</code> 指令指定的命令会覆盖原有所有命令及参数</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exec 形式,是推荐的形式.容器中 `executable` 进程 ID 为 1,可以使用 docker stop 命令优雅的停止容器.</span></span><br><span class="line"><span class="comment"># 可以通过 ENTRYPOINT ["sh", "-c", "echo $&#123;HOME&#125;"] 获取变量的值</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell 形式. 容器启动后默认执行 `/bin/sh -c command param1 param2`,这种方式启动的容器会自动回收孤儿进程与僵尸进程</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>

<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p><code>CMD</code> 指令一般用来设置容器启动后执行命令的默认参数.如果是参数,则必须指定 <code>ENTRYPOINT</code> 指令.如果包含多个 <code>CMD</code> 指令,以最后一个为准.</p>
<p><code>docker run [command]</code> 时会覆盖 <code>CMD</code> 指令内容,对 <code>ENTRYPOINT</code> 无影响</p>
<p><code>CMD</code> 指令有 3 种形式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exec 形式,是推荐的形式.该形式不会支持管道或变量替换.容器中 `executable` 进程 ID 为 1</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell 形式. 容器会默认使用 `/bin/sh -c command param1 param2` 启动容器,这种方式启动的容器会自动回收孤儿进程与僵尸进程</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作为 ENTRYPOINT 的默认参数,此时 ENTRYPOINT 必须使用 exec 形式</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"param1"</span>,<span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure>

<p>下表列出了不同 <code>ENTRYPOINT</code> 与 <code>CMD</code> 指令在容器启动时运行的命令:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">No ENTRYPOINT</th>
<th align="center"><code>ENTRYPOINT exec_entry p_entry</code></th>
<th align="center"><code>ENTRYPOINT [&quot;exec_entry&quot;, &quot;p_entry&quot;]</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">No CMD</td>
<td align="center">error</td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry</code></td>
</tr>
<tr>
<td align="center"><code>CMD [&quot;exec_cmd p_cmd&quot;]</code></td>
<td align="center"><code>exec_cmd p_c</code></td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry exec_cmd p_cmd</code></td>
</tr>
<tr>
<td align="center"><code>CMD [&quot;p1_cmd&quot;, &quot;p2_cmd&quot;]</code></td>
<td align="center"><code>p1_cmd p2_cmd</code></td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry p1_cmd p2_cmd</code></td>
</tr>
<tr>
<td align="center"><code>CMD exec_cmd p_cmd</code></td>
<td align="center"><code>exec_cmd p_cmd</code></td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry /bin/sh -c exec_cmd _cmd</code></td>
</tr>
</tbody></table>
<p>可以在 <a href="https://github.com/docker-library/" target="_blank" rel="noopener">GitHub</a> 上查看官方镜像的 Dockerfile</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题之 Kubernetes</title>
    <url>/2020/06/04/interview-questions-kubernetes/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h3><ul>
<li>etcd: 提供数据库服务,保存了整个集群的状态</li>
<li>kube-apiserver: 提供了资源操作的唯一入口,并提供认证,授权,访问控制,API注册和发现等机制</li>
<li>kube-controller-manager: 负责维护集群的状态,比如故障检测,自动扩展,滚动更新等</li>
<li>cloud-controller-manager: 是与底层云计算服务商交互的控制器</li>
<li>kub-scheduler: 负责资源的调度,按照预定的调度策略将 Pod 调度到相应的机器上</li>
<li>kubelet: 负责维护 Pod 的生命周期,同时也负责 Volume 和网络的管理</li>
<li>kube-proxy: 负责为 Service 提供内部的服务发现和负载均衡,并维护网络规则</li>
<li>container-runtime: 是负责管理运行容器的软件,比如 docker</li>
</ul>
<blockquote>
<p>master</p>
</blockquote>
<ul>
<li>kube-apiserver: 暴露 kubernetes 所有API,为 api 对象验证并配置数据.API Server 提供 REST 操作和到集群共享状态的前端,所有其他组件通过它进行交互</li>
<li>kube-controller-manager: 通过 apiserver 监控整个集群的状态，并确保集群处于预期的工作状态</li>
<li>kube-scheduler: 负责工作节点上工作负载的分配和管理</li>
</ul>
<blockquote>
<p>node</p>
</blockquote>
<ul>
<li>kubelet: 定时汇报当前节点的状态给 apiserver;获取 pod 的期望状态,调用对应的容器平台接口达到这个状态;镜像和容器的清理工作,保证节点上镜像不会占满磁盘空间,退出的容器不会占用太多资源</li>
<li>kube-proxy: 该进程可以看做是 service 的透明代理和负载均衡器.其核心功能是将某个 service 的访问请求转发到后端的某个 Pod 上. 有 Userspace,Iptables,IPVS 三种实现方式,默认 IPVS</li>
</ul>
<h3 id="简述-Kubernetes-的工作流程"><a href="#简述-Kubernetes-的工作流程" class="headerlink" title="简述 Kubernetes 的工作流程"></a>简述 Kubernetes 的工作流程</h3><p>Kubernetes 各个组件中的通信都是以 HTTPS 方式进程的.Kubernetes 各个组件均使用 watch 机制跟踪检查 API Server 上相关变动</p>
<ol>
<li>kubectl 客户端工具会校验请求资源合法性,并将相关资源对象封装成 HTTP 请求,以加密方式发送给 kube-apiserver</li>
<li>kube-apiserver 接收到 HTTPS 请求后,对请求来源进行认证,然后进行授权及准入控制的校验.校验通过后,将修改写入 etcd.响应客户端的同时,调用 kube-controller-manager 进行处理</li>
<li>kube-controller-manager 对集群中资源对象副本 ReplicaSet 进行检查.如果已经达到预期状态,则不作调整;否则调用 kube-schedule 进行处理</li>
<li>kube-scheduler 收到信号后进行调度,包括预选/优选调度,并将结果返回给 API Server,后写入 etcd.如果资源不够,资源对象会进入 Pending 等待状态</li>
<li>kubelet 根据调度结果调用 CRI(Container Runtime Interface)执行 Pod 资源创建/回收操作.</li>
</ol>
<p><img src="/images/what-happens-when-k8s.svg" alt="what-happens-when-k8s"></p>
<h3 id="Kubernetes-容器间通信方式"><a href="#Kubernetes-容器间通信方式" class="headerlink" title="Kubernetes 容器间通信方式"></a>Kubernetes 容器间通信方式</h3><ul>
<li>相同 Pod 中的容器间可使用 localhost 直接通信</li>
<li>相同 Node,不同 Pod 间可通过 docker0 网桥直接通信</li>
<li>不同 Node,不同 Pod 间可通过 Node 上的 flannel0 虚拟网卡进行路由转发,从 docker0 转发到 flannel0</li>
<li>Pod 访问 Service 通过 kube-proxy 进程创建的 ipvs 规则进行通信</li>
</ul>
<h3 id="Kubernetes-中的服务类型"><a href="#Kubernetes-中的服务类型" class="headerlink" title="Kubernetes 中的服务类型"></a>Kubernetes 中的服务类型</h3><ul>
<li><code>ClusterIP</code>: 通过集群内部 IP 地址暴露服务,此地址仅在集群内部可达,而无法被集群外部客户端访问</li>
<li><code>NodePort</code>: 这种类型建立在 ClusterIP 之上,其在每个节点的 IP 地址的静态端口用于将集群外部的用户请求转发至目标 Service 的 ClusterIP 和 Port.这种类型的 Service 既可以通过 <code>&lt;ClusterIP:ServicePort&gt;</code> 进行访问,又可以通过 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 进行访问</li>
<li><code>LoadBalancer</code>: 这种类型构建在 NodePort 类型之上,其通过云厂商提供的负载均衡器将服务暴露到集群外部.此类型的 Service 会指向关联至 Kubernetes 集群外部的切实存在的某个负载均衡设备,该设备通过工作节点上的 NodePort 向集群内部发送请求流量.此类型优势在于负载均衡设备能够避免客户端指定节点故障而导致服务不可用</li>
<li><code>ExternalName</code>: 通过 Service 映射至 externalName 字段内容指定的主机名来暴露服务,此主机名需要被 DNS 服务器解析至 CNAME 类型的记录.主要用于将集群外部的服务以 DNS CNAME 的方式映射到集群中,从而让集群内的 Pod 资源能够访问外部 Service 的一种实现方式.</li>
</ul>
<h3 id="Kubernetes-负载均衡"><a href="#Kubernetes-负载均衡" class="headerlink" title="Kubernetes 负载均衡"></a>Kubernetes 负载均衡</h3><p>通过 service/kube-proxy 实现四层负载均衡,通过 ingress 实现七层负载均衡,常用控制工具有 ingress-controller,traefik</p>
<h3 id="kube-proxy-原理"><a href="#kube-proxy-原理" class="headerlink" title="kube-proxy 原理"></a>kube-proxy 原理</h3><p>kube-proxy 部署在每个 Node 节点上,通过监听集群状态变更,并对本机 iptables/ipvs 做修改,从而实现网络路由.而其中的负载均衡,也是通过 iptables/ipvs 的特性实现的</p>
<h3 id="kubernetes-中-pause-容器是做什么用的"><a href="#kubernetes-中-pause-容器是做什么用的" class="headerlink" title="kubernetes 中 pause 容器是做什么用的"></a>kubernetes 中 pause 容器是做什么用的</h3><p><a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">参考</a></p>
<ul>
<li>作为 Pod 共享名称空间的基础容器</li>
<li>启动 init 进程,并共享 PID 名称空间,接收信号并作出处理,完成 Pod 的生命周期</li>
</ul>
<h3 id="Pod的生命周期"><a href="#Pod的生命周期" class="headerlink" title="Pod的生命周期"></a>Pod的生命周期</h3><p>Pod 状态始终处于一下几个状态之一:</p>
<ul>
<li>Pending: 部署 Pod 事务已被集群受理,但当前容器镜像还未下载完或现有资源无法满足 Pod 的资源需求</li>
<li>Running: 所有容器已被创建,并被部署到节点上</li>
<li>Successed: Pod成功退出,并不会被重启</li>
<li>Failed: Pod中有容器被终止</li>
<li>Unknown: 未知原因,如 kube-apiserver 无法与Pod进行通讯</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init 初始化容器</span><br><span class="line">主容器</span><br><span class="line">    post start hook 容器创建完成后立即运行的钩子函数</span><br><span class="line">    livenessProbe 存活状态检测</span><br><span class="line">    readinessProbe 就绪状态检测</span><br><span class="line">    pre stop hook 容器删除之前的钩子函数</span><br></pre></td></tr></table></figure>

<h3 id="Kubernetes-中容器的健康状态检测"><a href="#Kubernetes-中容器的健康状态检测" class="headerlink" title="Kubernetes 中容器的健康状态检测"></a>Kubernetes 中容器的健康状态检测</h3><p>kubernetes 在创建 Pod 时,可以为 Pod 指定 <code>LivenessProbe</code> 相关参数即可进行存活状态检测,指定 <code>ReadinessProbe</code> 即可完成就绪状态检测</p>
<p>检测方式包括</p>
<ul>
<li><code>ExecAction</code>: 执行命令.如果状态码为 0,表示健康/就绪</li>
<li><code>HTTPGetAction</code>: 向指定 url 发送 http 请求.如果 http code 为 200-400,则表示健康/就绪</li>
<li><code>TCPSocketAction</code>: 对指定端口进行 TCP 检查.如果能建立连接,则表示健康/就绪</li>
</ul>
<p>相关检查会反馈到 <code>kubectl describe &lt;pod&gt;</code> 的 status.conditions 字段中</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="如何在-Kubernetes-集群中自定义-hosts"><a href="#如何在-Kubernetes-集群中自定义-hosts" class="headerlink" title="如何在 Kubernetes 集群中自定义 hosts"></a>如何在 Kubernetes 集群中自定义 hosts</h3><ul>
<li>在集群中添加自定义 hosts</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coredns-configmap.yaml 支持 hosts 插件,可以自定义解析</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">Corefile:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">.:53</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">errors</span></span><br><span class="line">        <span class="string">health</span></span><br><span class="line">        <span class="string">kubernetes</span> <span class="string">cluster.local</span> <span class="string">in-addr.arpa</span> <span class="string">ip6.arpa</span> <span class="string">&#123;</span></span><br><span class="line">           <span class="string">pods</span> <span class="string">insecure</span></span><br><span class="line">           <span class="string">upstream</span></span><br><span class="line">           <span class="string">fallthrough</span> <span class="string">in-addr.arpa</span> <span class="string">ip6.arpa</span></span><br><span class="line">           <span class="string">ttl</span> <span class="number">30</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">hosts</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="string">cache.redis</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">prometheus</span> <span class="string">:9153</span></span><br><span class="line">        <span class="string">forward</span> <span class="string">.</span> <span class="string">/etc/resolv.conf</span></span><br><span class="line">        <span class="string">cache</span> <span class="number">30</span></span><br><span class="line">        <span class="string">loop</span></span><br><span class="line">        <span class="string">reload</span></span><br><span class="line">        <span class="string">loadbalance</span></span><br><span class="line">    <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在某类 Pod 中添加自定义 hosts</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 Pod 的 spec 字段中定义 hostAliases 字段</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostAliases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">"x.x.x.x"</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"hostname1_for_x.x.x.x"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"hostname2_for_x.x.x.x"</span></span><br></pre></td></tr></table></figure>

<h3 id="Pod-时间同步"><a href="#Pod-时间同步" class="headerlink" title="Pod 时间同步"></a>Pod 时间同步</h3><p>将物理机的时区文件以 hostspath 方式只读挂载,只需要保证系统时间是正确的即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-localtime</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-localtime</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure>

<h3 id="集群内外网络互通问题"><a href="#集群内外网络互通问题" class="headerlink" title="集群内外网络互通问题"></a>集群内外网络互通问题</h3><ul>
<li>Kubernetes 集群内部 node 上的 Pod 网络通信是通过 cni 网络插件实现的,路由信息保存在 etcd 中,并通过 node 节点上 iptables/ipvs  实现</li>
<li>集群外部的主机需要手动添加路由,将 Pod 网络的下一跳地址指向响应的 node 节点即可</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route add -net 10.244.0.0 netmask 255.255.0.0 gw &lt;nodeIP&gt;</span><br></pre></td></tr></table></figure>

<h3 id="拉取私有镜像"><a href="#拉取私有镜像" class="headerlink" title="拉取私有镜像"></a>拉取私有镜像</h3><p>kubernetes 提供了 <code>imagePullSecret</code> 配置从私有镜像仓库中拉取镜像.如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry NAME --docker-username=&lt;username&gt; --docker-password=&lt;password&gt; --docker-email=&lt;email&gt; --docker-server=&lt;docker-registry-url&gt; [-n &lt;namespace&gt;]</span><br><span class="line"></span><br><span class="line">kubectl patch sa &lt;sa_name&gt; -p <span class="string">'&#123;"imagePullSecrets": [&#123;"name": "$NAME"&#125;]&#125;'</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是如上过程并不能拉取私有镜像仓库中的 pause 镜像.</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题之 Linux</title>
    <url>/2020/06/04/interview-questions-linux/</url>
    <content><![CDATA[<h2 id="命令或-Bash-相关"><a href="#命令或-Bash-相关" class="headerlink" title="命令或 Bash 相关"></a>命令或 Bash 相关</h2><h3 id="Bash-中两个数做运算的几种方式"><a href="#Bash-中两个数做运算的几种方式" class="headerlink" title="Bash 中两个数做运算的几种方式"></a>Bash 中两个数做运算的几种方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sum=$[ <span class="variable">$&#123;v1&#125;</span> + <span class="variable">$&#123;v2&#125;</span> ]</span><br><span class="line">(( sum=<span class="variable">$&#123;v1&#125;</span> + <span class="variable">$&#123;v2&#125;</span> ))</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$&#123;v1&#125;</span>+<span class="variable">$&#123;v2&#125;</span>     <span class="comment"># 这里运算符两端必须没有空格</span></span><br><span class="line">`expr <span class="variable">$&#123;v1&#125;</span> + <span class="variable">$&#123;v2&#125;</span>`    <span class="comment"># 这里运算符号两端必须要有空格</span></span><br></pre></td></tr></table></figure>

<h3 id="等相关参数都有什么意义"><a href="#等相关参数都有什么意义" class="headerlink" title="$?,$* 等相关参数都有什么意义"></a><code>$?,$*</code> 等相关参数都有什么意义</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$: shell 本身的 processID</span><br><span class="line">$?: 最后运行命令的结束代码</span><br><span class="line"><span class="variable">$0</span>: shell 脚本文件名</span><br><span class="line">$*: 参数列表</span><br><span class="line"><span class="variable">$@</span>: 参数列表</span><br><span class="line"><span class="variable">$#</span>: 参数个数</span><br><span class="line"><span class="variable">$&#123;#str&#125;</span>: str 变量字符长度</span><br></pre></td></tr></table></figure>

<h3 id="read-命令从管道中读取字节流"><a href="#read-命令从管道中读取字节流" class="headerlink" title="read 命令从管道中读取字节流"></a><code>read</code> 命令从管道中读取字节流</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"sinaops"</span> | <span class="built_in">read</span> a ; <span class="built_in">echo</span> <span class="variable">$a</span> <span class="comment"># 输出为空</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sinaops"</span> | <span class="keyword">while</span> <span class="built_in">read</span> a ; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$a</span> ; <span class="keyword">done</span> <span class="comment"># 输出 sinaops</span></span><br></pre></td></tr></table></figure>

<h3 id="find-使用"><a href="#find-使用" class="headerlink" title="find 使用"></a><code>find</code> 使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把 /data 目录及其子目录下所有以扩展名 .txt 结尾的文件中包含 magedu 的字符串全部替换为 magestudy</span></span><br><span class="line"><span class="comment"># &#123;&#125; 表示找到的文件</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> sed -i s<span class="string">'@magedu@magestudy@'</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="grep-sed-awk-的运用"><a href="#grep-sed-awk-的运用" class="headerlink" title="grep,sed,awk 的运用"></a><code>grep,sed,awk</code> 的运用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计域名出现次数 "http://hi.baidu.com/browse/"</span></span><br><span class="line"><span class="comment"># 与统计 IP 访问次数基本一致</span></span><br><span class="line">awk -F <span class="string">'/'</span> <span class="string">'&#123;num[$3]++&#125;END&#123;for (name in num)&#123;print  name,num[name]&#125;&#125;'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印奇数/偶数行</span></span><br><span class="line"><span class="comment"># n 表示读取模式空间的下一行; N 表示追加下一行到模式空间</span></span><br><span class="line">sed -n <span class="string">'p;n'</span> file <span class="comment"># 奇数行</span></span><br><span class="line">sed -n <span class="string">'n;p'</span> file <span class="comment"># 偶数行</span></span><br><span class="line"><span class="comment"># 奇数行和偶数行合并</span></span><br><span class="line">sed <span class="string">'N;s/\n/ /g'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 奇数行与偶数行交换</span></span><br><span class="line">sed -r <span class="string">'N;s@(.*)\n(.*)@\2\n\1@g'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件中两列数据,分别为 ip,status_code.统计状态码为 200 中,出现次数最多的 IP</span></span><br><span class="line">awk <span class="string">'/200$/&#123;ip_num[$1]++&#125;END&#123;for(ip in ip_num)&#123;print ip,ip_num[ip]&#125;&#125;'</span> ip_code | awk <span class="string">'/NR==1/&#123;print $1,"出现次数最多,为",$2&#125;'</span> | sort -nrk 2 | awk <span class="string">'&#123;if (FNR==1)&#123;print $1,"出现次数最多,为",$2&#125;&#125;'</span></span><br></pre></td></tr></table></figure>

<h3 id="为-history-添加时间戳-如何防止个人-history-操作泄露"><a href="#为-history-添加时间戳-如何防止个人-history-操作泄露" class="headerlink" title="为 history 添加时间戳,如何防止个人 history 操作泄露"></a>为 <code>history</code> 添加时间戳,如何防止个人 history 操作泄露</h3><p>设置 <code>export HISTTIMEFORMAT=&#39;%F %T&#39;</code> 环境变量后,以后记录的命令历史操作就会添加时间</p>
<ul>
<li>可以将 <code>history</code> 记录的个人操作清空,使用 <code>history -c</code> 清空当前命令历史,并使用 <code>history -w</code> 将已经清空的命令历史写入到命令历史文件 <code>~/.bash_history</code> 中(或直接清空该文件),下次登录边不再有命令历史</li>
<li>可以设置 <code>export HISTCONTROL=ignorespace</code> 环境变量,使得命令历史忽略记录以空格开始的命令.在执行敏感命令时,以空格开始</li>
<li>可以设置 <code>export HISTIGNORE=*</code> 环境变量,使命令历史忽略记录所有命令.使用 <code>export HISTIGNORE=</code> 恢复记录.</li>
</ul>
<h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="进程和线程有什么区别"><a href="#进程和线程有什么区别" class="headerlink" title="进程和线程有什么区别"></a>进程和线程有什么区别</h3><ul>
<li>进程(process)是系统进行资源分配和调度的基本单位,线程(Thread)是 CPU 调度和分派的基本单位</li>
<li>线程依赖于进程而存在,一个进程至少有一个线程</li>
<li>进程有自己的独立地址空间,线程共享所属进程的地址空间</li>
<li>进程是拥有系统资源的一个独立单位,而线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),和其他线程共享本进程的相关资源如内存,I/O,cpu 等</li>
<li>在进程切换时,涉及到整个当前进程 CPU 环境的保存环境的设置以及新被调度运行的CPU环境的设置,而线程切换只需保存和设置少量的寄存器的内容,并不涉及存储器管理方面的操作.进程切换的开销远大于线程切换的开销</li>
<li>线程之间的通信更方便,同一进程下的线程共享全局变量等数据,而进程之间的通信需要以进程间通信(IPC)的方式进行</li>
<li>多线程程序只要有一个线程崩溃,整个程序就崩溃了.但多进程程序中一个进程崩溃并不会对其它进程造成影响,因为进程有自己的独立地址空间</li>
</ul>
<h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ul>
<li>管道</li>
<li>消息队列</li>
<li>信号和信号量</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<h3 id="并发-并行-异步的区别"><a href="#并发-并行-异步的区别" class="headerlink" title="并发,并行,异步的区别"></a>并发,并行,异步的区别</h3><ul>
<li>并发: 在一段时间内交替做不同事情的能力,可以理解为单线程(协程)/多线程运行在单核处理器上,如果有其中一个任务/线程阻塞,CPU 立即切换,执行行另一个任务/线程的代码逻辑</li>
<li>并行: 在同一时刻做不同事情的能力,可以理解为多线程程序运行在多核处理器上,一个线程绑定一个 CPU,多个 CPU 同时处理代码逻辑</li>
</ul>
<h3 id="什么是-IO-多路复用？怎么实现"><a href="#什么是-IO-多路复用？怎么实现" class="headerlink" title="什么是 IO 多路复用？怎么实现"></a>什么是 IO 多路复用？怎么实现</h3><p>IO 多路复用是指单个进程/线程就可以同时处理多个IO请求.是一种可以监视多个描述符,一旦某个描述符就绪,能够通知程序进行相应的读写操作的机制.</p>
<h4 id="select-poll-epoll三者的区别"><a href="#select-poll-epoll三者的区别" class="headerlink" title="select/poll/epoll三者的区别?"></a>select/poll/epoll三者的区别?</h4><blockquote>
<p><code>select</code></p>
</blockquote>
<p>将文件描述符放入一个集合(<code>缺点1: 集合大小有限制,32 位机器默认是1024,64 位默认是 2048</code>)中,调用 select 时,将这个集合从用户空间拷贝到内核空间(<code>缺点2: 每次都要将集合从用户空间复制到内核空间,开销大</code>),由内核根据就绪状态修改该集合的内容.采用水平触发机制.select 函数返回后,需要通过遍历这个集合(<code>缺点3: 轮询的方式效率较低</code>),找到就绪的文件描述符.当文件描述符的数量增加时,效率率会线性下降</p>
<blockquote>
<p><code>poll</code></p>
</blockquote>
<p>和 select 几乎没有区别,区别在于文件描述符的存储方式不同.poll 采用链表的方式存储,没有最大存储数量的限制</p>
<blockquote>
<p><code>epoll</code></p>
</blockquote>
<ol>
<li>通过内核和用户空间共享内存,避免了不断复制的问题.</li>
<li>支持的同时连接数上限很高</li>
<li>文件描述符就绪时,采用回调机制,避免了轮询</li>
<li>支持水平触发和边缘触发.采用边缘触发机制时,只有活跃的描述符才会触发回调函数</li>
</ol>
<h3 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h3><p>为了限制不同程序的访问能力,防止一些程序访问其它程序的内存数据,CPU 划分了用户态和内核态两个权限等级</p>
<ul>
<li>用户态只能受限地访问内存,且不允许访问外围设备.没有占用 CPU 的能力,CPU 资源可以被其它程序获取</li>
<li>内核态可以访问内存所有数据以及外围设备,也可以进行程序的切换</li>
</ul>
<p>所有用户程序都运行在用户态,但有时需要进行一些内核态的操作,比如从硬盘或者键盘读数据,这时就需要进行系统调用,使 CPU 切换到内核态,执行相应的服务,再切换为用户态并返回系统调用的结果.</p>
<h4 id="为什么要分用户态和内核态"><a href="#为什么要分用户态和内核态" class="headerlink" title="为什么要分用户态和内核态"></a>为什么要分用户态和内核态</h4><ul>
<li>安全性: 防止用户程序恶意或者不小心破坏系统/内存/硬件资源；</li>
<li>封装性: 用户程序不需要实现更加底层的代码</li>
<li>利于调度: 如果多个用户程序都在等待键盘输入,这时就需要进行调度.统一交给操作系统调度更加方便</li>
</ul>
<h4 id="如何从用户态切换到内核态？"><a href="#如何从用户态切换到内核态？" class="headerlink" title="如何从用户态切换到内核态？"></a>如何从用户态切换到内核态？</h4><ul>
<li>系统调用: 比如读取命令行输入.本质上还是通过中断实现</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断: 外围设备完成用户请求的操作之后,会向 CPU 发出中断信号,这时 CPU 会转去处理对应的中断处理程序</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前,两个进程都不能向前执行,称这一组进程产生了死锁(deadlock).如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程 A -&gt; 锁定 a -&gt; 尝试锁定 b -&gt; 永久等待</span><br><span class="line">线程 B -&gt; 锁定 b -&gt; 尝试锁定 a -&gt; 永久等待</span><br></pre></td></tr></table></figure>

<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><ul>
<li>互斥: 一个资源一次只能被一个进程使用</li>
<li>占有并等待: 一个进程至少占有一个资源,并在等待另一个被其它进程占用的资源</li>
<li>非抢占: 已经分配给一个进程的资源不能被强制性抢占,只能由进程完成任务之后自愿释放</li>
<li>循环等待: 若干进程之间形成一种头尾相接的环形等待资源关系,该环路中的每个进程都在等待下一个进程所占有的资源</li>
</ul>
<h3 id="进程的有效用户与实际用户"><a href="#进程的有效用户与实际用户" class="headerlink" title="进程的有效用户与实际用户"></a>进程的有效用户与实际用户</h3><ul>
<li>Linux系统中某个可执行文件属于 root 并且有 setid,当一个普通用户 mike运行这个程序时,产生的进程的有效用户和实际用户分别是 root 和 mike</li>
</ul>
<h3 id="fork-创建进程"><a href="#fork-创建进程" class="headerlink" title="fork() 创建进程"></a><code>fork()</code> 创建进程</h3><p>下面程序共有多少进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在父进程中,fork 返回新创建子进程的进程 ID</span></span><br><span class="line"><span class="comment">* 在子进程中,fork 返回 0</span></span><br><span class="line"><span class="comment">* 如果出现错误,fork 返回一个负值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork() || fork();</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 共创建 3 个</span></span><br><span class="line"><span class="comment">* main() -&gt; fork() -&gt; fork()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork() &amp;&amp; fork();</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 共创建 3 个</span></span><br><span class="line"><span class="comment">* main() -&gt; fork()</span></span><br><span class="line"><span class="comment">*        -&gt; fork()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork() &amp;&amp; fork() || fork();</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 共创建 5 个</span></span><br><span class="line"><span class="comment">* main() -&gt; fork() -&gt; fork()</span></span><br><span class="line"><span class="comment">*        -&gt; fork() -&gt; fork()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork(); <span class="comment">// 新创建 1 个</span></span><br><span class="line">    fork() &amp;&amp; fork() || fork(); <span class="comment">// 新创建 (1+1)*2+(1+1)*2 = 8 个</span></span><br><span class="line">    fork(); <span class="comment">// 新创建 1+8+1=10 个</span></span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共创建 20 个进程</span></span><br></pre></td></tr></table></figure>

<h3 id="ln-s-与-mv-对某文件操作时-对-inode-和-block-有什么影响"><a href="#ln-s-与-mv-对某文件操作时-对-inode-和-block-有什么影响" class="headerlink" title="ln -s 与 mv 对某文件操作时,对 inode 和 block 有什么影响"></a><code>ln -s</code> 与 <code>mv</code> 对某文件操作时,对 inode 和 block 有什么影响</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 理解 blocks 为磁盘存储块, inode 为指向该存储块的地址</span></span><br><span class="line">ln -s afile bfile</span><br><span class="line"><span class="comment"># 原始文件不变</span></span><br><span class="line"><span class="comment"># 新文件 inode 与原始文件不同,且 block 为 0</span></span><br><span class="line"><span class="comment"># 原因: 创建符号链接,系统为符号链接分配 inode,符号链接不存储数据,只是作为引用,故 block 为 0</span></span><br><span class="line"></span><br><span class="line">mv afile bfile</span><br><span class="line"><span class="comment"># 原始文件不存在</span></span><br><span class="line"><span class="comment"># 新文件与原始文件 inode 与 block 相同</span></span><br><span class="line"><span class="comment"># 原因: 修改文件名后,系统只是将文件名做改变,inode 与存储 block 不变</span></span><br><span class="line"></span><br><span class="line">ln afile bfile</span><br><span class="line"><span class="comment"># 原始文件不变</span></span><br><span class="line"><span class="comment"># 新文件 inode 和 block 与原始文件相同</span></span><br><span class="line"><span class="comment"># 原因: 创建硬链接,相当于为原始文件指定一个别名,inode 与存储 block 不变,这两个文件名指向系统底层存储是一样的</span></span><br><span class="line"></span><br><span class="line">cp afile bfile</span><br><span class="line"><span class="comment"># 原始文件不变</span></span><br><span class="line"><span class="comment"># 新文件 block 与 原始文件相同,inode 不同</span></span><br><span class="line"><span class="comment"># 原因: 拷贝文件,相当于对系统底层存储做拷贝,系统为新文件重新分配 inode,文件内容一直,block不变</span></span><br></pre></td></tr></table></figure>

<h3 id="free-命令查看内存时-buffer-和-cache-各表示什么含义-如何清理-cache-缓存"><a href="#free-命令查看内存时-buffer-和-cache-各表示什么含义-如何清理-cache-缓存" class="headerlink" title="free 命令查看内存时,buffer 和 cache 各表示什么含义?如何清理 cache 缓存"></a><code>free</code> 命令查看内存时,buffer 和 cache 各表示什么含义?如何清理 cache 缓存</h3><p>这二者是为了提高IO性能的.</p>
<ul>
<li>buffer是即将要被写入磁盘的,buffer 能够使分散的写操作集中进行,减少磁盘碎片和硬盘的反复寻道,从而提高系统性能;</li>
<li>cache是被从磁盘中读出来的.cached 是把读取过的数据保存起来,重新读取时若命中就不要去读硬盘,若没有命中就读硬盘</li>
</ul>
<p><a href="https://blog.csdn.net/qq_29663071/article/details/81178289" target="_blank" rel="noopener">清理缓存</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches  <span class="comment"># 释放页面缓存</span></span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches  <span class="comment"># 释放索引,inodes 节点缓存,可能会降低磁盘索引效率</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches  <span class="comment"># 释放页面缓存,索引,inode 缓存</span></span><br></pre></td></tr></table></figure>

<h3 id="top-页面含义"><a href="#top-页面含义" class="headerlink" title="top 页面含义"></a>top 页面含义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时间及运行时长, 登录用户数, 平均负载</span><br><span class="line">任务数: 总数,运行中,休眠中,停止,僵尸进程</span><br><span class="line">CPU占比: 用户空间, 内核空间,, 空闲进程,等待进程</span><br><span class="line">内存: 总物理内存,使用,剩余,buffer 缓冲</span><br><span class="line">Swap: 总,使用,剩余,cache 缓存</span><br><span class="line"></span><br><span class="line">进程ID 用户 优先级 nice值 虚拟内存 物理内存 共享内存 进程状态 CPU 内存 运行时长 命令</span><br></pre></td></tr></table></figure>

<h3 id="kill-信号"><a href="#kill-信号" class="headerlink" title="kill 信号"></a><code>kill</code> 信号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 HUP 终端断线</span><br><span class="line">2 INT 中断,同 Ctrl + C</span><br><span class="line">3 QUIT 退出</span><br><span class="line">9 KILL 强制终止</span><br><span class="line">15 TERM 优雅的终止</span><br><span class="line">18 CONT 继续(bg&#x2F;fg命令)</span><br><span class="line">19 STOP 暂停,同 Ctrl + Z</span><br></pre></td></tr></table></figure>

<h3 id="tcpdump-抓包"><a href="#tcpdump-抓包" class="headerlink" title="tcpdump 抓包"></a><code>tcpdump</code> 抓包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-i &lt;DEV&gt;: 抓取指定网络接口的数据包</span><br><span class="line">-c &lt;COUNT&gt;: 抓取多少个数据包</span><br><span class="line">-w &lt;FILE&gt;: 抓取数据包保存在文件中,而不是直接输出</span><br><span class="line"></span><br><span class="line">expression: tcpdump 的表达式</span><br><span class="line"></span><br><span class="line">type: 指定抓取类型.host,net,port,portrange,默认host</span><br><span class="line">dir: 指定抓取传输方向.src,dst,src and dst,</span><br><span class="line">proto: 指定抓取数据包协议.ip,tcp,udp</span><br><span class="line"></span><br><span class="line">tcpdump [src | dst]host &lt;HOST&gt;: 指定主机</span><br><span class="line">tcpdump host &lt;HOST1&gt; and &lt;HOST2&gt;: 抓取 HOST1 和 HOST2之间的数据包</span><br><span class="line">tcpdump [tcp | udp] port &lt;PORT&gt;: 抓取执行端口数据包</span><br><span class="line">tcpdump host &lt;HOST&gt; and port &lt;PORT&gt;: 抓取主机和端口数据包</span><br><span class="line">tcpdump net &lt;NET&gt;: 抓取网络数据包</span><br></pre></td></tr></table></figure>

<h3 id="日志出现-kernel-nf-conntrack-tablefull-dropping-packet-错误"><a href="#日志出现-kernel-nf-conntrack-tablefull-dropping-packet-错误" class="headerlink" title="日志出现 kernel:nf_conntrack:tablefull,dropping packet 错误"></a>日志出现 <code>kernel:nf_conntrack:tablefull,dropping packet</code> 错误</h3><p>此错误表示连接跟踪表已满,开始丢包,可能的原因是由于频繁的连接/关闭,或者网络的一些 TCP 的连接导致的</p>
<p>解决方法:</p>
<ul>
<li>加大跟踪表的大小 <code>net.netfilter.nf_conntrack_max</code></li>
<li>禁用一些不必跟踪的连接状态</li>
<li>禁用 <code>ip_vs</code>,<code>nf_conntrack</code> 模块</li>
</ul>
<h3 id="sar-命令"><a href="#sar-命令" class="headerlink" title="sar 命令"></a>sar 命令</h3><p>统计,报告,保存系统运行状态信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sar [m [n]]: 每隔 m 秒报告一次,共报告 n 次,默认是 CPU 状态信息</span><br><span class="line">-b 报告 IO 和传输速率</span><br><span class="line">-f [filename] 从历史文件中报告数据</span><br><span class="line">-n [DEV,IP,TCP,UDP] 报告网络状态信息</span><br><span class="line">-o [filename] 将统计结果保存到二进制文件中</span><br><span class="line">-P [0..ALL] 查看 CPU 相关信息</span><br><span class="line">-r 报告内存利用率相关信息</span><br><span class="line">-S 报告 Swarp 利用率相关信息</span><br><span class="line">-u 报告 CPU 利用率状态信息</span><br><span class="line">-v 报告 inode 相关信息</span><br></pre></td></tr></table></figure>

<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符是一个非负的索引值,指向内核中的”文件记录表”.</p>
<ul>
<li>当打开一个现存文件或创建一个新文件时,内核就向进程返回一个文件描述符</li>
<li>当需要读写文件时,文件描述符可作为参数传递给相应的函数</li>
<li>Linux 下所有对设备和文件的操作都使用文件描述符来进行</li>
</ul>
<p>常见文件描述符如下</p>
<ul>
<li>0: 表示标准输入,对应宏为: <code>STDIN_FILENO</code>,函数 scanf() 使用的是标准输入</li>
<li>1: 表示标准输出,对应宏为: <code>STDOUT_FILENO</code>,函数 printf() 使用的是标准输出</li>
<li>2: 表示标准出错处理,对应的宏为: <code>STDERR_NO</code></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题之 MySQL</title>
    <url>/2020/06/04/interview-questions-mysql/</url>
    <content><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB-和-MyIsam-存储引擎的区别"><a href="#InnoDB-和-MyIsam-存储引擎的区别" class="headerlink" title="InnoDB 和 MyIsam 存储引擎的区别"></a>InnoDB 和 MyIsam 存储引擎的区别</h3><table>
<thead>
<tr>
<th align="center">维度</th>
<th align="center">InnoDB</th>
<th align="center">MyIsam</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务支持</td>
<td align="center">支持(ACID)</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">锁</td>
<td align="center">事务和行级锁</td>
<td align="center">表级锁</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">不支持</td>
<td align="center">支持 FULLTEXT 类型的全文索引</td>
</tr>
<tr>
<td align="center">主键/外键</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">存储结构</td>
<td align="center">表数据保存在一个数据文件中</td>
<td align="center">存储为3个文件, .frm 文件存储表定义; .MDY 数据文件; .MYI 索引文件</td>
</tr>
<tr>
<td align="center">存储空间</td>
<td align="center">需要更多的内存和存储</td>
<td align="center">可被压缩</td>
</tr>
<tr>
<td align="center">备份及恢复</td>
<td align="center">拷贝数据文件,备份 binlog,使用 mysqldump 进行备份</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>InnoDB 存储引擎支持事务,支持外键,支持非锁定读,行锁设计</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件读取顺序如下: <code>/etc/my.cnf -&gt; /etc/mysql/my.cnf -&gt; /usr/local/mysql/etc/my.cnf -&gt;  ~/.my.cnf</code>.后面的配置会覆盖前面的配置.如果忘记,可通过 <code>mysql --help | grep my.cnf</code> 进行查看.</p>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><ul>
<li>错误日志: 记录 MySQL 启动,运行,关闭过程中发生的错误.可通过 <code>show variables like &#39;%log_error%&#39;;</code> 查看错误日志文件位置.</li>
<li>慢查询日志: 记录查询时间超过 <code>long_query_time</code> 参数值(默认为 10)的所有 SQL 语句<ul>
<li><code>slow_query_log</code>: 设置是否开启慢查询日志</li>
<li><code>slow_query_log_file</code>: 慢查询日志文件</li>
</ul>
</li>
<li>二进制日志(binlog): 记录对 MySQL 数据库执行更改的所有操作,不包括 <code>SELECT</code> 和 <code>SHOW</code> 之类的操作.可用于复制备份恢复数据<ul>
<li><code>log_bin</code>: 是否记录 binlog</li>
<li><code>log_bin_index</code>: binlog 索引</li>
<li><code>binlog_format</code>: 记录二进制日志的格式. <code>STATEMENT</code> 记录逻辑 SQL 语句.<code>ROW</code> 格式记录表行更改情况(在执行 UPDATE 时,数据与原来一致,则不不会执行).<code>MIXED</code> 默认使用 <code>STATEMENT</code> 格式,一些情况使用 <code>ROW</code> 格式.</li>
<li><code>max_binlog_size</code>: binlog 文件最大大小,若超过该值,则产生新的 binlog 文件,并使索引加 1.</li>
<li><code>binlog_cache_size</code>: 未提交的 binlog 会被记录到缓存中,该选项配置会话缓存大小,默认为 32 KB.</li>
<li><code>sync_binlog</code>: 表示缓冲数据写入磁盘的方式.默认为 0.1 表示同步写磁盘来写二进制日志.</li>
</ul>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="为什么MySQL数据库索引选择使用-B-树"><a href="#为什么MySQL数据库索引选择使用-B-树" class="headerlink" title="为什么MySQL数据库索引选择使用 B+ 树"></a>为什么MySQL数据库索引选择使用 B+ 树</h3><ul>
<li>IO 次数少: B+ 树的中间结点只存放索引,数据都存在叶子结点中,因此中间结点可以存更多的数据,让索引树更加矮胖</li>
<li>范围查询效率更高: B 树需要中序遍历整个树,而 B+ 树需要遍历叶结点中的链表</li>
<li>查询效率更加稳定: 每次查询都需要从根结点到叶结点,路径长度相同,所以每次查询的效率都差不多</li>
</ul>
<h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><ul>
<li>聚簇索引</li>
</ul>
<p>聚簇索引按照每张表的主键构造一棵 B+ 树,叶子节点存放整张表的行记录数据.每个数据页都通过一个双向链表来进行链接.</p>
<p>聚簇索引对于主键的排序查找和范围查找非常快.叶子节点就是用户所要查询的数据.</p>
<ul>
<li>非聚簇索引</li>
</ul>
<p>非聚簇索引中叶子节点不包含行记录的全部数据,而是带有指向数据的指针.</p>
<p>当通过非聚簇索引查找数据时,InnoDB 存储引擎会遍历非聚簇索引并通过叶级别的指针获得指向主键索引的主键,然后再通过主键索引找到一个完整的行记录.</p>
<h3 id="在哪些地方适合创建索引"><a href="#在哪些地方适合创建索引" class="headerlink" title="在哪些地方适合创建索引"></a>在哪些地方适合创建索引</h3><ul>
<li>经常被查询的字段</li>
<li>某列常作为最大值,最小值</li>
<li>经常用作表连接的字段</li>
<li>经常出现在 <code>ORDER BY</code>/<code>GROUP BY</code>/<code>DISDINCT</code> 后面的字段</li>
</ul>
<h4 id="使用索引时的注意事项"><a href="#使用索引时的注意事项" class="headerlink" title="使用索引时的注意事项"></a>使用索引时的注意事项</h4><ul>
<li>建立索引的字段应该非空</li>
<li>选择数据重复率低的字段添加索引,如性别不适合做索引</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h3><ul>
<li>悲观锁: 认为数据随时会被修改,因此每次读取数据之前都会上锁,防止其它事务读取或修改数据.应用于数据更新比较频繁的场景</li>
<li>乐观锁: 操作数据时不会上锁,但是更新时会判断在此期间有没有别的事务更新这个数据.若被更新过,则失败重试.适用于读多写少的场景.乐观锁的实现方式有:<ul>
<li>加一个版本号或者时间戳字段,每次数据更新时同时更新这个字段</li>
<li>先读取想要更新的字段或者所有字段,更新的时候比较一下,只有字段没有变化才进行更新</li>
</ul>
</li>
</ul>
<h3 id="如何定位锁问题"><a href="#如何定位锁问题" class="headerlink" title="如何定位锁问题"></a>如何定位锁问题</h3><p>查看命令 <code>show engine innodb status</code> 的输出,并通过查询 <code>information_schema</code> 库中三个有关锁的表进行查看锁的详情</p>
<ul>
<li><code>innodb_trx</code>: 当前运行的所有事务</li>
<li><code>innodb_locks</code>: 当前出现的锁</li>
<li><code>innodb_lock_waits</code>: 锁等待的对应关系</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="MySQL-事务有哪些特性"><a href="#MySQL-事务有哪些特性" class="headerlink" title="MySQL 事务有哪些特性"></a>MySQL 事务有哪些特性</h3><ul>
<li>原子性(atomicity): 事务是一个不可分割的操作,要么全部正确执行,要么全部不执行</li>
<li>一致性(consistency): 事务把数据从一种一致性状态转化为另一种一致性状态,事务开始前后,数据库完整性没有被破坏</li>
<li>隔离性(isolation): 要求每个读写事务之间是分开的,在提交事务之前对其它事务是不可见的</li>
<li>持久性(durability): 事务一旦提交,结果是永久性的</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li>读未提交: 能够读取到未提交的数据,产生脏读问题</li>
<li>读已提交: 只能读取到已经提交的数据,解决脏读问题,产生不可重读问题.两次同样的查询,可能得到不一样的结果(在读过程中,其它事务修改了数据).</li>
<li>可重读(默认): 在事务开启时,不再允许修改操作.解决不可重读问题,但仍然存在幻读.幻读是指某个事务在读取范围内记录时,另一个事务又在该范围内插入新纪录,之前事务再次读取该范围的记录时,会产生幻行.</li>
<li>串行化: 强制事务串行执行,避免幻读问题</li>
</ul>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="MySQL-复制过程及原理"><a href="#MySQL-复制过程及原理" class="headerlink" title="MySQL 复制过程及原理"></a>MySQL 复制过程及原理</h3><p>过程:</p>
<ul>
<li>主库把数据更改记录在二进制日志中</li>
<li>备库将主库上的日志复制到自己的中继日志中</li>
<li>备库读取中继日志中的事件,并将其重放到备库上</li>
</ul>
<p>原理:</p>
<ul>
<li>主库记录二进制日志,在每次提交事务完成数据更新之前,主库将数据更新的事件记录到二进制日志中.</li>
<li>备库将主库的二进制日志复制到本地中继日志(Relay log)中.备库会启动一个 I/O 线程,并使用该线程与主库建立连接,读取二进制日志中的事件,复制到备库的本地中继日志中.如果该线程追上了主库,则进入睡眠状态,直到有信号通知.</li>
<li>备库的 SQL 线程从中继日志中读取事件并在备库中执行,直到 SQL 线程追上 I/O 线程,从而实现备库的更新</li>
</ul>
<h3 id="如何判断-MySQL-是否同步-该如何使其同步"><a href="#如何判断-MySQL-是否同步-该如何使其同步" class="headerlink" title="如何判断 MySQL 是否同步,该如何使其同步"></a>如何判断 MySQL 是否同步,该如何使其同步</h3><p>使用 <code>show slave status\G</code> 查看同步信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Slave_IO_State:</span><br><span class="line">Slave_IO_Running:</span><br><span class="line">Slave_SQL_Running:</span><br><span class="line">Slave_SQL_Running_State:</span><br><span class="line">Last_IO_Errno:</span><br><span class="line">Last_IO_Error:</span><br><span class="line">Last_SQL_Errno:</span><br><span class="line">Last_SQL_Error:</span><br><span class="line">Read_Master_Log_Pos: 256364229</span><br><span class="line">Exec_Master_Log_Pos: 256364229</span><br><span class="line">Seconds_Behind_Master: 0</span><br><span class="line">SQL_Delay: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 主库配置</span><br><span class="line">log_bin &#x3D; mysql-bin # 开启二进制日志并设置二进制文件前缀名</span><br><span class="line">server_id &#x3D; 10 # 唯一服务器ID,可自行设置</span><br><span class="line">sync_binlog &#x3D; 1 # MySQL 每次在提交事务之前会将二进制日志同步到磁盘上,保证服务器在崩溃时不丢失事件</span><br><span class="line">innodb_flush_logs_at_trx_commit &#x3D; 0,1,2  #  每次提交事务时会记录日志,开启会对性能产生影响,但是提升准确性</span><br><span class="line"></span><br><span class="line"># 主库执行</span><br><span class="line">create user repl_user@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO repl_user IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">flush privileges;</span><br><span class="line">show master status; # 获取到当前 binlog 及 position</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从库配置</span><br><span class="line">relay_log &#x3D; &#x2F;path&#x2F;to&#x2F;relay_log&#x2F;relay-bin</span><br><span class="line">log_slave_updates &#x3D; 1 # 允许从节点在二进制日志中记录更新事务</span><br><span class="line">log_bin &#x3D; mysql-bin</span><br><span class="line">skip_slave_start # 阻止从库在崩溃后自动启动复制</span><br><span class="line">read_only &#x3D; 1</span><br><span class="line"></span><br><span class="line"># 从库执行</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;server1&#39;,</span><br><span class="line">    MASTER_USER&#x3D;&#39;repl_user&#39;,</span><br><span class="line">    MASTER_PASSWORD&#x3D;&#39;123456&#39;,</span><br><span class="line">    MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,</span><br><span class="line">    MASTER_LOG_POS&#x3D;0;</span><br></pre></td></tr></table></figure>

<h3 id="MySQL-如何减少主从复制延迟"><a href="#MySQL-如何减少主从复制延迟" class="headerlink" title="MySQL 如何减少主从复制延迟"></a>MySQL 如何减少主从复制延迟</h3><ul>
<li>慢 SQL 语句过多,在开发或架构上做优化,减少慢 SQL 语句</li>
<li>主从复制单线程,主库写入过快.主库写,安全性较高,建议开启<code>sync_binlog=1</code>,<code>innodb_flush_log_at_trx_commit=1</code> 之类的设置,而从库可以不开启</li>
<li>master 负载过大.架构的前端要加 buffer 及缓存层,如 redis</li>
<li>slave 负载过大,使用多台slave来分摊读请求.再从这些 slave 中取一台专用的服务器</li>
<li>网络延迟</li>
<li>从库硬件性能较差</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="MySQL-重置密码"><a href="#MySQL-重置密码" class="headerlink" title="MySQL 重置密码"></a>MySQL 重置密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --skip-grant-tables --skip-networking</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user <span class="built_in">set</span> password=password(<span class="string">"new_password"</span>) <span class="built_in">where</span> user=<span class="string">"root"</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysqld --正常启动测试</span><br></pre></td></tr></table></figure>

<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><ol>
<li>通过 <code>show status like &#39;Com_%&#39;</code> 查看各种语句执行的次数,其中 <code>Slow_queries</code> 表示慢查询次数</li>
<li>通过 <code>show processlist</code> 命令查看当前 MySQL 正在进行的线程状态,是否锁表等</li>
<li>通过 <code>explain</code> 分析低效 SQL 的执行计划<ol>
<li><code>select_type</code> 表示选择的类型</li>
<li><code>type</code> 表示 MySQL 的访问方式,all(全表扫描),index(索引),range(索引范围),</li>
<li><code>possible_key</code> 表示查询时可能用到的索引</li>
<li><code>key</code> 表示实际用到的索引</li>
<li><code>key_len</code> 表示用到索引字段的长度</li>
<li><code>rows</code>: 扫描行的数量</li>
</ol>
</li>
<li>应尽量避免在 where 子句中使用 <code>!=,&lt;,&gt;</code> 操作符或对字段进行 null 值判断,否则将放弃使用索引而进行全表扫描</li>
<li>只返回必要的列: 最好不要使用 SELECT * 语句</li>
<li>将一个大连接查询分解成对每一个表进行一次单表查询,然后在应用程序中进行关联.好处有:<ol>
<li>高效利用缓存: 单表查询的缓存结果更可能被其它查询使用到,连接查询时,其中一个表发生变化,则整个缓存都会失效.</li>
<li>减少锁竞争</li>
</ol>
</li>
</ol>
<h3 id="常用-SQL-优化"><a href="#常用-SQL-优化" class="headerlink" title="常用 SQL 优化"></a>常用 SQL 优化</h3><ol>
<li><p>大量插入数据</p>
<ul>
<li>使用多个值的 insert 语句,避免连接关闭等消耗</li>
<li>使用 <code>insert delayed</code> 获取更高速度</li>
<li>使用 <code>load data infile</code> 代替 <code>insert</code></li>
<li>将索引文件和数据文件放在不通磁盘上,增大数据写入速率</li>
</ul>
</li>
<li><p>创建合适的索引,并按照索引顺序进行查询</p>
<ul>
<li>考虑在 where 及 order by 列上创建索引</li>
<li>避免在 where 字句中进行空值判断,或使用 <code>!=</code>,<code>&lt;&gt;</code>,<code>or</code>,<code>not in</code>,<code>like &#39;%xxx&#39;</code>,函数/计算,否则将导致放弃使用索引而进行全表扫描</li>
</ul>
</li>
</ol>
<h3 id="drop-delete-truncate-的区别"><a href="#drop-delete-truncate-的区别" class="headerlink" title="drop,delete,truncate 的区别"></a>drop,delete,truncate 的区别</h3><ul>
<li>drop 删除表有关的一切(数据,结构,约束,键),为 DDL 操作.<strong>不能回滚</strong></li>
<li>delete 删除表中数据,可增加 where 语句,但每次从表中删除一行,较慢.<strong>每行删除操作都会记录 binlog,可以回滚</strong></li>
<li>truncate 一次性清空表数据,保留表结构,约束,键.<strong>只有一条 binlog 日志记录此操作不能回滚</strong></li>
</ul>
<h2 id="表连接方式有哪些"><a href="#表连接方式有哪些" class="headerlink" title="表连接方式有哪些?"></a>表连接方式有哪些?</h2><ul>
<li>内连接(inner join): 仅将两个表中满足连接条件的行组合起来作为结果集<ul>
<li>等值连接：给定条件进行查询</li>
</ul>
</li>
<li>外连接(outer join)<ul>
<li>左连接: 左边表的所有数据都有显示出来,右边的表数据只显示共同有的那部分,没有对应的部分补 NULL</li>
<li>右连接: 和左连接相反</li>
<li>全外连接(Full Outer Join)查询出左表和右表所有数据,但是去除两表的重复数据</li>
</ul>
</li>
<li>交叉连接(Cross Join): 返回两表的笛卡尔积(对于所含数据分别为 m,n 的表,返回 m*n 行结果)</li>
</ul>
<h2 id="什么是-SQL-注入-如何防止"><a href="#什么是-SQL-注入-如何防止" class="headerlink" title="什么是 SQL 注入,如何防止"></a>什么是 SQL 注入,如何防止</h2><p>如果用户在提交参数时,在其中掺杂了一些 SQL 关键字或者特殊符号(比如,or # –),就可能会导致SQL语句的语意发生变化.从而执行一些意外的操作(在不知道密码的情况下也能登陆,甚至在不知道用户名和密码的情况下也能登陆),这就是 SQL 注入攻击.</p>
<p>有如下解决办法:</p>
<ul>
<li>检查用户输入的合法性</li>
<li>对进入数据库的特殊字符进行转义处理,或编码转换</li>
<li>预编译 SQL,使用 <code>PreparedStatement</code> 对象来替代 <code>Statement</code> 对象.<code>PreparedStatement</code> 对象会将要执行的 SQL 发送到数据库进行预处理</li>
<li>限制 web 应用连接数据库的权限</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题之 Nginx</title>
    <url>/2020/06/06/interview-questions-nginx/</url>
    <content><![CDATA[<h2 id="Nginx-支持的负载均衡算法有哪些-分别有什么应用场景"><a href="#Nginx-支持的负载均衡算法有哪些-分别有什么应用场景" class="headerlink" title="Nginx 支持的负载均衡算法有哪些?分别有什么应用场景"></a>Nginx 支持的负载均衡算法有哪些?分别有什么应用场景</h2><ul>
<li>round robin 轮询</li>
</ul>
<p>依次将请求分配到各个后端服务器中,是 Nginx 默认的负载均衡方式.适用于后端服务器性能一致的情况.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">    server 172.16.1.2:8080;</span><br><span class="line">    server 172.16.1.3:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>weight 加权轮询</li>
</ul>
<p>加权轮询.根据权重比率分发请求到各个后端服务器中.使用 <code>weight</code> 指定权重.适用于后端服务器性能不一致的情况.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">    server 172.16.1.2:8080 weight&#x3D;10;</span><br><span class="line">    server 172.16.1.3:8080 weight&#x3D;20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ip_hash 客户端 IP 哈希</li>
</ul>
<p>根据客户端 IP 地址的 hash 值将请求发送到后端服务器.可保证来自同一个客户端的请求被转发到固定的后端服务器中,可解决 session 问题.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 172.16.1.2:8080;</span><br><span class="line">    server 172.16.1.3:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>least_conn 最小连接数</li>
</ul>
<p>根据后端服务器的连接数进行分发,同时考虑后端服务器的权重.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 172.16.1.2:8080;</span><br><span class="line">    server 172.16.1.3:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>least_time 最小平均响应时间</li>
</ul>
<p>根据后端服务器的平均响应时间及活动连接数进行分发,同时考虑后端服务器的权重.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">    least_time header | last_byte [inflight];</span><br><span class="line">    server 172.16.1.2:8080;</span><br><span class="line">    server 172.16.1.3:8080;</span><br><span class="line">&#125;</span><br><span class="line"># 如果指定 &#96;header&#96;,则使用 &#96;$upstream_header_time&#96;(请求头的响应时间)作为响应时间的判断依据</span><br><span class="line"># 如果指定 &#96;last_byte&#96;,则使用 &#96;$upstream_response_time&#96;(请求响应时间)作为响应时间的判断依据.如果同时指定了 &#96;inflight&#96; 参数,则不完整的请求也会计算在内.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hash key</code> 自定义 hash 键轮询</li>
</ul>
<p>根据自定义 <code>key</code> 的值进行哈希从而选择后端服务器.<code>key</code> 可以包含文本,变量及其组合.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">    hash &lt;key&gt; [consistent];</span><br><span class="line">    server 172.16.1.2:8080;</span><br><span class="line">    server 172.16.1.3:8080;</span><br><span class="line">&#125;</span><br><span class="line"># 如果指定了 &#96;consistent&#96; 参数,则将使用 ketama 一致性哈希算法.</span><br><span class="line"># 该算法可以确保向组中添加服务器或从组中删除时,只有很少的键被重新映射到与原来不同的服务器.有助于缓存服务器获得更高的缓存命中率</span><br></pre></td></tr></table></figure>

<ul>
<li>random 完全随机</li>
</ul>
<blockquote>
<p>nginx version &gt;= 1.15.1</p>
</blockquote>
<p>将请求随机转发到后端服务器,同时考虑后端服务器权重.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">    random [two [method]];</span><br><span class="line">    server 172.16.1.2:8080;</span><br><span class="line">    server 172.16.1.3:8080;</span><br><span class="line">&#125;</span><br><span class="line"># 可选的 &#96;two&#96; 参数随机选择两个后端服务器,然后使用指定的 &#96;method&#96; 选择一个后端服务器.默认方法是 &#96;least_conn&#96;,将请求传递给活动连接数最少的服务器</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-请求处理有哪些阶段"><a href="#Nginx-请求处理有哪些阶段" class="headerlink" title="Nginx 请求处理有哪些阶段"></a>Nginx 请求处理有哪些阶段</h2><ol>
<li><code>POST_READ</code>: 读取请求头之后的第一个阶段,该阶段很少用. <code>http_realip_module</code> 模块工作在这个阶段,该模块可以将客户端地址更改为指定报头字段中发送的地址.</li>
<li><code>SERVER_REWRITE</code>: 主要用于 server 级别的 uri 重写,主要作用于 server {} 配置块中,location 配置块外.<code>ngx_http_rewrite_module</code> 可以工作在这个阶段,主要提供 <code>rewrite</code>、<code>set</code> 等指令</li>
<li><code>FIND_CONFIG</code>: 该阶段主要寻找 location 配置,使用重写后的 uri 来查找对应的 location</li>
<li><code>REWRITE</code>: 该阶段是 location 级别的 uri 重写阶段,该阶段执行 location {} 配置块内的重写指令,同样也可能被指定多次</li>
<li><code>POST_REWRITE</code>: 该阶段是 location 级别重写的后一个阶段,用来检查上阶段是否有 uri 重写,并根据结果跳转到合适的阶段(FIND_CONFIG)</li>
<li><code>PREACCESS</code>: 该阶段是访问权限控制的前一阶段,预控制阶段.工作在该阶段的模块主要有 <code>ngx_http_limit_conn_module</code>、<code>ngx_http_limit_req_module</code>,对请求速率或连接做出限制</li>
<li><code>ACCESS</code>: 该阶段是访问控制阶段.工作在该阶段的模块主要有 <code>ngx_http_access_module</code>、<code>ngx_http_auth_basic_module</code>、<code>ngx_http_auth_request_module</code> 用于对请求做出访问控制</li>
<li><code>POST_ACCESS</code>: 访问控制的最后一个阶段,主要配合 <code>ACCESS</code> 阶段实现后续处理.工作在该阶段的指令有 <code>satisfy</code>,该指令用于处理前面两个阶段的与或关系来判断请求是否可以被放行(<code>all</code> 表示所有都满足才可以访问,<code>any</code> 表示任意一个满足则放行)</li>
<li><code>PRECONTENT</code>: 生成内容的前一个阶段,主要用于 <code>try_files</code> 指令的处理</li>
<li><code>CONTENT</code>: 生成内容阶段,该阶段主要负责内容生成,输出 http 响应.主要指令 <code>proxy_pass</code>、<code>return</code>、<code>echo</code>(第三方模块)</li>
<li><code>LOG</code>: 记录日志阶段.根据日志相关配置将日志写入对应的文件</li>
</ol>
<h2 id="openresty-工作流程"><a href="#openresty-工作流程" class="headerlink" title="openresty 工作流程"></a>openresty 工作流程</h2><p>主要包含如下阶段</p>
<ol>
<li><code>init_by_lua*</code>: master 进程加载配置时执行,通常用于初始化全局配置或预加载 lua 模块</li>
<li><code>init_worker_by_lua*</code>: worker 进程启动时执行,通常用于定时拉取配置/数据或者后端服务的健康检查</li>
<li><code>ssl_certficate_by_lua*</code>: 主要用于处理 ssl 相关逻辑</li>
<li><code>set_by_lua*</code>: 主要用于处理配置变量相关逻辑</li>
<li><code>rewrite_by_lua*</code>: 主要用于处理 uri 重写&amp;跳转相关逻辑</li>
<li><code>access_by_lua*</code>: 主要用于处理访问控制相关逻辑</li>
<li><code>balancer_by_lua*</code>: 如果有后端服务,还会有 balancer 阶段,主要用于处理负载均衡相关逻辑</li>
<li><code>hedaer_filter_by_lua*</code>: 主要用于处理请求&amp;响应头过滤相关逻辑</li>
<li><code>body_filter_by_lua*</code>: 主要用于处理请求或响应 body 过滤相关逻辑</li>
<li><code>content_by_lua*</code>: 主要用于处理响应相关逻辑</li>
<li><code>log_by_lua*</code>: 主要用于处理日志&amp;计数相关逻辑</li>
</ol>
<p>流程图如下:</p>
<p><img src="/images/openresty-work-process.png" alt="openresty 工作流程"></p>
<h2 id="Nginx-location-匹配的顺序是什么"><a href="#Nginx-location-匹配的顺序是什么" class="headerlink" title="Nginx location 匹配的顺序是什么"></a>Nginx location 匹配的顺序是什么</h2><p>Nginx location 按照如下优先级顺序进行匹配</p>
<ul>
<li>精确匹配: <code>location = /path</code></li>
<li>以某个常规字符串开头: <code>location ^~ /prefix_path</code>,且 <code>prefix_path</code> 路径长者优先匹配</li>
<li>以正则表达式进行匹配: <code>location ~ regex_path</code> 或 <code>location ~* regex_path</code>(<code>~*</code> 表示忽略大小写).不管正则表达式如何进行锚定匹配,首先按照定义的顺序进行匹配.见如下示例:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如下情况 uri&#x3D;&#x2F;image&#x2F;.jpg 返回 &#x2F;image</span><br><span class="line">location ~ &#x2F;image &#123;</span><br><span class="line">    return 200 &#39;&#x2F;image&#39;;</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.jpg &#123;</span><br><span class="line">    return 200 &#39;.jpg&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如下情况 uri&#x3D;&#x2F;image&#x2F;.jpg 返回 .jpg</span><br><span class="line">location ~ \.jpg &#123;</span><br><span class="line">    return 200 &#39;.jpg&#39;;</span><br><span class="line">&#125;</span><br><span class="line">location ~ &#x2F;image &#123;</span><br><span class="line">    return 200 &#39;&#x2F;image&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通用匹配: <code>location /path</code>,且 path 路径长者优先匹配</li>
</ul>
<h2 id="Nginx-servername-匹配的顺序是什么"><a href="#Nginx-servername-匹配的顺序是什么" class="headerlink" title="Nginx servername 匹配的顺序是什么"></a>Nginx servername 匹配的顺序是什么</h2><ol>
<li>精确 server_name 匹配.</li>
<li>以 * 通配符开始的泛域名</li>
<li>以 * 通配符结束的泛域名</li>
<li>匹配正则表达式</li>
<li>listen 指定的 default server_name</li>
<li>http 模块下的第一个server配置块中的server_name</li>
</ol>
<h2 id="Nginx-重新加载配置文件的流程是什么"><a href="#Nginx-重新加载配置文件的流程是什么" class="headerlink" title="Nginx 重新加载配置文件的流程是什么"></a>Nginx 重新加载配置文件的流程是什么</h2><ol>
<li>向 master 发送 reload信号</li>
<li>master 校验配置文件语法</li>
<li>master 进程打开新的监听端口</li>
<li>master 进程用新配置启动新的 worker 子进程</li>
<li>master 进程向 worker 子进程发送 quit 信号</li>
<li>旧 worker 进程关闭监听句柄,处理完当前连接后后结束进程</li>
</ol>
<h2 id="Nginx-调优"><a href="#Nginx-调优" class="headerlink" title="Nginx 调优"></a>Nginx 调优</h2><h3 id="合理设置-Nginx-worker-进程数-并绑定到不同-CPU"><a href="#合理设置-Nginx-worker-进程数-并绑定到不同-CPU" class="headerlink" title="合理设置 Nginx worker 进程数,并绑定到不同 CPU"></a>合理设置 Nginx worker 进程数,并绑定到不同 CPU</h3><p>一般情况下,应将 worker 进程数设置为 CPU 核数,或设置为 <code>auto</code> 根据系统 CPU 自动配置.</p>
<p>可以通过 <code>worker_cpu_affinity</code> 将 Nginx worker 进程绑定到不同的 CPU 上,避免多个进程竞争同一个 CPU 资源,充分利用 CPU 多核资源.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  4;</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000;</span><br></pre></td></tr></table></figure>

<h3 id="使用-epoll-事件驱动模型-合理设置单个进程的最大连接数及最大打开文件数量"><a href="#使用-epoll-事件驱动模型-合理设置单个进程的最大连接数及最大打开文件数量" class="headerlink" title="使用 epoll 事件驱动模型,合理设置单个进程的最大连接数及最大打开文件数量"></a>使用 epoll 事件驱动模型,合理设置单个进程的最大连接数及最大打开文件数量</h3><blockquote>
<p>进程最大连接数受系统最大打开文件数限制,因此需要使用 <code>ulimit</code> 设置打开的文件数.或在 <code>/etc/security/limits.conf</code>, <code>/etc/security/limits.d/nginx.conf</code> 进行配置.配置如下</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n <span class="variable">$max_open_files</span> <span class="comment"># 设置系统最大打开文件数</span></span><br><span class="line">cat /etc/security/limits.d/nginx.conf</span><br><span class="line">*       soft    nproc   131072</span><br><span class="line">*       hard    nproc   131072</span><br><span class="line">*       soft    nofile  131072</span><br><span class="line">*       hard    nofile  131072</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections 15000;</span><br><span class="line">    worker_rlimit_nofile 65535;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开启-access-log-buffer-缓冲区"><a href="#开启-access-log-buffer-缓冲区" class="headerlink" title="开启 access_log buffer 缓冲区"></a>开启 access_log buffer 缓冲区</h3><p>在高并发场景下,nginx 日志写入磁盘可能会极大的影响 nginx 的性能.可以通过设置 <code>access_log ... buffer=size flush=time</code> 来开启 nginx access_log 日志的缓冲区大小,并设置同步到磁盘的时间.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]];</span><br><span class="line"># 或禁用某些不必要的日志.如静态文件的访问日志.</span><br><span class="line">access_log off;</span><br></pre></td></tr></table></figure>

<h3 id="开启高效文件传输模式-开启或-gzip-压缩"><a href="#开启高效文件传输模式-开启或-gzip-压缩" class="headerlink" title="开启高效文件传输模式,开启或 gzip 压缩"></a>开启高效文件传输模式,开启或 gzip 压缩</h3><ul>
<li>配置段 <code>sendfile</code> 参数用于开启文件高效传输模式</li>
<li>配置段<code>gzip</code> 参数可用于开启压缩功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    gzip  on;</span><br><span class="line">    sendfile on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化-Nginx-连接超时时间"><a href="#优化-Nginx-连接超时时间" class="headerlink" title="优化 Nginx 连接超时时间"></a>优化 Nginx 连接超时时间</h3><ul>
<li>配置段 <code>keepalive_timeout</code> 参数用于设置客户端连接保持会话的超时时间,超过这个时间服务器会关闭该连接</li>
<li>配置段 <code>client_header_timeout</code> 参数用于设置读取客户端请求头数据的超时时间.如果读取请求头超时,服务器将返回 “Request time out (408)” 错误.</li>
<li>配置段 <code>client_body_timeout</code> 参数用于设置读取客户端请求主体数据的超时时间.如果读取请求体超时,服务器将返回 “Request time out (408)” 错误.</li>
<li>配置段 <code>send_timeout</code> 参数用于指定响应客户端的超时时间,如果超时,Nginx 将会关闭连接.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 在大并发时,需要合理调小如下参数</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    client_header_timeout 15;</span><br><span class="line">    client_body_timeout 15;</span><br><span class="line">    send_timeout 25;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nginx-限制连接与限制请求速率"><a href="#Nginx-限制连接与限制请求速率" class="headerlink" title="Nginx 限制连接与限制请求速率"></a>Nginx 限制连接与限制请求速率</h3><ul>
<li><code>limit_conn_zone</code> 参数用于为共享内存区域设置参数</li>
<li><code>limit_conn</code> 参数用于设置指定内存区域的最大连接数</li>
<li><code>limit_conn_status</code> 参数用于设置超过最大连接数的请求状态码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m; # 设置 $binary_remote_addr 客户端地址的地址区域为 10m</span><br><span class="line">    limit_conn $&#123;zone&#125; $&#123;num&#125;; # 设置指定 zone 的最大连接数</span><br><span class="line">    limit_conn_status $&#123;http_code&#125;; # 设置超过最大连接数的状态码,默认 503</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>limit_req_zone</code> 参数用于为共享内存区域设置参数</li>
<li><code>limit_req</code> 参数用于设置指定内存区域的最大连接数</li>
<li><code>limit_req_status</code> 参数用于设置超过最大连接数的请求状态码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;1r&#x2F;s; </span><br><span class="line">    # 设置 $binary_remote_addr 客户端地址的地址区域为 10m,平均请求速率最大为 1r&#x2F;s</span><br><span class="line">    limit_req zone&#x3D;$&#123;zone&#125; burst&#x3D;$&#123;num&#125;; # 设置指定 zone 的最大并发请求</span><br><span class="line">    limit_req_status $&#123;http_code&#125;; # 设置超过最大请求数的状态码,默认 503</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合理配置-Nginx-expires-缓存"><a href="#合理配置-Nginx-expires-缓存" class="headerlink" title="合理配置 Nginx expires 缓存"></a>合理配置 Nginx expires 缓存</h3><ul>
<li><code>expires</code> 参数用于设置用户访问内容的缓存时间.用户会在本地浏览器中缓存这些内容,直到超过缓存时间.多用于配置静态内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css)$ &#123;</span><br><span class="line">    expires     3650d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限制上传文件大小"><a href="#限制上传文件大小" class="headerlink" title="限制上传文件大小"></a>限制上传文件大小</h3><ul>
<li><code>http</code> 配置段 <code>send_timeout</code> 参数用于设置客户端最大请求体大小.如果超过出,客户端会收到 413 错误,即请求体过大</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    client_max_body_size 8m;    # 设置客户端最大请求体大小为8M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化服务器域名的散列表大小"><a href="#优化服务器域名的散列表大小" class="headerlink" title="优化服务器域名的散列表大小"></a>优化服务器域名的散列表大小</h3><p>如果在 server_name 中配置了长域名,可能会出现如下错误.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 64</span><br><span class="line">nginx: configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf test failed</span><br></pre></td></tr></table></figure>

<p>此时需要对 <code>http</code> 配置段 <code>server_names_hash_bucket_size</code> 进行调整,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ngx_http_core_module</span><br><span class="line">http &#123;</span><br><span class="line">    server_names_hash_bucket_size  512;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-安全"><a href="#Nginx-安全" class="headerlink" title="Nginx 安全"></a>Nginx 安全</h2><h3 id="隐藏-修改-Nginx-响应头-Server-信息"><a href="#隐藏-修改-Nginx-响应头-Server-信息" class="headerlink" title="隐藏/修改 Nginx 响应头 Server 信息"></a>隐藏/修改 Nginx 响应头 Server 信息</h3><p>在配置文件 <code>http</code> 配置段中添加 <code>server_tokens off;</code> 配置项,即可隐藏 Nginx 版本号</p>
<p>要修改 Nginx 响应头部 Server 信息,需要对 <code>src/core/nginx.h</code> 源码文件进行修改,再按照需求进行编译.慎重!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/nginx.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nginx_version      1018000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGINX_VERSION      <span class="meta-string">"version"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGINX_VER          <span class="meta-string">"server/"</span> NGINX_VERSION</span></span><br></pre></td></tr></table></figure>

<p>修改完成后,响应头部如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: server&#x2F;version</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="只允许指定客户端访问"><a href="#只允许指定客户端访问" class="headerlink" title="只允许指定客户端访问"></a>只允许指定客户端访问</h3><ul>
<li><code>allow</code>,<code>deny</code> 参数用于配置可以/禁止访问 Nginx 指定内容的客户端.可配置在 <code>http, server, location, limit_except</code> 配置段中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    allow 192.168.1.1&#x2F;24;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置-Nginx-防盗链"><a href="#配置-Nginx-防盗链" class="headerlink" title="配置 Nginx 防盗链"></a>配置 Nginx 防盗链</h3><p>防盗链：简单地说，就是某些不法网站未经许可，通过在其自身网站程序里非法调用其他网站的资源，然后在自己的网站上显示这些调用的资源，使得被盗链的那一端消耗带宽资源</p>
<ul>
<li>根据 HTTP <code>referer</code> 字段实现防盗链: referer 是 HTTP的一个首部字段,用于指明用户请求的 URL 是从哪个页面通过链接跳转过来的</li>
<li>根据 cookie 实现防盗链: cookie 是服务器贴在客户端身上的 “标签”,服务器用它来识别客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png|bm|swf|flv|rar|zip|gz|bz2)$ &#123;</span><br><span class="line">    valid_referers  none  blocked  *.test.com  *.abc.com; # 表示这些地址可以访问上面的媒体资源</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        # 如果不是从以上域名访问,则返回 403</span><br><span class="line">        return 403</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nginx-错误页面优雅显示"><a href="#Nginx-错误页面优雅显示" class="headerlink" title="Nginx 错误页面优雅显示"></a>Nginx 错误页面优雅显示</h3><ul>
<li>使用 <code>error_page</code> 参数可对指定错误码返回的页面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    root   html&#x2F;www;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    error_page 400 401 402 403 404 405 408 410 412 413 414 415 500 501 502 503 506 &#x3D; http:&#x2F;&#x2F;www.xxxx.com&#x2F;error.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-常用信号"><a href="#Nginx-常用信号" class="headerlink" title="Nginx 常用信号"></a>Nginx 常用信号</h2><table>
<thead>
<tr>
<th align="left">kill 信号</th>
<th align="left">解释</th>
<th align="left">nginx 命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TERM(15), INT(2)</td>
<td align="left">快速停止</td>
<td align="left">nginx -s stop</td>
</tr>
<tr>
<td align="left">QUIT(3)</td>
<td align="left">优雅的停止</td>
<td align="left">nginx -s quit</td>
</tr>
<tr>
<td align="left">HUP(1)</td>
<td align="left">优雅的启动新的进程重新加载配置文件</td>
<td align="left">nginx -s reload</td>
</tr>
<tr>
<td align="left">USR1(10)</td>
<td align="left">日志文件滚动</td>
<td align="left">nginx -s reopen</td>
</tr>
<tr>
<td align="left">USR2(12)</td>
<td align="left">升级二进制可执行文件</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">WINCH(28)</td>
<td align="left">优雅的关闭 worker 进程</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="Nginx-平滑升级与回退"><a href="#Nginx-平滑升级与回退" class="headerlink" title="Nginx 平滑升级与回退"></a>Nginx 平滑升级与回退</h3><p>假设 nginx 版本升级前进程 id 为 <code>30818</code>,则平滑升级与版本回退过程如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向原 master 进程发送 USR2 信号,使用新版本的 nginx 启动 master 进程,此时老版本的 nginx 仍在处理请求</span></span><br><span class="line"><span class="built_in">kill</span> -USR2 30818</span><br><span class="line"><span class="comment"># 向原 master 进程发送 WINCH 信号,优雅停止旧版本的 nginx worker,此时切换为新版本的 nginx 处理请求</span></span><br><span class="line"><span class="built_in">kill</span> -WINCH 30818</span><br><span class="line"><span class="comment"># 向原 master 进程发送 QUIT 信号,优雅停止旧版本的 nginx master</span></span><br><span class="line"><span class="built_in">kill</span> -QUIT 30818</span><br></pre></td></tr></table></figure>

<hr>
<p>参考</p>
<ul>
<li><a href="https://www.cnblogs.com/zhichaoma/p/7989655.html" target="_blank" rel="noopener">Nginx 调优</a></li>
<li><a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_http_core_module.h#L107-L126" target="_blank" rel="noopener">nginx/nginx (github.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/379210150" target="_blank" rel="noopener">Nginx 的 11 个执行阶段详解</a></li>
<li><a href="https://www.cnblogs.com/fly-kaka/p/11102849.html" target="_blank" rel="noopener">OpenResty 执行流程阶段</a></li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题之 Redis</title>
    <url>/2020/06/04/interview-questions-redis/</url>
    <content><![CDATA[<h2 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快"></a>Redis 为什么这么快</h2><ul>
<li>Redis 中的数据保存在内存中,绝大多数请求都是纯粹的内存操作,非常快速</li>
<li>使用多路 I/O 复用模型,非阻塞 IO</li>
<li>采用单线程,避免不必要的上下文切换和竞争,也不存在多进程或多线程中各种锁的问题</li>
</ul>
<h2 id="Redis-支持的数据类型"><a href="#Redis-支持的数据类型" class="headerlink" title="Redis 支持的数据类型"></a>Redis 支持的数据类型</h2><p>Redis 支持如下数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string, 字符串</span><br><span class="line">hash, 哈希,键值映射</span><br><span class="line">list, 列表</span><br><span class="line">set, 无序集合</span><br><span class="line">zset, (带有分值 score 的)有序集合</span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><ul>
<li>int: 8 个字节的长整型</li>
<li>embstr: 小于等于 39 字节的字符串</li>
<li>raw: 大于等于 39 字节的字符串</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>缓存: 将后端数据缓存到特定的键中,并设置过期时间,减小后端应用的压力</li>
<li>计数: Redis 对整型数据提供自增自减函数,可以作为计数的基础工具,以实现快速计数,查询缓存的功能</li>
<li>共享 session: 使用 Redis 将用户的 Session 数据集中管理,每次用户更新或登录可直接从 Redis 中获取 Session</li>
<li>限速与过期: 限制用户的访问频率,如限制向同一手机号发送短信验证码的频率.设置验证码的过期时间等</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><ul>
<li>ziplist(压缩列表): 当元素个数小于 <code>hash-max-ziplist-entries</code> 配置(默认 512),同时元素值都小于 <code>hash-max-ziplist-value</code> 配置(默认 64 字节)</li>
<li>hashtable(哈希表): 哈希类型无法满足 ziplist 条件时</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>应用于使用 <code>string</code> 不好存储的场景,比如关系型数据库的缓存.</p>
<ul>
<li>将关系型数据库的表字段序列化后用一个键值保存.这么做的优点是可以简化编程,合理的序列化可以提高内存使用率.缺点是序列化与反序列化过程中会有一定的开销.</li>
<li>将关系型数据库的表属性使用一对 key-value.但是只用一个键保存.优点是简单直观,可以减少内存空间的使用.缺点是要控制 key-value 个数,控制 hash 内部编码在 ziplist 和 hashtable 之间的转换.</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><ul>
<li>ziplist(压缩列表): 当列表元素个数小于 <code>list-max-ziplist-entries</code> 配置(默认 512),同时列表中的元素值都小于 <code>list-max-ziplist-value</code> 配置(默认 64 字节)</li>
<li>linkedlist(链表): 列表类型无法满足 ziplist 条件时</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>列表: 列表是按照插入顺序排序,且支持按照索引范围获取元素</li>
<li>栈: lpush + lpop</li>
<li>队列: lpush + rpop</li>
<li>消息队列: lpush + brpop</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><ul>
<li>intset(整数集合): 集合中元素都是整数且元素个数小于 <code>set-max-intset-entries</code> 配置(默认 512)</li>
<li>hashtable(哈希表): 集合类型无法满足 intset 条件时</li>
</ul>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>标签: 对用户的某类属性打标签,然后对具有相同标签的用户做定向推荐</li>
<li>交集/并集: 对用户好友列表求交集/并集后,可以得到用户共同好友与可能认识的人</li>
</ul>
<h3 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h3><ul>
<li>ziplist(压缩列表): 当有序集合个数小于 <code>zset-max-ziplist-entries</code> 配置(默认 128),同时列表中的元素值都小于 <code>zset-max-ziplist-value</code> 配置(默认 64 字节)</li>
<li>skiplist(跳跃表): 列表类型无法满足 ziplist 条件时</li>
</ul>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<p>排行榜系统</p>
</blockquote>
<ul>
<li>添加用户点赞数: <code>zadd user:ranking 3 mike 4 jack</code> 表示用户 mike 得到 3 个赞,jack 得到 4 个赞</li>
<li>删除用户点赞数: <code>zrem user:ranking jack</code> 表示从排行榜上删除用户 jack 的点赞记录</li>
<li>排行: <code>zrevramgebyrank user:ranking 0 9</code> 表示获取点赞数前十名</li>
<li>用户排名及分数: <code>zscore user:ranking mike</code> 分数 <code>zrank user:ranking mike</code> 排名</li>
</ul>
<h2 id="RESP-Redis-服务端与客户端的通信协议"><a href="#RESP-Redis-服务端与客户端的通信协议" class="headerlink" title="RESP,Redis 服务端与客户端的通信协议"></a>RESP,Redis 服务端与客户端的通信协议</h2><ul>
<li>命令格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&lt;参数数量&gt; CRLF</span><br><span class="line">$&lt;参数 1 字节数量&gt; CRLF</span><br><span class="line">参数1</span><br><span class="line">$&lt;参数 2 字节数量&gt; CRLF</span><br><span class="line">参数2</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<ul>
<li>响应格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">状态回复: +</span><br><span class="line">错误回复: -</span><br><span class="line">整数回复: :</span><br><span class="line">字符串回复: $</span><br><span class="line">多字符串回复: *</span><br></pre></td></tr></table></figure>

<h2 id="Redis-的持久化方式"><a href="#Redis-的持久化方式" class="headerlink" title="Redis 的持久化方式"></a>Redis 的持久化方式</h2><p>Redis 数据保存在内存中,当进程重新启动时,释放内存并重新分配,数据会丢失.持久化就是将 Redis 内存中的数据保存在磁盘上,在进程重新启动时,可以从磁盘加载数据,保证数据持久性</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="bgsave-流程说明"><a href="#bgsave-流程说明" class="headerlink" title="bgsave 流程说明"></a>bgsave 流程说明</h4><ol>
<li>执行 bgsave 命令,父进程判断有无子进程在进行持久化操作.如有,则直接返回</li>
<li>父进程执行 fork 操作创建子进程(该过程父进程会阻塞),子进程创建 RDB 文件,并根据父进程内存生成临时快照文件,完成后对原有文件进行原子替换</li>
<li>子进程发送信号给父进程表示完成,父进程更新统计信息</li>
</ol>
<p><img src="/images/redis-bgsave.png" alt="redis-bgsave"></p>
<h4 id="bgsave-触发方式"><a href="#bgsave-触发方式" class="headerlink" title="bgsave 触发方式"></a><code>bgsave</code> 触发方式</h4><blockquote>
<p>手动触发</p>
</blockquote>
<ul>
<li><code>save</code>: <code>save</code> 命令会阻塞当前 Redis 服务,直到 RDB 持久化完成为止.</li>
<li><code>bgsave</code>: <code>bgsave</code> 命令会使 Redis 进程 fork 创建出子进程,RDB 持久化过程由子进程完成.fork 过程中,Redis 会阻塞,但一般时间很短.</li>
</ul>
<blockquote>
<p>自动触发</p>
</blockquote>
<ul>
<li>配置文件中使用 <code>save m n</code> 相关配置,表示 m 秒内存在 n 次修改时,自动触发 <code>bgsave</code>.</li>
<li>从节点全量复制时,主节点自动触发 <code>bgsave</code> 生成 RDB 文件,并发送给从节点</li>
<li>执行 <code>debug reload</code> 命令重新加载 Redis 时,会自动触发.</li>
<li>默认情况下,执行 <code>shutdown</code> 关闭 Redis 时,如果没有开启 AOF,则自动执行 <code>bgsave</code>.</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="AOF-流程说明"><a href="#AOF-流程说明" class="headerlink" title="AOF 流程说明"></a>AOF 流程说明</h4><ol>
<li>写入命令以 RESP 协议文本格式追加到 aof_buf 缓冲区中</li>
<li>AOF 缓冲区根据配置的同步策略向磁盘做同步操作.同步策略由 <code>appendfsync</code> 参数控制,包括以下 3 种策略<ul>
<li>always: 每次写入都要同步 AOF 文件,在一般的 SATA 盘上,Redis 只能支持大约几百 TPS 写入,与 Redis 高性能背道而驰</li>
<li>everysec(默认): 每秒同步一次,理论上在宕机的情况下只丢失 1 秒的数据</li>
<li>no: Redis 不做同步,同步硬盘由操作系统负责,通常 30 秒一次.无法保证数据安全.</li>
</ul>
</li>
<li>执行 AOF文件重写,<code>bgrewriteaof</code> 或自动触发.<ol>
<li>如果当前进程正在执行 AOF 重写,则直接返回.如果正在执行  <code>bgsave</code>,则等 <code>bgsave</code> 完成后再执行.</li>
<li>父进程 fork 子进程,开销与 <code>bgsave</code> 一样.子进程能够共享 fork 操作时的内存数据</li>
<li>父进程 fork 完成后,继续响应其它命令,所有修改操作依然写入 AOF 缓冲区,并根据 <code>appendfsync</code> 策略同步到磁盘</li>
<li>子进程根据内存快照,按照重写规则写入到新的 AOF 文件</li>
<li>写入完成后,通知父进程,父进程更新统计信息,使用新文件替换老文件,并将缓冲区写入新的 AOF 文件中</li>
</ol>
</li>
</ol>
<blockquote>
<p>注意: fork 阻塞,AOF 追加阻塞(磁盘同步过程中,可能造成阻塞)</p>
</blockquote>
<p><img src="/images/redis-aof.png" alt="redis aof"></p>
<h4 id="AOF-重写触发方式"><a href="#AOF-重写触发方式" class="headerlink" title="AOF 重写触发方式"></a>AOF 重写触发方式</h4><blockquote>
<p>手动触发</p>
</blockquote>
<ul>
<li><code>bgrewriteaof</code>: 直接使用 <code>bgrewriteaof</code> 命令触发 aof 重写</li>
</ul>
<blockquote>
<p>自动触发</p>
</blockquote>
<p>根据 <code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 参数确定触发时机</p>
<ul>
<li><code>auto-aof-rewrite-min-size</code>: 表示 AOF 重写时文件的最小体积.默认为 64M</li>
<li><code>auto-aof-rewrite-percentage</code>: 表示当前 AOF 文件空间(<code>aof_current_size</code>)和上一次重写后 AOF文件大小(<code>aof_base_size</code>)的比值</li>
</ul>
<p>自动触发时机为: <code>aof_current_size &gt; auto-aof-rewrite-min-size</code> &amp;&amp; <code>(aof_current_size - aof_base_size)/aof_base_size &gt;= auto-aof-rewrite-percentage</code>.即当前文件大小大于 AOF 重写的最小体积,且上一次重写后,文件大小增长的百分比超过一定值.</p>
<h2 id="Redis-复制过程"><a href="#Redis-复制过程" class="headerlink" title="Redis 复制过程"></a>Redis 复制过程</h2><p>从节点执行 <code>slaveof</code> 命令后</p>
<ol>
<li>保存主节点信息</li>
<li>建立网络连接,创建用于接收主节点发送复制命令的套接字</li>
<li>发送 ping 命令,检测套接字是否可用,主节点是否可接受处理命令</li>
<li>权限验证,主要是主节点中 <code>requirepass</code> 和从节点 <code>masterauth</code> 参数</li>
<li>同步数据集</li>
<li>命令持续复制</li>
</ol>
<p><img src="/images/redis-slaveof-master.png" alt="redis 主从复制"></p>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ol>
<li>从节点发送 <code>psync ? -1</code> 命令进行全量数据同步</li>
<li>主节点回复 +FULLRESYNC 响应</li>
<li>从节点接收主节点响应数据保存运行 ID 和偏移量 offset</li>
<li>主节点执行 <code>bgsave</code> 保存 RDB 文件到本地,并发送 RDB 到从节点.在这期间主节点仍然响应读写命令,并将数据保存在复制客户端缓冲区内.</li>
<li>从节点接收主节点传送来的数据后清空自身数据,并加载 RDB 文件.加载完成后,主节点将缓冲区内数据发送给从节点,保证数据一致性.</li>
<li>以上步骤完成后,如果从节点开启 AOF 持久化功能,则立刻进行 <code>bgrewriteaof</code> 操作.</li>
</ol>
<p><img src="/images/redis-full-copy.png" alt="redis 全量复制"></p>
<blockquote>
<p>耗时分析</p>
</blockquote>
<ul>
<li>主节点 <code>bgsave</code> 时间</li>
<li>主节点发送 RDB 网络传输时间</li>
<li>从节点清空自身数据时间</li>
<li>从节点加载 RDB 时间</li>
<li>从节点可能的 AOF 重写时间</li>
</ul>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ol>
<li>从节点发送 <code>psync {runId} {offset}</code> 命令进行部分复制</li>
<li>主节点判断 runId 与自身是否一致,如果一致,则根据参数 offset 在复制积压缓冲区查找,如果偏移量在缓冲区中,则发送 +CONTINUE 响应;若不一致或 offset 不在缓冲区中,则退化为全量复制</li>
<li>主节点根据偏移量把复制积压缓冲区内数据发送给从节点,保证主从复制进入正常状态</li>
</ol>
<p><img src="/images/redis-increment-copy.png" alt="redis 增量复制"></p>
<h3 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><blockquote>
<p>数据延迟</p>
</blockquote>
<p>读写分离的数据延时问题是无法避免的,延迟取决于网络带宽和命令阻塞情况.对于无法容忍大量延迟场景,可以编写外部监控程序监听主从节点的复制偏移量,当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点</p>
<blockquote>
<p>过期数据</p>
</blockquote>
<p>惰性删除: 主节点每次处理读取命令时,都会检查键是否超时,如果超时则执行 <code>del</code> 命令删除键对象, 之后 <code>del</code> 命令也会异步发送给从节点</p>
<p>定时删除: Redis 主节点在内部定时任务会循环采样一定数量的键,当发现采样的键过期时执行 <code>del</code> 命令,之后再同步给从节点</p>
<blockquote>
<p>从节点故障</p>
</blockquote>
<p>客户端维护可用从节点列表,当从节点故障时立刻切换到其他从节点或主节点上.此过程类似于延时过高的监控处理,需要开发人员改造客户端类库</p>
<h4 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h4><p>全量复制是一个非常消耗资源的操作.其场景包括</p>
<ul>
<li>第一次建立复制</li>
<li>节点运行 ID 不匹配: 当主从复制关系建立后,从节点会保存主节点的运行 ID.如果此时主节点因故障重启,那么它的运行 ID 会改变,从节点发现主节点运行 ID 不匹配时,会认为自己复制的是一个新的主节点从而进行全量复制.尽量从架构上避免,提供故障转移功能</li>
<li>复制积压缓冲区不足: 当主从节点网络中断后,从节点再次连上主节点时会发送 <code>psync {offset} {runId}</code> 命令请求部分复制,如果请求的偏移量不在主节点的积压缓冲区内,则无法提供给从节点数据,因此部分复制会退化为全量复制</li>
</ul>
<h4 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h4><ul>
<li>单主节点复制风暴</li>
<li>单机器复制风暴</li>
</ul>
<blockquote>
<p>解决</p>
</blockquote>
<ul>
<li>减少主节点(master)挂载从节点(slave)的数量或者采用树状复制结构,加入中间层从节点用来保护主节点</li>
<li>应该把主节点尽量分散在多台机器上,避免在单台机器上部署过多的主节点</li>
<li>当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制</li>
</ul>
<h2 id="阻塞原因"><a href="#阻塞原因" class="headerlink" title="阻塞原因"></a>阻塞原因</h2><ul>
<li>API 或数据结构使用不合理,使用 <code>slowlog get {n}</code> 查看最近 n 次慢查询记录.或使用 bigkeys 查看大对象.对于慢查询,Redis 提供了  <code>showlog-log-slower-than</code> 设置慢查询的阈值,<code>showlog-max-len</code> 设置慢查询日志最多存储多少条</li>
<li>CPU 饱和,单线程 Redis 处理命令时只能使用一个 CPU.建议使用统计命令 使用统计命令 <code>redis-cli -h{ip} -p{port} --stat</code> 查看当前 Redis 使用情况(可能存在 Redis 实例为了追求低内存使用量,过度放宽 ziplist 使用条件(修改 <code>hash-max-ziplist-entries</code> 和 <code>hash-max-ziplist-value</code> 配置),而 ziplist 的操作算法复杂度在 O(n)到 O(n^2) 之间,导致内存使用率过低,而 CPU 使用率过高</li>
<li>持久化阻塞. 在持久化时,如果 fork 操作本身耗时过长,必然会导致主线程的阻塞</li>
<li>CPU 竞争, Redis 是典型的 CPU 密集型应用,不应与其它 CPU 密集型应用部署在一起.且若做了 CPU 绑定, 父子进程 RDB/AOF 重写时,可能存在 CPU 竞争</li>
<li>内存交换(swap),保证 Redis 高性能的一个重要前提是将所有数据保存在内存中.如果数据部分保存在内存中,可能导致 Redis 性能下降.所以务必确保 Redis 实例有足够内存可以使用,并设置 <code>maxmemory</code>,降低系统使用 swap 的优先级</li>
<li>网络原因</li>
</ul>
<h2 id="Redis-有哪几种数据淘汰策略-Redis-的内存溢出控制策略"><a href="#Redis-有哪几种数据淘汰策略-Redis-的内存溢出控制策略" class="headerlink" title="Redis 有哪几种数据淘汰策略(Redis 的内存溢出控制策略)"></a>Redis 有哪几种数据淘汰策略(Redis 的内存溢出控制策略)</h2><p>Redis使用 <code>maxmemory</code> 参数限制最大可用内存.当 Redis 所用内存达到 <code>maxmemory</code> 上限时会触发相应的溢出控制策略,包含如下 6 种策略,且内存溢出控制策略可以采用 <code>config set maxmemory-policy {policy}</code> 动态配置</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">noeviction</td>
<td align="center">默认策略,不会删除任何数据,拒绝所有写入操作并返回错误信息(OOM),此时 Redis 只响应读操作</td>
</tr>
<tr>
<td align="center">volatile-lru</td>
<td align="center">根据LRU算法删除设置了超时属性的键,直到空间足够;如果没有可删除的键,则回退到noeviction策略</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">根据LRU算法删除键,不管数据有没有设置超时属性,直到空间足够</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">随机删除所有键,直到腾出足够空间为止</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">随机删除过期键,直到腾出足够空间为止</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">根据键值对象的ttl属性,删除最近将要过期数据.如果没有,回退到 noeviction 策略</td>
</tr>
</tbody></table>
<h2 id="Redis-内存优化有哪些方式"><a href="#Redis-内存优化有哪些方式" class="headerlink" title="Redis 内存优化有哪些方式"></a>Redis 内存优化有哪些方式</h2><ul>
<li>精简键值大小,键值字面量精简,控制 redis 内部编码类型以节省内存</li>
<li>数据优先使用整数,并使用对象共享池优化小整数大小</li>
<li>优化字符串使用,通过修改数据结构来节省内存.如 json 格式的字符串转化为 hash</li>
<li>合理设计数据保存类型,控制键</li>
</ul>
<h2 id="哨兵机制实现原理"><a href="#哨兵机制实现原理" class="headerlink" title="哨兵机制实现原理"></a>哨兵机制实现原理</h2><h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><ol>
<li>每隔 10 秒,Sentinel 节点向主/从节点发送 <code>info</code> 命令获取最新拓补结构</li>
<li>每隔 2 秒,Sentinel 节点向 Redis 数据节点 <code>__sentinel__:hello</code> 频道发送该 Sentinel 节点对于主节点的判断及当前 Sentinel 节点信息.每个 Sentinel 也会订阅该频道,了解其它 Sentinel 以及对主节点的判断(主要用于发现新的 Sentinel 节点,并交换主节点状态,作为客观下线及领导者选举的依据)</li>
<li>每隔 1 秒,Sentinel 向主从节点,Sentinel 节点发送 ping 命令做心跳检测(当节点不可达时做主观下线及领导者选举的依据)</li>
</ol>
<h3 id="故障恢复过程"><a href="#故障恢复过程" class="headerlink" title="故障恢复过程"></a>故障恢复过程</h3><ol>
<li>主观下线</li>
</ol>
<p>由定时任务 3 完成,当节点不可达时,认为该节点下线</p>
<ol start="2">
<li>客观下线</li>
</ol>
<p>当 Sentinel 主观下线节点是主节点时,该节点通过 <code>sentinel is-master-down-by-addr</code> 向其他节点询问对该主节点的判断,当主观下线超过 <code>&lt;quorum&gt;</code> 时,作出客观下线</p>
<ol start="3">
<li>领导者选举</li>
</ol>
<ul>
<li>主观下线后,该节点通过 <code>sentinel is-master-down-by-addr</code> 命令,要求将自己设置为领导者.</li>
<li>收到该命令的 Sentinel 节点,如果没有同意过其他 Sentinel 节点的命令,则同意,否则拒绝</li>
<li>当 Sentinel 节点的票数大于等于 <code>max(quorum, num(sentinels)/2 + 1)</code> 它将成为领导者</li>
</ul>
<ol start="4">
<li>故障转移</li>
</ol>
<p>领导者选举选出的节点负责故障转移</p>
<ul>
<li>在从节点中选出一个节点执行 <code>slaveof no one</code> 让其成为新主节点</li>
<li>向剩余节点发送命令,让他们成为新主节点的从节点</li>
<li>将原来主节点更新为从节点,并保持关注,恢复后进程复制</li>
</ul>
<blockquote>
<p>设置 slave 节点资源池,实时掌握从节点状态,可保证从节点高可用</p>
</blockquote>
<h2 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h2><p>Redis 集群采用虚拟槽分区的,所有的键根据哈希函数映射到 0-16383 槽内.</p>
<p>缺点:</p>
<ul>
<li>批量操作受限制</li>
<li>复制结构只支持一层</li>
</ul>
<h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><ol>
<li>准备节点</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster-enabled yes <span class="comment"># 开启集群模式</span></span><br><span class="line">cluster-config-file <span class="string">""</span> <span class="comment"># 指定集群配置文件</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>节点握手,<code>cluster meet &lt;redisIP&gt; &lt;redisPort&gt;</code></li>
<li>分配槽,配置主从.<code>cluster addlots &lt;lot&gt;</code>, <code>cluster replicate &lt;redisRunId&gt;</code></li>
</ol>
<h3 id="集群节点通信"><a href="#集群节点通信" class="headerlink" title="集群节点通信"></a>集群节点通信</h3><p>Gossip,流言协议</p>
<p>ping,pong,meet,fail</p>
<h2 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h2><h3 id="缓存和数据库数据一致性问题"><a href="#缓存和数据库数据一致性问题" class="headerlink" title="缓存和数据库数据一致性问题"></a>缓存和数据库数据一致性问题</h3><p>分布式环境下非常容易出现缓存和数据库间数据一致性问题,如果项目对缓存的要求是强一致性的,那么就不要使用缓存.我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率,而无法保证两者间的强一致性.合适的策略包括合适的缓存更新策略,更新数据库后及时更新缓存,缓存失败时增加重试等机制.</p>
<h3 id="Redis-缓存雪崩及其解决"><a href="#Redis-缓存雪崩及其解决" class="headerlink" title="Redis 缓存雪崩及其解决"></a>Redis 缓存雪崩及其解决</h3><p>缓存中大量 key 在同一时间失效,导致大量的请求全部落在了数据库上,数据库必然扛不住,真实情况可能DBA 都没反应过来直接挂了.此时,如果重启数据库,但立马又被新流量给打死了,导致后端数据库无法启动的情况.依赖该库所有接口几乎都会报错,如果没做熔断等策略基本上就是服务完全不可用.</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<ul>
<li>设置 key 随机失效时间</li>
<li>将热点数据均匀分布在不同的 Redis 库中也能避免全部失效.或设置热点数据永不过期,有更新操作则更新缓存</li>
</ul>
<h3 id="缓存穿透和击穿"><a href="#缓存穿透和击穿" class="headerlink" title="缓存穿透和击穿"></a>缓存穿透和击穿</h3><p>通常出于容错的考虑,如果从存储层查不到数据则不写入缓存层.缓存穿透是指用户不断对缓存和数据库中都没有的数据发起请求,将导致不存在的数据每次请求都要到存储层去查询,失去了缓存保护后端存储的意义.这样不断攻击导致数据库压力很大,严重的话会击垮数据库</p>
<blockquote>
<p>解决: 在接口层增加校验,比如用户鉴权,参数做校验,对不合法的请求直接返回,而不查询缓存与数据库.</p>
</blockquote>
<p>缓存击穿不同的是缓存击穿是指一个 Key 非常热点,在不停地扛着大量的请求,大并发集中对这一个点进行访问.当这个 Key 在失效的瞬间,持续的大并发直接落到了数据库上,就在这个 Key 的点上击穿了缓存</p>
<blockquote>
<p>解决: 设置热点数据永不过期</p>
</blockquote>
<h2 id="Redis-安全策略"><a href="#Redis-安全策略" class="headerlink" title="Redis 安全策略"></a>Redis 安全策略</h2><ul>
<li>简单的密码验证,通过 <code>requirepass</code> 配置</li>
<li>对危险命令重命名,通过 <code>rename-command</code> 设置,危险命令包括<ul>
<li><code>keys</code>: 如果键值较多,存在阻塞 Redis 的可能性</li>
<li><code>flushall</code>/<code>flushdb</code>: 数据全部被清除</li>
<li><code>save</code>: 如果键值较多,存在阻塞 Redis 的可能性</li>
<li><code>debug</code>: 例如 debug reload 会重启 Redis</li>
<li><code>config</code>: config 包含 redis 配置相关命令,应该交给管理员使用</li>
<li><code>shutdown</code>: 停止 Redis</li>
</ul>
</li>
<li>bind: 选择指定网卡做绑定,而不要绑定 0.0.0.0</li>
<li>修改默认端口</li>
<li>尽量不要使用 root 用户运行</li>
<li>定期备份数据</li>
</ul>
<h2 id="Redis-分布式锁的注意事项"><a href="#Redis-分布式锁的注意事项" class="headerlink" title="Redis 分布式锁的注意事项"></a>Redis 分布式锁的注意事项</h2><ul>
<li>避免死锁</li>
</ul>
<p>一个客户端获取锁成功,但是在释放锁之前崩溃了.可通过设置锁的超时时间</p>
<ul>
<li>自动续约</li>
</ul>
<p>在方法未结束之前,锁已经失效.可以通过启动一个监控线程,监控线程的运行状态,如果锁快要过期,则自动续约</p>
<ul>
<li>避免其它客户端解锁</li>
</ul>
<p>一个客户端获取锁成功,但另一个客户端尝试解锁.可以通过在加锁时设置随机变量,解锁时对该随机变量进行校验实现解决</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>运维面试题之 TCP/IP</title>
    <url>/2020/06/04/interview-questions-tcp-ip/</url>
    <content><![CDATA[<h2 id="OSI-七层模型-TCP-IP-四层模型"><a href="#OSI-七层模型-TCP-IP-四层模型" class="headerlink" title="OSI 七层模型,TCP/IP 四层模型"></a>OSI 七层模型,TCP/IP 四层模型</h2><p>OSI从上到下依次是 应用层 -&gt; 表示层 -&gt; 会话层 -&gt; 传输层 -&gt; 网络层 -&gt; 数据链路层 -&gt; 物理层</p>
<p>TCP/IP 从上到下依次是 应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 链路层</p>
<h2 id="TCP-与-UDP-有什么区别"><a href="#TCP-与-UDP-有什么区别" class="headerlink" title="TCP 与 UDP 有什么区别"></a>TCP 与 UDP 有什么区别</h2><ul>
<li>TCP 是面向连接的,通信之前需要进行三次握手,建立连接,通信结束后需要四次挥手,断开连接; UDP是无连接的,即发送数据之前不需要建立连接</li>
<li>TCP 提供可靠的服务,以收到确认,超时重传,重新排序等机制提供数据可靠性; UDP 不保证数据的可靠性</li>
<li>TCP 面向字节流,实际上是 TCP 把数据看成一连串无结构的字节流,一个数据包可以拆分成若干组进行发送; UDP 是面向报文的,一个报文只能一次发完</li>
<li>每一条 TCP 连接只能是点到点的; UDP 支持一对一,一对多,多对一和多对多的交互通信</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道; UDP 则是不可靠信道</li>
<li>TCP 相对于 UDP 来说要求系统资源较多</li>
</ul>
<h2 id="TCP-IP-首部"><a href="#TCP-IP-首部" class="headerlink" title="TCP/IP 首部"></a>TCP/IP 首部</h2><p><img src="/images/IP-header.png" alt="IP 首部"></p>
<p><img src="/images/TCP-header.png" alt="TCP 首部"></p>
<ul>
<li>16 位源端口号,16位目的端口号: 用于寻找发送端和接收端的应用进程,加上IP首部的源端 IP 及目的 IP,唯一确认一个 TCP 连接</li>
<li>32 位序号: 标识发送的数据字节流,标识在这个报文段中的第一个数据字节,2^32 - 1 后重新从 0 开始.包含该主机选择的连接的ISN(Initial Sequence Number),要发送的第一个数据字节序号为 ISN + 1.</li>
<li>32 位确认序号: ACK为 1 时有效,确认号应该是上次成功收到的数据字节序号 + 1.</li>
<li>4 位首部长度: 首部中 32bit 的数目,一般为 5,也就是 20 字节</li>
<li>URG: 紧急指针</li>
<li>ACK: 确认序号有效</li>
<li>PSH: 接收方应尽快将此报文段交给应用层</li>
<li>RST: 重建连接</li>
<li>SYN: 同步序号,用来发起一个新连接</li>
<li>FIN: 发端完成发送任务</li>
<li>16 位窗口大小: TCP流量控制,字节数，起始于确认序列号指明的值,接收端期望收到的字节,最大为65535.</li>
<li>16 位检验和：包括计算 TCP 首部和数据综合的二进制反码和检验和.用于接收端校验</li>
<li>16 位紧急指针：URG为 1 时有效,是一个正向的偏移量,和序号字段值相加表示最后一个字节的序号</li>
</ul>
<h2 id="TCP-三次握手-四次挥手过程"><a href="#TCP-三次握手-四次挥手过程" class="headerlink" title="TCP 三次握手,四次挥手过程"></a>TCP 三次握手,四次挥手过程</h2><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p><img src="/images/tcp-establish-connection.jpg" alt="TCP 建立连接"></p>
<ol>
<li>客户端发送连接请求报文(<code>SYN=1,seq=x</code>)到服务器,并进入 <code>SYN_SEND</code> 状态,等待服务端确认</li>
<li>服务端收到后,回传一个确认报文(<code>SYN=1,seq=y,ACK=1,ack=x+1</code>)以示传达确认信息,此时服务器进入 <code>SYN_RECV</code> 状态</li>
<li>客户端接收服务端的确认包,向服务器发送确认包(<code>ACK=1,seq=x+1,ack=y+1</code>).随后,客户端与服务端建立连接,进入 <code>ESTABLISHED</code> 状态,完成三次握手</li>
</ol>
<p>握手过程中状态码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SYN &#x3D; 1,ACK &#x3D; 0,seq &#x3D; x;</span><br><span class="line">SYN &#x3D; 1,ACK &#x3D; 1,seq &#x3D; y,ack &#x3D; x+1;</span><br><span class="line">SYN &#x3D; 0,ACK &#x3D; 1,seq &#x3D; x+1,ack&#x3D;y+1</span><br></pre></td></tr></table></figure>

<h4 id="为什么需要三次握手-两次不行吗"><a href="#为什么需要三次握手-两次不行吗" class="headerlink" title="为什么需要三次握手,两次不行吗"></a>为什么需要三次握手,两次不行吗</h4><ul>
<li>主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判,造成服务端资源/时间的浪费.</li>
</ul>
<blockquote>
<p>考虑如下场景: 客户端发送报文没有直接到达,而是在某个网络节点滞留了.一段时间后,连接释放,但此时报文到达服务端.服务端误以为是客户端发来建立请求的报文,而给出响应.但由于现在 客户端并没有发出建立连接的请求,因此不会理睬服务端的确认报文.如果两次握手,此时服务端认为连接已经建立,会等待客户端发送数据,造成服务端资源浪费</p>
</blockquote>
<ul>
<li>确保服务端发送的确认报文客户端可以收到</li>
</ul>
<h4 id="第三次握手中-如果客户端的-ACK-未送达服务器-会怎样"><a href="#第三次握手中-如果客户端的-ACK-未送达服务器-会怎样" class="headerlink" title="第三次握手中,如果客户端的 ACK 未送达服务器,会怎样"></a>第三次握手中,如果客户端的 ACK 未送达服务器,会怎样</h4><ul>
<li>服务端: 重新发送之前的 SYN + ACK.默认重发五次,之后自动关闭连接进入 CLOSED 状态,此时会以 RST 报文应答</li>
<li>客户端: 在接收到服务端超时重发的 SYN + ACK 报文后,重新发送 ACK 报文.</li>
</ul>
<h4 id="如果已经建立了连接-但客户端出现了故障怎么办"><a href="#如果已经建立了连接-但客户端出现了故障怎么办" class="headerlink" title="如果已经建立了连接,但客户端出现了故障怎么办"></a>如果已经建立了连接,但客户端出现了故障怎么办</h4><p>服务器每收到一次客户端的请求后都会重新复位一个计时器,时间通常是设置为 2 小时.若两小时还没有收到客户端的任何数据,服务器就会发送一个探测报文段,以后每隔 75 秒钟发送一次.若一连发送 10 个探测报文仍然没反应,服务器就认为客户端出了故障,接着就关闭连接.</p>
<h4 id="三次握手有什么缺陷"><a href="#三次握手有什么缺陷" class="headerlink" title="三次握手有什么缺陷"></a>三次握手有什么缺陷</h4><p>伪造大量 IP 的向 server 发送 TCP 连接请求报文包,从而将 server 的半连接队列(即 server 收到连接请求 SYN 之后将 client 加入半连接队列中)占满,从而使得 server 拒绝其他正常的连接请求,即拒绝服务攻击.</p>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p><img src="/images/tcp-release-connection.jpg" alt="TCP 断开连接"></p>
<ol>
<li>客户端发送连接释放报文(<code>FIN=1,seq=u</code>),并停止发送数据,客户端进入 <code>FIN_WAIT_1</code> 状态</li>
<li>服务器收到连接释放报文,发出确认报文(<code>ACK=1,seq=v,ack=u+1</code>),服务器进入 <code>CLOSE_WAIT</code> 状态.客户端接收到服务器的确认请求后,客户端进入<code>FIN_WAIT_2</code> 状态,等待服务器发送连接释放报文.此时客户端不再向服务端发送数据,若服务端发送数据,客户端依然接受.</li>
<li>服务端将最后的数据发送完毕后,向客户端发送释放报文(<code>FIN=1,ACK=1,seq=w,ack =u+1</code>),服务端进入 <code>LAST_ACK</code> 状态.</li>
<li>客户端收到服务端连接释放报文后,必须回复确认(<code>ACK=1,seq=u+1,ack=w+1</code>),客户端进入 <code>TIME_WAIT</code> 状态,时长为 2∗MSL(报文最长寿命).</li>
</ol>
<p>挥手过程中状态码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. FIN &#x3D; 1,seq &#x3D; u;</span><br><span class="line">2. ACK &#x3D; 1,seq &#x3D; v,ack &#x3D; u+1;</span><br><span class="line">3. FIN &#x3D; 1,ACK &#x3D; 1,seq &#x3D; w,ack &#x3D;u+1;</span><br><span class="line">4. ACK &#x3D; 1,seq &#x3D; u+1,ack &#x3D; w+1</span><br></pre></td></tr></table></figure>

<h4 id="为什么最后要等待-2-MSL"><a href="#为什么最后要等待-2-MSL" class="headerlink" title="为什么最后要等待 2 * MSL"></a>为什么最后要等待 2 * MSL</h4><ul>
<li>保证客户端发送的最后一个 ACK 报文能够到达服务器,保证可靠的终止 TCP 连接.TCP 内部存在超时重传机制,如果服务端在发出释放报文后,没有收到确认报文,服务端会重新发送一次,客户端就能够在 2 * MSL 内收到重传报文</li>
<li>保证新连接中不会出现旧连接的请求报文.客户端发送完最后一个确认报文后,在这个 2 * MSL 时间中,就可以使本连接持续的时间内所产生的所有报文段都从网络中消失.</li>
</ul>
<h4 id="为什么建立连接是三次握手-而关闭连接却是四次挥手呢"><a href="#为什么建立连接是三次握手-而关闭连接却是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手,而关闭连接却是四次挥手呢"></a>为什么建立连接是三次握手,而关闭连接却是四次挥手呢</h4><ul>
<li>建立连接</li>
</ul>
<p>因为服务端在 LISTEN 状态下,收到建立连接请求的SYN报文后,把ACK和SYN放在一个报文里发送给客户端.</p>
<ul>
<li>关闭连接</li>
</ul>
<p>当收到对方的 FIN 报文时,仅表示对方不再发送数据但还能接收收据,我们也未必把全部数据都发给了对方,所以我们可以立即关闭,也可以发送一些数据给对方后,再发送 FIN 报文给对方表示同意关闭连接.因此关闭连接的 ACK 和 FIN 一般会分开发送.</p>
<h2 id="TCP-以什么方式提供数据可靠性"><a href="#TCP-以什么方式提供数据可靠性" class="headerlink" title="TCP 以什么方式提供数据可靠性"></a>TCP 以什么方式提供数据可靠性</h2><ul>
<li>将数据切分为最合适发送的数据块</li>
<li>计时,收到后确认与超时重传.当 TCP 发出一个段后,它会启动一个定时器,等待目的端确认收到这个报文段.如果不能及时收到一个确认,将重发这个报文</li>
<li>首部与数据校验和确保数据在传输过程中的任何变化</li>
<li>流量控制,防止较快主机致使较慢主机的缓冲区溢出</li>
<li>重新排序机制确保收到的数据以正确的顺序交给其他层</li>
<li>丢弃重复数据</li>
</ul>
<h2 id="TCP-如何实现流量控制-最大化利用带宽"><a href="#TCP-如何实现流量控制-最大化利用带宽" class="headerlink" title="TCP 如何实现流量控制/最大化利用带宽"></a>TCP 如何实现流量控制/最大化利用带宽</h2><p>滑动窗口协议.目的是防止发送方发送速率太快,接收方缓存区不够导致溢出.接收方会维护一个接收窗口 receiver window(窗口大小单位是字节).接收窗口的大小是根据自己的资源情况动态调整的,在返回 ACK 时将接收窗口大小放在 TCP 报文中的窗口大小字段告知发送方.发送窗口的大小不能超过接受窗口的大小.只有当发送方发送并收到确认之后,才能将发送窗口右移.</p>
<h3 id="接收窗口为-0-时会怎样"><a href="#接收窗口为-0-时会怎样" class="headerlink" title="接收窗口为 0 时会怎样"></a>接收窗口为 0 时会怎样</h3><p>如果接收方没有能力接收数据,就会将接收窗口设置为 0.这时发送方必须暂停发送数据,但是会启动一个持续计时器(persistence timer),到期后发送一个大小为 1 字节的探测数据包,以查看接收窗口状态.如果接收方能够接收数据,就会在返回的报文中更新接收窗口大小,恢复数据传送.</p>
<h2 id="TCP-拥塞控制是怎么实现的"><a href="#TCP-拥塞控制是怎么实现的" class="headerlink" title="TCP 拥塞控制是怎么实现的"></a>TCP 拥塞控制是怎么实现的</h2><ul>
<li>TCP 拥塞检测</li>
</ul>
<p>针对丢包情况,TCP 采取的首要机制是重传.当网络处于拥塞崩溃状态时,网络却需要传输更多的数据包,结果只会更糟糕.TCP 中,丢包也被用作判断拥塞是否发生与否的标准.</p>
<ul>
<li>减缓 TCP 发送</li>
</ul>
<p>TCP 在发送端引入了一个窗口控制变量,确保发送窗口大小不超过接收端接收能力和网络传输能力.此变量称为拥塞窗口(congestion window),记作 cwnd.因此发送端实际窗口大小 W 就是接收端通知窗口 awnd 和拥塞窗口 cwnd 的较小者.</p>
<ul>
<li>经典算法</li>
</ul>
<ol>
<li>慢启动: 刚开始发送数据时,先把拥塞窗口设置为一个最大报文段 MSS 的数值,每收到一个新的确认报文之后,就把拥塞窗口加 1 个MSS.这样每经过一个 RTT,拥塞窗口的大小就会加倍.随着数据的传输,拥塞窗口呈指数型增长,在 k 轮数据传输后,W=2^k</li>
<li>拥塞避免: 当拥塞窗口的大小达到慢开始门限(slow start threshold)时,开始执行拥塞避免算法,拥塞窗口大小不再指数增加,而是线性增加,即每经过一个传输轮次只增加1 MSS.</li>
</ol>
<h2 id="DNS-域名解析过程"><a href="#DNS-域名解析过程" class="headerlink" title="DNS 域名解析过程"></a>DNS 域名解析过程</h2><ol>
<li>应用首先检查缓存中有没有这个域名对应的解析过的 IP 地址.如果缓存中有,则返回缓存中的 IP 地址.否则进行下一步</li>
<li>查找本机的 host 文件, Linux 为 <code>/etc/hosts</code>,Windows 为 <code>C:\Windows\System32\drivers\etc\hosts</code>.若查到,则返回.否则进行下一步</li>
<li>发送请求到 DNS 服务器 Linux 为 <code>/etc/resolv.conf</code>.DNS 服务器在收到客户机的请求后,首先检查 DNS 服务器的缓存,若查到请求的地址或名字,即向客户机发出应答信息.否则在数据库中查找,若查到请求的地址或名字,即向客户机发出应答信息</li>
<li>若没有找到,则将请求发给根域 DNS 服务器,并依序从根域查找顶级域,由顶级域查找二级域…直至找到要解析的地址或名字,即向客户机所在网络的 DNS 服务器发出应答信息,DNS 服务器收到应答后现在缓存中存储,然后,将解析结果发给客户机</li>
</ol>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s.io/apimachinery/pkg/util/wait 包使用</title>
    <url>/2023/02/23/k8s-apimachinery-pkg-util-wait-usage/</url>
    <content><![CDATA[<p>阅读 k8s 源码过程发现总会有 <code>wait.Poll(param)</code> 之类的函数调用，因此参考 <a href="https://pkg.go.dev/k8s.io/apimachinery/pkg/util/wait" target="_blank" rel="noopener">pkg.go.dev</a> 与 <a href="https://github.com/kubernetes/apimachinery/blob/master/pkg/util/wait/wait.go" target="_blank" rel="noopener">github.com</a> 对 <code>wait</code> 包中提供的常用函数做了汇总，提升阅读效率。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConditionFunc <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(done <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待 interval 后执行一次 ConditionFunc,之后每隔 interval 时间执行一次 ConditionFunc,直到它返回 true,err</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Poll</span><span class="params">(interval time.Duration, condition ConditionFunc)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 interval 后执行一次 ConditionFunc,之后每隔 interval 时间执行一次 ConditionFunc,直到它返回 true,err或timeout</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollInfinite</span><span class="params">(interval time.Duration, condition ConditionFunc)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 interval 后执行一次 ConditionFunc,之后每隔 interval 时间执行一次 ConditionFunc,直到它返回 true,err 或 stopCh 被关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollUntil</span><span class="params">(interval time.Duration, condition ConditionFunc, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即执行一次 ConditionFunc,之后每隔 interval 时间执行一次 ConditionFunc,直到它返回 true,err或timeout.共执行 timeout/interval 次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollImmediate</span><span class="params">(interval, timeout time.Duration, condition ConditionFunc)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行一次 ConditionFunc,之后每隔 interval 时间执行一次 ConditionFunc,直到它返回 true或err</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollImmediateInfinite</span><span class="params">(interval time.Duration, condition ConditionFunc)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行一次 ConditionFunc,之后每隔 interval 时间执行一次 ConditionFunc,直到它返回 true,err或 stopCh 被关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollImmediateUntil</span><span class="params">(interval time.Duration, condition ConditionFunc, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环执行 f,直到 stopCh 通道关闭.可以传入 `NeverStop` 参数</span></span><br><span class="line"><span class="comment">// 如果 jitterFactor &gt; 0,则等待周期会在 (period, period+jitterFactor*period) 内抖动.否则,</span></span><br><span class="line"><span class="comment">// 如果 sliding 为 true,则函数执行完成后才计算开始等待周期;否则,等待周期将包含函数的执行时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JitterUntil</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">period</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">jitterFactor</span> <span class="title">float64</span>, <span class="title">sliding</span> <span class="title">bool</span>, <span class="title">stopCh</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直到 stopCh 关闭,每隔 period 周期运行 f</span></span><br><span class="line"><span class="comment">// 实际是调用了 `JitterUntil(f, period, 0.0, true, stopCh)`.也就是等函数执行完成后再等待 period,运行 f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Until</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">period</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">stopCh</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 实际是调用了 `JitterUntil(f, period, 0.0, false, stopCh)`.也就是每隔 period 就周期执行 f,不考虑 f 的执行时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NonSlidingUntil</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">period</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">stopCh</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>以上函数均支持传入<code>ctx context.Context</code> 参数,形成带上下文的函数.<br>如 <code>func PollImmediateWithContext(ctx context.Context, interval, timeout time.Duration, condition ConditionWithContextFunc) error</code> 等</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pkg.go.dev/k8s.io/apimachinery/pkg/util/wait" target="_blank" rel="noopener">pkg.go.dev</a></li>
<li><a href="https://github.com/kubernetes/apimachinery/blob/master/pkg/util/wait/wait.go" target="_blank" rel="noopener">github.com</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>Kubernetes</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived</title>
    <url>/2020/06/04/keepalived-details/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>keepalived 主要包含如下三个模块:</p>
<ul>
<li>core: keepalived 的核心莫模块,负责主进程的启动和维护,全局配置文件的加载解析等</li>
<li>check: 负责对 real server 的健康检查,包括了各种健康检查方式,以及对应的配置的解析</li>
<li>vrrp: 维护了 VIP 与 real server 的映射关系,根据优先级来选择主备节点.它基于 vrrp(虚拟路由冗余)协议,实现了当主节点挂掉时,使得 VIP 和对应的 MAC 地址漂移到备机上,通知其它主机刷新 arp 列表的功能.</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>keepalived 常用配置文件示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</span><br><span class="line">global_defs &#123;</span><br><span class="line">    # 尽量不使用 root 运行脚本</span><br><span class="line">    enable_script_security</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义定期执行脚本的相关属性</span><br><span class="line">vrrp_script haproxy-check &#123;</span><br><span class="line">    user root</span><br><span class="line">    script &quot;&#x2F;bin&#x2F;bash &#x2F;etc&#x2F;keepalived&#x2F;check_haproxy.sh&quot;</span><br><span class="line">    interval 3</span><br><span class="line">    weight -2</span><br><span class="line">    fall 10</span><br><span class="line">    rise 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义 vrrp_instance 示例</span><br><span class="line">vrrp_instance haproxy-vip &#123;</span><br><span class="line">    # 主机状态 MASTER 或 BACKUP</span><br><span class="line">    state MASTER</span><br><span class="line">    # 定义节点优先级,MASTER 比其他节点多 50</span><br><span class="line">    priority 100</span><br><span class="line">    interface ens33</span><br><span class="line">    # 0-255 的任意数字</span><br><span class="line">    virtual_router_id 1</span><br><span class="line">    # 指定发送 VRRP 通告的间隔,单位是秒</span><br><span class="line">    advert_int 3</span><br><span class="line">    # 使用单播将 vrrp 报文发送到以下地址列表.可以理解为 real server 地址列表</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        192.168.1.3</span><br><span class="line">        192.168.1.4</span><br><span class="line">        192.168.1.5</span><br><span class="line">    &#125;</span><br><span class="line">    # 虚拟 IP 地址</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.100</span><br><span class="line">    &#125;</span><br><span class="line">    # 添加追踪脚本,用于监测 real server 的脚本</span><br><span class="line">    track_script &#123;</span><br><span class="line">        haproxy-check</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下是配置文件中用到的 <code>/etc/keepalived/check_haproxy.sh</code> 脚本文件,用于监测 VIP 的指定端口是否存活</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">VIRTUAL_IP=192.168.1.100</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">errorExit</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"*** $*"</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ip addr | grep -q <span class="variable">$VIRTUAL_IP</span> ; <span class="keyword">then</span></span><br><span class="line">    curl -s --max-time 2 --insecure https://<span class="variable">$&#123;VIRTUAL_IP&#125;</span>:8443/ -o /dev/null || errorExit <span class="string">"Error GET https://<span class="variable">$&#123;VIRTUAL_IP&#125;</span>:8443/"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 01 系统基础</title>
    <url>/2021/03/18/kubernetes-in-action-01-system-basis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Kubernetes 是 Google 开源的一个容器编排引擎,它是 CNCF(Cloud Native Computing Founddation,云原生计算基金会)的第一个开源项目.</p>
<p>Kubernetes 有如下重要特性:</p>
<ul>
<li>自动装箱</li>
</ul>
<p>构建于容器之上,基于资源依赖及其他约束自动完成容器部署且不影响其可用性,并通过调度机制以提升资源利用率.</p>
<ul>
<li>自我修复</li>
</ul>
<p>支持容器故障后自动重启,节点故障后重新调度容器,容器健康检查失败后重新创建等自我修复机制.</p>
<ul>
<li>水平扩展</li>
</ul>
<p>支持通过简单命令或 UI 进行手动水平扩展,目前支持 CPU 资源负载率的自动水平扩展.</p>
<ul>
<li>服务发现和负载均衡</li>
</ul>
<p>Kubernetes 通过 KubeDNS(或 CoreDNS)组件为系统内置了服务发现功能,并为每个 Service 配置 DNS 名称.Service 通过 iptables 或 ipvs 内建了负载均衡机制.</p>
<ul>
<li>自动发布和回滚</li>
</ul>
<p>Kubernetes 支持灰度更新应用程序或其配置信息,并会监控更新过程中程序的健康状态,一旦有故障发生,就会自动执行回滚</p>
<ul>
<li>密钥和配置管理</li>
</ul>
<p>Kubernetes 的 ConfigMap 实现了配置与镜像解耦,使用 Secret 对象保存敏感数据</p>
<ul>
<li>存储编排</li>
</ul>
<p>Kubernetes 支持 Pod 对象按需自动挂载不同类型的存储系统.</p>
<ul>
<li>批量处理执行</li>
</ul>
<p>Kubernetes 支持批处理作业及 CI(持续集成)</p>
<h2 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h2><p>从抽象的视角来讲,Kubernetes 包含如下抽象对象:</p>
<ul>
<li>Pod</li>
</ul>
<p>Pod 是 Kubernetes 的最小调度单元,它可以封装一个或多个容器.同一 Pod 中的容器共享网络名称空间和存储资源,但彼此在 User,PID,mount(根文件系统) 等名称空间上保持隔离.</p>
<ul>
<li>资源标签(Label)</li>
</ul>
<p>标签是将资源进行分类的标识符,其实就是一个键值型数据,用来指定对象辨识的属性</p>
<ul>
<li>标签选择器(Label Selector)</li>
</ul>
<p>它是一种根据 Label 来过滤符合条件的资源对象的机制</p>
<ul>
<li>Pod 控制器(Controller)</li>
</ul>
<p>用户通常借助于 Pod 控制器部署及管理 Pod 对象.包括 <code>ReplicationController,ReplicaSet,Deployment,StatefulSet,Job</code> 等.</p>
<ul>
<li>服务资源(Service)</li>
</ul>
<p>Service 是建立在一组 Pod 对象之上的资源抽象,它通过标签选择器选定一组 Pod 对象,并为这组 Pod 对象定义一个统一的固定访问入口.若 Kubernetes 存在 DNS 附件,它就会在 Service 创建时配置一个 DNS 名称以便客户端进行服务发现.到达 Service 的请求将被负载均衡至其后的各个 Pod 之上,因此 Service 本质上来讲是一个四层代理服务.Service 还可以将集群外部流量引入到集群中来</p>
<ul>
<li>存储卷(Volume)</li>
</ul>
<p>存储卷是独立于容器文件系统之外的存储空间,常用于扩展容器的存储空间并为它提供持久存储能力.</p>
<ul>
<li>名称空间(Namespace)</li>
</ul>
<p>名称空间通常用于实现租户或项目的隔离,从而形成逻辑分组</p>
<ul>
<li>注解(Annotation)</li>
</ul>
<p>注解是另一种附加在对象之上的键值型数据,它拥有更大的容量,但不能用于标识和选择对象,其主要目的是方便工具或用户的阅读及查找等</p>
<ul>
<li>Ingress</li>
</ul>
<p>Service 是一种四层代理服务,而 Ingress 是在应用层实现的 HTTP 负载均衡机制,是一种七层代理服务.它仅仅是一组路由规则的集合.这些规则通过 Ingress Controller 发挥作用</p>
<h2 id="集群组件"><a href="#集群组件" class="headerlink" title="集群组件"></a>集群组件</h2><h3 id="Master-组件"><a href="#Master-组件" class="headerlink" title="Master 组件"></a>Master 组件</h3><ul>
<li>api-server</li>
</ul>
<p>负责输出 RESTful 风格的 API,是发往集群所有 REST 命令的接入点,负责接收,校验,响应所有的 REST 请求.是整个集群的网关</p>
<ul>
<li>集群状态存储</li>
</ul>
<p>Kubernetes 集群的所有状态信息都需要持久存储于存储系统 etcd 中,etcd 是独立的服务组件,并不隶属于 Kubernetes 集群自身.生产环境应该以 etcd 集群的方式确保其服务可用性</p>
<ul>
<li>控制器管理器(controller-manager)</li>
</ul>
<p>集群中大多数功能由几个被称为控制器的进程执行实现的,这几个进程被集成于 kube-controller-manager 守护进程中.</p>
<ul>
<li>调度器(Scheduler)</li>
</ul>
<p>API Server 确认 Pod 对象的创建请求之后,需要由调度器根据集群各节点的可用资源状态及运行容器的资源需求做出调度决策.</p>
<h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h3><ul>
<li>kubelet</li>
</ul>
<p>kubelet 从 API Server 接收关于 Pod 对象的配置信息并确保他们处于目标状态.kubelet 会在 API Server 上注册当前工作节点,定期向 Master 汇报节点资源使用情况,并通过 cAdvisor 监控容器和节点的资源占用情况</p>
<ul>
<li>容器运行时环境(Container Runtime)</li>
</ul>
<p>每个 Node 都需要提供一个容器运行时环境,它负责下载镜像并运行容器.Kubernetes 主要使用的容器运行时环境为 Docker</p>
<ul>
<li>kube-proxy</li>
</ul>
<p>每个工作节点都需要运行一个 kube-proxy 守护进程,它能够按需为 Service 资源对象生成 iptables 或 ipvs 规则</p>
<h3 id="其它核心附件"><a href="#其它核心附件" class="headerlink" title="其它核心附件"></a>其它核心附件</h3><ul>
<li>CNI(Container Network Interface): 用于网路规划及相关策略的分配</li>
<li>KubeDNS: 提供集群内 DNS 服务</li>
<li>Kubernetes Dashboard: 管理集群应用或集群自身的 WebUI</li>
<li>heapster: 容器和节点的性能监控与分析系统,能够收集并解析多种指标.后续使用 Prometheus</li>
<li>Ingress Controller: 提供应用层负载均衡机制.目前项目有 nginx-controller,traefik 等</li>
</ul>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>Kubernetes 要求网络模型符合如下需求:</p>
<ul>
<li>所有 Pod 间均可不经 NAT 机制而直接通信</li>
<li>所有节点均可不经 NAT 机制而直接与所有容器通信</li>
<li>所有 Pod 对象都位于同一平面网络,而且可使用 Pod 自身的地址直接通信</li>
</ul>
<p>Kubernetes 中的网络模型主要存在四种类型的网络:</p>
<ul>
<li>同一 Pod 内的容器间通信: 直接通过本地的回环地址通信</li>
<li>相同节点各 Pod 彼此之间的通信: 通过 Pod 网络(docker0 网络实现)进行通信</li>
<li>不同节点各 Pod 彼此之间的通信: 通过不同节点上的 Pod 网络(docker0 网桥实现)进行通信</li>
<li>Pod 与 Service 间的通信:  通过 keub-porxy 借助 iptables 规则或 ipvs 规则重定向</li>
<li>集群外部流量同 Service 之间的通信: 通过 keub-porxy 借助 iptables 规则或 ipvs 规则重定向</li>
</ul>
<p>Kubernetes 为 Pod 和 Service 资源对象分别使用了各自的专用网络,Pod 网络由 Kubernetes 的网络插件实现,Service 的网络由 Kubernetes 集群指定.</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 02 快速开始</title>
    <url>/2021/03/18/kubernetes-in-action-02-quick-start/</url>
    <content><![CDATA[<h2 id="Kubernetes-的核心对象"><a href="#Kubernetes-的核心对象" class="headerlink" title="Kubernetes 的核心对象"></a>Kubernetes 的核心对象</h2><h3 id="Pod-资源对象"><a href="#Pod-资源对象" class="headerlink" title="Pod 资源对象"></a>Pod 资源对象</h3><p>Pod 资源对象是一种集合了一个到多个应用容器,存储资源,专用 IP 及支撑容器运行的其它选项的逻辑组件,是 Kubernetes 的部署单元及原子运行单元.它通常由共享资源紧密的一个或多个应用容器组成.</p>
<p>Kubernetes 的网络模型要求各 Pod 对象的 IP 地址位于同一网络平面中,各 Pod 之间使用其 IP 地址直接进行通信,无论它们运行于集群内的哪个工作节点上,这些 Pod 对象都像是运行于同一局域网中的多个主机</p>
<p>Pod 对象中的各进程均运行于彼此隔离的容器中,并于各容器间共享两种关键资源: 网络和存储卷</p>
<ul>
<li>网络</li>
</ul>
<p>每个 Pod 对象都会被分配一个集群内专用的 IP 地址,称为 Pod IP.同一 Pod 内部的所有容器共享 Pod 对象的 Network 和 UTS 名称空间,包括主机名,IP 地址和端口等.因此,Pod 内容器间通信可基于本地回环接口进行,Pod 外的其它组件通信则需要使用 Service 资源对象的 ClusterIP 及其相应端口完成</p>
<ul>
<li>存储卷</li>
</ul>
<p>存储卷资源可以共享给 Pod 内部的所有容器使用,从而完成容器间数据的共享.存储卷还可以确保在容器终止后被重启/删除后数据不会丢失,从而保证了声明周期内的 Pod 对象数据的持久化存储.</p>
<p>一个 Pod 对象代表某个应用程序的一个特定实例,如果需要扩展应用程序,则需要为此应用程序同时创建多个 Pod 实例,每个实例均代表应用程序的一个运行的副本.这些副本化的 Pod 对象的创建和管理通常被称为”控制器”.</p>
<p>创建 Pod 时,可以使用 Pod Preset 对象为 Pod 注入特定的信息,如 ConfigMap,Secret,存储卷和环境变量等.</p>
<p>基于期望的目标状态和各节点的资源可用性,Master 会将 Pod 对象调度至某选定的工作节点运行,工作节点从指定的镜像仓库下载镜像,并于本地的容器运行时环境中启动容器.Master 会将整个集群的状态保存于 etcd 中,并通过 API Server 共享给集群中的各组件及客户端.</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Kubernetes 使用控制器实现对 Pod 对象的管理操作,从而实现 Pod 对象的扩缩容,滚动更新和自愈能力等</p>
<p>控制器本身也是一种资源类型,其中与工作负载相关的实现如 <code>ReplicationController,Deployment,StatefulSet,DaemonSet,Jobs</code>等,可以统称它们为 Pod 控制器</p>
<p>Pod 控制器的定义通常由期望的 Pod 副本数量,Pod 模版和标签选择器组成.Pod 控制器会根据标签选择器对 Pod 对象的标签进行匹配检查,所有满足选择条件的 Pod 对象都将受控于当前控制器并计入其副本总数,并确保此数目能够精确反映期望的副本数.</p>
<p>在实际应用场景中,用户需要手动修改 Pod 控制器中期望副本数量以实现应用规模的扩缩容.若集群中部署了 HeapSter 或 Prometheus 一类的资源指标监控附件时,用户可以使用 “HorizontalPodAutoscaler(HPA)” 计算出合适的 Pod 副本数量,并自动修改 Pod 控制器中期望的副本数以实现应用规模的动态伸缩,提高资源利用率</p>
<p>Kubernetes 集群中每个节点通过 cAdvisor 收集容器及节点的 CPU,内存,磁盘等资源的利用率指标数据,HPA 基于这些统计数据监控容器健康状态并做出扩展决策.</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>尽管 Pod 对象拥有 IP 地址,但此地址无法确保在 Pod 对象重启或重建后保持不变.Service 资源用于被访问的 Pod 对象中添加一个有着固定 IP 地址的中间层,客户端地址发起请求后由相关的 Service 资源调度并代理至后端的 Pod 对象</p>
<p>Service 是微服务的一种实现,实际上是通过规则定义出由多个 Pod 对象组合而成的逻辑集合,并附带访问这组 Pod 对象的策略.Service 对象挑选,关联 Pod 对象的方式同 Pod 控制器一样,都需要基于标签选择器进行定义.</p>
<p>Service 主要有三种常用类型:</p>
<ul>
<li>仅用于集群内部通信的 <code>ClusterIP</code></li>
<li>接入集群外部请求的 <code>NodePort</code> 类型,它通过端口映射来实现,工作于每个节点的主机 IP 之上</li>
<li><code>LoadBalancer</code> 类型,将外部请求负载均衡至多个节点的 NodePort 之上.它主要用于云厂商环境中,使用云厂商提供的 LoadBalancer 负载均衡提供服务.</li>
</ul>
<h2 id="部署应用程序的主要过程"><a href="#部署应用程序的主要过程" class="headerlink" title="部署应用程序的主要过程"></a>部署应用程序的主要过程</h2><p>用户只需要向 API Server 请求创建一个 Pod 控制器,由控制器根据镜像等信息向 API Server 请求创建出一定数量的 Pod 对象,并由 Master 之上的调度器指派至选定的工作节点以运行容器化应用.</p>
<p>用户还需要创建一个集体的 Service 对象以便为这些 Pod 对象建立起一个固定的访问入口,从而使客户端能够通过服务名称或 ClusterIP 进行访问</p>
<h2 id="部署-Kubernetes-集群"><a href="#部署-Kubernetes-集群" class="headerlink" title="部署 Kubernetes 集群"></a>部署 Kubernetes 集群</h2><h2 id="kubeadm-部署工具"><a href="#kubeadm-部署工具" class="headerlink" title="kubeadm 部署工具"></a>kubeadm 部署工具</h2><p>kubeadm 仅关心如何初始化并启动集群,余下的其它操作则不在其考虑范围之内.</p>
<p>kubeadm 集成了众多管理 Kubernetes 集群的命令行工具,其中</p>
<ul>
<li><code>kubeadm init</code> 用于集群的快速初始化,其核心功能是部署 Master 节点的各个组件.</li>
<li><code>kubeadm join</code> 用于将节点快速加入到指定集群中</li>
<li><code>kubeadm token</code> 可在集群构建后管理用于加入集群时使用的认证令牌(token)</li>
<li><code>kubeadm reset</code> 删除构建集群过程中生成的文件并重置回初始状态</li>
<li><code>kubeadm config</code> 管理 kubeadm 集群配置,该配置保留在集群的 ConfigMap 中.常用如下<ul>
<li><code>kubeadm config images list/pull</code> 列出/拉取 kubeadm 构建需要的镜像</li>
<li><code>kubeadm config print init-defaults/join-defaults</code> 打印初始化或加入节点的默认配置</li>
<li><code>kubeadm config view</code> 查看当前 kubeadm 集群的配置</li>
</ul>
</li>
<li><code>kubeadm upgrade</code> 用于平滑的升级 K8S 集群</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集群初始化</span></span><br><span class="line">kubeadm init \</span><br><span class="line">  --config=/etc/kubernetes/kubeadm.yml  \ <span class="comment"># 指定初始化集群的相关配置文件</span></span><br><span class="line">  <span class="comment"># api-server 相关</span></span><br><span class="line">  --control-plane-endpoint=<span class="variable">$&#123;vip:port&#125;</span> \ <span class="comment"># 指定用于 api-server 高可用的代理地址,VIP:port</span></span><br><span class="line">  --apiserver-advertise-address=<span class="variable">$&#123;ip&#125;</span> \ <span class="comment"># 指定 api-server 的 IP 地址</span></span><br><span class="line">  --apiserver-bind-port=6443 \ <span class="comment"># 指定 api-server 监听端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 证书相关</span></span><br><span class="line">  --cert-dir=/etc/kubernetes/pki \ <span class="comment"># 指定初始化过程中生成的证书地址</span></span><br><span class="line">  --cri-socket=/var/run/dockershim.sock \ <span class="comment"># 默认为空,docker 默认使用 /var/run/dockershim.sock 作为 cri-socket</span></span><br><span class="line">  --image-repository=<span class="variable">$&#123;image-repo&#125;</span> \ <span class="comment"># 指定拉取镜像的镜像仓库</span></span><br><span class="line">  --kubernetes-version=<span class="variable">$&#123;k8s-version&#125;</span> \ <span class="comment"># 指定 k8s 集群的版本,默认为 kubeadm 版本</span></span><br><span class="line">  --service-cidr=10.96.0.0/16 \ <span class="comment"># 指定 service VIP 地址段</span></span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \ <span class="comment"># 指定 pod 网络地址段</span></span><br><span class="line">  --node-name=<span class="variable">$&#123;HOSTNAME&#125;</span></span><br><span class="line">  --token=abcdef.0123456789abcdef \ <span class="comment"># 指定节点与集群间建立信任的 token</span></span><br><span class="line">  --upload-certs \ <span class="comment"># 将证书信息上传到 k8s 集群 kubeadm-certs Secret 对象</span></span><br><span class="line">  --ignore-preflight-errors=Swap,IsPrivilegedUser,all \ <span class="comment"># 忽略检查过程中产生的报错,而使用警告方式通知</span></span><br></pre></td></tr></table></figure>

<p>集群初始化示例如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=v1.15.0 --service-cidr=10.96.0.0/16 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.2.3 --image-repository=registry.cn-hangzhou.aliyuncs.com/k8sxio</span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加节点</span></span><br><span class="line">kubeadm join 192.168.2.3:6443 --token 1cvajd.j94i1p8vxzc5kim9 \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:27a53f3a71536eb9c78c380f302866ed6801b221fbbcc4ad71d632a19a9cfcda</span><br></pre></td></tr></table></figure>

<p>其中,另外还可以使用配置文件方式初始化 kubernetes 集群,使用 <code>kubeadm config print init-defaults</code> 打印出的默认配置文件如下,可以在此基础上稍作修改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span>  <span class="comment"># 可使用 kubeadm token generate 生成随机 token</span></span><br><span class="line">  <span class="attr">ttl:</span> <span class="string">24h0m0s</span></span><br><span class="line">  <span class="attr">usages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="comment"># 高可用 api-server </span></span><br><span class="line"><span class="comment"># controlPlaneEndpoint: "k8s-lb:16443"</span></span><br><span class="line"><span class="comment"># 单机 api-server </span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>   <span class="comment"># 单机 api-server 地址</span></span><br><span class="line">  <span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line">  <span class="attr">criSocket:</span> <span class="string">/var/run/dockershim.sock</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-m3</span></span><br><span class="line">  <span class="attr">taints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">CoreDNS</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line">  <span class="comment"># 支持使用自建的 etcd</span></span><br><span class="line">  <span class="comment"># external:</span></span><br><span class="line">    <span class="comment"># endpoints:</span></span><br><span class="line">    <span class="comment"># - https://192.168.2.2:2379</span></span><br><span class="line">    <span class="comment"># - https://192.168.2.3:2379</span></span><br><span class="line">    <span class="comment"># - https://192.168.2.4:2379</span></span><br><span class="line">    <span class="comment"># caFile: /etc/kubernetes/pki/etcd/ca.pem  #搭建 etcd 集群时生成的ca证书</span></span><br><span class="line">    <span class="comment"># certFile: /etc/kubernetes/pki/apiserver-etcd-client.pem   # 访问 etcd 的客户端证书</span></span><br><span class="line">    <span class="comment"># keyFile: /etc/kubernetes/pki/apiserver-etcd-client-key.pem  # 访问 etcd 的客户端证书密钥文件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">k8s.gcr.io</span> <span class="comment"># 默认的镜像仓库</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.19.0</span> <span class="comment"># 默认的 k8s 版本</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line"><span class="attr">scheduler:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-集群运行模式"><a href="#2-2-2-集群运行模式" class="headerlink" title="2.2.2 集群运行模式"></a>2.2.2 集群运行模式</h3><ul>
<li>独立组件模式: 系统组件直接以守护进程方式运行于节点之上,各个组件之间相互协作构成集群.期间需要用到的证书及 Token 等认证信息也需要手动生成,过程较为繁琐.</li>
<li>静态 Pod 模式: 除 kubelet 和 Docker 之外的其它组件都是都是以静态 Pod 对象运行于 Master 主机上</li>
</ul>
<h2 id="2-3-kubectl-命令详解"><a href="#2-3-kubectl-命令详解" class="headerlink" title="2.3 kubectl 命令详解"></a>2.3 kubectl 命令详解</h2><p>详见 <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands" target="_blank" rel="noopener">kubectl</a> 命令行官网</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get: 显示一个或多个资源</span><br><span class="line">    pods(pods信息) | cs/componentstatus(运行状态信息) | nodes(节点) | namespace(名称空间) | deployment(资源部署) | svc(pods的service): 相关资源可通过 `kubectl api-resources` 查看</span><br><span class="line"> -o --output wide | json | yaml: 指定输出格式</span><br><span class="line"> -n default | kube-system | kube-public : 指定名称空间</span><br><span class="line"> -l --selector= key [=value] : 指定带有指定标签或标签值的资源</span><br><span class="line"> -L --label-column= k1,k2: 输出各个指定标签的标签值</span><br><span class="line">    --show-labels : 输出 label 信息</span><br><span class="line"></span><br><span class="line">create: 根据命令行临时创建一个资源,可能主要用于测试</span><br><span class="line">    <span class="comment"># 创建用于 imagePullSecret 指定拉取镜像的认证信息</span></span><br><span class="line">    kubectl create secret docker-registry &lt;NAME&gt; \</span><br><span class="line">      --docker-username=user --docker-password=password \</span><br><span class="line">      --docker-email=email --docker-server=https://index.docker.io/v1/</span><br><span class="line"></span><br><span class="line">run: 在集群上运行镜像</span><br><span class="line">    kubectl run &lt;NAME&gt; --image=&lt;IMAGE&gt; : 运行镜像,并指定pod名称&lt;NAME&gt;</span><br><span class="line">    --port=&lt;PORT&gt;: 指定被暴露的端口</span><br><span class="line">    --env=<span class="string">"&lt;KEY&gt;=&lt;VALUE&gt;"</span>: 环境变量,可以指定多次,但每次只能指定一个变量</span><br><span class="line"> -l --labels=<span class="string">"&lt;K1&gt;=&lt;V1,K2=V2&gt;"</span>: 指定标签,可以一次指定多个</span><br><span class="line"> -r --replicas=1: 指定运行的实例个数</span><br><span class="line">    --dry-run= <span class="literal">false</span> | <span class="literal">true</span>: 如果为<span class="literal">true</span>,则打印相应的API对象而不创建</span><br><span class="line">    --restart= Always | OnFailure | Never: pod的重启策略</span><br><span class="line">    -- &lt;COMMAND&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt;: 运行<span class="built_in">command</span>及其参数,而不运行镜像默认程序</span><br><span class="line">    --schedule=<span class="string">"0/5 * * * ?"</span>: 开启周期调度任务</span><br><span class="line">    --expose= <span class="literal">false</span> | <span class="literal">true</span> : 如果为<span class="literal">true</span>,则为运行的容器创建公共外部服务,相当于 `kubectl expose`</span><br><span class="line">    --limits=<span class="string">''</span>: 资源限定,如 cpu=200m,memory=512Mi</span><br><span class="line"> -o --output wide | json | yaml: 指定输出格式</span><br><span class="line"> -it: 交互式启动</span><br><span class="line"> -w: 监控,类似于 watch 命令</span><br><span class="line"></span><br><span class="line">apply: 将指定文件中的配置用于创建资源</span><br><span class="line"> -f --filename: 指定yaml文件创建资源</span><br><span class="line"></span><br><span class="line">config: kubectl的配置相关</span><br><span class="line">    current-context: 打印当前使用的上下文</span><br><span class="line">    <span class="built_in">set</span>-cluster NAME --server=&lt;serverIP:PORT&gt; --certificate-authority=&lt;ca.crt&gt; --embed-certs=<span class="literal">true</span>: 添加集群</span><br><span class="line">    <span class="built_in">set</span>-credentials NAME --client-certificate=&lt;crt_file&gt; --client-key=&lt;key_file&gt; --embed-certs=<span class="literal">true</span>: 添加用户</span><br><span class="line">    <span class="built_in">set</span>-context NAME --cluster=&lt;cluster_name&gt; --user=&lt;user_name&gt;: 添加/设置上下文</span><br><span class="line">    delete-cluster NAME: 删除指定集群</span><br><span class="line">    use-context CONTEXT_NAME: 使用指定上下文</span><br><span class="line">    view: 打印默认的 kubeconfig</span><br><span class="line"></span><br><span class="line">describe: 资源或资源组的详细信</span><br><span class="line">    pod | svc | node | deployment [name]</span><br><span class="line"> -l --selector=<span class="string">''</span>: 通过指定的标签筛选查看,如 key=value  </span><br><span class="line"></span><br><span class="line">edit: 对资源配置进行编辑,默认使用vi编辑器</span><br><span class="line">    RESOURCE NAME: 如 `kubectl edit svc &lt;svc_name&gt;`</span><br><span class="line"></span><br><span class="line">explain: 列出资源支持的字段.可用作构建yaml文件时的参考文档</span><br><span class="line">    kubectl explain RESOURCE: RESOURCE 支持多级嵌套</span><br><span class="line"></span><br><span class="line">expose: 暴露出一个资源作为 kubenetes 公共外部服务,可以理解为 k8s 中的 pods 的 service</span><br><span class="line">    deployment &lt;pod名称&gt;: 创建service服务</span><br><span class="line">    --name=&lt;deployment_name&gt;: 指定公共服务名称</span><br><span class="line">    --port=&lt;PORT&gt;: 指定映射pod中的端口</span><br><span class="line">    --target-port=&lt;PORT&gt;: 指定映射 service 中的端口</span><br><span class="line">    --protocol= TCP | UDP : 指定协议</span><br><span class="line">    --<span class="built_in">type</span>=</span><br><span class="line">        ClusterIP: 只有 k8s 集群才可以访问</span><br><span class="line">        NodePort: 将端口映射到本地 kube-proxy 进程,端口随机.可通过外部服务进行访问</span><br><span class="line"></span><br><span class="line">label: 为已经创建/存在的资源添加标签</span><br><span class="line">    kubectl label TYPE NAME KEY=VALUE</span><br><span class="line">    --overwrite: 是否进行覆盖,如果不指定,且已经有该标签,则报错</span><br><span class="line">    --all: 更新所有名称空间内的资源标签</span><br><span class="line">    <span class="comment"># 为 k8s 集群节点添加/删除 role</span></span><br><span class="line">    <span class="comment"># kubectl label node k8s-m1 node-role.kubernetes.io/master=</span></span><br><span class="line">    <span class="comment"># kubectl label node k8s-m1 node-role.kubernetes.io/master-</span></span><br><span class="line"></span><br><span class="line">patch: 使用指定的 PATCH 合并修补程序, PATCH 格式为 JSON 格式</span><br><span class="line">    kubectl patch TYPE NAME -p PATCH </span><br><span class="line"></span><br><span class="line">rollout: 管理资源的部署</span><br><span class="line">    <span class="built_in">history</span>: 查看 deployment 的更新历史, 如, `kubectl rollout <span class="built_in">history</span> deployment deploy-demo`</span><br><span class="line">    undo: 对之前的设定做回滚,如 `kubectl rollout undo deployment nginx-deploy`</span><br><span class="line">        --to-revision: 指定回滚到哪个版本,默认回滚到上一个版本</span><br><span class="line"></span><br><span class="line">scale: 改变 Deployment,ReplicaSet 等的对象的数量</span><br><span class="line">    --replicas=&lt;num&gt; TYPE NAME</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>: 设定对象的特定功能</span><br><span class="line">    env(环境变量)</span><br><span class="line">    image(镜像):</span><br><span class="line">        TYPE NAME CONTAINER_NAME=CONTAINER_IMAGE: 更换镜像,如 `kubectl <span class="built_in">set</span> image deployment nginx-deploy nginx-deploy=&lt;image_name&gt;` </span><br><span class="line"></span><br><span class="line">taint: 管理污点</span><br><span class="line">    kubectl taint &lt;node&gt; &lt;污点名&gt; key=value</span><br><span class="line">    <span class="comment"># 为 k8s 节点添加/删除 NoSchedule</span></span><br><span class="line">    <span class="comment"># kubectl taint nodes k8s-master node-role.kubernetes.io/master:NoSchedule</span></span><br><span class="line">    <span class="comment"># kubectl taint nodes k8s-master node-role.kubernetes.io/master:NoSchedule-</span></span><br><span class="line"></span><br><span class="line">token: 管理 token</span><br><span class="line">    create: 创建token</span><br><span class="line">      --<span class="built_in">print</span>-join-command: 创建加入节点的token</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 03 资源管理</title>
    <url>/2021/03/18/kubernetes-in-action-03-resource-management/</url>
    <content><![CDATA[<h2 id="资源对象与-API-群组"><a href="#资源对象与-API-群组" class="headerlink" title="资源对象与 API 群组"></a>资源对象与 API 群组</h2><p>Kubernetes 将一切事物都抽象为 API 资源,其遵循 REST 风格组织并管理这些资源及对象,同时支持通过标准的 HTTP 方法对资源进行增删改查等管理操作</p>
<h3 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h3><p>依据资源的主要功能作为分类标准,Kubernetes 的 API 对象大体可分为</p>
<ul>
<li>工作负载(Workload)</li>
<li>发现和负载均衡(Discovery LB)</li>
<li>配置和存储(Config,Storage)</li>
<li>集群(Cluster)</li>
<li>元数据(Metadata)</li>
</ul>
<h4 id="工作负载型资源"><a href="#工作负载型资源" class="headerlink" title="工作负载型资源"></a>工作负载型资源</h4><p>Pod 是工作负载型资源中的基础资源,它负责运行容器,并向容器解决环境性的依赖.但 Pod 可能会因为资源超限或节点故障等原因而终止,这些 Pod 资源需要被重建,而这类工作通常需要 Pod 控制器来完成</p>
<p>下面是各 Pod 控制器的说明</p>
<ul>
<li><code>ReplicationController</code>: 用于确保每个 Pod 副本在任意时刻均能满足目标数量.建议使用 <code>Deployment</code> 代替它</li>
<li><code>ReplicaSet</code>: 新一代的 <code>ReplicationController</code>,<code>ReplicationController</code> 只支持等值选择,<code>ReplicaSet</code> 还支持基于集合的选择器</li>
<li><code>Deployment</code>: 管理无状态的持久化应用,为 Pod 和 <code>ReplicaSet</code> 提供声明式更新,是构建在 <code>ReplicaSet</code> 上更为高级的控制器</li>
<li><code>StatefulSet</code>: 管理有状态的持久化应用,其与 <code>Deployment</code> 的不同之处在于 <code>StatefulSet</code> 会为每个 Pod 创建一个独有的持久性标识符,并会确保各 Pod 间的顺序性</li>
<li><code>DaemonSet</code>: 确保节点都运行了某 Pod 的一个副本,新增的节点一样会被添加此 Pod;节点移除时,Pod 会被回收.常用于运行集群存储守护进程,日志收集进程,监控进程等.</li>
<li><code>Job</code>: 管理运行完成后即可终止的应用.如批处理作业任务.</li>
<li><code>CronJob</code>: 定时作业任务,会创建多个 <code>Job</code> 任务</li>
</ul>
<h4 id="发现和负载均衡"><a href="#发现和负载均衡" class="headerlink" title="发现和负载均衡"></a>发现和负载均衡</h4><p>Kubernetes 使用 <code>Service</code> 资源和 <code>Endpoint</code> 资源为工作负载添加发现机制及负载均衡功能,使用 <code>Ingress</code> 通过七层代理实现请求流量负载均衡.</p>
<h4 id="配置与存储"><a href="#配置与存储" class="headerlink" title="配置与存储"></a>配置与存储</h4><ul>
<li><code>Volume</code>: 通过引入挂载外部存储卷的方式来满足内部存储数据持久化的需要,它支持众多类型的存储设备或存储系统.</li>
<li><code>ConfigMap</code>: 能够以环境变量或存储卷的方式将配置文或配置文件接入到 Pod 资源的容器中,并且可被多个同类的 Pod 共享引用,从而实现”一次修改,多次生效”的功能</li>
<li><code>Secret</code>: 与 <code>ConfigMap</code> 类似,对于敏感类数据</li>
</ul>
<h4 id="集群级资源"><a href="#集群级资源" class="headerlink" title="集群级资源"></a>集群级资源</h4><p>Pod,Deployment,Service,ConfigMap 等资源属于名称空间资源,而 Kubernetes 中还存在一些集群级别的资源,用于定义集群自身配置信息的对象,包含如下资源</p>
<ul>
<li><code>Namespace</code>: 资源对象名称的作用范围.</li>
<li><code>Node</code>: Kubernetes 集群的工作节点,其标识符在当前集群中必须是唯一的</li>
<li><code>Role</code>: 名称空间级别的由规则组成的权限集合</li>
<li><code>ClusterRole</code>: Cluster 级别的由规则组成的权限集合</li>
<li><code>RoleBinding</code>: 将 Role 中的权限绑定在一个或一组用户上,它隶属于且仅能作用于一个名称空间</li>
<li><code>ClusterRoleBinding</code>: 将 ClusterRole 中的权限绑定在一个或一组用户上,它可作用于整个集群</li>
</ul>
<h3 id="资源-API-的组织形式"><a href="#资源-API-的组织形式" class="headerlink" title="资源 API 的组织形式"></a>资源 API 的组织形式</h3><p>Kubernetes 将 API 分割为多个逻辑组合,称为 API 群组.当前系统的 API Server 上的相关信息可通过 <code>kubectl api-versions</code> 命令获取.每个 API 群组表现为一个以 <code>/apis</code> 为根路径的 REST 路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;&lt;namespace&gt;&#x2F;&lt;resource_types&gt;&#x2F;&lt;resource_name&gt;</span><br><span class="line">&#x2F;apis&#x2F;&lt;group&gt;&#x2F;&lt;version&gt;&#x2F;namespaces&#x2F;&lt;namespace&gt;&#x2F;&lt;resource_types&gt;&#x2F;&lt;resource_name&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 04 Pod 管理</title>
    <url>/2021/03/18/kubernetes-in-action-04-manage-pod/</url>
    <content><![CDATA[<h2 id="容器与-Pod-资源对象"><a href="#容器与-Pod-资源对象" class="headerlink" title="容器与 Pod 资源对象"></a>容器与 Pod 资源对象</h2><p>现代的容器技术被设计用来运行单个进程,该进程在容器中 PID 名称空间进程号为1,可直接接受并处理信号.在此进程终止时,容器即终止退出.它将日志信息直接输出至标准输出,支持用户使用命令(<code>kubectl logs</code>)进行获取.这也是 Docker 及 Kubernetes 使用容器的标准方式</p>
<p>Pod 对象是一组容器的集合,这些容器共享 Network,UTS,IPC 名称空间,因此具有相同的域名,主机名和网络接口,并可通过 IPC 直接通信.</p>
<h2 id="管理-Pod-对象的容器"><a href="#管理-Pod-对象的容器" class="headerlink" title="管理 Pod 对象的容器"></a>管理 Pod 对象的容器</h2><p>一个 Pod 对象至少存在一个容器,<code>containers</code> 字段是定义 Pod 时嵌套字段 <code>pod.spec</code> 的必选项,用于为 Pod 指定要创建的容器列表.</p>
<h3 id="镜像及其获取策略"><a href="#镜像及其获取策略" class="headerlink" title="镜像及其获取策略"></a>镜像及其获取策略</h3><p>容器的 <code>pod.spec.containers.imagePullPolicy</code> 字段用于为其指定镜像获取策略,它的可用值包括</p>
<ul>
<li>Always: 镜像标签为 “latest” 或镜像不存在时总是从仓库中获取镜像</li>
<li>IfNotPresent: 仅当本地镜像缺失时才从目标仓库下载镜像</li>
<li>Never: 禁止从仓库下载镜像,仅使用本地镜像</li>
</ul>
<p>需要注意的是,使用私有仓库中的镜像通常需要由 Registry 服务器完成认证后才能进行.认证过程要么在相关节点上交互式执行 <code>docker login</code> 登录,要么就是将认证信息定义为专属的 Secret 资源,并配置 Pod 通过 <code>imagePullSecretes</code> 字段调用此认证信息完成.其中,<code>imagePullSecretes</code> 字段支持配置在 <code>pod.spec.containers</code> 字段中,也可以配置在 <code>serviceaccount.imagePullSecretes</code> 字段中,后者用于通过 sa 认证拉取镜像.</p>
<h3 id="暴露端口"><a href="#暴露端口" class="headerlink" title="暴露端口"></a>暴露端口</h3><p>Kubernetes 系统的网络模型中,各 Pod 的 IP 地址处于同一网络平面,无论是否容器指定了要暴露的端口,都不会影响集群中其它节点之上的 Pod 客户端对其进行访问,任何监听在非 lo 接口上的端口都可以通过 Pod 网络直接被请求.</p>
<p>容器的 <code>pod.spec.containers.ports</code> 字段是一个列表,由一到多个端口对象组成,它的常用嵌套字段包括:</p>
<ul>
<li><code>containerPort &lt;integer&gt;</code>: 必选字段,指定 Pod 对象暴露的端口</li>
<li><code>name &lt;string&gt;</code>: 指定端口名称,且在当前 Pod 中是唯一的,此端口名可被 Service 资源调用</li>
<li><code>protocol</code>: 端口相关协议,其值仅为 TCP 或 UDP,默认为 TCP</li>
</ul>
<p>然而 Pod 对象的 IP 地址仅在当前集群内可达,无法接受来自集群外部客户端的请求流量.解决方案是通过其所在的工作节点的 IP 地址和端口将其暴露到集群外部.需要做如下配置:</p>
<ul>
<li><code>hostPort &lt;integer&gt;</code>: 主机端口,它将接收的请求通过 NAT 机制转发至 <code>containerPort</code> 字段指定的容器端口</li>
<li><code>hostIP &lt;string&gt;</code>: 主机端口绑定的主机 IP,默认为 0.0.0.0</li>
</ul>
<p>需要注意的是,<code>hostPort</code> 与 <code>NodePort</code> 类型的 Service 对象暴露端口的方式不同,<code>NodePort</code> 是通过所有节点暴露容器服务,而 <code>hostPort</code> 则只是 Pod 对象所在节点暴露容器服务.</p>
<h3 id="自定义运行的容器化应用"><a href="#自定义运行的容器化应用" class="headerlink" title="自定义运行的容器化应用"></a>自定义运行的容器化应用</h3><p><code>pod.spec.containers</code> 中的 <code>command</code> 字段能够指定不同于镜像默认运行的应用程序,并可以使用 <code>args</code> 字段进行参数传递,它们将覆盖镜像中的默认定义.</p>
<p>如果仅为容器定义了 <code>command</code> 字段,它将覆盖镜像中定义的程序及参数,并以无参数方式运行应用程序;如果仅为容器定义了 <code>args</code> 字段,它将作为参数传递给镜像中默认指定运行的应用程序.</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>向 Pod 对象中的容器传递环境变量参数的方法有两种:</p>
<ul>
<li><code>env</code>: 该字段嵌套在 <code>spec.contianers</code> 中,它是由容器变量构成的列表.通常由 <code>name</code> 和 <code>value</code> 指定环境变量的名称和值.该字段还可以使用 <code>valueFrom</code> 从 <code>configMap</code>,<code>secret</code>,<code>field</code>,<code>resourceField</code> 中获取变量的值</li>
<li><code>envFrom</code>: 该字段可以从 <code>ConfigMap</code> 和 <code>Secret</code> 资源中获取</li>
</ul>
<h3 id="共享节点的网络名称空间"><a href="#共享节点的网络名称空间" class="headerlink" title="共享节点的网络名称空间"></a>共享节点的网络名称空间</h3><p>多数情况下,同一个 Pod 的各个容器均运行于一个独立的,隔离的名称空间中,容器间彼此共享网络协议栈及相关网络设备.然而,有一些 Pod 对象需要运行于所在节点的名称空间中,执行系统级别的任务.Kubernetes 提供了如下配置来共享节点的名称空间</p>
<ul>
<li><code>pod.spec.hostNetwork</code>: 是否共享主机节点网络名称空间</li>
<li><code>pod.spec.hostIPC</code>: 是否共享主机节点的 IPC 名称空间,可用于进程间通信</li>
<li><code>pod.spec.hostPID</code>: 是否共享主机节点的 PID 名称空间,共享进程 ID</li>
</ul>
<h3 id="设置-Pod-的安全上下文"><a href="#设置-Pod-的安全上下文" class="headerlink" title="设置 Pod 的安全上下文"></a>设置 Pod 的安全上下文</h3><p>Pod 对象的安全上下文用于设定 Pod 或容器的权限和访问控制功能,常用属性包含以下几个方面:</p>
<ul>
<li>基于用户 id 和组 id 的访问控制对象时的权限</li>
<li>以 root 或非 root 方式运行</li>
<li>是否能够 sudo</li>
</ul>
<p>Pod 的安全上下文定义在 <code>pod.spec.securityContext</code> 字段中,容器的安全上下文定义在 <code>pod.spec.containers.securityContext</code> 字段中.下面列出几个常用的字段:</p>
<ul>
<li><code>allowPrivilegeEscalation</code>: 是否允许权限升级,即 sudo.仅支持 containers</li>
<li><code>privileged</code>: 是否支持特权运行容器,等同于 root.仅支持 containers</li>
<li><code>runAsGroup</code>: 以 GID 身份运行程序.两者都支持</li>
<li><code>runAsNonRoot</code>: 容器是否必须以非 root 用户运行.两者都支持</li>
<li><code>runAsUser</code>: 以 UID 身份运行程序.两者都支持</li>
</ul>
<h2 id="标签与标签选择器"><a href="#标签与标签选择器" class="headerlink" title="标签与标签选择器"></a>标签与标签选择器</h2><p>标签是 Kubernetes 极具特色的功能之一,它能够附加于 Kubernetes 任何资源对象之上,而后即可由标签选择器进行匹配度检查从而完成资源挑选.</p>
<h3 id="管理资源标签"><a href="#管理资源标签" class="headerlink" title="管理资源标签"></a>管理资源标签</h3><p>创建资源时,可以在其 <code>pod.metadata.labels</code> 字段定义要附加的标签项.可在 <code>kubectl get pods</code> 命令中使用 <code>--show-labels</code> 选项,以额外显示对象的标签信息.</p>
<p><code>kubectl label</code> 命令可以直接管理活动对象的标签,按需进行添加或修改等操作.</p>
<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>标签选择器用于表达式标签的查询条件或选择标准,Kubernetes API 目前支持两个选择器: 基于等值关系和基于集合关系.基于等值关系的标签选择器可用操作符有<code>&quot;=&quot;,&quot;==&quot;,&quot;!=&quot;</code>;基于集合关系的标签选择器支持 <code>&quot;in&quot;,&quot;notin&quot;,&quot;exists&quot;</code> 三种操作符</p>
<p>使用标签选择器遵循如下逻辑:</p>
<ul>
<li>多个选择器之间的逻辑关系为”与”操作</li>
<li>使用空值的标签选择器意味着每个资源对象都将被选中</li>
<li>空的标签选择器将无法选出任何资源</li>
</ul>
<p>标签选择器一般在 Pod 控制器或 Service 资源对象中使用,它们在 <code>pod.spec.selector</code> 字段,通过 <code>matchLabels</code> 或 <code>matchExpressions</code> 来指定标签选择器.</p>
<h3 id="节点选择器-nodeSelector"><a href="#节点选择器-nodeSelector" class="headerlink" title="节点选择器 nodeSelector"></a>节点选择器 nodeSelector</h3><p>节点选择器是标签及标签选择器的一种应用,它能够让 Pod 对象基于集群中工作节点的标签来挑选倾向运行的目标节点</p>
<p>Pod 对象的 <code>pod.spec.nodeSelector</code> 可用于定义节点标签选择器,用户事先为特定部分的 Node 资源对象设定好标签,而后配置 Pod 对象通过节点标签选择器进行匹配检测,从而完成节点亲和性调度</p>
<h2 id="Pod-的生命周期"><a href="#Pod-的生命周期" class="headerlink" title="Pod 的生命周期"></a>Pod 的生命周期</h2><p>Pod 对象从其创建开始至其终止退出的时间范围称为生命周期.其中包括</p>
<ul>
<li>初始化容器</li>
<li>容器启动后钩子</li>
<li>容器存活性检测,就绪性检测</li>
<li>容器终止前钩子</li>
</ul>
<p><img src="/images/pod-lifecyle.png" alt="Pod 的生命周期"></p>
<h3 id="Pod-的相位"><a href="#Pod-的相位" class="headerlink" title="Pod 的相位"></a>Pod 的相位</h3><p>Pod 对象总是应该处于以下几个状态之一:</p>
<ul>
<li><code>Pending</code>: API Server 创建了 Pod 资源对象并已存入 etcd 中,但尚未被调度完成或仍处于从仓库下载镜像的过程</li>
<li><code>Running</code>: Pod 已经被调度至某节点,所有容器都已经被 kubelet 创建完成</li>
<li><code>Succeeded</code>: Pod 中所有容器都已经调度成功且不会被重启</li>
<li><code>Failed</code>: 所有容器已终止,但至少有一个容器终止失败,容器返回了非 0 值的退出状态或已被系统终止</li>
<li><code>Unknown</code>: API Server 无法正常获取到 Pod 对象的状态信息,通常是其无法与节点的 kubelet 通信所致</li>
</ul>
<h3 id="Pod-生命周期中的重要行为"><a href="#Pod-生命周期中的重要行为" class="headerlink" title="Pod 生命周期中的重要行为"></a>Pod 生命周期中的重要行为</h3><h4 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h4><p>初始化容器即应用程序的主容器启动之前要运行的容器,常用于为主容器执行一些预置操作,有如下典型特性:</p>
<ul>
<li>初始化容器必须运行完成直到结束,若初始化容器失败,Kubernetes 需要重启它直到成功完成</li>
<li>每个初始化容器都必须按定义的顺序串行运行</li>
</ul>
<p>初始化容器的典型应用需求具体如下:</p>
<ul>
<li>运行特定的工具程序</li>
<li>提供主容器中不具备的工具程序或代码</li>
<li>为容器镜像的构建和部署人员提供分离,独立的工作途径</li>
</ul>
<p>Pod 资源的 <code>pod.spec.initContainers</code> 字段以列表形式定义可用的初始化容器</p>
<h4 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h4><p>Kubernetes 为容器提供了两种生命周期钩子函数:</p>
<ul>
<li><code>postStart</code>: 容器创建后立即运行的钩子处理器</li>
<li><code>preStop</code>: 于容器终止操作之前立即运行的钩子处理器.它以同步的方式调用,在其完成之前会阻塞删除容器操作的调用</li>
</ul>
<p>以上两种处理器定义在 <code>pod.spec.containers.lifecycle</code> 字段中</p>
<p>钩子处理器的实现方式有 <code>Exec</code> 和 <code>HTTP</code> 两种,分别用于直接执行命令和向 URL 发起 HTTP 请求.</p>
<h3 id="容器状态探测"><a href="#容器状态探测" class="headerlink" title="容器状态探测"></a>容器状态探测</h3><p>Kubelet 可以执行对容器进行两种类型的检测:</p>
<ul>
<li><code>livenessProbe</code>: 存活性检测.判断容器是否处于运行状态,未通过检测的容器,则将其杀死并根据 <code>pod.spec.restartPolicy</code> 决定是否将其重启</li>
<li><code>redinessProbe</code>: 就绪性检测.判断容器是否准备就绪并可对外提供服务,未通过检测的容器,端点控制器(Service等)会将其 IP 从所有匹配到此 Pod 对象的 Service 对象端点列表中移除.检测通过后,再添加到端点列表中</li>
</ul>
<p>Kubernetes 的容器支持的存活性/就绪性检测探测方法包含如下三种:</p>
<ul>
<li><code>ExecAction</code>: 在容器中执行一个命令,根据返回状态码进行诊断</li>
<li><code>TCPSocketAction</code>: 通过与容器的某个 TCP 端口尝试建立连接进行诊断</li>
<li><code>HTTPGetAction</code>: 向容器 IP 地址指定端口指定路径发送 HTTP Get 请求</li>
</ul>
<blockquote>
<p>设置 exec 探针</p>
</blockquote>
<p>exec 类型的探针通过在目标容器中执行有用户自定义命令判断容器状态.<code>pod.spec.containers.livenessProbe.exec</code> 字段用于此类检测,它只有一个可用属性 <code>command</code>,用于执行要执行的命令</p>
<blockquote>
<p>设置 HTTP 探针</p>
</blockquote>
<p>基于 HTTP 的探测向目标容器发起一个 HTTP 请求,根据其响应码进行结果判定.<code>pod.spec.containers.livenessProbe.httpGet</code> 字段用于定义此类检测.它的可用配置字段包括如下几个:</p>
<ul>
<li><code>host</code>: 请求的主机地址,默认为 Pod IP</li>
<li><code>port</code>: 请求端口,必选字段</li>
<li><code>httpHeaders</code>: 自定义请求报文首部</li>
<li><code>path</code>: 请求的 HTTP 资源路径</li>
<li><code>scheme</code>: 建立连接时使用的协议,仅可为 HTTP 或 HTTPS,默认 HTTP</li>
</ul>
<blockquote>
<p>设置 TCP 探针</p>
</blockquote>
<p>基于 TCP 的存活性探测用于向容器的特定端口发起 TCP 请求并尝试连接并进行结果判定.<code>pod.spec.containers.livenessProbe.tcpSocket</code> 字段用于定义此类检测.包含以下两个属性:</p>
<ul>
<li><code>host</code>: 请求连接的目标 IP 地址,默认为 Pod IP</li>
<li><code>port</code>: 请求连接的目标端口,必须字段</li>
</ul>
<blockquote>
<p>探测行为属性</p>
</blockquote>
<p><code>pod.spec.containers.livenessProbe</code> 字段通过如下字段来配置相关探测属性</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">显示属性</th>
<th align="center">含义</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>initialDelaySeconds</code></td>
<td align="center">delay</td>
<td align="center">容器启动多久后开始第一次探测</td>
<td align="center">0(s)</td>
</tr>
<tr>
<td align="center"><code>timeoutSeconds</code></td>
<td align="center">timeout</td>
<td align="center">探测的超时时长</td>
<td align="center">1(s)</td>
</tr>
<tr>
<td align="center"><code>periodsSeconds</code></td>
<td align="center">period</td>
<td align="center">探测的频度</td>
<td align="center">1(s)</td>
</tr>
<tr>
<td align="center"><code>successThreshold</code></td>
<td align="center">#success</td>
<td align="center">处于失败状态时,至少多少次成功才认为通过检测</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>failureThreshold</code></td>
<td align="center">#failure</td>
<td align="center">处于成功状态时,至少多少次失败才认为通过检测</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h3 id="容器的重启策略"><a href="#容器的重启策略" class="headerlink" title="容器的重启策略"></a>容器的重启策略</h3><p>Pod 对象终止后是否应该被重建取决于重启策略 <code>pod.spec.restartPolicy</code> 属性的定义</p>
<ul>
<li>Always: 但凡 Pod 对象终止就重启,默认配置</li>
<li>OnFailure: 仅在 Pod 对象出现错误时重启</li>
<li>Never: 从不重启</li>
</ul>
<h2 id="资源需求及资源限制"><a href="#资源需求及资源限制" class="headerlink" title="资源需求及资源限制"></a>资源需求及资源限制</h2><p>在 Kubernetes 上,可由容器或 Pod 消耗的计算资源是指 CPU 和内存.CPU 是可压缩型资源,资源额度可按需收缩;内存是不可压缩资源,资源不足可能产生问题</p>
<p>目前来说,资源隔离尚属于容器级别,CPU 和内存资源的配置需要在 Pod 中的容器上进行,可由 <code>pod.spec.containers.resources.requests</code> 确保资源的可用值,<code>pod.spec.containers.resources.limits</code> 限制资源可能的最大值.</p>
<p>根据 Pod 对象的 <code>requests</code> 和 <code>limits</code> 属性,Kubernetes 将 Pod 对象归类到 <code>BestEffort</code>,<code>Burstable</code> 和 <code>Guaranteed</code> 三个服务质量(QoS)类别下:</p>
<ul>
<li><code>Guaranteed</code>: 每个容器都为 CPU 和内存设置了相同值的 requests 和 limits 属性,这类 Pod 具有最高优先级</li>
<li><code>Burstable</code>: 至少设置了 CPU 或内存资源的 requests 属性,但不满足 Guaranteed 条件的 Pod 资源,具有中等优先级</li>
<li><code>BestEffort</code>: 没有为任何一个容器设置 requests 或 limits 属性的 Pod 资源,具有最低优先级.</li>
</ul>
<p>不同 QoS 的 Pod 有以下不同：</p>
<ul>
<li>CPU 调度按照 request 资源划分权重，<code>Guaranteed</code> 类型的 Pod 会绑定 CPU 核心，<code>Burstable</code> 与<code>BestEffort</code> 类型的 Pod 共享该节点上剩余的 CPU 资源核心。</li>
<li>Memory 按照 QoS 划分 OOMScore，<code>Guaranteed</code> 类型的 Pod 为 -998，<code>BestEffort</code> 类型的 Pod 为 1000，<code>Burstable</code> 类型的 Pod 会根据内存申请的大小和节点内存的关系分配 2-999 的 OOMScore。因此在内存资源紧缺时,<code>BestEffort</code> 类别的容器首先被终止，因为系统不为其提供任何资源级别的保证。<code>Guaranteed</code> 类别最后被终止。同时，同等级别的 Pod 资源，与自身的 requests 属性相比，内存使用率越高的对象越先被杀死。</li>
</ul>
<h2 id="Pod-资源定义清单文件"><a href="#Pod-资源定义清单文件" class="headerlink" title="Pod 资源定义清单文件"></a>Pod 资源定义清单文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span> </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="string">&lt;label_key&gt;:</span> <span class="string">&lt;label_value&gt;</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="string">&lt;anno_key&gt;:</span> <span class="string">&lt;anno_value&gt;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span> <span class="comment"># 是否与主机共享使用网络名称空间</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">false</span> <span class="comment"># 是否与主机共享使用 IPC</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">false</span> <span class="comment"># 是否与主机共享使用 PID</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="number">0</span> <span class="comment"># 指定 pod 的优先级.优先级高的优先被调度.Kubernetes 内置了 2 个 `PriorityClass: `system-cluster-critical`(10^9) 和 `system-node-critical`(10^9+1000)</span></span><br><span class="line">  <span class="comment"># K8S 中内置了 system-node-critical 和 system-cluster-critical.可通过创建 priorityClass 自定义优先级</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">"default"</span> <span class="comment"># 指定要使用的 service account 认证,默认为当前名称空间下的 "default" sa 对象</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="comment"># 重启策略,Always,Never,OnFailure,默认 Always</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="string">&lt;label_key&gt;:</span> <span class="string">&lt;label_value&gt;</span> <span class="comment"># 通过标签选择器进行节点筛选</span></span><br><span class="line">  <span class="attr">hostAliases:</span>  <span class="comment"># 为此类 Pod 添加 hosts 配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">"127.0.0.1"</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"foo.local"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">##### 镜像相关 #####</span></span><br><span class="line">  <span class="attr">initContainers:</span> <span class="comment"># 与 containers 支持的字段相同</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">    <span class="attr">image:</span> </span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="comment"># 拉取镜像策略,Always,IfNotPresent,Never</span></span><br><span class="line">    <span class="attr">imagePullSecret:</span> <span class="comment"># 拉取景象的 Secret 对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment"># 暴露端口</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment"># 暴露端口名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="comment"># 容器内暴露端口</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 设置变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment"># 变量名</span></span><br><span class="line">      <span class="attr">value:</span> <span class="comment"># 变量值</span></span><br><span class="line">      <span class="attr">valueFrom:</span> <span class="comment"># 从 configMap,默认传入的 field 字段,resources 设置,secrete 中获取变量值</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">key:</span> </span><br><span class="line">          <span class="attr">name:</span> </span><br><span class="line">          <span class="attr">options:</span> <span class="comment"># 指定 ConfigMap 或指定 key 是否必需存在</span></span><br><span class="line">        <span class="attr">fieldRef:</span> </span><br><span class="line">          <span class="attr">fieldPath:</span> <span class="comment"># 支持 metadata.name, metadata.namespace,metadata.labels[&lt;KEY&gt;], metadata.annotations[&lt;KEY&gt;], spec.nodeName,spec.serviceAccountName, status.hostIP, status.podIP</span></span><br><span class="line">          <span class="attr">apiVerion:</span></span><br><span class="line">        <span class="attr">resourceFieldRef:</span></span><br><span class="line">          <span class="attr">resource:</span> <span class="comment"># 支持 limits.cpu, limits.memory, requests.cpu,requests.memory</span></span><br><span class="line">          <span class="attr">containerName:</span> <span class="comment"># 镜像名称</span></span><br><span class="line">        <span class="attr">secretKeyRef:</span></span><br><span class="line">          <span class="attr">key:</span> </span><br><span class="line">    </span><br><span class="line">    <span class="attr">envFrom:</span>    <span class="comment"># 从 Secret,configMap 中获取变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">        <span class="attr">name:</span>   <span class="comment"># 配置 configMap 的名称</span></span><br><span class="line">      <span class="attr">prefix:</span>  <span class="comment"># 指定前缀,避免多个 ConfigMap 键值产生冲突,引用时需要加上此前缀,可选参数</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">        <span class="attr">name:</span>   <span class="comment"># 配置 Secret 的名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span>  <span class="comment"># 存储卷名称</span></span><br><span class="line">      <span class="attr">mountPath:</span>  <span class="comment"># 挂载容器内路径</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span> <span class="comment"># 是否挂载为只读卷</span></span><br><span class="line">      <span class="attr">subPath:</span>  <span class="comment"># 挂载存储卷时使用的子路径,在 mountPath 指定路径下使用一个子路径作为其挂载点 </span></span><br><span class="line"></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment"># pod资源相关</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">"1"</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"512Mi"</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">"1"</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"512Mi"</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">livenessProbe/ReadinessProbe:</span> <span class="comment"># 存活/就绪状态监测策略</span></span><br><span class="line">      <span class="string">exec</span> <span class="string">|</span> <span class="string">httpGet</span> <span class="string">|</span> <span class="attr">tcpSocket:</span> <span class="comment"># 执行命令 | 发送 http get 请求 | 端口检测</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="string">第一次探测的延时时间</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="string">探测时间间隔</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="string">失败多少次后判断失败</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">lifecycle:</span>  <span class="comment"># 启动后,停止前的钩子策略</span></span><br><span class="line">      <span class="attr">postStart/preStop:</span> <span class="string">启动后,停止前</span></span><br><span class="line">        <span class="string">exec</span> <span class="string">|</span> <span class="string">httpGet</span> <span class="string">|</span> <span class="attr">tcpSocket:</span> <span class="comment"># 执行命令 | 发送 http get 请求 | 端口检测</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">##### 存储卷相关 #####</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 存储卷相关</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span>  <span class="comment"># 要挂载卷的唯一名称</span></span><br><span class="line">    <span class="string">&lt;type&gt;:</span> <span class="comment"># 常用的包括 emptyDir,hostPath,configMap,secret,nfs,rbd,glusterfs,persistentVolumeClaim</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># &lt;type&gt; = emptyDir # 多用于同一 Pod 中容器间共享路径</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment"># &lt;type&gt; = hostPath # 多用于测试</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span>  <span class="comment"># 挂载的本地路径</span></span><br><span class="line">      <span class="attr">type:</span>  <span class="comment"># 本地路径的体现方式,详见 https://kubernetes.io/docs/concepts/storage/volumes#hostpath</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># &lt;type&gt; = configMap # 挂载 configMap 作为存储卷</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span>  <span class="comment"># 指定 configMap 名称</span></span><br><span class="line">      <span class="attr">items:</span> <span class="comment"># 挂载 configMap 对象中部分 items,可选参数</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span>  <span class="comment"># configMap 中的键(文件名)</span></span><br><span class="line">        <span class="attr">path:</span>  <span class="comment"># 挂载后的相对路径</span></span><br><span class="line">        <span class="attr">mode:</span>  <span class="comment"># 挂载的文件访问权限,如 0644</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">0644</span> <span class="comment"># 默认的文件访问权限</span></span><br><span class="line">      <span class="attr">optional:</span> <span class="literal">false</span> <span class="comment"># configMap 对象是否必须被定义</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># &lt;type&gt; = secret # 挂载 secret 作为存储卷,用法基本与 ConfigMap 对象挂载为存储卷相同</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span>  <span class="comment"># 指定 secret 名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># &lt;type&gt; = nfs</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="comment"># 共享的nfs路径</span></span><br><span class="line">      <span class="attr">server:</span>  <span class="comment"># nfs 服务器地址</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># &lt;type&gt; = rbd</span></span><br><span class="line">    <span class="attr">rbd:</span></span><br><span class="line">      <span class="attr">monitors:</span>  <span class="comment"># Ceph 存储监控器列表,逗号分隔字符串,必需字段</span></span><br><span class="line">      <span class="attr">image:</span> <span class="comment"># rados image 名称</span></span><br><span class="line">      <span class="attr">pool:</span> <span class="string">RBD</span> <span class="comment"># rados 存储池名称</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">admin</span> <span class="comment"># rados 用户名</span></span><br><span class="line">      <span class="attr">keyring:</span> <span class="string">"/etc/ceph/keyring"</span> <span class="comment"># RBD 用户认证时使用的 keyring 文件路径</span></span><br><span class="line">      <span class="attr">secretRef:</span>  <span class="comment"># RBD 用户认证时使用的 Secret 对象,会覆盖 keyring 指定信息</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fsType:</span> <span class="string">ext4</span> <span class="comment"># 要挂载的文件系统类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># &lt;type&gt; = glusterfs</span></span><br><span class="line">    <span class="attr">glusterfs:</span></span><br><span class="line">      <span class="attr">endpoints:</span>  <span class="comment"># Endpoints 资源名称,用于提供 Glusterfs 集群部分节点信息作为访问入口,必需字段,可以手动创建</span></span><br><span class="line">      <span class="attr">path:</span>  <span class="comment"># 用到的 GlusterFS 集群的卷路径,必需字段</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># &lt;type&gt; = persistentVolumeClaim</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span>  <span class="comment"># PVC 名称</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">##### Pod/节点亲和相关 #####</span></span><br><span class="line">  <span class="attr">affinity:</span> </span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment"># 节点亲和</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 尽量满足</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchFields:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#123;key:</span> <span class="string">,</span> <span class="attr">operator:</span> <span class="string">,</span> <span class="attr">values:</span> <span class="string">[]&#125;</span></span><br><span class="line">        <span class="attr">weight:</span>  <span class="comment"># 设置权重</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 必须满足</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点选择条件列表</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchFields:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#123;key:</span> <span class="string">,</span> <span class="attr">operator:</span> <span class="string">,</span> <span class="attr">values:</span> <span class="string">[]&#125;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#123;key:</span> <span class="string">,</span> <span class="attr">operator:</span> <span class="string">,</span> <span class="attr">values:</span> <span class="string">[]&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment"># pod 亲和</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchLabels:</span></span><br><span class="line">            <span class="string">&lt;key&gt;:</span> <span class="string">&lt;value&gt;</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="comment"># 指定键的值相同的 Pod 在同一位置</span></span><br><span class="line">      </span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">podAffinityTerm:</span></span><br><span class="line">          <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchLabels:</span></span><br><span class="line">              <span class="string">&lt;key&gt;:</span> <span class="string">&lt;value&gt;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="comment"># 指定键的值相同的 Pod 最好在同一位置</span></span><br><span class="line">        <span class="attr">weight:</span>   <span class="comment"># 设置权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment"># Pod 反亲和,定义方式同 podAffinity</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">##### 污点容忍相关 #####</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="comment"># 能够容忍的污点的key</span></span><br><span class="line">    <span class="attr">value:</span> <span class="comment"># 能够容忍的污点的value</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="comment"># 能够容忍的污点的程度,后面会有介绍.可选值为 NoSchedule,NoExecute 或 PreferNoSchedule</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="comment"># 对能够容忍的污点和 node 节点上的污点做比较.可选值为 Exists 或 Equal,存在或相等</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="comment"># 容忍时间,要求 effect 必须不能设置为 NoExecute</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 05 Pod 控制器</title>
    <url>/2021/03/18/kubernetes-in-action-05-controller-manager/</url>
    <content><![CDATA[<p>Pod 控制器由 master 的 kube-controller-manager 组件提供,常见的控制器有 <code>ReplicationController,ReplicaSet,Deployment,DaemonSet,StatefulSet,Job,CronJob</code> 等.它们分别以不同的方式管理 Pod 对象.</p>
<p>Pod 控制器资源至少应该包含三个基本组成部分:</p>
<ul>
<li>标签选择器: 匹配并关联 Pod 资源对象,并据此完成受其管控的 Pod 资源计数</li>
<li>期望的副本数: 期望在集群中运行着的 Pod 资源的对象数量</li>
<li>Pod 模版: 用于新建 Pod 资源对象的 Pod 模版资源</li>
</ul>
<p>Pod 控制器类资源的 spec 字段通常需要内嵌 <code>replica</code>,<code>selector</code> 和 <code>template</code> 字段,其中 <code>template</code> 为 Pod 模版定义,Pod 模版的定义基本与 Pod 定义相同,包括 metadata 和 spec 及其内嵌的其它各个字段.</p>
<h2 id="ReplicaSet-控制器"><a href="#ReplicaSet-控制器" class="headerlink" title="ReplicaSet 控制器"></a>ReplicaSet 控制器</h2><p>ReplicaSet(rs) 是 Pod 控制器的一种实现,用于确保由其管控的 Pod 对象副本在任意时刻都能满足期望的数量.</p>
<p>ReplicaSet 控制器资源启动后会查找集群中匹配其标签选择器的 Pod 资源对象,当前活动对象的数量与期望的数量不吻合时,多则删除,少则通过 Pod 模版创建以补足</p>
<p>想对于手动创建 Pod 和管理 Pod 资源来说,ReplicaSet 能够实现如下功能:</p>
<ul>
<li>确保 Pod 资源对象的数量精确反映期望值,多退少补</li>
<li>确保 Pod 健康运行,如果节点故障会自动转移</li>
<li>弹性伸缩,根据系统负载动态调整相关 Pod 资源对象的数量</li>
</ul>
<p>ReplicaSet 控制器的定义也由 <code>kind,apiVerion,metadata,spec</code> 字段组成.它的 spec 字段一般嵌套使用如下几个属性字段:</p>
<ul>
<li><code>replicas</code>: 期望的 Pod 对象副本数</li>
<li><code>selector</code>: 当前控制器匹配 Pod 对象副本的标签选择器,支持 <code>matchLabels</code> 和 <code>matchExpressions</code> 两种匹配机制</li>
<li><code>template</code>: Pod 资源模版</li>
</ul>
<p>一般来说定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span> </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="comment"># 副本数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 选择器</span></span><br><span class="line">      <span class="comment"># ... 标签</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> </span><br><span class="line">      <span class="comment"># ... 表达式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">##### pod 模版,内嵌 pod yaml 中 matadata 和 spec #####</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 内嵌 pod yaml中的 metadata和spec</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">name:</span> </span><br><span class="line">      <span class="comment"># namespace:  # 一般与控制器在同一个 namespace 中</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 这里的labels至少要包含所有标签选择器中的标签</span></span><br><span class="line">        <span class="comment"># ... 标签</span></span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">        <span class="attr">image:</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">          <span class="attr">containerPort:</span></span><br></pre></td></tr></table></figure>

<h2 id="Deployment-控制器"><a href="#Deployment-控制器" class="headerlink" title="Deployment 控制器"></a>Deployment 控制器</h2><p>Deployment 是 Kubernetes 控制器的又一种实现,它构建于 ReplicaSet 控制器之上,可以为 Pod 和 ReplicaSet 提供声明式更新.</p>
<p>与 ReplicaSet 类似,Deployment 同样是为了保证 Pod 资源健康运行,同时添加了如下特性:</p>
<ul>
<li>事件和状态查看: 可以查看 Deployment 对象升级的详细进度和状态</li>
<li>回滚: 升级完成后发现问题,使用回滚机制将应用返回到前一个或指定版本上</li>
<li>版本记录: 对 Deployment 对象的每次操作都保存下来,以供后续可能执行的回滚操作使用</li>
<li>暂停和启动: 对于每次升级,随时暂停和启动</li>
<li>多种自动更新方案: 支持重建更新及滚动更新机制</li>
</ul>
<p>一般来说定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span> </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="comment"># 副本数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">##### 升级策略 #####</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span> <span class="comment"># 旧版本记录个数,默认为10</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 更新类型,可选参数为 Recreate 和 RollingUpdate,默认滚动更新</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span> <span class="comment"># 最多允许同时创建几个 Pod</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">0</span> <span class="comment"># 最多允许几个 Pod 同时不可用</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">minReadySeconds:</span> <span class="number">0</span> <span class="comment"># 指定 Pod 正常启动多少秒后才会被认为是就绪状态</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span> <span class="comment"># 指定 Pod 启动过程中超过多少秒会认为是失败状态</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># Pod 的模版,详见 Pod yaml</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="comment"># 这里是 pod 的名称前缀</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="comment"># ... 标签</span></span><br><span class="line">    <span class="attr">spec:</span>   </span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment"># 容器名称</span></span><br><span class="line">        <span class="attr">image:</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment"># 容器暴露出来的端口名称</span></span><br><span class="line">          <span class="attr">containerPort:</span></span><br></pre></td></tr></table></figure>

<h2 id="DaemonSet-控制器"><a href="#DaemonSet-控制器" class="headerlink" title="DaemonSet 控制器"></a>DaemonSet 控制器</h2><p>DaemonSet 是 Pod 控制器的又一种实现,用于集群中的全部节点(包括新加入的节点)同时运行一个指定的 Pod 资源副本,当从集群移除节点时, Pod 对象也将被自动回收.管理员也可以使用节点选择器和节点标签指定仅在部分节点上运行指定 Pod</p>
<p>DaemonSet 有特定的应用场景,通常运行执行系统级操作任务的应用,如:</p>
<ul>
<li>运行集群存储的守护进程,如 glusterfs 或 ceph</li>
<li>运行日志守护进程,如 fluentd 和 logstash</li>
<li>运行监控系统的代理守护进程,如 Prometheus,Ganglia 等</li>
</ul>
<p>一般定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReadSeconds:</span> <span class="number">0</span> <span class="comment"># 创建成功后最小准备时间</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 节点标签选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">##### 升级策略 #####</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span>  <span class="comment"># 旧版本记录个数,默认为10</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 更新类型,可选参数为 Recreate 和 RollingUpdate,默认滚动更新</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span> <span class="comment"># 最多允许多出几个</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">0</span> <span class="comment"># 最多允许少几个</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># Pod 的模版,详见 Pod yaml</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="comment"># 这里是 pod 的名称前缀</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="comment"># ... 标签</span></span><br><span class="line">    <span class="attr">spec:</span>   </span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment"># 容器名称</span></span><br><span class="line">        <span class="attr">image:</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="comment"># 容器暴露出来的端口名称</span></span><br><span class="line">          <span class="attr">containerPort:</span></span><br></pre></td></tr></table></figure>

<h2 id="Job-控制器"><a href="#Job-控制器" class="headerlink" title="Job 控制器"></a>Job 控制器</h2><p>Job 控制器用于调配 Pod 对象的一次性任务,容器中的进程在正常运行结束后不会对其进行重启,而是将 Pod 对象置于 “Cpmpleted” 状态.</p>
<p>Job 控制器常用于管理那些运行一段时间便可完成的任务,如计算或备份</p>
<p>一般来说定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVerion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="comment"># 定义 Job 完成期望的数量</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="comment"># 定义 Job 的并行数量</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="comment"># 定义 Job 的重试次数</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># Pod 模版</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> </span><br><span class="line">        <span class="attr">image:</span></span><br><span class="line">        <span class="attr">command:</span></span><br></pre></td></tr></table></figure>

<h2 id="CronJob-控制器"><a href="#CronJob-控制器" class="headerlink" title="CronJob 控制器"></a>CronJob 控制器</h2><p>Crontab 控制器用于管理 Job 控制器资源的运行时间.CronJob 类似于 Linux 操作系统的周期性任务作业计划(crontab)的方式控制器运行的时间及重复运行的方式.</p>
<p>CronJob 对象支持使用的时间格式类似于 Crontab,”?” 和 “*” 意义相同,表示任何可用有效值.</p>
<p>一般定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span>  <span class="comment"># Cron 格式的作业调度运行时间点,必须字段</span></span><br><span class="line">  <span class="attr">jobTemplate:</span>  <span class="comment"># Job 控制器模版,生成 Job 对象,必须字段</span></span><br><span class="line">    <span class="comment"># ... Job ...</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span>  <span class="string">Allow</span> <span class="comment"># 并发执行策略,可选值有 "Allow","Forbid","Replace",默认为 Allow</span></span><br><span class="line">  <span class="attr">failedJobHistoryLimit:</span> <span class="number">1</span> <span class="comment"># 失败记录保留历史记录数,默认为1</span></span><br><span class="line">  <span class="attr">successfulJobHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 成功记录保留历史记录数,默认为3</span></span><br><span class="line">  <span class="attr">startDeadlineSeconds:</span>  <span class="comment"># 记录启动的超时时长</span></span><br><span class="line">  <span class="attr">suspend:</span> <span class="literal">false</span> <span class="comment"># 是否挂起后续的执行任务,默认为 false</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 06 Service 和 Ingress</title>
    <url>/2021/03/18/kubernetes-in-action-06-service-and-ingress/</url>
    <content><![CDATA[<p>Kubernetes 提供了两种内建的云端负载均衡机制用于发布公共应用,一种是工作于传输层的 Service 资源,另一种是工作与应用层的 Ingress 资源</p>
<h2 id="Service-资源及其实现"><a href="#Service-资源及其实现" class="headerlink" title="Service 资源及其实现"></a>Service 资源及其实现</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Service 是 Kubernetes 的核心资源之一,它是一种抽象: 通过规则定义出由多个 Pod 对象组合而成的逻辑组合以及访问这组 Pod 的策略. Service 关联 Pod 资源的规则要借助于标签选择器来完成,</p>
<p>Service 基于标签选择器,将一组 Pod 定义成一个逻辑组合,并通过自己的 IP 地址和端口调度代理至组内的 Pod 对象之上,它向客户端隐藏了真实的,处理用户请求的 Pod 资源.</p>
<p>Service 对象的 IP 也被称为 Cluster IP,它在 Service 对象创建后即保持不变,并能被同一集群中的资源所访问.Service 端口用于接收客户端请求,并将其转发至其后端 Pod 的相应端口上,这种代理机制被称为端口代理或四层代理,它工作在 TCP/IP 协议栈的传输层.</p>
<p>Service 资源会通过 API Server 持续监控标签选择器匹配到后端 Pod 对象,并跟踪各对象的变动.不过,Service 并不直接链接至 Pod 对象,他们之间还有 Endpoints 资源对象,它是一个由 IP 地址和端口组成的列表,这些 IP 地址和端口来自于 Service 标签选择器匹配到的 Pod 资源,创建 Service 资源对象时,其关联的 Endpoints 对象也会自动创建.</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>简单来讲, Service 对象就是工作节点上一些 iptables 或 ipvs 规则,用于将到达 Service 对象 IP 地址的流量调度转发至相应的 Endpoints 对象指向的 IP 地址和端口之上.工作于每个节点的 kube-proxy 组件通过 API Server 持续监控各个 Service 及其关联的 Pod 对象,并将其变动反映到 iptables 或 ipvs 规则上.</p>
<p>Service IP 是用于生成 iptables 或 ipvs 规则时使用的 IP 地址,是虚拟 IP,kube-proxy 将请求代理至相应端点的方式有3种,<code>userspace(用户空间)</code>,<code>iptables</code> 和 <code>ipvs</code></p>
<ul>
<li>userspace 代理模型</li>
</ul>
<p>kube-proxy 负责跟踪 API Server 上 Service 和 Endpoints 对象的变动,并据此调整 Service 资源的定义.对于每个 Service 对象,它会随机打开一个本地端口,任何到达此代理端口的连接请求都将被代理至 Pod 对象上.默认调度算法是轮询</p>
<p>在这种代理模型中,请求流量到达内核空间后经由套接字送往用户空间的 kube-proxy,而后再送往内核空间,调度至后端 Pod.请求在内核空间和用户空间中来回转发效率不高.</p>
<ul>
<li>iptables 代理模型</li>
</ul>
<p>与 userspace 基本类似,kube-proxy 负责跟踪 API Server 上 Service 和 Endpoints 对象的变动,并据此调整 Service 资源的定义.对于每个 Service 对象,它都会创建 iptables 规则直接捕获到达 Cluster IP 和 Port 的流量,并将其重定向(DNAT,目标地址转换)至当前 Service 的后端.默认算法是随机调度.</p>
<p>相对于用户空间模型,iptables 无需将流量在用户空间和内核空间切换,效率更高;但后端 Pod 无响应时不会自动进行重定向</p>
<ul>
<li>ipvs 代理模型</li>
</ul>
<p>kube-proxy 负责跟踪 API Server 上 Service 和 Endpoints 对象的变动,据此来调用 netlink 接口创建 ipvs 规则,并确保与 API Server 中变动保持同步.其请求流量的调度功能由 ipvs 实现,余下功能仍由 iptables 完成.</p>
<p>类似于 iptables 模型,ipvs 构建于 netfilter 钩子函数上,它使用 hash 表作为底层数据结构并工作于内核空间,流量转发速度快,规则同步性能好的特性</p>
<h3 id="Service-清单文件"><a href="#Service-清单文件" class="headerlink" title="Service 清单文件"></a>Service 清单文件</h3><p>一般定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVerion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span>  <span class="comment"># Service 类型,默认为 ClusterIP.可选值为 ClusterIP,NodePort,LoadBalacer,ExternalName(用于接入集群外部CNAME)</span></span><br><span class="line">  <span class="attr">selector:</span>  <span class="comment"># Service 的标签选择器,用于关联后端 Pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span>  <span class="comment"># Service 的 IP 地址,可选值为 "None","" 或指定 IP 地址."None" 用于构建 Headless Service.</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span>  <span class="comment"># 端口名称</span></span><br><span class="line">    <span class="attr">port:</span>  <span class="comment"># Service 暴露出来的端口,如果为空,默认与 targetPort 一致,</span></span><br><span class="line">    <span class="attr">targetPort:</span>  <span class="comment"># 转发到后端的 Pod 端口</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span>  <span class="comment"># 端口协议,TCP 或 UDP</span></span><br><span class="line">    <span class="attr">nodePort:</span>  <span class="comment"># Service 端口在工作节点进行端口映射暴露出来的端口,默认范围为 30000-32767,仅当 type 为 NodePort 时有效.</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">externalName:</span>  <span class="comment"># 接入集群外部 CNAME,一般为域名,但是不可以指定端口,仅用于 Service 类型为 ExternalName 时</span></span><br><span class="line">  <span class="attr">externalIPs:</span>  <span class="comment"># 接入集群外部服务,外部服务的 IP 列表</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="comment"># 控制流量的路由策略,可选值有 Cluster,Local.Cluster 会将外部流量路由到所有就绪的 endpoints,而 Local 只会路由到当前节点上就绪的 endpoints</span></span><br><span class="line">  <span class="attr">loadBalancerIP:</span>  <span class="comment"># 指定创建负载均衡器使用的 IP 地址,需要云厂商支持</span></span><br><span class="line">  <span class="attr">loadBalancerSourceRanges:</span>  <span class="comment"># 指定负载均衡器允许的客户端来源的地址范围</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span> <span class="comment"># 会话粘滞性,可选值有 ClientIP,None</span></span><br><span class="line">    <span class="comment"># timeoutSeconds: 10800s # 如果 `sessionAffinity` 设置为 ClientIP,该参数设置会话的保持时间.默认为 3h</span></span><br></pre></td></tr></table></figure>

<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>Kubernetes 内部提供了服务发现机制.它通过注入环境变量和域名解析的方式实现服务发现.</p>
<h3 id="服务发现方式-环境变量"><a href="#服务发现方式-环境变量" class="headerlink" title="服务发现方式: 环境变量"></a>服务发现方式: 环境变量</h3><p>创建 Pod 资源时,kubelet会将其所属名称空间内的每个活动的 Service 对象以一系列环境变量的形式注入其中.</p>
<blockquote>
<p>Kubernetes Service 环境变量</p>
</blockquote>
<p>Kubernetes 为每个 Service 资源生成包括以下形式的环境变量在内的一系列环境变量,在同一名称空间中创建的 Pod 对象都会自动拥有这些变量</p>
<ul>
<li><code>{SVCNAME}_SERVICE_HOST</code></li>
<li><code>{SVCNAME}_SERVICE_PORT</code></li>
</ul>
<blockquote>
<p>Docker link 形式的环境变量</p>
</blockquote>
<p>在创建 Pod 对象时,Kubernetes 会将一系列环境变量注入到 Pod 对象中.如下示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># printenv | grep MYAPP</span></span><br><span class="line">MYAPP_SVC_PORT_80_TCP_ADDR=10.107.208.93</span><br><span class="line">MYAPP_SVC_PORT_80_TCP_PORT=80</span><br><span class="line">MYAPP_SVC_PORT_80_TCP_PROTO=TCP</span><br><span class="line">MYAPP_SVC_PORT_80_TCP=tcp://10.107.208.93:80</span><br><span class="line">MYAPP_SVC_SERVICE_HOST=10.107.208.93</span><br><span class="line">MYAPP_SVC_SERVICE_PORT=80</span><br><span class="line">MYAPP_SVC_PORT=tcp://10.107.208.93:80</span><br></pre></td></tr></table></figure>

<h3 id="服务发现方式-DNS"><a href="#服务发现方式-DNS" class="headerlink" title="服务发现方式: DNS"></a>服务发现方式: DNS</h3><p>创建 Service 资源对象时,集群内的 DNS 服务会为它们自动创建资源记录用于名称解析和服务注册.Pod 可以直接使用标准的 DNS 名称来访问这些 Service 资源.每个 Service 对象相关的 DNS 记录包含如下两个.</p>
<ul>
<li>A记录: <code>{SVCNAME}.{NAMESPACE}.svc.{CLUSTER_DOMAIN}</code></li>
<li>SRV 记录: <code>_{PORT_NAME}._{PORT_PROTOCOL}.svc.{SVCNAME}.{NAMESPACE}.{CLUSTER_DOMAIN}</code></li>
</ul>
<p>而 Kubernetes 中 Pod 的 DNS 配置信息会自动注入到它的 <code>/etc/resolv.conf</code> 文件中.其文件内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 10.96.0.10</span><br><span class="line">search &#123;NAMESPACE&#125;.svc.&#123;CLUSTER_DOMAIN&#125; svc.&#123;CLUSTER_DOMAIN&#125; &#123;CLUSTER_DOMAIN&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><p>Service 的 IP 地址仅在集群内可达,但总会有些服务需要暴露到外部网络中接收各类客户端的访问.此时,需要在集群的边缘为其添加一层转发机制,以实现将外部请求流量接入到集群的 Service 资源上.</p>
<h3 id="Service-类型"><a href="#Service-类型" class="headerlink" title="Service 类型"></a>Service 类型</h3><p>Kubernetes 的 Service 有以下 4 种类型,详见<a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" target="_blank" rel="noopener">官方文档</a></p>
<ul>
<li><code>ClusterIP</code>: 通过集群内部 IP 地址暴露服务,此地址仅在集群内部可达,而无法被集群外部客户端访问</li>
<li><code>NodePort</code>: 这种类型建立在 ClusterIP 之上,其在每个节点的 IP 地址的静态端口用于将集群外部的用户请求转发至目标 Service 的 ClusterIP 和 Port.这种类型的 Service 既可以通过 <code>&lt;ClusterIP:ServicePort&gt;</code> 进行访问,又可以通过 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 进行访问</li>
<li><code>LoadBalancer</code>: 这种类型构建在 NodePort 类型之上,其通过云厂商提供的负载均衡器将服务暴露到集群外部.此类型的 Service 会指向关联至 Kubernetes 集群外部的切实存在的某个负载均衡设备,该设备通过工作节点上的 NodePort 向集群内部发送请求流量.此类型优势在于,负载均衡设备能够避免客户端指定节点故障而导致服务不可用</li>
<li><code>ExternalName</code>: 通过 Service 映射至 externalName 字段内容指定的主机名来暴露服务,此主机名需要被 DNS 服务器解析至 CNAME 类型的记录.主要用于将集群外部的服务以 DNS CNAME 的方式映射到集群中,从而让集群内的 Pod 资源能够访问外部 Service 的一种实现方式.</li>
</ul>
<h3 id="HeadLess-类型的-Service-资源"><a href="#HeadLess-类型的-Service-资源" class="headerlink" title="HeadLess 类型的 Service 资源"></a>HeadLess 类型的 Service 资源</h3><p>如果客户端需要直接访问 Service 资源后端的所有 Pod 资源,这时就应该想客户端暴露每个 Pod 资源的 IP 地址,而不再是中间层 Service 对象的 ClusterIP.这类型的 Service 资源便称为 Headless Service.</p>
<p>正常的 Service 需要通过 ipvs 规则转发到实际的 Pod 上.而 Headless Services 不会分配 ClusterIP,而是将 Endpoints 返回,也就将服务端的所有节点地址返回,让客户端自行要通过负载策略完成负载均衡.</p>
<p>其定义方式与 ClusterIP 定义方式基本相同,区别在于 <code>spec.clusterIP</code> 的值为 “None”,如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVerison:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Ingress-资源"><a href="#Ingress-资源" class="headerlink" title="Ingress 资源"></a>Ingress 资源</h2><p>Ingress 是 Kubernetes API 标准类型之一,它是基于 DNS 名称或 URL 路径把请求转发至指定的 Service 资源的规则,用于将集群外部的请求流量转发至集群内部完成服务发布.</p>
<p>Ingress 资源本身并不能进行流量从穿透,它仅仅是一组路由规则的组合,这些规则要想真正发挥作用还需要其它功能的辅助,然后根据这些规则的匹配机制路由请求流量.这种能够为 Ingress 资源监听套接字并转发流量的组件被称为 Ingress 控制器.</p>
<p>Ingress 控制器可以由任何具有反向代理功能的服务程序实现,如 Nginx,<a href="https://traefik.io/" target="_blank" rel="noopener">Traefik</a></p>
<p>使用 Ingress 资源进行流量转发时,Ingress 控制器可基于某 Ingress 资源定义的规则将客户端流量直接转发至与 Service 对应的后端 Pod 资源上,这种转发机制会绕过 Service 资源,从而省去不必要的开销.</p>
<h3 id="创建-Ingress-资源"><a href="#创建-Ingress-资源" class="headerlink" title="创建 Ingress 资源"></a>创建 Ingress 资源</h3><p>Ingress 资源是基于 HTTP 虚拟主机或 URL 的转发规则,它在配置清单的 spec 字段提供了 <code>rules,backend,tls</code> 等字段进行定义.一般如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span> <span class="comment"># 1.19 后变更为 stable API</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span> <span class="comment"># 定义负载均衡的规则</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="comment"># 指定主机名,可选</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="comment"># 指定主机名下的指定指定路径会转发到指定后端,默认为"/"</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="comment"># 指定 path 的匹配方式,可选值为 Prefix(前缀),Exact(精确),ImplementationSpecific(具体实现)</span></span><br><span class="line">        <span class="attr">backend:</span> <span class="comment"># 指定后端相关参数,可选值包括 service(服务),resource(资源,多用于静态资源存储)</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">name:</span> </span><br><span class="line">              <span class="attr">number:</span></span><br><span class="line">          <span class="attr">resource:</span></span><br><span class="line">            <span class="attr">apiGroup:</span> <span class="comment"># 被引用资源的 apiGroup 组</span></span><br><span class="line">            <span class="attr">kind:</span> <span class="comment"># 被引用资源的 Kind 类型</span></span><br><span class="line">            <span class="attr">name:</span> <span class="comment"># 被引用资源的名称</span></span><br><span class="line">            </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="comment"># 支持指定多个主机名,根据不同主机名分发到不同的后端服务</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span></span><br><span class="line">          <span class="attr">servicePort:</span> </span><br><span class="line">  </span><br><span class="line">  <span class="attr">tls:</span> <span class="comment"># TLS 相关配置,目前仅支持默认 443 端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">secretName:</span>  <span class="comment"># 用于 TLS 加密通信的密钥名称</span></span><br><span class="line">    <span class="attr">hosts:</span> <span class="comment"># 用于 TLS 加密通信的主机列表</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">defaultBackend:</span> <span class="comment"># 默认提供后端负载均衡服务的配置</span></span><br><span class="line">    <span class="comment"># ... Backend 相关参数 ...</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="comment"># 1.18 后引入该字段.取代已弃用的 `kubernetes.io/ingress.class` 注解.为了向后兼容,`kubernetes.io/ingress.class` 注解优先级较高</span></span><br></pre></td></tr></table></figure>

<h3 id="Ingress-资源类型"><a href="#Ingress-资源类型" class="headerlink" title="Ingress 资源类型"></a>Ingress 资源类型</h3><p>ingress 根据 rules 规则定义参数/方式的不同,大致分为 3 种类型</p>
<ul>
<li>单 Service 资源型 Ingress: 只指定 <code>spec.rules.backend</code> 字段,将所有请求转发至指定 Service 资源.</li>
<li>基于 URL 路径进行流量分发: 在 <code>spec.rules</code> 字段中指定单个主机名 <code>host</code>,并在该主机名下指定的多个不同的 <code>path</code>,各个 <code>path</code> 的请求都会转发至对应的 Service 资源.</li>
<li>基于主机名的虚拟主机: 在 <code>spec.rules</code> 下指定多个主机名 <code>host</code>,并根据请求中 <code>Host</code> 请求头将请求转发到对应 <code>host</code> 的后端 Service 资源.</li>
</ul>
<h3 id="部署-Ingress-控制器"><a href="#部署-Ingress-控制器" class="headerlink" title="部署 Ingress 控制器"></a>部署 Ingress 控制器</h3><p>Ingress 控制器自身是运行于 Pod 中的容器应用,一般是 Nginx 一类具有代理及负载均衡能力的守护进程.它监视着来自于 API Server 的 Ingress 对象状态,并以其规则生成相应的应用程序专有格式的配置文件并通过重载或重启守护进程而使新配置生效.</p>
<p>同样运行为 Pod 资源的 Ingress 控制器有该如何接入外部请求的流量呢?常用解决方案有如下两种</p>
<ul>
<li>以 Deployment 控制器管理 Ingress 控制器的 Pod 资源,并通过 NodePort 或 LoadBalancer 类型的 Service 对象为其接入集群外部的请求流量.这就意味着,定义一个 Ingress 控制器时,需要在其前端定义一个专用的 Service 资源</li>
<li>借助于 DaemonSet 控制器,将 Ingress 控制器的 Pod 资源各自以单一实例的方式运行于集群的所有部分工作节点之上,并配置这类 Pod 对象以 hostPort 的方式在当前节点接入流量.好像都需要在其前端定义一个专用的 Service 资源</li>
</ul>
<p>常用的 Ingress-controller 资源有:</p>
<ul>
<li>以 Nginx 为例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.44.0/deploy/static/provider/cloud/deploy.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>以 Traefik:v1.7 为例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-rbac.yaml</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-deployment.yaml</span><br><span class="line"><span class="comment"># 或使用 DaemonSet</span></span><br><span class="line"><span class="comment"># kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/traefik-ds.yaml</span></span><br><span class="line"><span class="comment"># 使用 Traefik 内置的 WebUI</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/containous/traefik/v1.7/examples/k8s/ui.yaml</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 07 存储卷及数据持久化</title>
    <url>/2021/03/19/kubernetes-in-action-07-storage-volume-and-data-persistence/</url>
    <content><![CDATA[<p>Kubernetes 提供的存储卷(Volume)属于 Pod 资源级别,共享于 Pod 内所有容器,可用于在容器文件系统之外的存储应用程序的相关数据,甚至还可以独立于 Pod 声明周期之外实现数据持久化.</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Kubernetes-支持的存储卷类型"><a href="#Kubernetes-支持的存储卷类型" class="headerlink" title="Kubernetes 支持的存储卷类型"></a>Kubernetes 支持的存储卷类型</h3><p>Kubernetes 支持非常丰富的存储卷类型,包括本地存储(节点)和网络存储系统中的诸多机制,甚至支持 Secret 和 ConfigMap 这样的存储资源.</p>
<p>目前,Kubernetes 支持的存储卷包含如下类型:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">节点级别: emptyDir,hostPath</span><br><span class="line">网络存储: nfs,Glusterfs,cephfs</span><br><span class="line">特殊存储: ConfigMap,Secret # 用于向 Pod 注入配置或敏感数据</span><br><span class="line">云端存储: awsElaasticBlockStore,gcePersistentDisk</span><br></pre></td></tr></table></figure>

<p>上述类型中,<code>emptyDir,hostPath</code> 两种类型不具有持久性,要想使用持久类型的存储卷,就得使用网络存储系统.然而,网络存储通常不易使用.</p>
<p>Kubernetes 设计了一种集群级别的资源 <code>PersistentVolume(PV)</code> 来用于简易使用网络存储,它由管理员配置存储系统,而后由用户通过 <code>PersistentVolumeClaim(PVC)</code> 存储卷直接申请使用的机制大大简化了终端存储用户的配置过程.</p>
<h3 id="存储卷的使用方式"><a href="#存储卷的使用方式" class="headerlink" title="存储卷的使用方式"></a>存储卷的使用方式</h3><p>在 Pod 中定义使用存储卷的配置由两部分组成:</p>
<ul>
<li>通过 <code>spec.volumes</code> 字段定义在 Pod 之上的存储卷列表</li>
<li>通过 <code>spec.containers.volumeMounts</code> 字段定义在容器上定义的存储卷挂载列表,它只能挂载当前 Pod 资源中定义的具体存储卷</li>
</ul>
<p>定义方式详见 <a href="/2021/03/18/kubernetes-in-action-04-manage-pod/" title="K8S 实战 - 04 Pod 管理">K8S 实战 - 04 Pod 管理</a> 最后.</p>
<h2 id="持久存储卷"><a href="#持久存储卷" class="headerlink" title="持久存储卷"></a>持久存储卷</h2><p>PersistentVolume(PV) 是指由集群管理员配置提供的魔偶存储系统上的一段存储空间,它是对底层共享存储的抽象,将共享存储作为一种可由用户申请使用的资源,实现了存储消费机制.</p>
<p>PV 是集群级别的资源,不属于任何名称空间,用户对 PV 资源的使用是需要通过 PersistentVolumeClaim(PVC) 提出使用申请来完成绑定.PVC 是 PV 资源的消费者,它向 PV 申请特定大小空间及访问模式,从而创建出 PVC 存储卷,由 Pod 资源通过 PersistentVolumeClaim 存储卷关联使用</p>
<p>尽管 PVC 使得用户可以以抽象的方式访问存储资源,但是很多时候还是回涉及 PV 的属性.为此,Kubernetes 引入了 StorageClass 资源对象,将存储资源定义为具有显著特性的类别(Class),而不是具体的PV.用户通过 PVC 直接向意向的类别发出申请,这么做避免事先创建 PV 的过程.</p>
<h3 id="创建-PV"><a href="#创建-PV" class="headerlink" title="创建 PV"></a>创建 PV</h3><p>PersistentVolume 主要支持以下几个通用字段,用于定义 PV 的容量,访问模式和回收策略等</p>
<ul>
<li><code>capacity</code>: 当前 PV 的容量</li>
<li><code>accessModes</code>: 访问模式,可选参数为<ul>
<li><code>ReadWriteOnce</code>: 仅可被单个节点读写挂载,RWO</li>
<li><code>ReadOnlyMany</code>: 可被多个节点只读挂载,ROX</li>
<li><code>ReadWriteMany</code>: 可被多个节点读写挂载,RWX</li>
</ul>
</li>
<li><code>persistentVolumeReclaimPolicy</code>: PV 空间被释放时的处理机制,可选参数如下:<ul>
<li><code>Retain</code>: 保持不动,由管理员手动回收</li>
<li><code>Recycle</code>: 空间回收,删除存储卷目录下所有文件,仅支持 NFS 和 hostPath</li>
<li><code>Delete</code>: 删除存储卷,仅支持云端存储系统</li>
</ul>
</li>
<li><code>StorageClass</code>: 当前 PV 所属的 StorageClass 的名称,默认为空</li>
<li><code>mountOptions</code>: 挂载选项组成的列表</li>
</ul>
<p>一般定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span>  <span class="comment"># 指定 PV 容量,单位为 Mi,Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 设定访问模式列表.可选值为 `ReadWriteOnce`,`ReadOnlyMany`,`ReadWriteMany`</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span>  <span class="comment"># 设定回售策略.可选值为 `Retain`,`Recycle`,`Delete`</span></span><br><span class="line">  <span class="attr">mountOptions:</span> <span class="comment"># 设定挂载选项列表</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">&lt;type&gt;:</span> <span class="comment"># 与 Pod 中定义 Volumes 大致相同,支持 hostPath,nfs,rbd(ceph),glusterfs</span></span><br><span class="line">  <span class="comment"># &lt;type&gt; = hostPath # 多用于测试</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span>  <span class="comment"># 挂载的本地路径</span></span><br><span class="line">    <span class="attr">type:</span>  <span class="comment"># 本地路径的体现方式,详见 https://kubernetes.io/docs/concepts/storage/volumes#hostpath</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># &lt;type&gt; = nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="comment"># 共享的nfs路径</span></span><br><span class="line">    <span class="attr">server:</span>  <span class="comment"># nfs 服务器地址</span></span><br><span class="line">    <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># &lt;type&gt; = rbd</span></span><br><span class="line">  <span class="attr">rbd:</span></span><br><span class="line">    <span class="attr">monitors:</span>  <span class="comment"># Ceph 存储监控器列表,逗号分隔字符串,必需字段</span></span><br><span class="line">    <span class="attr">image:</span> <span class="comment"># rados image 名称</span></span><br><span class="line">    <span class="attr">pool:</span> <span class="string">RBD</span> <span class="comment"># rados 存储池名称</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span> <span class="comment"># rados 用户名</span></span><br><span class="line">    <span class="attr">keyring:</span> <span class="string">"/etc/ceph/keyring"</span> <span class="comment"># RBD 用户认证时使用的 keyring 文件路径</span></span><br><span class="line">    <span class="attr">secretRef:</span>  <span class="comment"># RBD 用户认证时使用的 Secret 对象,会覆盖 keyring 指定信息</span></span><br><span class="line">    <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fsType:</span> <span class="string">ext4</span> <span class="comment"># 要挂载的文件系统类型</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># &lt;type&gt; = glusterfs</span></span><br><span class="line">  <span class="attr">glusterfs:</span></span><br><span class="line">    <span class="attr">endpoints:</span>  <span class="comment"># Endpoints 资源名称,用于提供 Glusterfs 集群部分节点信息作为访问入口,必需字段,可以手动创建</span></span><br><span class="line">    <span class="attr">path:</span>  <span class="comment"># 用到的 GlusterFS 集群的卷路径,必需字段</span></span><br><span class="line">    <span class="attr">readOnly:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>创建完成的 PV 资源可能处于下列四种状态,它们代表着 PV 资源生命周期中的各个阶段:</p>
<ul>
<li><code>Available</code>: 可用状态的自由资源,尚未被 PVC 绑定</li>
<li><code>Bound</code>: 已经绑定至某 PVC</li>
<li><code>Released</code>: 已经绑定的 PVC 已经被删除,但资源尚未被集群回收</li>
<li><code>Failed</code>: 故障状态</li>
</ul>
<h3 id="创建-PVC"><a href="#创建-PVC" class="headerlink" title="创建 PVC"></a>创建 PVC</h3><p>PersistentVolumeClaim 是存储卷类型的资源,它通过申请占用某个 PersistentVolume 而创建,它与 PV 是一对一关系,用户无须关系底层细节.申请时,用户只需要指定目标空间大小,访问模式,PV 标签选择器和 StorageClass 等相关信息即可.PVC 的 spec 可嵌套字段如下:</p>
<ul>
<li><code>accessMode</code>: 当前 PVC 访问模式,可选字段与 PV 相同</li>
<li><code>resources</code>: 当前 PVC 存储卷需要占用的资源量最小值</li>
<li><code>selector</code>: 绑定 PV 应用的标签选择器,用于挑选要绑定的 PV</li>
<li><code>storageClassName</code>: 存储类名称</li>
<li><code>volumeName</code>: 直接指定要绑定的 PV 卷名</li>
</ul>
<p>一般定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessMode:</span> <span class="comment"># 设定访问模式列表.可选值为 `ReadWriteOnce`,`ReadOnlyMany`,`ReadWriteMany`</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span>  <span class="comment"># 指定 PVC 需求容量,单位为 Mi,Gi</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 指定标签选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">storageClassName:</span>  <span class="comment"># 限定从指定 storageClass 中选择 PV</span></span><br></pre></td></tr></table></figure>

<p>使用 PVC 的方式见 <a href="/2021/03/18/kubernetes-in-action-04-manage-pod/" title="K8S 实战 - 04 Pod 管理">K8S 实战 - 04 Pod 管理</a> 最后,只需要指定 <code>spec.volumes.persistentVolumeClaim</code> 下 <code>claimName</code> 和 <code>readOnly</code>(可选) 字段即可</p>
<h3 id="存储类-StorageClass"><a href="#存储类-StorageClass" class="headerlink" title="存储类 StorageClass"></a>存储类 StorageClass</h3><p>存储类(storageClass)是 Kubernetes 资源的一种,它由管理员为管理 PV 方便而按需创建的类别,管理员可以自定义标准进行分类.</p>
<p>存储类的好处之一就是支持 PV 的动态创建,系统按照 PVC 的需求标准动态创建 PV 会为存储类带来极大的灵活性.</p>
<p>StorageClass 中没有 <code>spec</code>字段,但包含如下5个字段:</p>
<ul>
<li><code>provisioner</code>: 供给方,提供了存储资源的存储系统,存储类要依赖 Provisioner 来判定要使用的存储插件以便适配到目标存储系统</li>
<li><code>parameters</code>: 存储类使用参数描述要关联到的存储卷,不同的 provisioner 需要提供的参数各不相同</li>
<li><code>reclaimPolicy</code>: 动态创建 PV 的回收策略,可选值为 Delete(删除,默认) 和 Retain(保留).</li>
<li><code>mountOptions</code>: 挂载选项列表</li>
</ul>
<p>一般定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># glusterfs</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-storageclass</span>     <span class="comment"># 暴露出来的 StorageClass 名称</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="literal">true</span> </span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">fuseim.pri/ifs</span> <span class="comment"># 需要与 nfs-client-provisioner Deployment 中传入 PROVISIONER_NAME 变量值一致</span></span><br><span class="line"><span class="comment"># parameters: # nfs-storageclass 没有参数</span></span><br></pre></td></tr></table></figure>

<h3 id="PV-和-PVC-的生命周期"><a href="#PV-和-PVC-的生命周期" class="headerlink" title="PV 和 PVC 的生命周期"></a>PV 和 PVC 的生命周期</h3><p>PV 是 Kubernetes 集群的存储资源,PVC 则代表着资源需求.创建 PVC 时对 PV 发起的使用申请,即为绑定.PV 和 PVC 是一一对应关系,可用于响应 PVC 申请的 PV 必须能够容纳 PVC 的请求条件.它们遵循如下生命周期</p>
<ul>
<li>存储供给: 静态供给或动态供给</li>
<li>存储绑定: PV 和 PVC 是一一对应关系,如果系统找到符合 PVC 条件的 PV,两者会进行绑定,且绑定后不再与其它 PV 或 PVC 资源进行绑定</li>
<li>存储回收: 完成存储卷的使用目标后,即可删除 PVC 对象以便进行资源回收.可用的资源回收策略有3种: <code>Retained</code>,<code>Recycled</code> 和 <code>Deleted</code></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 08 ConfigMap 和 Secret</title>
    <url>/2021/03/19/kubernetes-in-action-08-configmap-and-secret/</url>
    <content><![CDATA[<p>ConfigMap 和 Secret 是 Kubernetes 系统上两种特殊类型的存储卷,ConfigMap 对象用于为容器中应用提供配置数据,Secret 用于保存敏感的配置信息,如密钥,证书等.它们将相应的配置信息保存至对象中,而后在 Pod 资源上以存储卷的形式将其挂载并获取相关配置.</p>
<h2 id="容器化应用的配置方式"><a href="#容器化应用的配置方式" class="headerlink" title="容器化应用的配置方式"></a>容器化应用的配置方式</h2><p>为容器中应用提供配置信息主要有如下几种方式:</p>
<ul>
<li>通过命令行传递参数</li>
</ul>
<p>在制作 Docker 镜像时,Dockerfile 中的 <code>ENTRYPOINT</code> 和 <code>CMD</code> 指令可用于指定容器启动时要运行的程序及相关参数.</p>
<p>在基于某镜像使用 <code>docker</code> 相关命令创建容器时,可以使用 <code>docker run IMAGE [COMMAND] [ARGS]</code> 在命令行向容器传入自定义参数</p>
<p>在 Kubernetes 系统创建 Pod 资源时,可以使用 <code>spec.containers</code> 下的 <code>command</code> 和 <code>args</code> 向容器传入命令和参数</p>
<ul>
<li>将配置文件嵌入镜像文件</li>
</ul>
<p>在 Dockerfile 中使用 <code>COPY</code> 指令将定义好的配置文件复制到镜像文件系统上的目标位置.但配置文件相关的任何修改都不得不重新构建镜像文件来实现</p>
<ul>
<li>通过环境变量向容器注入配置信息</li>
</ul>
<p>用户在使用 <code>docker run</code> 命令启动容器时,通过 <code>-e</code> 选项可以像容器传递环境变量.一般来说容器的 <code>ENTRYPOINT</code> 脚本会为这些环境变量提供默认值,保证用户在未传入环境变量时能够基于默认值启动容器</p>
<p>Kubernetes 创建 Pod 资源时,可以使用 <code>spec.containers.env</code> 和 <code>spec.containers.envFrom</code> 为容器的环境变量传值.</p>
<ul>
<li>通过存储卷向容器注入配置信息</li>
</ul>
<p>Docker 存储卷能够将宿主机上的任何文件或目录映射到容器文件系统上,在启动容器时进行加载.</p>
<p>Kubernetes 中的 <code>ConfigMap</code> 和 <code>Secret</code> 资源对象,要么被 Pod 资源以存储卷的形式加载,要么由容器通过 <code>envFrom</code> 字段以变量形式加载.</p>
<h3 id="通过命令行参数配置容器应用"><a href="#通过命令行参数配置容器应用" class="headerlink" title="通过命令行参数配置容器应用"></a>通过命令行参数配置容器应用</h3><p>创建 Pod 资源时,可以在容器定义中自定义要运行的命令以及为其传递的选项和参数.在容器的配置上下文中,使用 <code>command</code> 字段指定要运行的程序,<code>args</code> 字段指定传递给程序的选项及参数.这类程序会被直接执行,而不会由 shell 解析器运行,因此不支持命令展开 <code>{}</code>,重定向等操作.</p>
<p>可以简单理解为,Kubernetes 配置清单文件中的 <code>command</code> 对应于 Dockerfile 中 <code>ENTRYPOINT</code>,<code>args</code> 对应于 <code>CMD</code>.</p>
<h3 id="利用环境变量配置容器应用"><a href="#利用环境变量配置容器应用" class="headerlink" title="利用环境变量配置容器应用"></a>利用环境变量配置容器应用</h3><p>在 Kubernetes 中启动创建 Pod 资源时,可以使用 <code>spec.containers.env</code> 参数来定义所使用的环境变量列表.</p>
<p>环境变量通常由 <code>name</code> 和 <code>value(或 valueFrom)</code> 字段构成.定义方式详见 <a href="/2021/03/18/kubernetes-in-action-04-manage-pod/" title="K8S 实战 - 04 Pod 管理">K8S 实战 - 04 Pod 管理</a> 最后.</p>
<h2 id="应用程序配置管理及-ConfigMap-资源"><a href="#应用程序配置管理及-ConfigMap-资源" class="headerlink" title="应用程序配置管理及 ConfigMap 资源"></a>应用程序配置管理及 ConfigMap 资源</h2><p>Kubernetes 基于 ConfigMap 对象实现了将配置文件从容器镜像中解耦,从而增强了容器应用的可移植性.ConfigMap 对象将配置数据以键值对的形式进行存储,用户可以在不同环境中创建名称相同但内容不同的 ConfigMap 对象,从而为不同环境中同一功能的 Pod 资源提供不同的配置信息,实现应用与配置的灵活勾兑.</p>
<h3 id="创建-ConfigMap-对象"><a href="#创建-ConfigMap-对象" class="headerlink" title="创建 ConfigMap 对象"></a>创建 ConfigMap 对象</h3><p>ConfigMap 资源对象可以使用清单创建,也可以通过 <code>kubectl create configmap</code> 命令创建,命令语法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create configmap &lt;map-name&gt; &lt;datasource&gt;</span><br></pre></td></tr></table></figure>

<p>其中数据源可以通过目录,文件或直接值来获取,并转换为 key-value 后创建 ConfigMap 对象</p>
<h4 id="使用键值对直接创建"><a href="#使用键值对直接创建" class="headerlink" title="使用键值对直接创建"></a>使用键值对直接创建</h4><p>为 <code>kubectl create configmap</code> 命令使用 <code>--from-literal</code> 选项可以在命令行直接给出键值对创建 ConfigMap 对象.该选项可以重复使用以传递多个键值对.</p>
<h4 id="基于配置文件创建"><a href="#基于配置文件创建" class="headerlink" title="基于配置文件创建"></a>基于配置文件创建</h4><p>为 <code>kubectl create configmap</code> 命令使用 <code>--from-file</code> 选项可以基于文件内容创建 ConfigMap 对象.该选项可以重复使用以传递多个文件.</p>
<p>这种方式创建的 ConfigMap 对象,其存储的数据键为文件名,值为文件内容</p>
<h4 id="基于目录创建"><a href="#基于目录创建" class="headerlink" title="基于目录创建"></a>基于目录创建</h4><p>与基于文件创建方式一样,<code>--from-file</code> 支持传入路径,这种方式创建的 ConfigMap 对象,会将该路径下所有文件一同创建于同一 ConfigMap 资源中.其存储的数据键为指定目录下文件名,值为对应文件内容</p>
<h4 id="使用清单创建"><a href="#使用清单创建" class="headerlink" title="使用清单创建"></a>使用清单创建</h4><p>一般创建方式如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># 存储键值对数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># immutable: true # 表示不可变更的 ConfigMap 对象.1.19 之后可以使用,1.21 变为 stable.</span></span><br></pre></td></tr></table></figure>

<h3 id="在-Pod-中使用-ConfigMap-资源对象"><a href="#在-Pod-中使用-ConfigMap-资源对象" class="headerlink" title="在 Pod 中使用 ConfigMap 资源对象"></a>在 Pod 中使用 ConfigMap 资源对象</h3><ul>
<li>通过在 Pod 清单文件中使用 <code>spec.containers.env.valueFrom.configMapKeyRef</code> 将 ConfigMap 对象中键值数据传递到 Pod 中作为环境变量,Pod 中环境变量的引用方式为 <code>$(VAR_NAME)</code></li>
<li>通过在 Pod 清单文件中使用 <code>spec.volumes.configMap</code> 将 configMap 作为存储卷挂载到 Pod 中,Pod 中挂载存储卷的字段为 <code>spec.containers.volumeMounts</code></li>
</ul>
<p>清单文件详见 <a href="/2021/03/18/kubernetes-in-action-04-manage-pod/" title="K8S 实战 - 04 Pod 管理">K8S 实战 - 04 Pod 管理</a> 最后.</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>ConfigMap 资源支持容器应用动态更新配置,用户直接更新 ConfigMap 对象,而后由容器应用重载其配置文件即可</p>
<p>在 Pod 资源中调用 ConfigMap 对象时需要注意:</p>
<ul>
<li>以存储卷方式引用的 ConfigMap 对象必须先于 Pod 存在,否则将会导致 Pod 无法正常启动的错误</li>
<li>当以环境变量方式注入 ConfigMap 中键不存在时会被忽略,Pod 会正常启动,但日志会记录 “InvalidVariableNames” 错误引用信息</li>
<li>ConfigMap 是名称空间级别的资源,引用它的 Pod 必须处于同一名称空间中</li>
</ul>
<h2 id="Secret-资源"><a href="#Secret-资源" class="headerlink" title="Secret 资源"></a>Secret 资源</h2><p><code>Secret</code> 资源的功能类似于 <code>ConfigMap</code>,以键值方式存储数据,在 Pod 资源中通过环境变量或存储卷进行数据访问.不同的是,Secret 对象仅会被分发至调用了此对象的 Pod 资源所在的工作节点,且只能由节点将其存储在内存中;Secret 对象的数据存储及打印格式为 Base64 编码的字符串(可通过 <code>base64 --decode</code> 进行解码),因此用户在创建 Secret 数据时也要提供此种编码格式的数据.不过,在容器中以环境变量或存储卷的方式进行访问时,它们会被自动解码为明文格式.</p>
<p>Secret 资源主要分为以下几种:</p>
<table>
<thead>
<tr>
<th align="left">内置类型</th>
<th align="left">用法简介</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>opaque</code></td>
<td align="left">用户定义的任意数据,base64 编码,存储密码、密钥、证书等数据</td>
<td align="left"><code>generic</code></td>
</tr>
<tr>
<td align="left"><code>kubernetes.io/service-account-token</code></td>
<td align="left">Service Accoount 的认证信息,在创建 Service Account 时自动创建</td>
<td align="left"><code>generic</code></td>
</tr>
<tr>
<td align="left"><code>kubernetes.io/dockercfg</code></td>
<td align="left"><code>~/.dockercfg</code> 文件的序列化形式</td>
<td align="left"><code>docker-registry</code></td>
</tr>
<tr>
<td align="left"><code>kubernetes.io/dockerconfigjson</code></td>
<td align="left"><code>~/.docker/config.json</code> 文件的序列化形式</td>
<td align="left"><code>docker-registry</code></td>
</tr>
<tr>
<td align="left"><code>kubernetes.io/basic-auth</code></td>
<td align="left">基本身份认证的凭据</td>
<td align="left"><code>generic</code></td>
</tr>
<tr>
<td align="left"><code>kubernetes.io/ssh-auth</code></td>
<td align="left">SSH 身份认证的凭据</td>
<td align="left"><code>generic</code></td>
</tr>
<tr>
<td align="left"><code>kubernetes.io/tls</code></td>
<td align="left">TLS 客户端或者服务器端的数据</td>
<td align="left"><code>tls</code></td>
</tr>
<tr>
<td align="left"><code>bootstrap.kubernetes.io/token</code></td>
<td align="left">启动引导令牌数据</td>
<td align="left"><code>generic</code></td>
</tr>
</tbody></table>
<p>以上详细示例可参见 <a href="https://kubernetes.io/docs/concepts/configuration/secret/" target="_blank" rel="noopener">Secrets | Kubernetes</a> 官方文档.</p>
<h2 id="创建-Secret-资源"><a href="#创建-Secret-资源" class="headerlink" title="创建 Secret 资源"></a>创建 Secret 资源</h2><h3 id="创建-generic-类型的-Secret-资源"><a href="#创建-generic-类型的-Secret-资源" class="headerlink" title="创建 generic 类型的 Secret 资源"></a>创建 <code>generic</code> 类型的 Secret 资源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic NAME </span><br><span class="line"><span class="comment"># [--from-file=[key=]source] # 基于文件内的键值对创建 secret</span></span><br><span class="line"><span class="comment"># [--from-literal=key1=value1] # 基于 key/value 键值对创建 secret,可以指定多个</span></span><br><span class="line"><span class="comment"># [--from-file=ssh-privatekey=&lt;path_to_id_rsa&gt; --from-file=ssh-publickey=&lt;path_to_id_rsa.pub&gt;] # 创建 ssh 身份认证的凭据</span></span><br></pre></td></tr></table></figure>

<h3 id="创建-tls-类型的-Secret-资源"><a href="#创建-tls-类型的-Secret-资源" class="headerlink" title="创建 tls 类型的 Secret 资源"></a>创建 <code>tls</code> 类型的 Secret 资源</h3><p>使用如下命令可以基于私钥文件和证书文件创建用于 SSL/TLS 通信的 Secret 对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls NAME --cert=&lt;path_to_cert&gt; --key=&lt;path_to_key&gt;</span><br></pre></td></tr></table></figure>

<p>示例如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">umask</span> 077;openssl genrsa -out nginx.key 2048)</span><br><span class="line">openssl req -new -x509 -key nginx.key -out nginx.crt -subj /C=CN/ST=BeiJing/L=BeiJing/O=DevOps/CN=&lt;hostname.com&gt;</span><br><span class="line">kubectl create secret tls &lt;sceret_name&gt; --key=nginx.key --cert=nginx.crt</span><br></pre></td></tr></table></figure>

<h3 id="创建-docker-registry-类型的-Secret-资源"><a href="#创建-docker-registry-类型的-Secret-资源" class="headerlink" title="创建 docker-registry 类型的 Secret 资源"></a>创建 <code>docker-registry</code> 类型的 Secret 资源</h3><p>使用如下命令可以创建 <code>docker-registry</code> 类型的 Secret 对象,该对象可以用作 <code>spec.containers.imagePullSecret</code> 的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry NAME \</span><br><span class="line">  --docker-user=&lt;username&gt; \</span><br><span class="line">  --docker-password=&lt;password&gt; \</span><br><span class="line">  --docker-email=&lt;email&gt; \</span><br><span class="line">  ---docker-server=https://index.docker.io/v1/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 09 StatefulSet 控制器</title>
    <url>/2021/03/19/kubernetes-in-action-09-statefulset/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>StatefulSet 是 Pod 资源控制器的一种实现,用于部署和扩展有状态应用的 Pod 资源,确保他们的运行顺序及每个 Pod 资源的唯一性,StatefulSet 需要为每个 Pod 维持一个唯一且固定的标识符,为其创建专有的存储卷.StatefulSet 主要有如下特性</p>
<ul>
<li>稳定且唯一的网络标识符</li>
<li>稳定且持久的存储</li>
<li>有序优雅的部署和扩展,删除和终止</li>
<li>有序而自动的滚动更新</li>
</ul>
<p>一般来说,完整可用的 StatefulSet 通常由以下三个组件组成:</p>
<ul>
<li><code>Headless Service</code>: 用于为资源标识符生成可解析的 DNS 资源记录</li>
<li><code>StatefulSet</code>: 用于管控 Pod 资源</li>
<li><code>VolumeClaimTemplates</code>: 基于静态或动态 PV 为 Pod 资源提供专有且稳定的存储</li>
</ul>
<p>对于一个拥有 N 个副本的 StatefulSet 来说,其 Pod 对象会被有序的创建,顺序依次是 <code>{0...N-1}</code>,删除则以相反的方式进行.Pod 资源的名称格式为 <code>$(statefulset_name)-$(ordinal)</code>,其域名后缀由相关 Headless 类型的 Service 资源给出,格式为 <code>$(service_name).$(namespace).svc.cluster.local</code>.</p>
<p>StatefulSet 控制器会为每个 VolumeClaim 模版创建一个专用的 PV,它会从模版中指定 StorageClass 中为每个 PVC 创建 PV,未指定 Storage 将使用默认的 StorageClass 资源.如果不支持 PV 的动态供给,就需要事先创建好满足需求的所有 PV.</p>
<h2 id="StatefulSet-应用"><a href="#StatefulSet-应用" class="headerlink" title="StatefulSet 应用"></a>StatefulSet 应用</h2><h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><p>一个完整的 StatefulSet 控制器需要由 Headless Service, StatefulSet 和 volumeClaimTemplate 组成.一般来说定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 Headless Service,暴露后端 Pod IP</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># clusterIP 为 None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="number">9090</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="string">prometheus</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 创建 sts 对象</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">lables:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podManagementPolicy:</span> <span class="string">"Parallel"</span> <span class="comment"># 指定创建/删除 Pod 时的策略,可选值为 "OrderedReady"(默认),"Parallel".分别表示串行和并行(无需等待)创建/删除 Pod </span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span> <span class="comment"># 保留历史 ControllerRevision 的数量</span></span><br><span class="line">  <span class="attr">updateStrategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">"RollingUpdate"</span> <span class="comment"># 指定升级策略,可选值为 RollingUpdate 与 OnDelete(用户必须手动删除Pod)</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">partition:</span>  <span class="comment"># RollingUpdate 时,保留旧版本 Pod 的数量</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">"prometheus"</span> <span class="comment"># 指定 headless Service 服务名称</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 指定 Pod 副本数</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">prometheus-pod</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Pod 模版相关内容</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="comment"># &lt;Pod 相关内容&gt;</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># PVC 模版相关内容</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">    <span class="comment"># &lt;PVC 相关内容&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span>  <span class="comment"># PVC 名称,用于 Pod 内部挂载</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">storageClassName:</span>  <span class="comment"># 指定 storageClass 名称</span></span><br><span class="line">      <span class="attr">accessModes:</span>  <span class="comment"># 指定访问模式</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">resources:</span>  <span class="comment"># 指定资源,一般为存储大小</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">"500Mi"</span></span><br></pre></td></tr></table></figure>

<p>可以看出,StatefulSet 除了需要在 spec 字段中定义 <code>serviceName</code>,<code>volumeClaimTemplates</code> 外,其它常用字段基本与 Deployment 相同</p>
<h3 id="StatefulSet-中-Pod-资源的标识符"><a href="#StatefulSet-中-Pod-资源的标识符" class="headerlink" title="StatefulSet 中 Pod 资源的标识符"></a>StatefulSet 中 Pod 资源的标识符</h3><p>StatefulSet 控制器创建的 Pod 对象拥有固定且唯一的标识符,他们基于唯一索引,即相关 StatefulSet 名称而生成,名称格式为 <code>&lt;statefulset_name&gt;-&lt;ordinal_index&gt;</code>(index 从 0 开始).</p>
<p>这些名称会由 StatefulSet 资源相关的 headless 资源创建为 DNS 资源记录,域名格式为 <code>$(service_name).$(namespace).svc.cluster.local</code>.Pod 资源记录为 <code>$(pod_name).$(service_name).$(namespace).svc.cluster.local</code>.</p>
<p>Headless Service 资源借助 SRV 记录来引用真正提供服务的后端 Pod 资源的主机名称,进行指向包含 Pod IP 地址的记录条目.StatefulSet 控制器管理的 Pod 在重建后 IP 可能会变化,但它的名称标识在重建后保持不变.</p>
<h2 id="StatefulSet-中-Pod-资源的存储卷"><a href="#StatefulSet-中-Pod-资源的存储卷" class="headerlink" title="StatefulSet 中 Pod 资源的存储卷"></a>StatefulSet 中 Pod 资源的存储卷</h2><p>StatefulSet 控制器通过 <code>volumeClaimTemplates</code> 为每个 Pod 副本自动创建并关联一个 PVC 对象,它们分别绑定了一个动态供给的 PV 对象.</p>
<p>删除 StatefulSet 控制器的 Pod 资源,其存储卷并不会被删除,除非用户或管理员手动删除.因此,经由 StatefulSet 重建后的 Pod,会自动关联之前的 PVC 存储卷,且之前数据依旧可用,实现数据持久化.</p>
<h2 id="案例-etcd-集群"><a href="#案例-etcd-集群" class="headerlink" title="案例: etcd 集群"></a>案例: etcd 集群</h2><ul>
<li>Service 资源清单</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVerision:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">service.alpha.kubernetes.io/tolerate-unready-endpoints:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">etcd-member</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2379</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2380</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">peer</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">etcd-client</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">etcd-member</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">etcd-client</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">2379</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">2379</span></span><br></pre></td></tr></table></figure>

<ul>
<li>StatefulSet 资源清单</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">  <span class="attr">labels:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">etcd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nameService:</span> <span class="string">etcd</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">etcd-member</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">etcd-member</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">"quay.io/coreos/etcd:v3.2.16"</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2379</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2380</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">peer</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CLUSTER_SIZE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"3"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SET_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"etcd"</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/etcd</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"/bin/sh"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"-ecx"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">          <span class="string">IP=$(hostname</span> <span class="string">-i)</span></span><br><span class="line">          <span class="string">PEERS=""</span></span><br><span class="line">          <span class="string">for</span> <span class="string">i</span> <span class="string">in</span> <span class="string">$(seq</span> <span class="number">0</span> <span class="string">$(($&#123;CLUSTER_SIZE&#125;</span> <span class="number">-1</span><span class="string">)));</span> <span class="string">do</span></span><br><span class="line">            <span class="string">...</span></span><br><span class="line">          <span class="string">done</span></span><br><span class="line">          <span class="string">exec</span> <span class="string">etcd</span> <span class="string">--name</span> <span class="string">$&#123;HOSTNAME&#125;</span> <span class="string">\</span></span><br><span class="line">            <span class="string">--listen-peer-urls</span> <span class="string">http://$&#123;IP&#125;:2380</span> <span class="string">\</span> </span><br><span class="line">            <span class="string">--listen-client-urls</span> <span class="string">http://$&#123;IP&#125;:2379,http://127.0.0.1:2379</span> <span class="string">\</span> </span><br><span class="line">            <span class="string">--advertise-client-urls</span> <span class="string">http://$&#123;HOSTNAME&#125;.$&#123;SET_NAME&#125;:2379</span> <span class="string">\</span> </span><br><span class="line">            <span class="string">--initial-advertise-peer-urls</span> <span class="string">http://$&#123;HOSTNAME&#125;.$&#123;SET_NAME&#125;:2380</span> <span class="string">\</span> </span><br><span class="line">            <span class="string">--initial-cluster-token</span> <span class="string">etcd-cluster-1</span> <span class="string">\</span></span><br><span class="line">            <span class="string">--initial-cluster</span> <span class="string">$&#123;PEERS&#125;</span> <span class="string">\</span> </span><br><span class="line">            <span class="string">--initial-cluster-state</span> <span class="string">new</span> <span class="string">\</span></span><br><span class="line">            <span class="string">--data-dir</span> <span class="string">/var/run/etcd/default.etcd</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">nfs-storageclass</span></span><br><span class="line">      <span class="attr">accessModes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ReadWriteOnce"</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 10 认证,授权与准入控制</title>
    <url>/2021/03/19/kubernetes-in-action-10-authentication-authorization-and-access-control/</url>
    <content><![CDATA[<h2 id="访问控制概述"><a href="#访问控制概述" class="headerlink" title="访问控制概述"></a>访问控制概述</h2><p>API Server 作为 Kubernetes 集群系统的网关,是访问及管理资源对象的唯一入口,余下所有需要访问集群资源的组件都要经过此网关进行集群访问和管理.这些客户端均要经过由 API Server 访问或改变集群状态并完成数据存储,并由它对每一次的访问请求进行合法校验,包括用户身份,操作权限验证及操作是否符合全局规范的约束等.所有检查均正常且对象的配置信息合法性检验无误后才能访问或存入后端存储系统 etcd 中.</p>
<p>客户端认证操作由 API Server 配置的一个到多个认证插件完成.收到请求后,API Server 依次调用为其配置的认证插件来认证客户端身份,直到其中一个插件可以识别出请求者的身份为止.授权操作由一到多个授权插件进行,它负责确定哪些通过认证的用户是否有权限执行其发出的资源操作请求.通过授权检测的用户所请求的修改相关的操作还要经由一个到多个准入控制插件的遍历检测.其中任何检查失败都可能会导致写入操作失败.</p>
<h3 id="用户帐户和用户组"><a href="#用户帐户和用户组" class="headerlink" title="用户帐户和用户组"></a>用户帐户和用户组</h3><p>客户端访问 API Server 的途径通常有三种: kubectl,客户端库或直接使用 REST 接口.而可以执行此类请求的主体可以分为常规用户(User Account)和服务帐号(Service Account)</p>
<ul>
<li><code>User Account</code>: 指独立于 Kubernetes 之外的其它服务管理的服务帐号,如密钥等</li>
<li><code>Service Account</code>: 由 Kubernetes API 管理的账号,用于为 Pod 之中的服务进程在访问 Kubernetes API 时提供身份标识.Service Account 通常要绑定于特定的名称空间.附带着一组存储为 Secret 的用于访问 API Server 的凭据.</li>
</ul>
<p>Kubernetes 中用户组只是用户帐号的逻辑集合,它本身没有操作权限,但附加于组上的权限可以由其内部的所有哟过户继承,以实现高效的授权管理机制.Kubernetes 有着以下几个内建的用于特殊目的的组.</p>
<ul>
<li><code>system:unauthenticated</code>: 未通过认证测试的用户所属的组</li>
<li><code>system:authenticated</code>: 认证成功后用户自动加入的一个组</li>
<li><code>system:serviceaccounts</code>: 当前系统上的所有 Service Account 对象</li>
<li><code>system:serviceaccounts:&lt;namespace&gt;</code>: 特定名称空间内所有 Service Account 对象.</li>
</ul>
<h3 id="认证-授权与准入控制"><a href="#认证-授权与准入控制" class="headerlink" title="认证,授权与准入控制"></a>认证,授权与准入控制</h3><p>API Server 处理请求过程中,认证插件负责鉴定用户身份,授权插件用于操作权限许可鉴别,准入控制则用于在资源对象创建,删除,更新或连接操作时实现更精细的许可检查.</p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>Kubernetes 使用身份认证插件对 API 请求进行身份认证,支持的认证方式包括客户端证书,承载令牌,身份验证代理或 HTTP basic 认证等.具体如下:</p>
<ul>
<li>X509 客户端证书认证: 客户端请求中携带 X509 格式的数字证书用于认证.</li>
<li>静态令牌文件: 保存着令牌信息文件,由 kube-apiserver 的命令行选项 <code>--token-auth-file</code> 加载,服务器启动后不可更改.</li>
<li>引导令牌(Bootstrap Token): 有新的工作节点首次加入时,Master 使用引导令牌确认节点身份的合法性后自动为其签署数字证书以用于后续的安全通信,使用 <code>kubeadm join</code> 将节点加入 kubeadm 初始化的集群时使用的即是这种认证方式.</li>
<li>静态密码文件: 用户名和密码等令牌以明文的格式存储 CSV 格式文件,由 <code>kube-apiserver</code> 使用 <code>--basic-auth-file</code> 选项进行加载.</li>
<li>服务帐户令牌: 由 kube-apiserver 自动启用,并可以使用 <code>--service-account-key-file</code> 验证承载令牌的密钥,省略时将使用 <code>kube-apiserver</code> 自己的证书匹配的私钥文件.</li>
<li>匿名请求: 未被任何验证机制明确拒绝的用户即为匿名用户,其被自动标识为 <code>system:anonymous</code>,并隶属于 <code>system:unauthenticated</code> 用户组.在 API Server 启用了除 <code>AlwaysAllow</code> 以外的认证机制时,匿名用户处于启用状态.可以使用 <code>--anonymous-auth=false</code> 将其禁用.</li>
</ul>
<p>API Server 是一种 REST API,除了身份认证信息之外,请求报文还需要提供操作方法及其目标对象.具体如下:</p>
<ul>
<li>API: 定义请求的目标是否是一个 API 资源</li>
<li>Request path: 请求的非资源路径,如 “/api” 或 “/healthz”</li>
<li>API group: 需要访问的 API 组,仅对资源型请求有效</li>
<li>Namespace: 目标资源所属的名称空间,仅对隶属于名称空间类型的资源有效</li>
<li>API request verb: API 请求类的操作,资源型请求,包括 <code>get,list,create,update,patch,watch,proxy,redirect,delete,deletecollection</code> 等</li>
<li>HTTP request verb: HTTP 请求类的操作,非资源型请求要执行的操作,如 <code>get,post,put,delete</code></li>
<li>Resource: 请求目标资源的 ID 或名称</li>
<li>Subresource: 请求的子资源</li>
</ul>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>通过身份认证后的请求需要转交给授权插件进行许可检查.API Server 支持使用四类内建的授权插件来定义用户的操作权限</p>
<ul>
<li>Node: 基于 Pod 资源的目标调度节点来实现对 kubelet 的访问控制</li>
<li>ABAC(attribute-based access control): 基于属性的访问控制</li>
<li>RBAC(role-based access control): 基于角色的访问控制</li>
<li>Webhook: 基于 HTTP 回调机制通过外部 REST 服务检查确认用户授权的访问控制</li>
</ul>
<h4 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h4><p>准入控制用于在客户端请求经过身份认证和授权检查之后,在对象持久化存储 etcd 之前拦截请求,用于实现在资源的创建,更新和删除操作期间强制执行对象的语义验证功能.主要包含如下几种:</p>
<ul>
<li>AlwaysAdmit: 允许所有请求</li>
<li>AlwaysDeny: 拒绝所有请求</li>
<li>AlwaysPullImages: 总是下载镜像</li>
<li>NamespaceLifecycle: 拒绝于不存在的名称空间中创建资源,删除名称空间会删除其下的所有资源</li>
<li>ServiceAccount: 用于实现 Service Account 管控机制的自动化,实现创建 Pod 对象时自动为其附加相关的 Service Account 对象.</li>
<li>DefaultStorageClass: 监控所有创建 PVC 对象的请求,保证没有附加任何专用 storageClass 的请求会自动设置一个默认值</li>
<li>ResourceQuota: 用于对名称空间设置可用资源上限,并确保在其中创建的任何设置了资源限额的对象不会超过名称空间的资源配额</li>
<li>DefaultTolerationSeconds: 如果 Pod 对象上不存在污点容忍期限,则为它们设置默认的容忍期限,来容忍 <code>notready:NoExecute</code> 和 <code>unreachable:NoExecute</code> 类的污点5分钟.</li>
</ul>
<h2 id="服务管理与应用"><a href="#服务管理与应用" class="headerlink" title="服务管理与应用"></a>服务管理与应用</h2><h3 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h3><p>运行过程中,Pod 资源里容器进程需要调用 Kubernetes API,这些服务通常需要认证客户端身份.Service Account 就是让 Pod 对象内容器容器进程访问其他服务时提供身份认证信息的账户.</p>
<p>在创建 Pod 资源时,每个 Pod 资源都自动关联了一个存储卷,并由其容器挂载至 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 目录.挂载点通常存在三个文件 <code>ca.crt,namespace 和 token</code>.其中,token 保存了 Service Account 认证的 token,容器中进程使用它向 API Server 发起连接请求,进而完成认证过程.</p>
<p>每个 Pod 对象都只有一个服务账户,若创建 Pod 时未予以明确指定,则准入控制器会为其自动附加当前命名空间中默认的服务账户,名称为 <code>default</code></p>
<p>Kubernetes 通过如下三个独立组件间的相互协作来实现服务账户自动化:</p>
<ol>
<li><code>Service Account 帐户控制器</code></li>
</ol>
<p>负责为名称空间管理相应的资源,确保每个名称空间中存在一个名为 <code>default</code> 的 Service Account 对象</p>
<ol start="2">
<li><code>令牌控制器</code></li>
</ol>
<p>是 controller-manager 的子组件.任务如下:</p>
<ul>
<li>监控 Service Account 的创建操作,并为其添加用于访问 API 的 Secret 对象</li>
<li>监控 Service Account 的删除操作,并删除其相关的所有 Service Account 令牌密钥</li>
<li>监控 Secret 对象的添加操作,确保其引用的 Service Account 已经存在,并为 Secret 对象添加认证令牌</li>
<li>监控 Secret 对象的删除操作,确保删除每个 Service Account 中对此 Secret 的引用</li>
</ul>
<ol start="3">
<li><code>Service Account 准入控制器</code></li>
</ol>
<p>是 API Server 的一部分,负责创建或更新 Pod 时对其按需进行 Service Account 对象相关信息的修改.如下:</p>
<ul>
<li>若 Pod 没有明确定义使用的 Service Account 对象,则将其设置为 <code>default</code></li>
<li>确保 Pod 明确引用的 Service Account 已经存在,否则请求将被拒绝</li>
<li>若 Pod 对象中不包含 <code>imagePullSecrets</code>,则把 Service Account 的 <code>imagePullSecrets</code> 添加到 Pod 对象中</li>
<li>为带有访问 API 的令牌的 Pod 添加一个存储卷</li>
<li>为 Pod 对象中每个容器添加一个 volumeMounts,挂载至 <code>/var/run/secrets/kubernetes.io/serviceaccount</code></li>
</ul>
<h3 id="创建Service-Account"><a href="#创建Service-Account" class="headerlink" title="创建Service Account"></a>创建Service Account</h3><ul>
<li>使用资源清单文件进行创建</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span>  <span class="comment"># 指定拉取镜像的 docker-registry 类型的 Secret 对象,在 Pod 没有指定 imagePullSecrets 时使用此对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>kubectl create serviceaccount &lt;name&gt; [-n &lt;namespace&gt;]</code> 命令行直接创建</li>
</ul>
<h2 id="X-509-数字证书认证"><a href="#X-509-数字证书认证" class="headerlink" title="X.509 数字证书认证"></a>X.509 数字证书认证</h2><p>Kubernetes 支持的 HTTPS 客户端证书认证,基于 SSL/TLS 协议,安全性高,易于实现,成为主要认证方式之一.</p>
<p>服务端与客户端相互认证的场景中,双方各自需要配备一套证书,并拥有信任的签证机构的证书列表.使用私有签证机构颁发的数字证书时,用户通常需要手动将私有签证机构的证书添加到信任的签证机构列表中.</p>
<h3 id="Kubernetes-中的-SSL-TLS-认证"><a href="#Kubernetes-中的-SSL-TLS-认证" class="headerlink" title="Kubernetes 中的 SSL/TLS 认证"></a>Kubernetes 中的 SSL/TLS 认证</h3><p>构建安全基础通信环境的 Kubernetes 集群时,需要用到 TLS 及数字证书的通信场景有很多种.<br><img src="/images/SSL-TLS-communication-in-kubernetes.png" alt="Kubernetes 的 SSL/TLS 通信"></p>
<p>etcd 集群内各节点间的通信,各节点与其客户端(主要是 API Server)之间的通信都应该以加密的方式进行,并需要进行身份验证</p>
<ul>
<li>etcd 集群内各节点通信: etcd 集群内各节点间的集群事务通信,默认监听于 TCP/2380,基于 SSL/TLS 通信时需要 peer 类型的数字证书,可实现节点间的身份认证及通信安全.</li>
<li>etcd 服务器与客户端通信: etcd 的 REST API 服务,默认监听于 TCP/2379,用于接收并响应客户端请求,基于 SSL/TLS 通信,支持服务端认证和双向认证</li>
</ul>
<p>API Server 与其客户端之间采用 HTTPS 通信可兼顾实现通信与认证的功能,它们之间通信证书可由同一个 CA 进行管理,客户端大体可以分为如下三类:</p>
<ul>
<li>控制平面的 kube-scheduler 和 kube-controller-manager</li>
<li>工作节点组件 kubelet 和 kube-proxy: 初次接入集群时,kubelet 可自动生成私钥和证书签署请求,并由 Master 为其自动进行证书签名和颁发,这就是所谓的 tls bootstraping.</li>
<li>kubectl 及其它形式的客户端.</li>
</ul>
<h3 id="客户端配置文件-kubeconfig"><a href="#客户端配置文件-kubeconfig" class="headerlink" title="客户端配置文件 kubeconfig"></a>客户端配置文件 kubeconfig</h3><p>客户端都可以使用 <code>kubeconfig</code> 配置文件提供接入多个集群的相关配置信息,能够设置成不同的上下文环境,并在各环境中快速切换.</p>
<p>使用 kubeadm 初始化集群后生成的 <code>/etc/kubernetes/admin.conf</code> 文件即为 kubeconfig 格式的配置文件.kubectl 会加载 <code>$HOME/.kube/config</code> 后接入服务器.<code>kubectl config view</code> 会显示当前使用的配置文件.配置文件中包含集群列表,用户列表,上下文列表,及当前使用的上下文等信息.如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"></span><br><span class="line"><span class="attr">users:</span> <span class="comment"># 用户列表</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">REDACTED</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clusters:</span> <span class="comment"># 集群列表</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line">  <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://&lt;apiserver_host&gt;:6443</span></span><br><span class="line"></span><br><span class="line"><span class="attr">contexts:</span> <span class="comment"># 上下文列表</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-admin@kubernetes</span></span><br><span class="line">  <span class="attr">context:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">kubernetes-admin@kubernetes</span> <span class="comment"># 当前使用的上下文</span></span><br></pre></td></tr></table></figure>

<p>管理员也可以创建其它基于 SSL/TLS 认证的自定义用户帐号,授予指定权限.其配置过程由两部分组成:</p>
<ol>
<li>为用户创建专用私钥及证书文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成私钥文件</span></span><br><span class="line"><span class="built_in">cd</span> /etc/kubernetes/pki</span><br><span class="line">(<span class="built_in">umask</span> 077; openssl genrsa -out kube-user.key 2048)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建证书签署请求</span></span><br><span class="line">openssl req -new -key kube-user.key -out kube-user.csr -subj <span class="string">"/CN=kube-user/O=kubeusers"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于 kubeadm 安装 Kubernetes 集群时生成的 CA 证书进行证书签署</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> kube-user.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out kube-user.crt -days 3650</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证证书信息(可选)</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> kube-user.crt -text -noout</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将其配置于某 kubeconfig 文件中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置集群信息,一般集群已经存在,可以省略此步骤</span></span><br><span class="line"><span class="comment"># kubectl config set-cluster kubernetes --embed-certs=true \</span></span><br><span class="line"><span class="comment">#  --certificate-authority=/etc/kubernetes/pki/ca.crt \</span></span><br><span class="line"><span class="comment">#  --server="https://&lt;apiserver&gt;:6443"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置用户</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials kube-user \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --client-certificate=/etc/kubernetes/pki/kube-user.crt \</span><br><span class="line">  --client-key=/etc/kubernetes/pki/kube-user.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 context</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-context kube-user@kubernetes \</span><br><span class="line">  --user=kube-user \</span><br><span class="line">  --cluster=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换上下文</span></span><br><span class="line">kubectl config use-context kube-user@kubernetes</span><br></pre></td></tr></table></figure>

<h2 id="基于角色的访问控制-RBAC"><a href="#基于角色的访问控制-RBAC" class="headerlink" title="基于角色的访问控制 RBAC"></a>基于角色的访问控制 RBAC</h2><p>RBAC(Role-Based Access Control)基于”角色(role)”这一核心组件实现了权限指派,它为帐号赋予一到多个角色从而让其具有角色之上的权限.帐号可以是用户帐号,用户组,服务账号机器相关的组等,同时关联至多个角色的账号所拥有的权限是多个角色上的权限集合;权限是允许或不允许对一个或多个对象(object)执行的操作(verb).</p>
<p>RBAC 授权插件支持 <code>Role</code> 和 <code>ClusterRole</code> 两类角色,其中 <code>Role</code> 作用于名称空间级别,用于定义名称空间内的资源权限集合,而 <code>ClusterRole</code> 则用于组织集群级别的资源权限集合.</p>
<p>对这两类角色进行赋权时,需要用到 <code>RoleBinding</code> 和 <code>ClusterRoleBinding</code>.<code>RoleBinding</code> 用于将 <code>Role</code> 上的许可权限绑定到一个或一组用户之上,它隶属于且仅能作用于一个名称空间.绑定时,它可以引用 <code>Role</code>,也可以引用<code>ClusterRole</code>.<code>ClusterRoleBinding</code> 则把 <code>ClusterRole</code> 中定义的许可权限绑定在一个或一组用户之上,它仅可以引用集群级别的 <code>ClusterRole</code>.</p>
<h3 id="Role-和-RoleBinding"><a href="#Role-和-RoleBinding" class="headerlink" title="Role 和 RoleBinding"></a>Role 和 RoleBinding</h3><p>Role 是一组许可权限的集合,它描述了对哪些资源可执行哪些操作.</p>
<ul>
<li>使用资源配置清单定义 Role</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-name</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span>  <span class="comment"># 包含了资源的 API 组的名称,"" 表示 core API group</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">["pods",</span> <span class="string">"pods/log"</span><span class="string">]</span>  <span class="comment"># 规则应用的目标资源列表,缺省时表示所有资源</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span>  <span class="comment"># 可应用至此规则的操作类型列表,必需字段.可选项有 get,list,create,update,patch,watch,proxy,redirect,delete 和 deletecollection.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用命令行定义 Role</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create role &lt;role-name&gt; --verb=<span class="string">"*"</span> --resource=<span class="string">"service,service/*"</span> [-n default]</span><br></pre></td></tr></table></figure>

<p>RoleBinding 用于将 Role 中定义的权限赋予一个用户或一组用户,它由一组主体,一个 <code>Role</code> 或 <code>ClusterRole</code> 组成.</p>
<ul>
<li>使用资源配置清单定义 RoleBinding</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">rolebinding-name</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kube-user</span>  <span class="comment"># 绑定主体对象名称</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">User</span>  <span class="comment"># 绑定主体对象类型,可选类型有 User,Group,ServiceAccount</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-name</span>  <span class="comment"># 绑定角色名称</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span>  <span class="comment"># 该角色类型,可选类型有 Role,ClusterRole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><code>Role</code> 和 <code>RoleBinding</code> 是名称空间级别的资源,他们仅能用于完成单个名称空间内的访问控制.</p>
<h3 id="ClusterRole-和-ClusterRoleBinding"><a href="#ClusterRole-和-ClusterRoleBinding" class="headerlink" title="ClusterRole 和 ClusterRoleBinding"></a>ClusterRole 和 ClusterRoleBinding</h3><p>ClusterRole 是集群级别的资源,配置方式与 Role 基本相同.</p>
<ul>
<li>使用资源配置清单定义 ClusterRole</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">clusterRole-name</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">resources:</span> <span class="string">["nodes",</span> <span class="string">"pods"</span><span class="string">,</span> <span class="string">"pods/log"</span><span class="string">]</span>  <span class="comment"># 支持集群级别资源</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span>  <span class="comment"># 可应用至此规则的操作类型列表,必需字段.可选项有 get,list,create,update,patch,watch,proxy,redirect,delete 和 deletecollection.</span></span><br><span class="line">  <span class="attr">apiGroups:</span> <span class="string">[""]</span>  <span class="comment"># 包含了资源的 API 组的名称,默认表示 core API group</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持对非资源型 URL 的访问,如下</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">noResourceURLs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/api</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/api/*</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用命令行定义 ClusterRole</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrole &lt;clusterrole-name&gt; --verb=<span class="string">"*"</span> --resource=<span class="string">"nodes,nodes/*"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用资源配置清单定义 ClusterRoleBinding</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">clusterrolebinding-name</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kube-user</span>  <span class="comment"># 绑定主体对象名称</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">User</span>  <span class="comment"># 绑定主体对象类型,可选类型有 User,Group,ServiceAccount</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">clusterrole-name</span>  <span class="comment"># 绑定集群角色名称</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span>  <span class="comment"># 集群角色</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合型-ClusterRole"><a href="#聚合型-ClusterRole" class="headerlink" title="聚合型 ClusterRole"></a>聚合型 ClusterRole</h3><p>Kubernetes 自 1.9 版本支持在资源清单文件中使用 <code>aggregationRule</code> 字段来整合其它 ClusterRole 对象的规则,这种类型的 ClusterRole 的权限受控于选择器,由所有被标签选择器匹配到指定标签的 ClusterRole 合并而成.示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">clusterrole-name1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">clusterrole-for-aggregate:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">resources:</span> <span class="string">["service",</span> <span class="string">"nodes"</span><span class="string">,</span> <span class="string">"endpoints"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">aggregate-clusterrole</span></span><br><span class="line"><span class="attr">aggregationRule:</span></span><br><span class="line">  <span class="attr">clusterRoleSelectors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">clusterrole-for-aggregate:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">rules:</span> <span class="string">[]</span></span><br></pre></td></tr></table></figure>

<h3 id="超级管理员-cluster-admin"><a href="#超级管理员-cluster-admin" class="headerlink" title="超级管理员 cluster-admin"></a>超级管理员 <code>cluster-admin</code></h3><p>内建的 ClusterRole 资源 <code>cluster-admin</code> 拥有管理集群所有资源的权限,它基于同名的 ClusterRoleBinding 资源绑定到了 <code>system:masters</code> 组上,这意味着隶属于此组的用户豆浆具有集群的超级管理权限.</p>
<p>于是,为 Kubernetes 集群定义超级管理员的方式至少具有两种:</p>
<ul>
<li>创建用户证书,其 Subject 中 O 的属性值为 <code>system:masters</code></li>
<li>创建 ClusterRoleBinding,将用户绑定至 <code>cluster-admin</code> 这个 ClusterRole 资源上.</li>
</ul>
<h3 id="应用-Kubernetes-Dashboard-部署"><a href="#应用-Kubernetes-Dashboard-部署" class="headerlink" title="应用: Kubernetes Dashboard 部署"></a>应用: Kubernetes Dashboard 部署</h3><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">Dashboard</a> 是 Kubernetes 的 Web GUI,其认证和授权均可由 Kubernetes 集群实现,它目前支持的认证方式有承载令牌和 kubeconfig 两种.</p>
<h4 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml 文件地址可通过 https://github.com/kubernetes/dashboard 找到</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 dashboard 的 service 类型设置为 NodePort</span></span><br><span class="line">kubectl patch svc kubernetes-dashboard -p <span class="string">'&#123;"spec":&#123;"type":"NodePort"&#125;&#125;'</span> -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看部署情况</span></span><br><span class="line">kubectl get pods,service -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建完成后,可通过部署 Dashboard 时创建的 ServiceAccount 对象 `kubernetes-dashboard` 的 secret 及其 token</span></span><br><span class="line"><span class="comment"># 获取到的 token 可直接用于令牌登录 dashboard</span></span><br><span class="line">secret_name=`kubectl get secret -n kubernetes-dashboard | awk <span class="string">'/^kubernetes-dashboard/&#123;print $1&#125;'</span>`</span><br><span class="line">kubectl describe secret <span class="variable">$&#123;secret_name&#125;</span> -n kubernetes-dashboard | awk <span class="string">'/token:/&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure>

<h4 id="配置-token-认证"><a href="#配置-token-认证" class="headerlink" title="配置 token 认证"></a>配置 token 认证</h4><blockquote>
<p>此示例仅为演示</p>
</blockquote>
<ol>
<li>在指定名称空间下,创建 serviceaccount,并与集群中 <code>cluster-admin</code> 管理资源做绑定</li>
</ol>
<ul>
<li>使用命令行创建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line">kubectl create clusterrolebinding dashboard-admin \</span><br><span class="line">  --clusterrole=cluster-admin \</span><br><span class="line">  --serviceaccount=kube-system:dashboard-admin</span><br></pre></td></tr></table></figure>

<ul>
<li>使用清单文件创建</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-admin</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-admin</span></span><br><span class="line">  <span class="attr">namespace:</span>  <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取创建的 secret 及其 token,获取到的 token 可直接用于令牌登录 dashboard</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">secret_name=`kubectl get secret -n kube-system | awk <span class="string">'/^dashboard-admin/&#123;print $1&#125;'</span>`</span><br><span class="line">kubectl describe secret <span class="variable">$&#123;secret_name&#125;</span> -n kube-system | awk <span class="string">'/token:/&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure>

<h2 id="准入控制器"><a href="#准入控制器" class="headerlink" title="准入控制器"></a>准入控制器</h2><h3 id="LimitRange-资源"><a href="#LimitRange-资源" class="headerlink" title="LimitRange 资源"></a>LimitRange 资源</h3><p>LimitRange 资源用于在每个名称空间中为每个容器指定最小及最大计算资源用量,甚至是默认的计算资源需求和计算资源限制.在名称空间定义了 LimitRange 对象后,客户端提交创建或修改的对象会受到 LimitRanger 控制器的检查,任何违反 LimitRange 对象定义的资源最大用量的请求将会被拒绝</p>
<p>LimmitRange 支持限制容器,Pod 和 PersistentVolumeClaim 三种资源对象系统资源用量.容器和 Pod 主要用于定义可用的 CPU 和内存资源范围,PVC 主要定义存储空间限制.</p>
<p>一般定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">default:</span> <span class="comment"># 定义默认的资源 limit 值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">    <span class="attr">defaultRequest:</span> <span class="comment"># 定义默认的资源 request 值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">    <span class="attr">min:</span> <span class="comment"># 定义资源的最小使用限制</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">    <span class="attr">max:</span> <span class="comment"># 定义资源的最大使用限制</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">    <span class="attr">maxLimitRequestRatio:</span> <span class="comment"># 指定资源必须包含非 0 的 limit 和 request 值,且 limit 除以 request 的值小于等于此值.表示定义资源的最大突发值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Container</span></span><br></pre></td></tr></table></figure>

<h3 id="ResourceQuota-资源"><a href="#ResourceQuota-资源" class="headerlink" title="ResourceQuota 资源"></a>ResourceQuota 资源</h3><p>ResourceQuota 资源用于定义名称空间的数量或系统资源配额,它支持限制每种资源类型的对象总数,以及所有对象所能消耗的计算资源及存储资源总量等.</p>
<p>定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">namespace:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hard:</span> <span class="comment"># 每个命名资源的所需限制集,常用字段如下</span></span><br><span class="line">    <span class="attr">pods:</span> <span class="string">"5"</span></span><br><span class="line">    <span class="attr">requests.cpu:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">requests.memory:</span> <span class="string">1Gi</span></span><br><span class="line">    <span class="attr">limits.cpu:</span> <span class="string">"2"</span></span><br><span class="line">    <span class="attr">limits.memory:</span> <span class="string">2Gi</span></span><br><span class="line">    <span class="attr">count/deployments.apps:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">count/deployments.extensions:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">persistentvolumeclaims:</span> <span class="string">"2"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 实战 - 11 网络模型与网络策略</title>
    <url>/2021/03/19/kubernetes-in-action-11-network-and-policy/</url>
    <content><![CDATA[<p>在了解 Kubernetes 网络模型之前,我们先来看一下 Docker 的网络模型</p>
<h2 id="Docker-容器网络模型"><a href="#Docker-容器网络模型" class="headerlink" title="Docker 容器网络模型"></a>Docker 容器网络模型</h2><p>Docker 网络模型的原始模型主要有三种:</p>
<ul>
<li><code>Bridge</code>: 桥接,借助于虚拟网桥设备为容器建立网络连接.是 Docker 默认的网络模型</li>
<li><code>Host</code>: 主机,设定容器直接共享使用节点主机的网络名称空间</li>
<li><code>Container</code>: 容器,多个容器共享同一个网络名称空间,彼此之间能够以本地通信的方式建立连接</li>
<li><code>None</code>: 不使用网络</li>
</ul>
<p>因此,在创建 Docker 容器时,默认有四种网络可供选择使用,具体如下:</p>
<ul>
<li>Closed container(封闭式容器): 此类容器使用 “None” 网络,它们没有对外通信的网络接口,通常用于不需要网络的后端作业处理场景</li>
<li>Bridge container(桥接式容器): 此类容器使用 “Bridge” 模型的网络,容器引擎会为每个容器创建一对(两个)虚拟以太网设备,一个配置为容器的网络接口,另一个在节点主机上接入指定的虚拟网桥设备(默认为 docker0)</li>
<li>Open container(开放式容器): 此类容器使用 “Host” 模型的网络,共享使用 Docker 主机的网络及器接口</li>
<li>Joined container(联盟式容器): 此类容器共享使用某个已存在的容器的网络名称空间,共享使用指定容器的网络及接口.</li>
</ul>
<p>Docker 进程首次启动时,它会在当前节点上创建一个名为 <code>docker0</code> 的桥设备,并默认配置其使用 <code>172.17.0.0/16</code> 的网络(可通过 <code>bridge</code> 进行配置),该网络是 Bridge 模型的一种实现,也是创建 Docker 容器时默认使用的网络模型.</p>
<p>跨节点的容器间进行通信时,每个节点上的容器都将从 <code>172.17.0.0/16</code> 网络中获取 IP 地址,导致不同的 Docker 主机上的容器可能会使用相同的地址,因此它们无法直接通信.</p>
<p>而解决此问题的通信方式是 NAT.所有发往 Docker 主机外部的流量都会在执行过程中进行源地址转换,接入 Docker 主机外部的流量,则需要通过目标地址转换或端口映射将其暴露于外部网络中.因此,多节点上的 Docker 容器间通信依赖 NAT 机制转发实现.</p>
<h2 id="Kubernetes-网络模型"><a href="#Kubernetes-网络模型" class="headerlink" title="Kubernetes 网络模型"></a>Kubernetes 网络模型</h2><p>Kubernetes 网络模型主要可用于解决四类通信请求:</p>
<ul>
<li>同一 Pod 内容器间通信</li>
</ul>
<p>Pod 对象内各容器共享同一网络名称空间,彼此间可以通过 lo 接口完成交互</p>
<ul>
<li>Pod 间通信</li>
</ul>
<p>各 Pod 对象运行于同一个平面网络中,每个 Pod 对象拥有一个集群全局唯一的地址,并直接可以与其它 Pod 进行通信.此网络称为 Pod 网络.</p>
<p>运行 Pod 的各节点也会通过桥接设备持有此平面网络的一个 IP 地址,因此 Node 到 Pod 间通信也可以在此网络上直接进行.</p>
<ul>
<li>Service 到 Pod 间通信</li>
</ul>
<p>Service 资源的专用网络也称为集群网络(Cluster Network),需要在启动 kube-apiserver 时通过 <code>--service-cluster-ip-range</code> 选项进行指定,如 <code>10.96.0.0/12</code>.每个 Service 对象在此网络有拥有一个称为 ClusterIP 的固定地址.</p>
<p>Service 创建完成后,会触发各节点上的 kube-proxy,并在相应节点上创建 iptables 或 ipvs 规则,完成从 Service 的 ClusterIP 与 PodIP 之间的报文转发.</p>
<ul>
<li>集群外部与 Service 间通信</li>
</ul>
<p>Service 有多种类型,常用的有如下三种: ClusterIP(默认),NodePort,LoadBalancer</p>
<p>ClusterIP 类型的 Service 只会得到虚拟的 ServiceIP 和 ServicePort,只能在 Kubernetes 集群内部被访问.</p>
<p>NodePort 类型的 Service 在 ClusterIP 的基础上构建,它 会得到虚拟的 ServiceIP 和 ServicePort 用于 Kubernetes 集群内部通信,Kubernetes 还会在所有 Node 节点上为其分配端口,用于从集群外部通过 NodeIP:nodePort 访问.分配的端口的值可以通过<code>spec.ports[*].nodePort</code> 指定,或由 Kubernetes 自行分配,默认为30000-32767.</p>
<p>LoadBalancer 类型的 Service 在 NodePort 的基础上构建,并为其开通负载均衡,一般需要云厂商设备的支持.</p>
<h2 id="flannel-网络插件"><a href="#flannel-网络插件" class="headerlink" title="flannel 网络插件"></a>flannel 网络插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 flannel, yaml 文件地址可通过 https://github.com/flannel-io/flannel 获得</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>flannel 解决了多节点 Docker 主机中容器通信中时的两个问题</p>
<ul>
<li>各 Docker 主机在 docker0 桥上默认使用同一个子网,不同节点的容器可能会得到相同的地址,跨节点的容器间通信会面临地址冲突的问题</li>
<li>各个节点上网络中缺乏路由信息,报文无法准确送达</li>
</ul>
<p>解决办法如下:</p>
<ul>
<li>预留使用一个网络,为每各个节点的 Docker 容器引擎分配一个子网(如 10.244.1.0/24 和 10.244.2.0/24),并将分配信息保存于 etcd 持久存储.</li>
<li>支持 VxLAN, host-gw, UDP 网路模型,使用”后端”解决相关问题<ul>
<li><code>VxLAN</code>: 使用 VxLAN 模块封装报文</li>
<li><code>host-gw</code>: Host GateWay,在节点上创建到达目标容器的路由完成报文转发,这种方式要求各节点本身在一个二层网络中.</li>
<li>UDP: 使用普通 UDP 报文封装完成隧道转发,性能较低</li>
</ul>
</li>
</ul>
<h3 id="flannel-配置参数"><a href="#flannel-配置参数" class="headerlink" title="flannel 配置参数"></a>flannel 配置参数</h3><p>默认情况下,flannel 的配置信息保存于 etcd 的键名 <code>/coreos.com/netwok/config</code> 之下,它的值是一个 JSON 格式的字典数据,它可以使用的键包含以下几个:</p>
<ul>
<li><code>Network</code>: flannel 在全局使用的 CIDR 格式的 IPv4 网络,字符串格式,必选字段</li>
<li><code>SubnetLen</code>: 将 Network 属性指定的 IPv4 网络基于指定位的掩码切割为供节点使用的子网.当网络的掩码小于24时,默认为24</li>
<li><code>SubnetMin/SubnetMax</code>: 可用作分配给节点使用的子网范围</li>
<li><code>Backend</code>: flannel 要使用的后端类型,以及后端的相关配置.包含 type(类型,默认为 VxLAN)和 Port(端口)字段</li>
</ul>
<p>配置示例如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Network"</span>: <span class="string">"10.244.0.0/16"</span>,</span><br><span class="line">    <span class="attr">"SubnetLen"</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="attr">"Backend"</span>: &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"VxLAN"</span>,</span><br><span class="line">        <span class="attr">"Port"</span>: <span class="number">8472</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络策略"><a href="#网络策略" class="headerlink" title="网络策略"></a>网络策略</h2><p>网络策略(Network Policy)用于控制分组的 Pod 资源之间如何进行通信,它为 Kubernetes 实现了更为精细的流量控制,实现租户隔离控制. Kuberntes 使用资源对象 <code>NetworkPolicy</code> 定义网络控制策略.</p>
<p>Pod 网络流量包含 “流入(Ingress)” 和 “流出(Egress)” 两种方向,每种方向的控制包含 “允许” 和 “禁止” 两种.默认情况下,Pod 的流量可以自由来去,一旦有策略应用于 Pod,那么所有为经明确允许的流量都将被拒绝,</p>
<p>网络策略需要使用 Cannal 或 Calico 提供,安装方式如下,详情请见<a href="https://docs.projectcalico.org/" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.10/manifests/canal.yaml</span><br></pre></td></tr></table></figure>

<p>一般来说,网络策略定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">namesapce:</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span>  <span class="comment"># pod 标签选择器,&#123;&#125;表示所有</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span> <span class="comment"># 表示入站流量管理策略启用</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span>  <span class="comment"># 表示出站流量管理策略启用</span></span><br><span class="line">  <span class="attr">ingress/egress:</span> <span class="comment"># 定义入站/出站策略.如果不定义此字段,则表示禁止所有入站/出站流量;如果该字段值为&#123;&#125;,则表示允许所有入站/出站流量</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from/to:</span>  <span class="comment"># 入站或出站流量的列表对象,可以根据如下方式进行限定</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span> <span class="comment"># 地址范围</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span> <span class="comment"># 是一个 CIDR 地址,格式为:网段/掩码</span></span><br><span class="line">        <span class="attr">except:</span> <span class="number">10.244</span><span class="number">.1</span><span class="number">.2</span><span class="string">/32</span> <span class="comment"># 是一个 CIDR 地址,格式为:网段/掩码,表示除了这个</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSeletor:</span> <span class="comment"># 名称空间选择器</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span>  <span class="comment"># pod 选择器</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP/UDP</span></span><br></pre></td></tr></table></figure>

<p>一般来说,我们会将同一名称空间下的 Pod 的入站流量全部禁止,只留下特定应用端口的入站流量,将除 kube-system 外的不同名称空间下的 Pod 进行隔离.故默认定义如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 禁止所有名称空间中 Pod 的入站出站流量</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deny-other-namespace</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 开放 kube-system 和自身名称空间中 Pod 出站入站流量</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">allow-namespace-default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">key:name</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">kube-system</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">key:name</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">kube-system</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 禁止所有 Pod 入站流量</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deny-all-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 定义允许 Pod 的入站流量,开放应用端口的入站流量</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">allow-xxx-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol :</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 防火墙及 iptables 详解</title>
    <url>/2020/06/11/linux-firewall-and-iptables/</url>
    <content><![CDATA[<h2 id="Linux-防火墙"><a href="#Linux-防火墙" class="headerlink" title="Linux 防火墙"></a>Linux 防火墙</h2><p>Linux 防火墙基于内核实现,它使用 Netfilter 包过滤引擎,根据用户通过 <code>iptables</code> 命令定义的规则实现对数据包的过滤或转发.</p>
<h3 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h3><p>Linux 防火墙内置了 4 个表分别提供不同的功能.表及其功能如下:</p>
<table>
<thead>
<tr>
<th align="center">表</th>
<th align="center">提供功能</th>
<th align="center">内置规则链</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>filter</code></td>
<td align="center">包过滤</td>
<td align="center">INPUT,FORWARD,OUTPUT</td>
</tr>
<tr>
<td align="center"><code>nat</code></td>
<td align="center">网络地址转换</td>
<td align="center">PREROUTING,POSTROUTING,OUTPUT</td>
</tr>
<tr>
<td align="center"><code>mangle</code></td>
<td align="center">包重构</td>
<td align="center">PREROUTING,POSTROUTING,INPUT,OUTPUT,FORWARD</td>
</tr>
<tr>
<td align="center"><code>raw</code></td>
<td align="center">数据跟踪处理,提供连接跟踪机制</td>
<td align="center">OUTPUT,PREROUTING</td>
</tr>
</tbody></table>
<p>规则表之间的优先顺序为 <code>raw -&gt; mangle -&gt; nat -&gt; filter</code>.</p>
<p><img src="/images/firewalld-tables-and-chains.png" alt="四表五链"></p>
<p>Linux 防火墙还内置了 5 条规则链,用于表示数据包传输的路径,每一条链其实就是用户定义的规则清单,其中包含一条或多条规则.规则链及其生效时间/功能如下:</p>
<table>
<thead>
<tr>
<th align="center">链</th>
<th align="center">生效时间</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>PREROUTING</code></td>
<td align="center">数据包刚进入网络接口,路由之前</td>
<td align="center">对刚进如网络接口数据包进行路由选择,是流入本机还是由本机转发</td>
</tr>
<tr>
<td align="center"><code>INPUT</code></td>
<td align="center">数据包从内核流入用户空间</td>
<td align="center">对流入用户空间的包应用规则,是拒绝,丢弃还是接受</td>
</tr>
<tr>
<td align="center"><code>FORWARD</code></td>
<td align="center">数据包在内核空间中,从一个网络接口进入,另一个网络接口出去</td>
<td align="center">对由本机转发的数据包应用规则</td>
</tr>
<tr>
<td align="center"><code>OUTPUT</code></td>
<td align="center">数据包从用户空间流出到内核空间</td>
<td align="center">对从用户空间流出到内核空间的数据包应用规则</td>
</tr>
<tr>
<td align="center"><code>POSTROUTING</code></td>
<td align="center">数据包离开网络接口前</td>
<td align="center">对离开本机前的数据包进行路由选择</td>
</tr>
</tbody></table>
<h3 id="数据包的传输过程"><a href="#数据包的传输过程" class="headerlink" title="数据包的传输过程"></a>数据包的传输过程</h3><ol>
<li>当一个数据包流入本机网卡时,它首先进入 <code>PREROUTING</code> 链,内核根据数据包目的 IP 判断是否需要转发出去</li>
<li>如果数据包就是进入本机的,它将会到达 <code>INPUT</code> 链.<code>INPUT</code> 链规则接受该数据包后,相关进程就会收到它,进行处理后发送响应数据包,响应数据包会经过 <code>OUTPUT</code> 链,然后到 <code>POSTROUTING</code> 链后流出本机.</li>
<li>如果数据包是要转发出去的,且内核允许转发(通过 <code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code> 开启).数据包就会经过 <code>FORWARD</code> 链,到达 <code>POSTROUTING</code> 链后流出本机</li>
</ol>
<p><img src="/images/packet-flow.svg" alt="数据包流向"></p>
<p><img src="/images/packet-flow.png" alt="数据包流向"></p>
<h2 id="使用-iptables-管理防火墙规则"><a href="#使用-iptables-管理防火墙规则" class="headerlink" title="使用 iptables 管理防火墙规则"></a>使用 iptables 管理防火墙规则</h2><p>iptables 仅作为 Linux 防火墙管理工具,让人们更加便捷,直观的管理 Linux 主机防火墙.</p>
<p>iptables 设置规则的基本语法格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables [-t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转]</span><br><span class="line"></span><br><span class="line">Usage: iptables -[ACD] chain rule-specification [options]</span><br><span class="line">       iptables -I chain [rulenum] rule-specification [options]</span><br><span class="line">       iptables -R chain rulenum rule-specification [options]</span><br><span class="line">       iptables -D chain rulenum [options]</span><br><span class="line">       iptables -[LS] [chain [rulenum]] [options]</span><br><span class="line">       iptables -[FZ] [chain] [options]</span><br><span class="line">       iptables -[NX] chain</span><br><span class="line">       iptables -E old-chain-name new-chain-name</span><br><span class="line">       iptables -P chain target [options]</span><br><span class="line">       iptables -h (print this help information)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables --help</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 常用选项</span><br><span class="line">-n, --number: 显示防火墙规则链的序号</span><br><span class="line">-t &lt;TABLE&gt;: 指定表,默认表为 filter</span><br><span class="line">-L, --list: 列出表下的防火墙规则链</span><br><span class="line">-F, --flush: 清空防火墙规则链中所有条目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 命令选项</span><br><span class="line">-P &lt;chain&gt; &lt;target&gt;: 指定默认的</span><br><span class="line">-N &lt;chain&gt;: 创建新规则链</span><br><span class="line">-E &lt;old_chain&gt; &lt;new_chain&gt;: 重命名规则链</span><br><span class="line"></span><br><span class="line">-A &lt;chain&gt; &lt;rule&gt;: 向规则链中追加规则</span><br><span class="line">-A &lt;chain&gt; &lt;rule_num&gt;: 删除规则链中指定规则</span><br><span class="line">-I &lt;chain&gt; [rule_num] &lt;rule&gt;: 向规则链中插入规则,默认在最开始插入规则</span><br><span class="line">-D &lt;chain&gt; [rule_num]: 删除指定规则,默认删除 num&#x3D;1 的规则</span><br><span class="line">-R &lt;chain&gt; &lt;rule_num&gt; &lt;rule&gt;: 将规则链中指定规则</span><br><span class="line"></span><br><span class="line">-L [chain [rule_num]]: 列出指定链的防火墙规则.默认为表中所有</span><br><span class="line">-S [chain [rule_num]]: 列出指定链的防火墙规则.默认为表中所有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 条件匹配</span><br><span class="line">--- 基本匹配 ---</span><br><span class="line">[!] -s, --src, --source: 检查源 IP</span><br><span class="line">[!] -d, --dst, --destination: 检查目标 IP</span><br><span class="line">[!] -p, --protocol &#123;tcp|udp|icmp&#125;: 检查报文协议</span><br><span class="line">-i, --in-interface IFACE: 数据报文的流入接口.仅能用于 PREROUTING,INPUT 及 FORWARD 链上</span><br><span class="line">-o, --out-interface IFACE: 数据报文的流出接口.仅能用于 FORWARD,OUTPUT 及 POSTROUTING 链上</span><br><span class="line"></span><br><span class="line">--- 隐式扩展匹配 ---</span><br><span class="line">-p &#123;tcp|udp&#125;</span><br><span class="line">    --dport PORT[-PORT]: 检查目标端口</span><br><span class="line">    --sport PORT[-PORT]: 检查源端口</span><br><span class="line">-p icmp</span><br><span class="line">    --icmp-type: icmp 类型,0-8</span><br><span class="line"></span><br><span class="line">--- 显示扩展匹配,需要显示使用 -m 显示指定 ---</span><br><span class="line">-m multiport: 多端口扩展</span><br><span class="line">    [!] --source-ports,--sports port[,port|,port:port]...：指明多个源端口</span><br><span class="line">    [!] --destination-ports,--dports port[,port|,port:port]...：指明多个离散的目标端口</span><br><span class="line">    [!] --ports port[,port|,port:port]...</span><br><span class="line"></span><br><span class="line">-m iprange: 指定 ip 地址范围</span><br><span class="line">    [!] --src-range from[-to]：指明连续的源 IP 地址范围</span><br><span class="line">    [!] --dst-range from[-to]：指明连续的目标 IP 地址范围</span><br><span class="line"></span><br><span class="line">-m string: 指定报文内容出现的字符串</span><br><span class="line">    [!] --string pattern: 指定字符正则表达式</span><br><span class="line"></span><br><span class="line">-m time扩展: 指定时间范围</span><br><span class="line">    --datestart</span><br><span class="line">    --datestop</span><br><span class="line">    --timestart</span><br><span class="line">    --timestop</span><br><span class="line">    --monthdays</span><br><span class="line">    --weekdays</span><br><span class="line"></span><br><span class="line">-m connlimit: 指定并发连接数</span><br><span class="line">    --connlimit-above n：连接的数量大于 n</span><br><span class="line">    --connlimit-upto n: 连接的数量小于等于 n</span><br><span class="line"></span><br><span class="line">-m limit: 报文收发速率</span><br><span class="line">    --limit rate[&#x2F;second|&#x2F;minute|&#x2F;hour|&#x2F;day]: 限制速率</span><br><span class="line">    --limit-burst number: 限制并发量</span><br><span class="line"></span><br><span class="line">-m state: 根据连接追踪机制检查连接的状态</span><br><span class="line">    --state &#123;NEW,ESTABLISHED,RELATED,INVALIED&#125;: 指定连接状态,一个或多个</span><br><span class="line"></span><br><span class="line"># 目标或动作</span><br><span class="line">-j TARGET: 跳转至指定的 TARGET</span><br><span class="line">   ACCEPT: 接受</span><br><span class="line">   DROP: 丢弃,不回应任何信息</span><br><span class="line">   REJECT: 拒绝,回应拒绝信息</span><br><span class="line">   RETURN: 返回调用链</span><br><span class="line">   REDIRECT: 端口重定向</span><br><span class="line">   LOG: 在 &#x2F;var&#x2F;log&#x2F;messages 文件中记录日志信息,然后将数据包传递给下一条规则</span><br><span class="line">   MARK: 做防火墙标记</span><br><span class="line">   DNAT --to: 目标地址转换</span><br><span class="line">   SNAT: 源地址转换</span><br><span class="line">   MASQUERADE: 地址伪装</span><br><span class="line">   ...</span><br><span class="line">   自定义链：由自定义链上的规则进行匹配检查</span><br></pre></td></tr></table></figure>

<h2 id="常用-iptables-规则链"><a href="#常用-iptables-规则链" class="headerlink" title="常用 iptables 规则链"></a>常用 iptables 规则链</h2><ul>
<li>允许 ssh 连接,仅开放 22 端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅对指定网段开放 22 端口</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性开放多端口 22,80,443</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>允许 ping</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从外部向内部 ping</span></span><br><span class="line">iptables -A INPUT -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-reply -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从内部向外部 ping</span></span><br><span class="line">iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type <span class="built_in">echo</span>-reply -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>防止 DDOS 攻击</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 25/minute --<span class="built_in">limit</span>-burst 100 -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>设置端口转发</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>记录丢弃的包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -N LOGGING</span><br><span class="line">iptables -A LOGGING -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 2/min -j LOG --<span class="built_in">log</span>-prefix <span class="string">"IPTables Packet Dropped: "</span> --<span class="built_in">log</span>-level 7</span><br><span class="line">iptables -A LOGGING -j DROP</span><br><span class="line">iptables -A INPUT -j LOGGING</span><br></pre></td></tr></table></figure>

<h2 id="iptables-性能优化技巧"><a href="#iptables-性能优化技巧" class="headerlink" title="iptables 性能优化技巧"></a>iptables 性能优化技巧</h2><p>合理的配置 iptables 规则可以保护我们的内部主机.但是当 iptables 规则设置不合理时,可能会造成服务不可访问或服务性能下降.因此在使用 iptables 配置防火墙规则时,应注意如下几点:</p>
<ul>
<li>安全放行所有 ESTABLISHED 状态连接,建议放在第一条,效率更高</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -I OUTPUT -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>尽可能将可由一条规则能够描述的多个规则合并为一条规则,如添加多个端口/IP 访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -m iprange --src-range 192.168.0.10-192.168.0.20 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -m iprange --src-range 192.168.0.10-192.168.0.20 -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>有特殊目的限制访问功能要在放行规则之前加以拒绝</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对服务器限制发送带有 *iqiyi.com 的报文</span></span><br><span class="line">iptables -I OUTPUT 2 -m string --string <span class="string">"*iqiyi.com"</span> --algo kmp -j REJECT</span><br></pre></td></tr></table></figure>

<ul>
<li>谨慎放行入站的新请求</li>
<li>在规则最后添加默认策略</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -P DROP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>面试</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS Nginx HAProxy 负载均衡器对比分析</title>
    <url>/2020/06/04/lvs-nginx-haproxy/</url>
    <content><![CDATA[<blockquote>
<p>LVS</p>
</blockquote>
<ul>
<li>LVS 工作在 OSI 模型第 4 层,基于内核实现,没有额外流量的产生,性能最好</li>
<li>配置性低,无需配置文件,只是提供了 <code>ipadm</code> 命令行工具对 ipvs 规则进行设置与配置</li>
</ul>
<blockquote>
<p>Nginx</p>
</blockquote>
<ul>
<li>Nginx 工作在 OSI 模型第七层</li>
<li>安装配置较为简单,支持正则表达式匹配,能够针对 http 应用层做一些分流策.</li>
<li>高性能,可承担高并发压力</li>
<li>同时也是功能强大的 Web 应用服务器</li>
</ul>
<blockquote>
<p>HAProxy</p>
</blockquote>
<ul>
<li>专业级负载均衡软件,工作在 OSI 模型第 4/7 层</li>
<li>相较于 Nginx 有更出色的负载均衡速度,在并发处理上也优于 Nginx.但在正则表达式支持上较弱</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>LVS</tag>
        <tag>Haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>logrus 快速开始</title>
    <url>/2021/11/02/logrus-quick-start/</url>
    <content><![CDATA[<p>我们日常使用 go 提供的 <code>log</code> 标准库可能过于简单了.因此有了很多基于标准库二次开发的第三方日志库.<a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener"><code>logrus</code></a> 就是其中一个.<code>logrus</code> 完全兼容标准的<code>log</code> 库,还支持文本、JSON 两种日志输出格式.很多知名的开源项目都使用了这个库,如 <a href="https://github.com/moby/moby" target="_blank" rel="noopener"><code>docker</code></a>, <a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener"><code>etcd</code></a> 等.</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>logrus</code> 的使用非常简单,与标准库log类似.但 <code>logrus</code> 支持更多的日志级别: <code>Trace</code>,<code>Debug</code>,<code>Info</code>,<code>Warn</code>,<code>Error</code>,<code>Fatal</code>,<code>Panic</code>.默认为<code>Info</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logrus.Debug(<span class="string">"debug msg"</span>)</span><br><span class="line">  logrus.Info(<span class="string">"info msg"</span>)</span><br><span class="line">  logrus.Warn(<span class="string">"warn msg"</span>)</span><br><span class="line">  logrus.Error(<span class="string">"error msg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出如下:</span></span><br><span class="line"><span class="comment">INFO[0000] info msg</span></span><br><span class="line"><span class="comment">WARN[0000] warn msg</span></span><br><span class="line"><span class="comment">ERRO[0000] error msg</span></span><br><span class="line"><span class="comment">FATA[0000] fatal msg</span></span><br><span class="line"><span class="comment">exit status 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>可以看到输出内容很简陋.因此我们可以对 <code>logrus</code>进行定制.</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p><code>logrus</code> 提供了众多函数对日志的输出格式进行定制.如:</p>
<ul>
<li>日志的输出级别</li>
<li>日志使用文本格式还是 JSON 格式</li>
<li>日志带有时间戳</li>
<li>日志输出到指定文件中或直接输出到日志处理工具中</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们可以自行调用 New 或 StandardLogger 方法,产生一个默认的 Logger 对象.以下所有包函数都是通过调用此对象的方法来实现的.New 方法见如下实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Logger</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StandardLogger</span><span class="params">()</span> *<span class="title">Logger</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志格式化输出的格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFormatter</span><span class="params">(formatter Formatter)</span></span></span><br><span class="line"><span class="comment">// 设置日志的默认级别</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetLevel</span><span class="params">(level Level)</span></span></span><br><span class="line"><span class="comment">// 设置日志的输出位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetOutput</span><span class="params">(out io.Writer)</span></span></span><br><span class="line"><span class="comment">// 设置日志是否记录调用的位置,此函数会显示日志调用的位置,多用于调试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetReportCaller</span><span class="params">(include <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持在日志的前面添加一些字段.返回 Entry 对象,该对象是实际产生日志的对象.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithField</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Entry</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithFields</span><span class="params">(fields Fields)</span> *<span class="title">Entry</span></span></span><br></pre></td></tr></table></figure>

<p>以上大多都是直接调用包函数来完成相关配置的.其实在 <code>logrus</code> 包中有一个默认的 <code>logrus.Logger</code> 对象.所有其他的包函数都是调用其相关方法实现的.其定义方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/sirupsen/logrus/blob/v1.8.1/logger.go#L84</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Logger&#123;</span><br><span class="line">    <span class="comment">// 输出到 stderr,日志格式为 TextFormatter,日志级别为 info,不记录调用的位置等</span></span><br><span class="line">    Out:          os.Stderr,</span><br><span class="line">    Formatter:    <span class="built_in">new</span>(TextFormatter),</span><br><span class="line">    Hooks:        <span class="built_in">make</span>(LevelHooks),</span><br><span class="line">    Level:        InfoLevel,</span><br><span class="line">    ExitFunc:     os.Exit,</span><br><span class="line">    ReportCaller: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p><code>logrus</code> 提供了 <code>JSONFormatter</code> 和 <code>TextFormatter</code> 来分别实现日志 JSON 和 文本 格式的输出.它们都实现了 <code>Formatter</code> 接口.因此,后续我们也可以自己编写对应的 <code>Formatter</code> 对象</p>
<p><code>JSONFormatter</code> 和 <code>TextFormatter</code> 中都定义了日志输出的各种参数.可以通过配置这些成员变量来配置日志的格式.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TextFormatter&#123;</span><br><span class="line">  <span class="comment">// 是否显示日志时间</span></span><br><span class="line">  FullTimestamp: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 日志时间格式</span></span><br><span class="line">  TimestampFormat: <span class="string">"2006-01-02 15:04:05"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>同时,对于输出位置来说,我们可以使用  <code>SetOutput</code> 函数进行修改,将日志输出到文件中.如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"io"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  stdout := os.Stdout</span><br><span class="line">  logfile, err := os.OpenFile(<span class="string">"log.txt"</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0755</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"create file log.txt failed: %v"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logrus.SetOutput(io.MultiWriter(stdout, logfile))</span><br><span class="line">  logrus.Info(<span class="string">"info msg"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><p>有时,我们会添加一字段到日志中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logrus.WithFields(logrus.Fields&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"dj"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">  &#125;).Info(<span class="string">"info msg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// time="2021-11-02T15:52:03+08:00" level=info msg="info msg" age=18 name=dj</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义-Formatter"><a href="#自定义-Formatter" class="headerlink" title="自定义 Formatter"></a>自定义 Formatter</h2><p>除了 <code>logrus</code> 包中定义的两种 <code>Formatter</code> 外,我们可以自定义 <code>Formatter</code>.只需要实现如下接口即可.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Formatter <span class="keyword">interface</span> &#123;</span><br><span class="line">  Format(*Entry) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下是<a href="https://pkg.go.dev/github.com/sirupsen/logrus" target="_blank" rel="noopener">文档</a>中提供的一种自定义的 <code>Formatter</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyJSONFormatter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *MyJSONFormatter)</span> <span class="title">Format</span><span class="params">(entry *logrus.Entry)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">  serialized, err := json.Marshal(entry.Data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Failed to marshal fields to JSON, %w"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">append</span>(serialized, <span class="string">'\n'</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  logrus.SetFormatter(<span class="built_in">new</span>(MyJSONFormatter))</span><br><span class="line">  logrus.WithFields(logrus.Fields&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"MyJSONFormatter"</span>,</span><br><span class="line">    <span class="string">"msg"</span>:  <span class="string">"message"</span>,</span><br><span class="line">  &#125;).Info(<span class="string">"my json format"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;"msg":"message","name":"MyJSONFormatter"&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面的示例可以看到, <code>Format()</code> 接口方法中包含 <code>Entry</code> 对象.其定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">  Logger *Logger</span><br><span class="line">  Data Fields  <span class="comment">// 用户自定义的字段数据</span></span><br><span class="line">  Time time.Time  <span class="comment">// 日志 entry 被创建的日期</span></span><br><span class="line">  Level Level  <span class="comment">// 日志 entry 的级别</span></span><br><span class="line">  Caller *runtime.Frame  <span class="comment">// 产生日志的位置.包含包名</span></span><br><span class="line">  Message <span class="keyword">string</span> <span class="comment">// 日志信息</span></span><br><span class="line">  Buffer *bytes.Buffer</span><br><span class="line">  Context context.Context <span class="comment">// 上下文</span></span><br><span class="line">  <span class="comment">// 其他被过滤的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>有这么一种需求,对不同的级别的日志,我希望能够输出到不同的位置.该怎么实现呢? <code>logrus</code> 提供了对日志级别的 <code>hooks</code> 机制.它可以对不同级别日志添加不同的 <code>hooks</code>.从而实现不同的需求.</p>
<p><code>logrus</code> 提供了两种 hooks. <code>writer</code> 和 <code>SyslogHook</code>.可以实现不同的功能</p>
<h3 id="writer"><a href="#writer" class="headerlink" title="writer"></a>writer</h3><p>参见 <a href="https://github.com/sirupsen/logrus/tree/v1.8.1/hooks/writer" target="_blank" rel="noopener">github</a> 的一个示例,将不同级别的日志写入到不同的日志文件中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  log <span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line">  <span class="string">"github.com/sirupsen/logrus/hooks/writer"</span></span><br><span class="line">  <span class="string">"io/ioutil"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.SetOutput(ioutil.Discard)</span><br><span class="line">  log.SetFormatter(&amp;log.TextFormatter&#123;</span><br><span class="line">    TimestampFormat: <span class="string">"2006-01-02 15:03:04"</span>,</span><br><span class="line">    FullTimestamp:   <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  errlog, err := os.OpenFile(<span class="string">"err.log"</span>, os.O_APPEND|os.O_CREATE|os.O_RDWR, <span class="number">0644</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> errlog.Close()</span><br><span class="line">  infolog, err := os.OpenFile(<span class="string">"info.log"</span>, os.O_APPEND|os.O_CREATE|os.O_RDWR, <span class="number">0644</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> infolog.Close()</span><br><span class="line"></span><br><span class="line">  log.AddHook(&amp;writer.Hook&#123; <span class="comment">// Send logs with level higher than warning to errlog</span></span><br><span class="line">    Writer: errlog,</span><br><span class="line">    LogLevels: []log.Level&#123;</span><br><span class="line">      log.PanicLevel,</span><br><span class="line">      log.FatalLevel,</span><br><span class="line">      log.ErrorLevel,</span><br><span class="line">      log.WarnLevel,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  log.AddHook(&amp;writer.Hook&#123; <span class="comment">// Send info and debug logs to infolog</span></span><br><span class="line">    Writer: infolog,</span><br><span class="line">    LogLevels: []log.Level&#123;</span><br><span class="line">      log.InfoLevel,</span><br><span class="line">      log.DebugLevel,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  log.Info(<span class="string">"This will go to info.log"</span>)</span><br><span class="line">  log.Warn(<span class="string">"This will go to err.log"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="syslogHook"><a href="#syslogHook" class="headerlink" title="syslogHook"></a>syslogHook</h3><p>参见 <a href="https://github.com/sirupsen/logrus/tree/v1.8.1/hooks/syslog" target="_blank" rel="noopener">github</a> 将日志输出到 <code>syslog</code> 第三方日志处理工具中.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"log/syslog"</span></span><br><span class="line">  <span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line">  lSyslog <span class="string">"github.com/sirupsen/logrus/hooks/syslog"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log       := logrus.New()</span><br><span class="line">  hook, err := lSyslog.NewSyslogHook(<span class="string">"udp"</span>, <span class="string">"localhost:514"</span>, syslog.LOG_INFO, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Hooks.Add(hook)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它类似的 <code>hooks</code> 还有</p>
<ul>
<li><a href="https://github.com/bshuster-repo/logrus-logstash-hook" target="_blank" rel="noopener">logrus-logstash-hook</a></li>
<li><a href="https://github.com/evalphobia/logrus_fluent" target="_blank" rel="noopener">logrus_fluent</a></li>
<li><a href="https://github.com/abramovic/logrus_influxdb" target="_blank" rel="noopener">logrus_influxdb</a></li>
<li><a href="https://github.com/gemnasium/logrus-postgresql-hook" target="_blank" rel="noopener">logrus-postgresql-hook</a></li>
<li><a href="https://github.com/gfremex/logrus-kafka-hook" target="_blank" rel="noopener">logrus-kafka-hook</a></li>
<li><a href="https://github.com/rogierlommers/logrus-redis-hook" target="_blank" rel="noopener">logrus-redis-hook</a></li>
</ul>
<hr>
<p>参考:</p>
<ul>
<li><a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">github - logrus</a></li>
<li><a href="https://pkg.go.dev/github.com/sirupsen/logrus" target="_blank" rel="noopener">logrus package - github.com/sirupsen/logrus - pkg.go.dev</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/105759117" target="_blank" rel="noopener">Go 每日一库之 logrus - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>3rd</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS 三种工作模式与负载均衡算法</title>
    <url>/2020/06/04/lvs-working-mode/</url>
    <content><![CDATA[<h2 id="LVS-简介"><a href="#LVS-简介" class="headerlink" title="LVS 简介"></a>LVS 简介</h2><p>LVS(Linux Virtual Server) 是由章文嵩博士主导的开源负载均衡项目,在 2.6 的及以后内核版本中已将 LVS 集成于内核模块中.该项目在 Linux 内核中实现了基于 IP 的数据请求负载均衡调度方案,其应用场景如图 1 所示:</p>
<p><img src="/images/lvs-use-cases.jpg" alt="LVS 应用场景"></p>
<p>互联网用户从外部访问公司的外部负载均衡服务器,终端用户的 Web 请求会发送给 LVS 调度器,调度器根据自己预设的算法决定将该请求发送给后端的某台 Web 服务器,比如,轮询算法可以将外部的请求平均分发给后端的所有服务器,终端用户访问 LVS 调度器虽然会被转发到后端真实的服务器,但如果真实服务器连接的是相同的存储,提供的服务也是相同的服务,最终用户不管是访问哪台真实服务器,得到的服务内容都是一样的,整个集群对用户而言都是透明的.根据 LVS 工作模式的不同,真实服务器会选择不同的方式将用户需要的数据发送到终端用户.LVS 工作模式分为 NAT 模式,IP 隧道(TUN)模式,以及直接路由(DR)模式.</p>
<p>Linux 操作系统提供了 <code>ipvsadm</code> 管理工具来管理 LVS 规则.其常用选项及参数有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A, --add-service     添加一个新的虚拟服务</span><br><span class="line">-E, --edit-service    编辑虚拟服务</span><br><span class="line">-D, --delete-service  删除虚拟服务</span><br><span class="line">-C, --clear           清除所有的虚拟服务规则</span><br><span class="line">-R, --restore         恢复虚拟服务规则</span><br><span class="line">-a, --add-server      在虚拟服务中添加一个真实服务器</span><br><span class="line">-r, --real-server     指定 Real Server</span><br><span class="line">-e, --edit-server     编辑某个真实服务器</span><br><span class="line">-d, --delete-server   删除某个真实服务器</span><br><span class="line">-L, -l, --list        显示内核中的虚拟服务规则</span><br><span class="line">-n, --numeric         以数字形式显示IP端口</span><br><span class="line">-c, --connection      显示 ipvs 中目前存在的连接,也可以用于分析调度情况</span><br><span class="line">-Z, --zero            将转发消息的统计清零</span><br><span class="line">-p, --persistent      配置持久化时间</span><br><span class="line">--set tcp tcpfin udp  配置超时时间(tcp&#x2F;tcpfin&#x2F;udp)</span><br><span class="line">-t | -u               TCP&#x2F;UDP 协议的虚拟服务</span><br><span class="line">-g | -m | -i          设置 LVS 模式为: DR | NAT | TUN</span><br><span class="line">-w        配置真实服务器的权重</span><br><span class="line">-s        配置负载均衡算法，如:rr, wrr, lc 等</span><br><span class="line">--timeout 显示配置的tcp&#x2F;tcpfin&#x2F;udp超时时间</span><br><span class="line">--stats   显示历史转发消息统计（累加值）</span><br><span class="line">--rate    显示转发速率信息(瞬时值)</span><br></pre></td></tr></table></figure>

<h2 id="LVS-三种工作模式"><a href="#LVS-三种工作模式" class="headerlink" title="LVS 三种工作模式"></a>LVS 三种工作模式</h2><p>首先了解以下缩写:</p>
<ul>
<li>DS：Director Server 前端负载均衡器节点</li>
<li>RS：Real Server 后端真实的工作服务器</li>
<li>VIP：DS 上的虚拟 IP 地址,直接面向用户请求</li>
<li>DIP：DS 内网 IP 地址,主要用于和内部主机通讯</li>
<li>RIP：Real Server IP,后端服务器的 IP 地址</li>
<li>CIP：Client IP,访问客户端的IP地址</li>
</ul>
<h3 id="NAT-模式"><a href="#NAT-模式" class="headerlink" title="NAT 模式"></a>NAT 模式</h3><p>NAT(Network Address Translation)即网络地址转换,包括 SNAT(源地址转换) 与 DNAT(目标地址转换).它通过修改请求报文的目标 IP 地址(同时可能会修改目标端口)挑选出某台 Real Server 的 RIP 地址实现转发.在请求与响应过程中期间,无论是进来的流量,还是出去的流量,都必须经过 LVS 负载均衡器.</p>
<ol>
<li>客户端将请求发往负载均衡器,请求报文源地址是 CIP,目标地址为 VIP</li>
<li>负载均衡器通过地址转换,将客户端发来的数据包转发至后端 RIP</li>
<li>RS 处理完成后响应对负载均衡器返回响应数据</li>
<li>负载均衡器通过地址转换,将 RS 的响应数据响应给客户端</li>
</ol>
<p><img src="/images/lvs-NAT.jpg" alt="LVS NAT"></p>
<blockquote>
<p>注意: RIP 与 DIP 需要在同一网络,且 RIP 网关必须指向 DIP</p>
</blockquote>
<ul>
<li>优点: 只需要暴露出一个 VIP 地址即可,对用户来说后端服务器是完全透明的</li>
<li>缺点: 当 RS 节点增长过多时,负载均衡器将成为性能瓶颈,速度会变慢</li>
</ul>
<h3 id="IP-隧道-TUN-模式"><a href="#IP-隧道-TUN-模式" class="headerlink" title="IP 隧道(TUN)模式"></a>IP 隧道(TUN)模式</h3><p>负载均衡器把客户端发来的数据包,封装一个新的 IP 头标记(仅目的IP)发给 RS.RS 收到后,先把数据包的头解开,还原数据包,处理后,直接返回给客户端,不需要再经过负载均衡器</p>
<ol>
<li>客户端将请求发往负载均衡器,请求报文源地址是 CIP,目标地址为 VIP</li>
<li>负载均衡器将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为DIP,目标地址改为RIP,并通过 IP 隧道技术将报文发给 RS</li>
<li>RS 收到后,先把数据包头解开,还原数据包,处理后,直接返回给客户端,不需要再经过负载均衡器</li>
</ol>
<p><img src="/images/lvs-TUN.jpg" alt="LVS TUN"></p>
<ul>
<li>优点: 减少负载均衡器压力,负载均衡器不再是系统的瓶颈,能够处理更多的请求流量</li>
<li>缺点: RS 节点需要合法 IP,且需要所有服务器支持 <code>IP Tunneling</code>(IP Encapsulation)协议,因此服务器可能只局限于部分 Linux 系统上</li>
</ul>
<h3 id="直接路由-DR-模式"><a href="#直接路由-DR-模式" class="headerlink" title="直接路由(DR)模式"></a>直接路由(DR)模式</h3><p>负载均衡器和 RS 都使用同一个 IP 对外服务,但只有负载均衡器对 ARP 请求进行响应.负载均衡器收到数据包后根据调度算法,找出对应的RS,把目的 MAC 地址改为 RS 的 MAC(IP一致),并将请求分发给这台RS.RS 收到数据包并处理完成之后,由于 IP 一致,可以直接将数据返给客户端,与直接从客户端收到这个数据包无异,处理后直接返回给客户端</p>
<ol>
<li>客户端将请求发往前端的负载均衡器,请求报文源地址是 CIP,目标地址为 VIP</li>
<li>负载均衡器将客户端请求报文的源 MAC 地址改为自己的 MAC 地址,目标 MAC 改为了 RS 的 MAC 地址,并将此包发送给 RS</li>
<li>处理完请求报文后,由于 RS 与 负载均衡器有具有同一 VIP,会将响应报文直接发送给客户端</li>
</ol>
<p><img src="/images/lvs-DR.jpg" alt="LVS DR"></p>
<ul>
<li>优点: 与隧道模式一样,负载均衡器也只是分发请求,应答包通过单独的路由方法返回给客户端.同时,不需要隧道结构,可以使用大多数服务器作为 RS</li>
<li>缺点：要求 VIP 必须与物理网卡在一个物理段上,否则 ARP 不能寻到不同网段的 MAC 地址.也就是说所有 RS 节点和调度器 LB 只能在一个局域网里面</li>
</ul>
<h2 id="LVS-负载均衡算法"><a href="#LVS-负载均衡算法" class="headerlink" title="LVS 负载均衡算法"></a>LVS 负载均衡算法</h2><ul>
<li>RR(Round Robin Scheduling): 轮询调度算法,将请求依次分配给不同的 RS 节点,RS 节点均摊请求.适用于 RS 节点性能差不多的情况</li>
<li>WRR(Weighted Round-Robin Scheduling): 加权轮询调度算法,按照 RS 的权重将请求分发给不同的 RS 节点, RS 节点按照权重比分摊请求.</li>
<li>WLC(Weighted Least-Connection Scheduling): 加权最小连接数调度算法, 假设 RS 权重为 Wi,当前连接数为 Ti,则选择 Ti/Wi 最小的 RS 节点作为下一个调度节点</li>
<li>DH(Destination Hashing Scheduling): 目标地址哈希调度算法,以目标地址为关键字做 hash 获取 RS 调度节点</li>
<li>SH(Source Hashing Scheduling): 源地址哈希调度算法,以源地址为关键字做 hash 来获取 RS 调度节点</li>
<li>LC(Least-Connection Scheduling): 最小连接数调度算法,IPVS 表存储了所有活动的连接,负载均衡器会进行比较,将连接请求发送到当前连接最少的 RS</li>
<li>LBLC(Locality-Based Least Connections Scheduling): 基于地址的最小连接数调度算法,将来自同一个目的地址的请求分配给同一台 RS.如果 RS 满负荷,则将这个请求分配给连接数最小的 RS,并以它作为下一次分配的首先考虑</li>
<li>LBLCLR(Locality-Based Least Connectio ns with Replication Scheduling):带复制的基于局部最少链接,先根据请求的目标 IP 地址找出该目标 IP 地址对应的服务器组,按最小连接原则从该服务器组中选出一台服务器,若服务器没有超载,将请求发送到该服务器,否则按最小连接原则从整个集群中选出一台服务器,将该服务器加入到服务器组中,将请求发送到该服务器.同时,当该服务器组有一段时间没有被修改,将最忙的服务器从服务器组中删除,以降低复制的程度.</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>面试</tag>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB Cluster 集群安装</title>
    <url>/2021/03/27/mysql-innode-cluseter-install/</url>
    <content><![CDATA[<p>MySQL InnoDB Cluster 为MySQL 提供了完整的高可用性解决方案.通过使用 MySQL Shell 附带的 AdminAPI,您可以轻松地配置和管理一组至少三个 MySQL 服务器实例,以充当 InnoDB 集群.</p>
<p>每个 MySQL 服务器实例都运行MySQL Group Replication,它提供了具有内置故障转移功能的 InnoDB Clusters 中复制数据的机制,消除了直接在 InnoD B群集中使用组复制的需要.</p>
<p>整个集群环境如下:</p>
<p><img src="/images/MySQL-InnoDB-Cluster.png" alt="MySQL InnoDB Cluster 概述"></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><table>
<thead>
<tr>
<th align="left">server id</th>
<th align="left">IP</th>
<th align="left">主机名</th>
<th align="left">部署应用</th>
<th align="left">应用版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">10.71.1.31</td>
<td align="left">mysql-1</td>
<td align="left">mysql-cluster,mysql-router,mysql-shell</td>
<td align="left">8.0.21</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">10.71.1.32</td>
<td align="left">mysql-2</td>
<td align="left">mysql-cluster,mysql-router,mysql-shell</td>
<td align="left">8.0.21</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">10.71.1.33</td>
<td align="left">mysql-3</td>
<td align="left">mysql-cluster,mysql-router,mysql-shell</td>
<td align="left">8.0.21</td>
</tr>
</tbody></table>
<p>以上三台设备都下载了 <a href="https://dev.mysql.com/downloads/cluster/" target="_blank" rel="noopener">mysql-cluster</a>,<a href="https://downloads.mysql.com/archives/router/" target="_blank" rel="noopener">mysql-router</a>,<a href="https://downloads.mysql.com/archives/shell/" target="_blank" rel="noopener">mysql-shell</a> 对应版本的安装包,解压到 <code>/usr/local/</code> 对应目录下.</p>
<h2 id="安装-MySQL-Cluster"><a href="#安装-MySQL-Cluster" class="headerlink" title="安装 MySQL Cluster"></a>安装 MySQL Cluster</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>mysql-cluster 配置文件如下.之后需要修改的配置包括</p>
<ul>
<li><code>server_id</code>: 集群主机的唯一标识</li>
<li><code>loose-group_replication_local_address</code>: 集群主机的本地 IP 地址及 replication 的端口</li>
<li><code>report_host</code>: 集群主机的本地 IP 地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">port            &#x3D; 3306</span><br><span class="line">socket          &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;tmp&#x2F;mysql.sock</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">socket          &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;tmp&#x2F;mysql.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">user                            &#x3D; mysql</span><br><span class="line">port                            &#x3D; 3306</span><br><span class="line">server_id                       &#x3D; 1</span><br><span class="line">basedir                         &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line">datadir                         &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;</span><br><span class="line">tmpdir                          &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;tmp&#x2F;</span><br><span class="line">socket                          &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;tmp&#x2F;mysql.sock</span><br><span class="line">slow_query_log                  &#x3D; ON</span><br><span class="line">slow_query_log_file             &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql-slow-queries.log</span><br><span class="line">long_query_time                 &#x3D; 10</span><br><span class="line">log_error                       &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;error.log</span><br><span class="line">log-bin                         &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;binlog&#x2F;mysql-bin.log</span><br><span class="line">pid-file                        &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;tmp&#x2F;mysql.pid</span><br><span class="line">character-set-server            &#x3D; utf8</span><br><span class="line">binlog_format                   &#x3D; ROW</span><br><span class="line">skip_name_resolve               &#x3D; on</span><br><span class="line">default-storage-engine          &#x3D; innodb</span><br><span class="line">max_connections                 &#x3D; 3000</span><br><span class="line">explicit_defaults_for_timestamp &#x3D; OFF</span><br><span class="line">gtid_mode                       &#x3D; on</span><br><span class="line">enforce_gtid_consistency&#x3D;on</span><br><span class="line">log-slave-updates&#x3D;on</span><br><span class="line"></span><br><span class="line">delayed_insert_limit &#x3D; 1000</span><br><span class="line">delayed_insert_timeout &#x3D; 3000</span><br><span class="line">delayed_queue_size &#x3D; 5000</span><br><span class="line"></span><br><span class="line">bulk_insert_buffer_size &#x3D;1024M</span><br><span class="line">concurrent_insert&#x3D;2</span><br><span class="line">thread_stack &#x3D;  32M</span><br><span class="line">event_scheduler &#x3D; ON</span><br><span class="line">lower_case_table_names&#x3D;1</span><br><span class="line">sort_buffer_size &#x3D; 600M</span><br><span class="line">net_buffer_length &#x3D;  1M</span><br><span class="line">read_rnd_buffer_size &#x3D; 600M</span><br><span class="line">tmp_table_size &#x3D; 600M</span><br><span class="line">max_heap_table_size &#x3D; 16M</span><br><span class="line">read_buffer_size&#x3D; 600M</span><br><span class="line">expire_logs_days &#x3D; 5</span><br><span class="line"></span><br><span class="line">#innodb</span><br><span class="line">sync_binlog&#x3D;1</span><br><span class="line">innodb_data_file_path &#x3D; ibdata1:10M:autoextend</span><br><span class="line">innodb_buffer_pool_size &#x3D; 1024M</span><br><span class="line">innodb_log_file_size &#x3D; 2047M</span><br><span class="line">innodb_log_buffer_size &#x3D; 8M</span><br><span class="line">innodb_flush_log_at_trx_commit &#x3D; 2</span><br><span class="line">innodb_lock_wait_timeout &#x3D; 50</span><br><span class="line">innodb_rollback_on_timeout &#x3D; ON</span><br><span class="line">innodb_file_per_table</span><br><span class="line">innodb_flush_method&#x3D;O_DIRECT</span><br><span class="line">innodb_open_files &#x3D; 65536</span><br><span class="line">innodb_io_capacity &#x3D; 1000</span><br><span class="line">innodb_read_io_threads &#x3D; 8</span><br><span class="line">innodb_write_io_threads  &#x3D; 1</span><br><span class="line">innodb_spin_wait_delay &#x3D; 96</span><br><span class="line">innodb_max_dirty_pages_pct &#x3D; 50</span><br><span class="line">innodb_sync_spin_loops &#x3D; 30</span><br><span class="line"></span><br><span class="line">#MYISAM</span><br><span class="line">key_buffer_size &#x3D;   1G</span><br><span class="line">myisam_sort_buffer_size &#x3D; 1G</span><br><span class="line">myisam_repair_threads&#x3D;2</span><br><span class="line"></span><br><span class="line"># innodb cluster</span><br><span class="line">transaction_write_set_extraction&#x3D;XXHASH64</span><br><span class="line">loose-group_replication_group_name&#x3D;&#39;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&#39;</span><br><span class="line">loose-group_replication_start_on_boot&#x3D;off</span><br><span class="line">loose-group_replication_ip_whitelist&#x3D;&#39;10.71.1.0&#x2F;24&#39;</span><br><span class="line">loose-group_replication_local_address&#x3D;&#39;10.71.1.31:33061&#39;</span><br><span class="line">loose-group_replication_group_seeds&#x3D;&#39;10.71.1.31:33061,10.71.1.32:33061,10.71.1.33:33061&#39;</span><br><span class="line">loose-group_replication_bootstrap_group&#x3D;off</span><br><span class="line">loose-group_replication_single_primary_mode&#x3D;on</span><br><span class="line">loose-group_replication_enforce_update_everywhere_checks&#x3D;off</span><br><span class="line">loose-group_replication_recovery_get_public_key&#x3D;on</span><br><span class="line">loose-group_replication_recovery_use_ssl&#x3D;off</span><br><span class="line">loose-group_replication_ssl_mode&#x3D;&#39;DISABLED&#39;</span><br><span class="line">loose-group_replication_consistency&#x3D;&#39;EVENTUAL&#39;</span><br><span class="line">loose-group_replication_member_expel_timeout&#x3D;5</span><br><span class="line">report_host&#x3D;&#39;10.71.1.31&#39;</span><br><span class="line">report_port&#x3D;3306</span><br><span class="line">plugin_load_add &#x3D;&#39;group_replication.so&#39;</span><br><span class="line">auto_increment_increment&#x3D;1</span><br><span class="line">auto_increment_offset&#x3D;1</span><br><span class="line">mysqlx_port&#x3D;33060</span><br><span class="line">admin_port&#x3D;33062</span><br></pre></td></tr></table></figure>

<h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><h4 id="添加用户-并授予权限"><a href="#添加用户-并授予权限" class="headerlink" title="添加用户,并授予权限"></a>添加用户,并授予权限</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf mysql-cluster-8.0.21-el7-x86_64.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">ln -s mysql-cluster-8.0.21-el7-x86_64 mysql</span><br><span class="line">mkdir mysql/&#123;data,<span class="built_in">log</span>,binlog,tmp&#125;</span><br><span class="line"></span><br><span class="line">groupadd mysql &amp;&amp; useradd -r -g mysql -s /bin/<span class="literal">false</span> mysql</span><br><span class="line">chown -R mysql:mysql /usr/<span class="built_in">local</span>/mysql/</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=/usr/local/mysql/bin:$PATH'</span> &gt;&gt; /etc/profile.d/mysql.sh</span><br><span class="line"><span class="built_in">source</span>  /etc/profile.d/mysql.sh</span><br></pre></td></tr></table></figure>

<h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/</span><br><span class="line">bin/mysqld --defaults-file=/etc/my.cnf --user=mysql -I</span><br><span class="line"><span class="comment"># 初始化数据库过程中,数据库密码会以随机字符串形式打印到 log/error.log 中</span></span><br><span class="line">tail <span class="built_in">log</span>/error.log</span><br><span class="line"><span class="comment"># 2021-03-27T01:23:19.648140Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: reOq-(AQ!6Mf</span></span><br></pre></td></tr></table></figure>

<h3 id="启动数据库并连接后修改密码"><a href="#启动数据库并连接后修改密码" class="headerlink" title="启动数据库并连接后修改密码"></a>启动数据库并连接后修改密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/mysqld_safe --defaults-file=/etc/my.cnf --user=mysql</span><br><span class="line"></span><br><span class="line">bin/mysql --defaults-file=/etc/my.cnf -u root -h localhost -p <span class="comment"># 输入 log.error.lor 中的密码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在所有节点上执行如下语句,修改密码</span></span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> super_read_only=<span class="keyword">OFF</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> read_only=<span class="keyword">OFF</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在所有节点上创建后续 mysql-router 引导启动时的用户并授权</span></span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这里提供了 mysqld 服务的启动脚本,使用 systemd 管理比较方便</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /usr/lib/systemd/system/mysqld.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=mysqld service</span><br><span class="line">Documentation=https://dev.mysql.com/doc/</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf --user=mysql</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h4 id="确认安装组复制插件-可能已经存在"><a href="#确认安装组复制插件-可能已经存在" class="headerlink" title="确认安装组复制插件(可能已经存在)"></a>确认安装组复制插件(可能已经存在)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在所有节点上执行如下语句</span></span><br><span class="line"><span class="keyword">INSTALL</span> <span class="keyword">PLUGIN</span> group_replication <span class="keyword">SONAME</span> <span class="string">'group_replication.so'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> PLUGIN_NAME, PLUGIN_STATUS <span class="keyword">FROM</span> INFORMATION_SCHEMA.PLUGINS  <span class="keyword">WHERE</span> PLUGIN_NAME <span class="keyword">LIKE</span> <span class="string">'%group_replication%'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建同步用户"><a href="#创建同步用户" class="headerlink" title="创建同步用户"></a>创建同步用户</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在所有节点上执行如下语句,创建组同步用户</span></span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`repl`</span>@<span class="string">`%`</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'repl'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> repl@<span class="string">'%'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> host, <span class="keyword">user</span>, authentication_string, <span class="keyword">plugin</span> <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_USER=<span class="string">'repl'</span>, MASTER_PASSWORD=<span class="string">'repl'</span> <span class="keyword">FOR</span> CHANNEL <span class="string">'group_replication_recovery'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> User_name,Channel_name <span class="keyword">FROM</span> mysql.slave_master_info <span class="keyword">WHERE</span> user_name = <span class="string">'repl'</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> group_replication_recovery_get_public_key=<span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="启动组复制"><a href="#启动组复制" class="headerlink" title="启动组复制"></a>启动组复制</h3><p>在此示例中,三个实例用于该组,这是创建组的最小实例数.可以添加更多实例将增加组的容错能力.例如,如果该组由三个成员组成,则在一个实例失败的情况下,该组可以继续.但是,如果发生另一个故障,该组将无法继续处理写事务.通过添加更多实例,在组继续处理事务时可能发生故障的服务器数量也会增加.一个组中最多可以使用 9 个实例。</p>
<h4 id="一些额外配置"><a href="#一些额外配置" class="headerlink" title="一些额外配置"></a>一些额外配置</h4><p>对于组复制,数据必须存储在InnoDB事务存储引擎中,使用其他存储引擎(包括临时 MEMORY 存储引擎)可能会导致组复制中的错误.可以设置如下 <code>disabled_storage_engines</code> 系统变量以防止其使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"># ...</span><br><span class="line">disabled_storage_engines&#x3D;&quot;MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY&quot;</span><br></pre></td></tr></table></figure>

<p>从 MySQL 8.0.21 开始,组复制支持二进制日志中校验和的存在,并且可以使用它们来验证某些通道上事件的完整性,因此可以使用默认设置.如不使用则可以设置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"># ...</span><br><span class="line">binlog_checksum&#x3D;NONE</span><br></pre></td></tr></table></figure>

<h4 id="引导组"><a href="#引导组" class="headerlink" title="引导组"></a>引导组</h4><p>当安装好三个节点后,首次启动组的过程称为引导.您可以使用 <code>group_replication_bootstrap_group</code> 系统变量来引导组.<strong>引导程序只能由一台服务器(启动该组的服务器)执行一次,并且只能执行一次.</strong></p>
<ul>
<li>连接到节点 1 并发出以下语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅在节点 1 上执行如下 SQL 启动引导</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> group_replication_bootstrap_group=<span class="keyword">ON</span>;</span><br><span class="line"><span class="comment">-- START  GROUP_REPLICATION;</span></span><br><span class="line"><span class="comment">-- 从 MySQL 8.0.21 开始,可以为 START GROUP_REPLICATION 语句提供分布式恢复数据的用户凭据</span></span><br><span class="line"><span class="keyword">START</span> GROUP_REPLICATION <span class="keyword">USER</span>=<span class="string">'repl'</span>, <span class="keyword">PASSWORD</span>=<span class="string">'repl'</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> group_replication_bootstrap_group=<span class="keyword">OFF</span>;</span><br></pre></td></tr></table></figure>

<p>在其他节点执行如下语句,加入组复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在节点 上执行如下 SQL 启动引导</span></span><br><span class="line"><span class="keyword">START</span> GROUP_REPLICATION;</span><br></pre></td></tr></table></figure>

<h4 id="检查组复制状态"><a href="#检查组复制状态" class="headerlink" title="检查组复制状态"></a>检查组复制状态</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 任意一个节点,执行如下语句,检查组复制状态</span></span><br><span class="line">mysql&gt; SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+<span class="comment">---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span></span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+<span class="comment">---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span></span><br><span class="line">| group_replication_applier | 0355f651-8e9b-11eb-93a6-e8611f128e89 | 10.71.1.31  |        3306 | ONLINE       | PRIMARY     | 8.0.21         |</span><br><span class="line">| group_replication_applier | 0356851b-8e9b-11eb-bbe5-e8611f1359d8 | 10.71.1.32  |        3306 | ONLINE       | SECONDARY   | 8.0.21         |</span><br><span class="line">| group_replication_applier | 0414ad46-8e9b-11eb-9faf-305a3a794266 | 10.71.1.33  |        3306 | ONLINE       | SECONDARY   | 8.0.21         |</span><br><span class="line">+<span class="comment">---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>至些,MGR 三节点组复制安装完毕~</p>
<h3 id="可能出现的错误及解决"><a href="#可能出现的错误及解决" class="headerlink" title="可能出现的错误及解决"></a>可能出现的错误及解决</h3><h4 id="Binlog-format-should-be-ROW-for-Group-Replication"><a href="#Binlog-format-should-be-ROW-for-Group-Replication" class="headerlink" title="Binlog format should be ROW for Group Replication"></a>Binlog format should be ROW for Group Replication</h4><ul>
<li>错误信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; START GROUP_REPLICATION USER='repl', PASSWORD='repl';</span><br><span class="line">ERROR 3092 (HY000): The server is not configured properly to be an active member of the group. Please see more details on error log.</span><br></pre></td></tr></table></figure>

<ul>
<li>error.log</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-03-27T02:19:57.240689Z 16 [ERROR] [MY-011595] [Repl] Plugin group_replication reported: &#39;Binlog format should be ROW for Group Replication&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> binlog_format=<span class="keyword">ROW</span>;</span><br></pre></td></tr></table></figure>

<h2 id="安装-MySQL-Shell"><a href="#安装-MySQL-Shell" class="headerlink" title="安装 MySQL Shell"></a>安装 MySQL Shell</h2><p>MySQL Shell 是 MySQL Server 的高级客户端和代码编辑器.除了提供的类似于 MySQL 的 SQL 功能外,MySQL Shell 还提供 JavaScript 和 Python 脚本功能,并包括与 MySQL 配合使用的 API.X DevAPI 使您能够使用关系数据和文档数据,AdminAPI 使您可以使用 InnoDB Cluster.</p>
<p>MySQL Shell 安装过程非常简单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf mysql-shell-8.0.21-linux-glibc2.12-x86-64bit.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">ln -s mysql-shell-8.0.21-linux-glibc2.12-x86-64bit mysql-shell</span><br><span class="line"></span><br><span class="line">chown -R mysql.mysql mysql-shell</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=/usr/local/mysql-shell/bin:$PATH'</span> &gt;&gt; /etc/profile.d/mysql-shell.sh</span><br><span class="line"><span class="built_in">source</span>  /etc/profile.d/mysql-shell.sh</span><br></pre></td></tr></table></figure>

<h2 id="创建-Innodb-Cluster-集群"><a href="#创建-Innodb-Cluster-集群" class="headerlink" title="创建 Innodb Cluster 集群"></a>创建 Innodb Cluster 集群</h2><p>如果您已经有组复制的现有部署,并且想要使用它来创建群集,请将 <code>adoptFromGR</code> 参数传递给该 <code>dba.createCluster()</code> 函数.创建的 InnoDB 群集匹配复制组是以单主数据库还是多主数据库运行.</p>
<p>要采用现有的组复制组,使用 MySQL Shell 连接到组成员执行以下 SQL:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlsh -uroot -hlocalhost -p</span><br><span class="line">var cluster = dba.createCluster(<span class="string">'testCluster'</span>, &#123;adoptFromGR: <span class="literal">true</span>&#125;);</span><br><span class="line">dba.getCluster(<span class="string">"testCluster"</span>).status();</span><br></pre></td></tr></table></figure>

<p>输出内容如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"clusterName"</span>: <span class="string">"testCluster"</span>,</span><br><span class="line">    <span class="attr">"defaultReplicaSet"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"primary"</span>: <span class="string">"10.71.1.31:3306"</span>,</span><br><span class="line">        <span class="attr">"ssl"</span>: <span class="string">"DISABLED"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="string">"OK"</span>,</span><br><span class="line">        <span class="attr">"statusText"</span>: <span class="string">"Cluster is ONLINE and can tolerate up to ONE failure."</span>,</span><br><span class="line">        <span class="attr">"topology"</span>: &#123;</span><br><span class="line">            <span class="attr">"10.71.1.31:3306"</span>: &#123;</span><br><span class="line">                <span class="attr">"address"</span>: <span class="string">"10.71.1.31:3306"</span>,</span><br><span class="line">                <span class="attr">"mode"</span>: <span class="string">"R/O"</span>,</span><br><span class="line">                <span class="attr">"readReplicas"</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">"replicationLag"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"role"</span>: <span class="string">"HA"</span>,</span><br><span class="line">                <span class="attr">"status"</span>: <span class="string">"ONLINE"</span>,</span><br><span class="line">                <span class="attr">"version"</span>: <span class="string">"8.0.21"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"10.71.1.32:3306"</span>: &#123;</span><br><span class="line">                <span class="attr">"address"</span>: <span class="string">"10.71.1.32:3306"</span>,</span><br><span class="line">                <span class="attr">"mode"</span>: <span class="string">"R/O"</span>,</span><br><span class="line">                <span class="attr">"readReplicas"</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">"replicationLag"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"role"</span>: <span class="string">"HA"</span>,</span><br><span class="line">                <span class="attr">"status"</span>: <span class="string">"ONLINE"</span>,</span><br><span class="line">                <span class="attr">"version"</span>: <span class="string">"8.0.21"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"10.71.1.33:3306"</span>: &#123;</span><br><span class="line">                <span class="attr">"address"</span>: <span class="string">"10.71.1.33:3306"</span>,</span><br><span class="line">                <span class="attr">"mode"</span>: <span class="string">"R/W"</span>,</span><br><span class="line">                <span class="attr">"readReplicas"</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">"replicationLag"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"role"</span>: <span class="string">"HA"</span>,</span><br><span class="line">                <span class="attr">"status"</span>: <span class="string">"ONLINE"</span>,</span><br><span class="line">                <span class="attr">"version"</span>: <span class="string">"8.0.21"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"topologyMode"</span>: <span class="string">"Single-Primary"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"groupInformationSourceMember"</span>: <span class="string">"10.71.1.31:3306"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字段如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;status&quot;: &quot;OK&quot; 表示集群状态是正常的</span><br><span class="line">&quot;topologyMode&quot;: &quot;Single-Primary&quot; 表示是单主模式</span><br><span class="line">&quot;mode&quot;: &quot;R&#x2F;W&quot; 表示可读可写</span><br><span class="line">&quot;mode&quot;: &quot;R&#x2F;O&quot; 表示只读</span><br></pre></td></tr></table></figure>

<h2 id="安装-MySQL-Router"><a href="#安装-MySQL-Router" class="headerlink" title="安装 MySQL Router"></a>安装 MySQL Router</h2><p>MySQL Router 是 InnoDB Cluster 的一部分.是轻量级的中间件,可在应用程序与后端 MySQL 服务器之间提供透明的路由.它可以用于各种用例,例如通过有效地将数据库流量路由到适当的后端MySQL服务器来提供高可用性和可伸缩性.</p>
<p>为了获得最佳性能,MySQL Router 通常与使用它的应用程序安装在同一主机上.可能的原因包括</p>
<ul>
<li><p>允许本地 UNIX 域套接字连接到应用程序,而不是TCP/IP,减少网络延迟</p>
</li>
<li><p>为了允许 MySQL 路由器连接到 MySQL 而不需要路由器主机的额外帐户,对于专门为应用程序主机创建的 MySQL 帐户（例如 <a href="mailto:myapp@198.51.100.45">myapp@198.51.100.45</a>），而不是像myapp @％这样的值 。</p>
</li>
</ul>
<p>您可以在网络上运行多个 MySQL Router 实例，而无需将MySQL Router隔离到单个计算机上</p>
<p><img src="/images/MySQL-Router.png" alt="MySQL-Router"></p>
<h3 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf mysql-router-8.0.21-el7-x86_64.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">ln -s mysql-router-8.0.21-el7-x86_64 mysql-router</span><br><span class="line">mkdir mysql-router/data</span><br><span class="line"></span><br><span class="line">chown -R mysql.mysql mysql-router</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=/usr/local/mysql-router/bin:$PATH'</span> &gt;&gt; /etc/profile.d/mysql-router.sh</span><br><span class="line"><span class="built_in">source</span>  /etc/profile.d/mysql-router.sh</span><br></pre></td></tr></table></figure>

<h3 id="bootstrap-引导并启动"><a href="#bootstrap-引导并启动" class="headerlink" title="bootstrap 引导并启动"></a>bootstrap 引导并启动</h3><p>bootstrap 引导,创建一个独立的 MySQL Router 实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlrouter --bootstrap <span class="string">'root'</span>@<span class="string">'10.71.1.31'</span> --directory /usr/<span class="built_in">local</span>/mysql-router/data --conf-use-sockets --user=mysql --name=mysql_router_13306 --conf-bind-address=10.71.1.31 --account-host=<span class="string">"%"</span></span><br><span class="line"><span class="comment"># --directory 选项指定 router 的目录,–-name 指定路由器名称.</span></span><br></pre></td></tr></table></figure>

<p>输出如下,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Bootstrapping MySQL Router instance at &#39;&#x2F;usr&#x2F;local&#x2F;mysql-router-8.0.21-el7-x86_64&#x2F;data&#39;...</span><br><span class="line"></span><br><span class="line">- Creating account(s) (only those that are needed, if any)</span><br><span class="line">- Verifying account (using it to run SQL queries that would be run by Router)</span><br><span class="line">- Storing account in keyring</span><br><span class="line">- Adjusting permissions of generated files</span><br><span class="line">- Creating configuration &#x2F;usr&#x2F;local&#x2F;mysql-router-8.0.21-el7-x86_64&#x2F;data&#x2F;mysqlrouter.conf</span><br><span class="line"></span><br><span class="line"># MySQL Router &#39;mysql_router_13306&#39; configured for the InnoDB Cluster &#39;testCluster&#39;</span><br><span class="line"></span><br><span class="line">After this MySQL Router has been started with the generated configuration</span><br><span class="line"></span><br><span class="line">    $ .&#x2F;mysqlrouter -c &#x2F;usr&#x2F;local&#x2F;mysql-router-8.0.21-el7-x86_64&#x2F;data&#x2F;mysqlrouter.conf</span><br><span class="line"></span><br><span class="line">the cluster &#39;testCluster&#39; can be reached by connecting to:</span><br><span class="line"></span><br><span class="line">## MySQL Classic protocol</span><br><span class="line"></span><br><span class="line">- Read&#x2F;Write Connections: localhost:6446, &#x2F;usr&#x2F;local&#x2F;mysql-router-8.0.21-el7-x86_64&#x2F;data&#x2F;mysql.sock</span><br><span class="line">- Read&#x2F;Only Connections:  localhost:6447, &#x2F;usr&#x2F;local&#x2F;mysql-router-8.0.21-el7-x86_64&#x2F;data&#x2F;mysqlro.sock</span><br><span class="line"></span><br><span class="line">## MySQL X protocol</span><br><span class="line"></span><br><span class="line">- Read&#x2F;Write Connections: localhost:64460, &#x2F;usr&#x2F;local&#x2F;mysql-router-8.0.21-el7-x86_64&#x2F;data&#x2F;mysqlx.sock</span><br><span class="line">- Read&#x2F;Only Connections:  localhost:64470, &#x2F;usr&#x2F;local&#x2F;mysql-router-8.0.21-el7-x86_64&#x2F;data&#x2F;mysqlxro.sock</span><br></pre></td></tr></table></figure>

<p>且在 <code>/usr/local/mysql-router/data/</code> 目录下生成了如下文件,其中包含配置文件,配置 key,启动/停止脚本等.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree &#x2F;usr&#x2F;local&#x2F;mysql-router&#x2F;data&#x2F;</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;mysql-router&#x2F;data&#x2F;</span><br><span class="line">├── data</span><br><span class="line">│   ├── keyring</span><br><span class="line">│   └── state.json  # 其中包含集群的 metadata-servers</span><br><span class="line">├── log</span><br><span class="line">│   └── mysqlrouter.log</span><br><span class="line">├── mysqlrouter.conf # 其中包含自动生成的配置信息</span><br><span class="line">├── mysqlrouter.key</span><br><span class="line">├── run</span><br><span class="line">├── start.sh</span><br><span class="line">└── stop.sh</span><br></pre></td></tr></table></figure>

<h3 id="运行并验证"><a href="#运行并验证" class="headerlink" title="运行并验证"></a>运行并验证</h3><p>运行 <code>/usr/local/mysql-router/data/</code> 目录下生成的 <code>start.sh</code> 启动 mysql-router.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /usr/local/mysql-router/data/start.sh</span></span><br><span class="line"><span class="comment"># ps -fe | grep mysql-router</span></span><br><span class="line">root     2035683       1  0 12:42 pts/1    00:00:00 sudo ROUTER_PID=/usr/<span class="built_in">local</span>/mysql-router-8.0.21-el7-x86_64/data/mysqlrouter.pid /usr/<span class="built_in">local</span>/mysql-router-8.0.21-el7-x86_64/bin/mysqlrouter -c /usr/<span class="built_in">local</span>/mysql-router-8.0.21-el7-x86_64/data/mysqlrouter.conf --user=mysql</span><br><span class="line">mysql    2035684 2035683  1 12:42 pts/1    00:00:01 /usr/<span class="built_in">local</span>/mysql-router-8.0.21-el7-x86_64/bin/mysqlrouter -c /usr/<span class="built_in">local</span>/mysql-router-8.0.21-el7-x86_64/data/mysqlrouter.conf --user=mysql</span><br><span class="line"><span class="comment"># 查看监听端口</span></span><br><span class="line"><span class="comment"># netstat -tnlp | grep 2035684</span></span><br><span class="line">tcp        0      0 10.71.1.31:64460        0.0.0.0:*               LISTEN      2035684/mysqlrouter</span><br><span class="line">tcp        0      0 10.71.1.31:6446         0.0.0.0:*               LISTEN      2035684/mysqlrouter</span><br><span class="line">tcp        0      0 10.71.1.31:6447         0.0.0.0:*               LISTEN      2035684/mysqlrouter</span><br><span class="line">tcp        0      0 10.71.1.31:64470        0.0.0.0:*               LISTEN      2035684/mysqlrouter</span><br></pre></td></tr></table></figure>

<p>查看配置文件可以知道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;usr&#x2F;local&#x2F;mysql-router&#x2F;data&#x2F;mysqlrouter.conf 片段</span><br><span class="line">[routing:testCluster_rw]</span><br><span class="line">bind_port&#x3D;6446  # 读写端口,处理读写请求</span><br><span class="line"></span><br><span class="line">[routing:testCluster_ro]</span><br><span class="line">bind_port&#x3D;6447  # 只读端口,处理只读请求</span><br></pre></td></tr></table></figure>

<p>对读写端口进行验证,发现请求到主节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -e 'show variables like "server_id"' -P 6446</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 1     |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>

<p>对只读端口进行验证,发现会在两个从节点上轮询</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -e 'show variables like "server_id"' -P 6447</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 2     |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -e 'show variables like "server_id"' -P 6447</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 3     |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><h4 id="MySQL-Router-引导时提示权限不足"><a href="#MySQL-Router-引导时提示权限不足" class="headerlink" title="MySQL-Router 引导时提示权限不足"></a>MySQL-Router 引导时提示权限不足</h4><ul>
<li>错误提示</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Error: Error creating MySQL account for router (GRANTs stage): Error executing MySQL query "<span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">EXECUTE</span> <span class="keyword">ON</span> mysql_innodb_cluster_metadata.* <span class="keyword">TO</span> <span class="string">'mysql_router5_ll685grbj15x'</span>@<span class="string">'%'</span><span class="string">": Access denied for user 'root'@'%' to database 'mysql_innodb_cluster_metadata' (1044)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 给用户授予对 mysql_innodb_cluster_metadata 授权的权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> <span class="string">`mysql_innodb_cluster_metadata`</span>.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> <span class="string">`mysql_innodb_cluster_metadata_bkp`</span>.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> <span class="string">`mysql_innodb_cluster_metadata_previous`</span>.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>

<h2 id="模拟主节点宕机"><a href="#模拟主节点宕机" class="headerlink" title="模拟主节点宕机"></a>模拟主节点宕机</h2><p>我们把 server_id=1 的 MySQL 主节点停止,使用 MySQL-Router 检测,发现读写请求会被转发到备节点上,该备节点被提升为主节点,形成一主一从的结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在节点 1 上执行</span></span><br><span class="line"><span class="comment"># systemctl stop mysqld</span></span><br><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -e 'show variables like "server_id"' -P 6446</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 2     |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -e 'show variables like "server_id"' -P 6447</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 3     |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -e 'show variables like "server_id"' -P 6447</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 3     |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>

<p>此时在读写端口 6446 上创建测试数据库,并在只读端口 6447 上查看.发现创建成功并完成同步.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -P 6446 -e "CREATE IF NOT EXIST DATABASE test;"</span></span><br><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot -P 6447 -e 'SHOW DATABASE;'</span></span><br><span class="line">+-------------------------------+</span><br><span class="line">| Database                      |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| information_schema            |</span><br><span class="line">| mysql                         |</span><br><span class="line">| mysql_innodb_cluster_metadata |</span><br><span class="line">| performance_schema            |</span><br><span class="line">| sys                           |</span><br><span class="line">| <span class="built_in">test</span>                          |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>

<p>此时恢复 server_id=1 的上的 MySQL 实例,并手动启动同步.发现之前创建的数据库可以同步到本机上的 MySQL 实例.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start mysqld</span></span><br><span class="line"><span class="comment"># mysql -uroot -h10.71.1.31 -proot</span></span><br><span class="line">mysql&gt; START GROUP_REPLICATION;</span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+-------------------------------+</span><br><span class="line">| Database                      |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| information_schema            |</span><br><span class="line">| mysql                         |</span><br><span class="line">| mysql_innodb_cluster_metadata |</span><br><span class="line">| performance_schema            |</span><br><span class="line">| sys                           |</span><br><span class="line">| <span class="built_in">test</span>                          |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>

<p>如上实现了 MySQL 集群的高可用于故障恢复后的数据同步功能.</p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://blog.csdn.net/qq_33158376/article/details/109799989" target="_blank" rel="noopener">MySQL8.0.21 InnoDB Cluster 从零搭建集群方案详细文档</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>node_exporter 源码解析</title>
    <url>/2020/07/01/node_exporter-source-code-analysis/</url>
    <content><![CDATA[<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p><a href="https://github.com/prometheus/node_exporter" target="_blank" rel="noopener"><code>node_exporter</code></a> 是使用 Go 语言编写的 Prometheus exporter,多用于收集 *NIX 内核公开的硬件或操作系统指标.</p>
<p>当前版本为 <a href="https://github.com/prometheus/node_exporter/tree/v1.0.1" target="_blank" rel="noopener"><code>v1.0.1</code></a>其代码组织结构很简单:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- collector&#x2F;: 该包下主要定义 Collector,并对定义的 Collector 进行注册</span><br><span class="line">- https&#x2F;: v1.0.0 新增内容,主要为支持 https 请求</span><br><span class="line">- vendor&#x2F;: node_exporter 的依赖包</span><br><span class="line">- go.mod: module 包管理的信息</span><br><span class="line">- go.sum: module 包管理的信息</span><br><span class="line">- node_exporter.go: node_exporter 主程序文件</span><br></pre></td></tr></table></figure>

<p>在使用过程中可能用到的目录或文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- docs&#x2F;: 一些 prometheus 规则和与 kube-prometheus 中 node_exporter 相关的 libsonnet 文件</span><br><span class="line">- examples&#x2F;: 一些服务启动脚本</span><br><span class="line">- Dockerfile: 构建 docker 镜像</span><br><span class="line">VERSION: 记录版本信息</span><br></pre></td></tr></table></figure>

<h2 id="node-exporter-go"><a href="#node-exporter-go" class="headerlink" title="node_exporter.go"></a><code>node_exporter.go</code></h2><p>首先来看 node_exporter 主要程序文件 <code>node_exporter.go</code>.</p>
<h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    _ <span class="string">"net/http/pprof"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"sort"</span>  </span><br><span class="line">    <span class="string">"github.com/prometheus/common/promlog"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/common/promlog/flag"</span></span><br><span class="line">    <span class="string">"github.com/go-kit/kit/log"</span> <span class="comment">// v1.0.0 新增日志输出</span></span><br><span class="line">    <span class="string">"github.com/go-kit/kit/log/level"</span> <span class="comment">// 日志级别相关</span></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus"</span> <span class="comment">// prometheus 客户端库</span></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus/promhttp"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/common/version"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/node_exporter/collector"</span> <span class="comment">// node_exporter 中定义的 Collector</span></span><br><span class="line">    <span class="string">"github.com/prometheus/node_exporter/https"</span> <span class="comment">// v1.0.0 新增支持 https 请求</span></span><br><span class="line">    kingpin <span class="string">"gopkg.in/alecthomas/kingpin.v2"</span> <span class="comment">// 用于定义标志.如 `--help`, `--log.level` 等标志</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>首先我们要知道 Go 导包过程中做了哪些事情,参见 <a href="/2020/05/04/go-study-notes-package/" title="go 学习笔记之包管理">go 学习笔记之包管理</a> 导入包小节.这里再赘述一遍.</p>
<blockquote>
<p>在执行 <code>main</code> 包的 <code>main</code> 函数之前,Go 程序先对整个程序的包进行初始化.包内的源码文件都可以定义一到多个初始化函数,编译器首先确保完成所有全局变量初始化,然后开始执行 <code>init()</code> 初始化函数,直到这些全部结束后,运行时才进入 <code>main.main</code> 入口函数.</p>
</blockquote>
<p>因此以上包及其引用包中的常量,全局变量会依次被初始化,<code>init()</code> 函数会被执行.</p>
<p>这里需要注意的是 <code>&quot;github.com/prometheus/client_golang/prometheus&quot;</code> 包中几乎每个文件的 <code>init()</code> 函数都会调用 <code>registerCollector(collector string, isDefaultEnabled bool, factory func(logger log.Logger) (Collector, error))</code> 函数对该文件中定义的 <code>Collector</code> 进行注册.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collector/collector.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    defaultEnabled  = <span class="literal">true</span></span><br><span class="line">    defaultDisabled = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// key: Collector 名称,value: 对应 Collector 工厂函数</span></span><br><span class="line">    factories        = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(logger log.Logger)</span> <span class="params">(Collector, error)</span>)</span></span><br><span class="line">    <span class="comment">// key: Collector 名称,value: 对应 Collector 是否启用</span></span><br><span class="line">    collectorState   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// key: Collector 名称,value: 对应 Collector 是否明确启用或禁用</span></span><br><span class="line">    forcedCollectors = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125; <span class="comment">// collectors which have been explicitly enabled or disabled</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collector/collector.go#L58</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerCollector</span><span class="params">(collector <span class="keyword">string</span>, isDefaultEnabled <span class="keyword">bool</span>, factory <span class="keyword">func</span>(logger log.Logger)</span> <span class="params">(Collector, error)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> helpDefaultState <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> isDefaultEnabled &#123;</span><br><span class="line">       helpDefaultState = <span class="string">"enabled"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       helpDefaultState = <span class="string">"disabled"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 Collector 的标志名称,以 `collector.` 为前缀</span></span><br><span class="line">    flagName := fmt.Sprintf(<span class="string">"collector.%s"</span>, collector)</span><br><span class="line">    <span class="comment">// 注册 Collector 标志的帮助信息</span></span><br><span class="line">    flagHelp := fmt.Sprintf(<span class="string">"Enable the %s collector (default: %s)."</span>, collector, helpDefaultState)</span><br><span class="line">    <span class="comment">// 注册标志的默认值</span></span><br><span class="line">    defaultValue := fmt.Sprintf(<span class="string">"%v"</span>, isDefaultEnabled)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否启用 `--collector.&lt;collector&gt;` 标志</span></span><br><span class="line">    flag := kingpin.Flag(flagName, flagHelp).Default(defaultValue).Action(collectorFlagAction(collector)).Bool()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collectorState 保存 Collector 启用/禁用状态</span></span><br><span class="line">    collectorState[collector] = flag</span><br><span class="line"></span><br><span class="line">    <span class="comment">// factories 保存 Collector 对应的工厂函数</span></span><br><span class="line">    factories[collector] = factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collector/meminfo.go</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-kit/kit/log"</span></span><br><span class="line">    <span class="string">"github.com/go-kit/kit/log/level"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    memInfoSubsystem = <span class="string">"memory"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> meminfoCollector <span class="keyword">struct</span> &#123;</span><br><span class="line">    logger log.Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将定义的 Collector 进行注册/启用</span></span><br><span class="line">    registerCollector(<span class="string">"meminfo"</span>, defaultEnabled, NewMeminfoCollector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMeminfoCollector</span><span class="params">(logger log.Logger)</span> <span class="params">(Collector, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;meminfoCollector&#123;logger&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// meminfoCollector 实现了 Collector 接口,该函数应该在数据指标更新时调动.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *meminfoCollector)</span> <span class="title">Update</span><span class="params">(ch <span class="keyword">chan</span>&lt;- prometheus.Metric)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> metricType prometheus.ValueType <span class="comment">// prometheus 的数据类型,可选值有 CounterValue(1),GaugeValue(2),UntypedValue(3)</span></span><br><span class="line">    memInfo, err := c.getMemInfo() <span class="comment">// 获取 内存信息,不再展开</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get meminfo: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    level.Debug(c.logger).Log(<span class="string">"msg"</span>, <span class="string">"Set node_mem"</span>, <span class="string">"memInfo"</span>, memInfo)</span><br><span class="line">    <span class="comment">// 对其中数据进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> memInfo &#123;</span><br><span class="line">        <span class="comment">// 判断数据类型,并将对应的数据与数据类型组成的 `constMetric` 发送到 `prometheus.Metric` 类型的管道中</span></span><br><span class="line">        <span class="keyword">if</span> strings.HasSuffix(k, <span class="string">"_total"</span>) &#123;</span><br><span class="line">            metricType = prometheus.CounterValue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            metricType = prometheus.GaugeValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// `prometheus.MustNewConstMetric()` 返回 `prometheus.constMetric` 对象,由描述信息,指标类型,指标值构成.如下指标</span></span><br><span class="line">        <span class="comment">// # HELP go_info Information about the Go environment.</span></span><br><span class="line">        <span class="comment">// # TYPE go_info gauge</span></span><br><span class="line">        <span class="comment">// go_info&#123;version="go1.14.4"&#125; 1</span></span><br><span class="line">        ch &lt;- prometheus.MustNewConstMetric(</span><br><span class="line">            prometheus.NewDesc(</span><br><span class="line">                <span class="comment">// 数据指标的描述信息由数据指标的名称,帮助信息(HELP xxx),指标变量标签(version),指标常量标签构成</span></span><br><span class="line">                prometheus.BuildFQName(namespace, memInfoSubsystem, k),</span><br><span class="line">                fmt.Sprintf(<span class="string">"Memory information field %s."</span>, k),</span><br><span class="line">                <span class="literal">nil</span>, <span class="literal">nil</span>,</span><br><span class="line">            ),</span><br><span class="line">            metricType, v,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main-入口函数"><a href="#main-入口函数" class="headerlink" title="main() 入口函数"></a><code>main()</code> 入口函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用 kingpin 定义了众多标志</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        listenAddress = kingpin.Flag(</span><br><span class="line">            <span class="string">"web.listen-address"</span>,</span><br><span class="line">            <span class="string">"Address on which to expose metrics and web interface."</span>,</span><br><span class="line">        ).Default(<span class="string">":9100"</span>).String()</span><br><span class="line">        metricsPath = kingpin.Flag(</span><br><span class="line">            <span class="string">"web.telemetry-path"</span>,</span><br><span class="line">            <span class="string">"Path under which to expose metrics."</span>,</span><br><span class="line">        ).Default(<span class="string">"/metrics"</span>).String()</span><br><span class="line">        disableExporterMetrics = kingpin.Flag(</span><br><span class="line">            <span class="string">"web.disable-exporter-metrics"</span>,</span><br><span class="line">            <span class="string">"Exclude metrics about the exporter itself (promhttp_*, process_*, go_*)."</span>,</span><br><span class="line">        ).Bool()</span><br><span class="line">        maxRequests = kingpin.Flag(</span><br><span class="line">            <span class="string">"web.max-requests"</span>,</span><br><span class="line">            <span class="string">"Maximum number of parallel scrape requests. Use 0 to disable."</span>,</span><br><span class="line">        ).Default(<span class="string">"40"</span>).Int()</span><br><span class="line">        disableDefaultCollectors = kingpin.Flag(</span><br><span class="line">            <span class="string">"collector.disable-defaults"</span>,</span><br><span class="line">            <span class="string">"Set all collectors to disabled by default."</span>,</span><br><span class="line">        ).Default(<span class="string">"false"</span>).Bool()</span><br><span class="line">        configFile = kingpin.Flag(</span><br><span class="line">            <span class="string">"web.config"</span>,</span><br><span class="line">            <span class="string">"[EXPERIMENTAL] Path to config yaml file that can enable TLS or authentication."</span>,</span><br><span class="line">        ).Default(<span class="string">""</span>).String()</span><br><span class="line">    )</span><br><span class="line">    promlogConfig := &amp;promlog.Config&#123;&#125;</span><br><span class="line">    flag.AddFlags(kingpin.CommandLine, promlogConfig)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Version 的输出信息,HelpFlag 的短字段</span></span><br><span class="line">    kingpin.Version(version.Print(<span class="string">"node_exporter"</span>))</span><br><span class="line">    kingpin.HelpFlag.Short(<span class="string">'h'</span>)</span><br><span class="line">    kingpin.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义日志记录器</span></span><br><span class="line">    logger := promlog.New(promlogConfig)</span><br><span class="line">    <span class="comment">// 如果指定了 `collector.disable-defaults` 选项,则调用 collector.DisableDefaultCollectors() 函数</span></span><br><span class="line">    <span class="keyword">if</span> *disableDefaultCollectors &#123;</span><br><span class="line">        collector.DisableDefaultCollectors()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Starting node_exporter"</span>, <span class="string">"version"</span>, version.Info())</span><br><span class="line">    level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Build context"</span>, <span class="string">"build_context"</span>, version.BuildContext())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 `metricsPath` 请求,默认为 `/metrics`.后续着重分析一下 newHandler() 函数</span></span><br><span class="line">    http.Handle(*metricsPath, newHandler(!*disableExporterMetrics, *maxRequests, logger))</span><br><span class="line">    <span class="comment">// 处理 `/` 请求</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(<span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;&lt;title&gt;Node Exporter&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Node Exporter&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;a href="`</span> + *metricsPath + <span class="string">`"&gt;Metrics&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;`</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Listening on"</span>, <span class="string">"address"</span>, *listenAddress)</span><br><span class="line">    <span class="comment">// 定义 http server 及其监听端口.</span></span><br><span class="line">    server := &amp;http.Server&#123;Addr: *listenAddress&#125;</span><br><span class="line">    <span class="comment">// 调用使用 https.Listen() 启动服务.该方法会根据是否指定 `--web.config` 判断是否启用 https 服务</span></span><br><span class="line">    <span class="keyword">if</span> err := https.Listen(server, *configFile, logger); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        level.Error(logger).Log(<span class="string">"err"</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collector/collector.go#L84</span></span><br><span class="line"><span class="comment">// 该函数对 collectorState 中保存的 Collector 进行遍历,将不在 forcedCollectors 中的 Collector 设置为 false.(不启用)</span></span><br><span class="line"><span class="comment">// 仅保留一些必须启用的 Collector</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DisableDefaultCollectors</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> c := <span class="keyword">range</span> collectorState &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := forcedCollectors[c]; !ok &#123;</span><br><span class="line">            *collectorState[c] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https/tls_config.go#L168</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(server *http.Server, tlsConfigPath <span class="keyword">string</span>, logger log.Logger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> tlsConfigPath == <span class="string">""</span> &#123;</span><br><span class="line">        level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"TLS is disabled and it cannot be enabled on the fly."</span>, <span class="string">"http2"</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 调用了 net/http 包的 ListenAndServe() 函数(net/http/server.go#L2813)</span></span><br><span class="line">        <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="newHandler-函数"><a href="#newHandler-函数" class="headerlink" title="newHandler() 函数"></a><code>newHandler()</code> 函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node.exporter.go#L49</span></span><br><span class="line"><span class="comment">// 返回了处理 http 请求的 handler,当请求到来时,调用 handler.ServeHTTP(ResponseWriter, *Request) 处理请求,并写入响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHandler</span><span class="params">(includeExporterMetrics <span class="keyword">bool</span>, maxRequests <span class="keyword">int</span>, logger log.Logger)</span> *<span class="title">handler</span></span> &#123;</span><br><span class="line">    h := &amp;handler&#123;</span><br><span class="line">       exporterMetricsRegistry: prometheus.NewRegistry(),</span><br><span class="line">       includeExporterMetrics:  includeExporterMetrics,</span><br><span class="line">       maxRequests:             maxRequests,</span><br><span class="line">       logger:                  logger,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有指定 `--web.disable-exporter-metrics` 选项,则传入 `includeExporterMetrics` 参数为 true</span></span><br><span class="line">    <span class="keyword">if</span> h.includeExporterMetrics &#123;</span><br><span class="line">        h.exporterMetricsRegistry.MustRegister(</span><br><span class="line">            <span class="comment">// 注册了 processCollector,goCollector.在查看 `/metrics` 时也会看到相关数据指标.如</span></span><br><span class="line">            <span class="comment">// process_cpu_seconds_total,process_max_fds</span></span><br><span class="line">            <span class="comment">// go_goroutines,go_info 等</span></span><br><span class="line">            prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts&#123;&#125;),</span><br><span class="line">            prometheus.NewGoCollector(),</span><br><span class="line">       )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 innerHandler 创建 innerHandler</span></span><br><span class="line">    <span class="keyword">if</span> innerHandler, err := h.innerHandler(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Couldn't create metrics handler: %s"</span>, err))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h.unfilteredHandler = innerHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP implements http.Handler.</span></span><br><span class="line"><span class="comment">// 处理请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 开启 debug 日志级别后发现,filters 为 "unsupported value type"</span></span><br><span class="line">    filters := r.URL.Query()[<span class="string">"collect[]"</span>]</span><br><span class="line">    level.Debug(h.logger).Log(<span class="string">"msg"</span>, <span class="string">"collect query:"</span>, <span class="string">"filters"</span>, filters)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filters) == <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// No filters, use the prepared unfiltered handler.</span></span><br><span class="line">       h.unfilteredHandler.ServeHTTP(w, r)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To serve filtered metrics, we create a filtering handler on the fly.</span></span><br><span class="line">    <span class="comment">// 动态创建 filteredHandler</span></span><br><span class="line">    filteredHandler, err := h.innerHandler(filters...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       level.Warn(h.logger).Log(<span class="string">"msg"</span>, <span class="string">"Couldn't create filtered metrics handler:"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">       w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">       w.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"Couldn't create filtered metrics handler: %s"</span>, err)))</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    filteredHandler.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// innerHandler is used to create both the one unfiltered http.Handler to be</span></span><br><span class="line"><span class="comment">// wrapped by the outer handler and also the filtered handlers created on the</span></span><br><span class="line"><span class="comment">// fly. The former is accomplished by calling innerHandler without any arguments</span></span><br><span class="line"><span class="comment">// (in which case it will log all the collectors enabled via command-line</span></span><br><span class="line"><span class="comment">// flags).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">innerHandler</span><span class="params">(filters ...<span class="keyword">string</span>)</span> <span class="params">(http.Handler, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据 filters 指定字符串 Collector,用于创建 `collector.NodeCollector`</span></span><br><span class="line">    nc, err := collector.NewNodeCollector(h.logger, filters...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't create collector: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only log the creation of an unfiltered handler, which should happen</span></span><br><span class="line">    <span class="comment">// only once upon startup.</span></span><br><span class="line">    <span class="comment">// 这里将在 node_exporter 启动时打印启用的 Collector 相关日志</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filters) == <span class="number">0</span> &#123;</span><br><span class="line">        level.Info(h.logger).Log(<span class="string">"msg"</span>, <span class="string">"Enabled collectors"</span>)</span><br><span class="line">        collectors := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> nc.Collectors &#123;</span><br><span class="line">            collectors = <span class="built_in">append</span>(collectors, n)</span><br><span class="line">        &#125;</span><br><span class="line">        sort.Strings(collectors)</span><br><span class="line">        <span class="keyword">for</span> _, c := <span class="keyword">range</span> collectors &#123;</span><br><span class="line">            level.Info(h.logger).Log(<span class="string">"collector"</span>, c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r := prometheus.NewRegistry()</span><br><span class="line">    r.MustRegister(version.NewCollector(<span class="string">"node_exporter"</span>))</span><br><span class="line">    <span class="keyword">if</span> err := r.Register(nc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't register node collector: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里应该是收集指标数据的过程</span></span><br><span class="line">    handler := promhttp.HandlerFor(</span><br><span class="line">        <span class="comment">// 传入的 Gatherers 内部保存了实现 Gatherer 接口的 Registry,将来 Registry 会在 Gather() 方法中通过其中保存的 Collector 对象调用 Collect() 方法收集数据指标.</span></span><br><span class="line">        <span class="comment">// 同时 Collector 对象的 Collect() 方法内部会调用 Collector.Update() 方法获取数据指标相关信息</span></span><br><span class="line">        prometheus.Gatherers&#123;h.exporterMetricsRegistry, r&#125;,</span><br><span class="line">        promhttp.HandlerOpts&#123;</span><br><span class="line">            ErrorHandling:       promhttp.ContinueOnError,</span><br><span class="line">            MaxRequestsInFlight: h.maxRequests,</span><br><span class="line">            Registry:            h.exporterMetricsRegistry,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 如果没有指定 --web.disable-exporter-metrics` 选项,则 `h.includeExporterMetrics = true`</span></span><br><span class="line">    <span class="keyword">if</span> h.includeExporterMetrics &#123;</span><br><span class="line">        <span class="comment">// Note that we have to use h.exporterMetricsRegistry here to</span></span><br><span class="line">        <span class="comment">// use the same promhttp metrics for all expositions.</span></span><br><span class="line">        <span class="comment">// 调用 InstrumentMetricHandler 方法,对 promhttp_metric_handler_requests_total,promhttp_metric_handler_requests_in_flight 值进行设置</span></span><br><span class="line">        handler = promhttp.InstrumentMetricHandler(</span><br><span class="line">            h.exporterMetricsRegistry, handler,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义-metrics"><a href="#自定义-metrics" class="headerlink" title="自定义 metrics"></a>自定义 metrics</h2><p>以上,我们只需要在 <code>collector</code> 包中创建如下内容,再通过 <code>node_exporter</code> 帮我们实现自定义 metrics.</p>
<ol>
<li>自定义 <code>customCollector</code> 结构体,实现 Collector 接口,也就是实现 <code>Update(ch chan&lt;- prometheus.Metric)</code> 方法.在 <code>Update()</code> 方法中,要借助 <code>prometheus.MustNewConst&lt;Histogram,Metric,Summary&gt;</code> 等方法创建 <code>prometheus.Metric</code> 接口的实现对象,并将其传入管道 <code>ch</code>.</li>
<li>在 <code>init()</code> 函数中调用 <code>registerCollector()</code> 函数注册自定义 customCollector 结构体.</li>
</ol>
<p>代码示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collector</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-kit/kit/log"</span></span><br><span class="line">    <span class="string">"github.com/go-kit/kit/log/level"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line"></span><br><span class="line">    kingpin <span class="string">"gopkg.in/alecthomas/kingpin.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 定义自定义数据指标的子系统名称</span></span><br><span class="line">    customMetricsSubsystem = <span class="string">"metrics"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 customMetricsCollector 结构体</span></span><br><span class="line"><span class="keyword">type</span> customMetricsCollector <span class="keyword">struct</span> &#123;</span><br><span class="line">    logger log.Logger</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 customMetricsCollector 的工厂函数,后续传入 registerCollector() 函数中,以便创建 customMetricsCollector 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCustomMetricsCollector</span><span class="params">(logger log.Logger)</span> <span class="params">(Collector, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;customMetricsCollector&#123;</span><br><span class="line">        logger: logger,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Update() 函数,以便在处理请求时被 Collector.Collect() 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *customMetricsCollector)</span> <span class="title">Update</span><span class="params">(ch <span class="keyword">chan</span>&lt;- prometheus.Metric)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> metricType prometheus.ValueType</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">1.1</span></span><br><span class="line">    metricType = prometheus.CounterValue</span><br><span class="line">    level.Debug(c.logger).Log(<span class="string">"msg"</span>, <span class="string">"Set custom_metrics"</span>, <span class="string">"metrics"</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 `prometheus.MustNewConstMetric` 创建自定义 `prometheus.Metric` 接口对象 `prometheus.constMetric`,并将其传入`prometheus.Metric` 管道</span></span><br><span class="line">    ch &lt;- prometheus.MustNewConstMetric(</span><br><span class="line">        <span class="comment">// 需要传入 Metric 实现对象的描述信息,对象数据类型,值</span></span><br><span class="line">        prometheus.NewDesc(</span><br><span class="line">            <span class="comment">// 描述信息包括 数据指标名称(由 `BuildFQName()`函数组合而成),帮助信息,变量标签,常量标签</span></span><br><span class="line">            prometheus.BuildFQName(namespace, customMetricsSubsystem, <span class="string">"custom_metrics"</span>),</span><br><span class="line">            fmt.Sprintf(<span class="string">"Custom metrics field %s."</span>, <span class="string">"custom_metrics"</span>),</span><br><span class="line">            <span class="literal">nil</span>, <span class="literal">nil</span>,</span><br><span class="line">        ),</span><br><span class="line">        metricType, value,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在该函数中调用 registerCollector() 函数,注册自定义 customMetricsCollector</span></span><br><span class="line">    registerCollector(<span class="string">"custom_metrics"</span>, defaultEnabled, NewCustomMetricsCollector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后,执行 <code>./node_exporter</code> 发现 <code>/metrics</code> 中包含自定义数据指标.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HELP node_metrics_custom_metrics Custom metrics field custom_metrics.</span><br><span class="line"># TYPE node_metrics_custom_metrics counter</span><br><span class="line">node_metrics_custom_metrics 1.1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>node_exporter</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 易错记录</title>
    <url>/2022/12/09/nginx-error-prone-record/</url>
    <content><![CDATA[<h2 id="upstream-keepalive-配置后不生效问题"><a href="#upstream-keepalive-配置后不生效问题" class="headerlink" title="upstream keepalive 配置后不生效问题"></a>upstream keepalive 配置后不生效问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>按照如下方式配置 keepalive 之后发现 nginx 与 upstream server 的长连接并没有开启.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">    keepalive 16;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 1.1.1.1:80;</span><br><span class="line">    server 2.2.2.2:80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header Connection &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;test;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header Connection &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>参考 <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">nginx 官方文档 - keepalive</a> <code>When using load balancing methods other than the default round-robin method, it is necessary to activate them before the keepalive directive.</code> 因为在 upstream 配置块里使用了 <code>ip_hash</code> 负载均衡算法，导致 <code>keepalive</code> 配置不生效.这也是 nginx 里少有的跟配置顺序相关的配置。</p>
<h3 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h3><p>修正后配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 1.1.1.1:80;</span><br><span class="line">    server 2.2.2.2:80;</span><br><span class="line">    keepalive 16;  # 将 keepalive 配置配置到最后面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header Connection &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;test;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header Connection &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.nginx.com/blog/avoiding-top-10-nginx-configuration-mistakes/" target="_blank" rel="noopener">top 10 错误配置</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">nginx 官方文档 - keepalive</a></li>
</ul>
<h2 id="nginx-惊群效应引发-cpu-使用率高"><a href="#nginx-惊群效应引发-cpu-使用率高" class="headerlink" title="nginx 惊群效应引发 cpu 使用率高"></a>nginx 惊群效应引发 cpu 使用率高</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>从 tengine-2.2.0 升级到 tengine-2.3.3 之后，发现升级之后 sys cpu 使用及平均负载会相较于之前高很多。同时,通过 <code>top</code> 可以看到 nginx worker 进程的 cpu 使用率也很高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  16;</span><br><span class="line">worker_cpu_affinity auto;</span><br><span class="line">worker_rlimit_nofile 655360;</span><br><span class="line">daemon on;</span><br><span class="line">error_log  var&#x2F;logs&#x2F;error.log;</span><br><span class="line">pid        var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">   use epoll;</span><br><span class="line">   worker_connections  655360;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>strace -C -T -ttt -p ${nginx_pid}  -o /tmp/strac.log</code> 后可以观察到如下日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1670466059.603682 write(116, &quot;&#123;\&quot;@timestamp\&quot;: \&quot;2022-12-08T10:20&quot;..., 568) &#x3D; 568 &lt;0.000014&gt;</span><br><span class="line">1670466059.603716 sendto(43, &quot;&lt;190&gt;Dec  8 10:20:59 bx-slb-10-1&quot;..., 616, 0, NULL, 0) &#x3D; 616 &lt;0.000018&gt;</span><br><span class="line">1670466059.603766 setsockopt(309, SOL_TCP, TCP_NODELAY, [1], 4) &#x3D; 0 &lt;0.000021&gt;</span><br><span class="line">1670466059.603824 epoll_wait(131, [&#123;EPOLLIN|EPOLLOUT|EPOLLRDHUP, &#123;u32&#x3D;3918290177, u64&#x3D;140707046907137&#125;&#125;], 512, 42) &#x3D; 1 &lt;0.000027&gt;</span><br><span class="line">1670466059.603878 recvfrom(196, &quot;&quot;, 8192, 0, NULL, NULL) &#x3D; 0 &lt;0.000011&gt;</span><br><span class="line">1670466059.603913 close(196)            &#x3D; 0 &lt;0.000024&gt;</span><br><span class="line">1670466059.603955 epoll_wait(131, [&#123;EPOLLIN, &#123;u32&#x3D;3918234496, u64&#x3D;140707046851456&#125;&#125;], 512, 42) &#x3D; 1 &lt;0.000152&gt;</span><br><span class="line">1670466059.604138 accept4(12, 0x7ffdb837b1f0, 0x7ffdb837b26c, SOCK_NONBLOCK) &#x3D; -1 EAGAIN (Resource temporarily unavailable) &lt;0.000027&gt;</span><br><span class="line">1670466059.604205 epoll_wait(131, [&#123;EPOLLIN, &#123;u32&#x3D;3918234496, u64&#x3D;140707046851456&#125;&#125;], 512, 41) &#x3D; 1 &lt;0.000345&gt;</span><br><span class="line">1670466059.604590 accept4(12, 0x7ffdb837b1f0, 0x7ffdb837b26c, SOCK_NONBLOCK) &#x3D; -1 EAGAIN (Resource temporarily unavailable) &lt;0.000021&gt;</span><br><span class="line">1670466059.604640 epoll_wait(131, [&#123;EPOLLIN, &#123;u32&#x3D;3918234496, u64&#x3D;140707046851456&#125;&#125;], 512, 41) &#x3D; 1 &lt;0.000092&gt;</span><br><span class="line">1670466059.604768 accept4(12, 0x7ffdb837b1f0, 0x7ffdb837b26c, SOCK_NONBLOCK) &#x3D; -1 EAGAIN (Resource temporarily unavailable) &lt;0.000013&gt;</span><br><span class="line">1670466059.604813 epoll_wait(131, [&#123;EPOLLIN, &#123;u32&#x3D;3918234496, u64&#x3D;140707046851456&#125;&#125;], 512, 41) &#x3D; 1 &lt;0.000189&gt;</span><br><span class="line">1670466059.605043 accept4(12, 0x7ffdb837b1f0, 0x7ffdb837b26c, SOCK_NONBLOCK) &#x3D; -1 EAGAIN (Resource temporarily unavailable) &lt;0.000026&gt;</span><br><span class="line">1670466059.605114 epoll_wait(131, [&#123;EPOLLIN|EPOLLOUT, &#123;u32&#x3D;3918271617, u64&#x3D;140707046888577&#125;&#125;], 512, 40) &#x3D; 1 &lt;0.000014&gt;</span><br><span class="line">1670466059.605156 recvfrom(279, &quot;HTTP&#x2F;1.1 200 OK\r\nServer: nginx\r\n&quot;..., 16384, 0, NULL, NULL) &#x3D; 377 &lt;0.000013&gt;</span><br><span class="line">1670466059.605203 writev(306, [&#123;&quot;HTTP&#x2F;1.1 200 OK\r\nServer: Tengine&quot;..., 358&#125;, &#123;&quot;4d\r\n&quot;, 4&#125;, &#123;&quot;&#123;\&quot;retcode\&quot;:20000000,\&quot;msg\&quot;:\&quot;\&quot;,\&quot;da&quot;..., 77&#125;, &#123;&quot;\r\n&quot;, 2&#125;, &#123;&quot;0\r\n\r\n&quot;, 5&#125;], 5) &#x3D; 446 &lt;0.000021&gt;</span><br><span class="line">1670466059.605279 write(116, &quot;&#123;\&quot;@timestamp\&quot;: \&quot;2022-12-08T10:20&quot;..., 525) &#x3D; 525 &lt;0.000016&gt;</span><br><span class="line">1670466059.605316 sendto(43, &quot;&lt;190&gt;Dec  8 10:20:59 bx-slb-10-1&quot;..., 573, 0, NULL, 0) &#x3D; 573 &lt;0.000014&gt;</span><br><span class="line">1670466059.605350 epoll_wait(131, [&#123;EPOLLIN|EPOLLOUT|EPOLLRDHUP, &#123;u32&#x3D;3918243081, u64&#x3D;140707046860041&#125;&#125;], 512, 40) &#x3D; 1 &lt;0.000614&gt;</span><br><span class="line">1670466059.605986 recvfrom(169, &quot;&quot;, 8192, 0, NULL, NULL) &#x3D; 0 &lt;0.000012&gt;</span><br><span class="line">1670466059.606015 close(169)            &#x3D; 0 &lt;0.000024&gt;</span><br><span class="line">1670466059.606056 epoll_wait(131, [&#123;EPOLLIN, &#123;u32&#x3D;3918234496, u64&#x3D;140707046851456&#125;&#125;], 512, 39) &#x3D; 1 &lt;0.000453&gt;</span><br><span class="line">1670466059.606544 accept4(12, 0x7ffdb837b1f0, 0x7ffdb837b26c, SOCK_NONBLOCK) &#x3D; -1 EAGAIN (Resource temporarily unavailable) &lt;0.000028&gt;</span><br><span class="line">1670466059.606612 epoll_wait(131, [&#123;EPOLLIN, &#123;u32&#x3D;3918234496, u64&#x3D;140707046851456&#125;&#125;], 512, 39) &#x3D; 1 &lt;0.000946&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到会有很多 <code>epoll_wait</code> 的 <code>accept4</code> 返回了 <code>Resource temporarily unavailable</code> 的字段。</p>
<p>使用 <code>sar -w</code> 可以看到如下内容，上下文切换要高很多，这也是 worker 进程占用高的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11:00:01 AM    proc&#x2F;s   cswch&#x2F;s</span><br><span class="line">Average:        21.96  132824.27&#96;</span><br></pre></td></tr></table></figure>

<h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>按照 <a href="http://nginx.org/en/docs/ngx_core_module.html#accept_mutex" target="_blank" rel="noopener">nginx 官方文档 - accept_mutex</a> 中描述，nginx-1.11.3 之后 <code>accept_mutex</code> 默认为关闭状态，当连接到来时，所有 worker 进程会尝试建立连接，就会导致所有 worker 进程都会被唤醒。开启这个参数后，相当于对连接加了一把锁，每个 worker 进程抢占这把锁,抢到锁的 worker 进程处理请求，没有抢到的继续处于 sleep 状态。避免由于新连接请求过来时所有 worker 都会被惊醒，造成 cpu 上下文切换。</p>
<p>tengine 与 nginx版本对应如下:</p>
<table>
<thead>
<tr>
<th align="left">tengine</th>
<th align="left">nginx</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2.2.0</td>
<td align="left">1.8.1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2.2.1</td>
<td align="left">1.8.1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2.2.3</td>
<td align="left">1.8.1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2.3.0</td>
<td align="left">1.15.9</td>
<td align="left">废弃 <code>dso_tool</code> 工具以及 <code>dso</code> 配置指令,可以使用 <code>load_module</code> 指令动态加载.参考: <a href="http://tengine.taobao.org/document_cn/dso_cn.html" target="_blank" rel="noopener">tengine - dso</a></td>
</tr>
<tr>
<td align="left">2.3.1</td>
<td align="left">1.16.0</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2.3.2</td>
<td align="left">1.17.3</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2.3.3</td>
<td align="left">1.18.0</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><code>accept_mutex</code> 参数配置为 on</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">event &#123;</span><br><span class="line">    accept_mutex on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>开启 <code>accept_mutex</code> 参数后，同一时刻只有一个 worker 进程处理新的连接请求。这就导致在高并发的场景下一定会有一些性能损耗。因此可以使用 <code>reuseport</code> 参数来开启多个 worker 进程监听同一个 socket 套接字。<a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="noopener">Socket Sharding in NGINX Release 1.9.1</a> 这里看起来开启 reuseport 性能会高不少。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/401910162" target="_blank" rel="noopener">Nginx惊群效应引起的系统高负载</a></li>
<li><a href="https://ld246.com/article/1588731832846" target="_blank" rel="noopener">Nginx 是如何解决 epoll 惊群的</a></li>
<li><a href="https://pureage.info/2015/12/22/thundering-herd.html" target="_blank" rel="noopener">accept 与 epoll 惊群</a></li>
<li><a href="http://nginx.org/en/docs/ngx_core_module.html#accept_mutex" target="_blank" rel="noopener">nginx 官方文档 - accept_mutex</a></li>
<li><a href="https://www.zhihu.com/question/51618274" target="_blank" rel="noopener">知乎 - reuseport</a></li>
<li><a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="noopener">Socket Sharding in NGINX Release 1.9.1</a></li>
</ul>
<h2 id="nginx-POST-请求偶发-502"><a href="#nginx-POST-请求偶发-502" class="headerlink" title="nginx POST 请求偶发 502"></a>nginx POST 请求偶发 502</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>从 tengine-2.2.0 升级到 tengine-2.3.3 之后，nginx 错误日志中有如下报错，且发现 POST 请求会偶发 502，GET 请求没有 502</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream prematurely closed connection while reading response header from upstream, client: 2.2.2.2, server: xxx, request: &quot;POST &#x2F;path&#x2F;to&#x2F;post&#x2F;uri HTTP&#x2F;1.1&quot;, upstream: &quot;http:&#x2F;&#x2F;1.1.1.1&#x2F;path&#x2F;to&#x2F;post&#x2F;uri&quot;, host: &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>抓包后发现后端 upstream server 在接收到请求后，返回了 FIN、ACK 的 TCP 包，导致 nginx 与 upstream server 连接断开。POST 请求不会重发，GET 请求会复用其他连接重新发到下一个可用的 upstream server。抓包截图如下：</p>
<p><img src="/images/nginx-upstream-tcpdump-post.png" alt="502 POST 请求抓包"></p>
<p><img src="/images/nginx-upstream-tcpdump-get.png" alt="GET 请求抓包"></p>
<h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><p>tengine-2.2.0 升级到 tengine-2.3.3 后，对应 nginx 1.18.0，<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream" target="_blank" rel="noopener">官方文档 proxy_next_upstream</a> 描述说在  1.9.13 之后的版本里添加了 <code>non_idempotent</code> 参数。对于非幂等的 POST, LOCK, PATCH 请求，需要显示打开此参数，nginx 才会帮忙转发。</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>在确认 POST 请求为幂等的情况下，<code>proxy_next_upstream</code> 参数显式配置为 <code>error timeout non_idempotent</code></p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream" target="_blank" rel="noopener">nginx 官方文档 - proxy_next_upstream</a></li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 多线程/多进程与 GIL</title>
    <url>/2020/06/09/python-GIL/</url>
    <content><![CDATA[<h2 id="全局解释器锁-GIL"><a href="#全局解释器锁-GIL" class="headerlink" title="全局解释器锁 GIL"></a>全局解释器锁 GIL</h2><p>CPython 解释器本身不是线程安全的,因此有全局解释器锁(GIL),用于保证同一时刻只允许使用一个线程执行 Python 字节码.</p>
<blockquote>
<p>这是 CPython 解释器的局限,与 Python 语言本身无关. Jython 和 IronPython 则没有这种限制.</p>
</blockquote>
<p>在 Python 多线程下,每个线程执行之前都需要获取 GIL 后才能执行线程代码中的代码,直到遇到 IO 阻塞或达到线程的最长执行时间后释放 GIL,等待下一次调度.而每次释放 GIL 锁,多个线程会进行锁竞争,切换线程,会造成资源损耗.这就是为什么即便在多核 CPU ,Python 的多线程效率可能并不高.</p>
<p>对于 CPU 密集型代码来说,多线程之间存在锁竞争,切换线程,会造成不必要的资源损耗,所以 <strong>Python 的多线程对 CPU 密集型代码并不友好</strong>.因此对于多核场景,推荐使用多进程,每个进程中的单个线程有独立的 GIL,互不干扰,这样就可以真正意义上的并行执行.</p>
<p>对于 IO 密集型代码来说,多线程能够有效有效提升效率,避免 IO 操作过程中的等待时间,所以 <strong>Python 的多线程对 IO 密集型代码比较友好</strong>.</p>
<h2 id="Python-中有-GIL-为什么还需要锁或线程同步"><a href="#Python-中有-GIL-为什么还需要锁或线程同步" class="headerlink" title="Python 中有 GIL,为什么还需要锁或线程同步"></a>Python 中有 GIL,为什么还需要锁或线程同步</h2><p>GIL 保护 Python 解释器.这意味着:</p>
<ul>
<li>您不必担心 Python 解释器由于多线程而出错</li>
<li>在同一时刻,只允许一个线程获取到 GIL,并执行,而一段时间内,多个线程是顺序执行的.</li>
</ul>
<p>但是 GIL 并不会保证您的代码原子执行.见如下示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_n_times</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_increment_n_times</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_in_x_threads</span><span class="params">(x, func, n)</span>:</span></span><br><span class="line">    threads = [threading.Thread(target=func, args=(n,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(x)]</span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    begin = time.time()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line">    print(<span class="string">'finished in &#123;&#125;s.\ntotal: &#123;&#125;\nexpected: &#123;&#125;\ndifference: &#123;&#125; (&#123;&#125; %)'</span></span><br><span class="line">           .format(time.time()-begin, total, n*x, n*x-total, <span class="number">100</span>-total/n/x*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'unsafe:'</span>)</span><br><span class="line">increment_in_x_threads(<span class="number">70</span>, increment_n_times, <span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nwith locks:'</span>)</span><br><span class="line">increment_in_x_threads(<span class="number">70</span>, safe_increment_n_times, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsafe:</span><br><span class="line">finished in 0.9840562343597412s.</span><br><span class="line">total: 4654584</span><br><span class="line">expected: 7000000</span><br><span class="line">difference: 2345416 (33.505942857142855 %)</span><br><span class="line"></span><br><span class="line">with locks:</span><br><span class="line">finished in 20.564176082611084s.</span><br><span class="line">total: 7000000</span><br><span class="line">expected: 7000000</span><br><span class="line">difference: 0 (0.0 %)</span><br></pre></td></tr></table></figure>

<p>对于对线程,如果没有锁,则会出现错误(33% 的加 1 过程失败).而带锁的计算结果是准确地,但速度要慢 20 倍.</p>
<p>为了解释上述过程没有加锁情况下,出现错误的原因,可以通过 <code>dis</code> 库函数查看 <code>x + 1</code> 的字节码(bytecode)执行过程.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="keyword">lambda</span> x: x+<span class="number">1</span>)</span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (x)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">4</span> BINARY_ADD</span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>这个操作需要多个 bytecodes 操作,在执行这个操作的多条 bytecodes 过程中可能就进行线程切换了,这样就出现了数据竞争的情况.</p>
<hr>
<p>参考:</p>
<ul>
<li><a href="https://www.zhihu.com/question/23030421" target="_blank" rel="noopener">Python有GIL为什么还需要线程同步？</a></li>
<li><a href="https://stackoverflow.com/questions/40072873/why-do-we-need-locks-for-threads-if-we-have-gil/40072999" target="_blank" rel="noopener">Why do we need locks for threads, if we have GIL?</a></li>
<li><a href="https://stackoverflow.com/questions/26873512/why-does-python-provide-locking-mechanisms-if-its-subject-to-a-gil" target="_blank" rel="noopener">why-does-python-provide-locking-mechanisms-if-its-subject-to-a-gil</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
        <tag>GIL</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus client_golang 简单使用</title>
    <url>/2020/07/01/prometheus-client_golang-Introduction/</url>
    <content><![CDATA[<p><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> 生态是一款优秀的开源监控解决方案,其中包括如下组件</p>
<ul>
<li><a href="https://github.com/prometheus/prometheus" target="_blank" rel="noopener">Prometheus</a></li>
</ul>
<p>通过配置各个采集任务,采集各个 expoter 或 pushgateway 数据,保存到其内部的时间序列数据库(TSDB)中.并根据规则对采集到的数据指标进行计算或重新保存为新的数据指标,判断是否达到阈值并向 Alertmanager 推送告警信息.</p>
<ul>
<li><a href="https://github.com/prometheus/alertmanager" target="_blank" rel="noopener">Alertmanager</a></li>
</ul>
<p>接收 Prometheus 推送过来的告警信息,通过告警路由,向集成的组件/工具发送告警信息.</p>
<ul>
<li>各种 <a href="https://prometheus.io/docs/instrumenting/exporters/" target="_blank" rel="noopener">Exporter</a></li>
</ul>
<p>收集系统或进程信息,转换为 Prometheus 可以识别的数据指标,以 http 或 https 服务的方式暴露给 Prometheus.</p>
<ul>
<li>[Pushgateway]</li>
</ul>
<p>收集系统或进程信息,转换为 Prometheus 可以识别的数据指标,向 Prometheus 推送数据指标.</p>
<p>本篇文章主要内容为根据 <a href="https://godoc.org/github.com/prometheus/client_golang" target="_blank" rel="noopener">Prometheus client_golang 官方文档</a>总结的 Prometheus client_golang 简单使用方法.</p>
<h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><p><a href="https://github.com/prometheus/client_golang" target="_blank" rel="noopener">prometheus/client_golang</a> 包结构如下:</p>
<table>
<thead>
<tr>
<th align="center">包路径</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">api</td>
<td align="center">api 包提供了 Prometheus HTTP API</td>
</tr>
<tr>
<td align="center">api/prometheus/v1</td>
<td align="center">v1 包提供了 v1 版本的 Prometheus HTTP API,详见 <a href="http://prometheus.io/docs/querying/api/" target="_blank" rel="noopener">http://prometheus.io/docs/querying/api/</a></td>
</tr>
<tr>
<td align="center">examples/random</td>
<td align="center">一个简单的示例,将具有不同类型的随机分布(均匀,正态和指数)的虚构 RPC 延迟公开为 Prometheus 数据指标</td>
</tr>
<tr>
<td align="center">examples/simple</td>
<td align="center">一个使用 Prometheus 工具的最小示例</td>
</tr>
<tr>
<td align="center">prometheus</td>
<td align="center">prometheus 包是 prometheus/client_golang 的核心包</td>
</tr>
<tr>
<td align="center">prometheus/graphite</td>
<td align="center">graphite 包提供了将 Prometheus 数据指标推送到 Graphite 服务的相关代码</td>
</tr>
<tr>
<td align="center">prometheus/internal</td>
<td align="center">内部包</td>
</tr>
<tr>
<td align="center">prometheus/promauto</td>
<td align="center">promauto 包提供了 Prometheus 指标的基本数据类型及其 <code>…Vec</code> 和 <code>…Func</code> 变体数据类型的构造函数</td>
</tr>
<tr>
<td align="center">prometheus/promhttp</td>
<td align="center">promhttp 包提供了 HTTP 服务端和客户端相关工具</td>
</tr>
<tr>
<td align="center">prometheus/push</td>
<td align="center">push 包提供了将指标推送到 Pushgateway 的函数</td>
</tr>
<tr>
<td align="center">prometheus/testutil</td>
<td align="center">testutil 包提供了测试使用 prometheus/client_golang 编写的代码的帮助程序</td>
</tr>
<tr>
<td align="center">prometheus/testutil/promlint</td>
<td align="center">promlint 包为 Prometheus 数据指标提供一个参考.</td>
</tr>
</tbody></table>
<h2 id="prometheus-包"><a href="#prometheus-包" class="headerlink" title="prometheus 包"></a><code>prometheus</code> 包</h2><p>导入方式 <code>import &quot;github.com/prometheus/client_golang/prometheus&quot;</code>.</p>
<p><code>prometheus</code> 包是 prometheus/client_golang 的核心包.它为工具代码提供原生数据指标用于监控,并为数据指标对象提供了注册表.<code>promauto</code> 为数据指标提供自动注册的构造函数,<code>promhttp</code> 子包允许通过 HTTP 公开已注册的数据指标,<code>push</code> 子包可以将已注册的数据指标推送到 Pushgateway.</p>
<p>示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus/promhttp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// 通过 NewGauge() 方法创建 Gauge 接口的实现对象</span></span><br><span class="line">    cpuTemp = prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">        Name: <span class="string">"cpu_temperature_celsius"</span>,</span><br><span class="line">        Help: <span class="string">"Current temperature of the CPU."</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 通过 NewCounterVec() 方法创建带"标签"的 CounterVec 对象</span></span><br><span class="line">    hdFailures = prometheus.NewCounterVec(</span><br><span class="line">        prometheus.CounterOpts&#123;</span><br><span class="line">            Name: <span class="string">"hd_errors_total"</span>,</span><br><span class="line">            Help: <span class="string">"Number of hard-disk errors."</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"device"</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Metrics 数据指标必须被注册后才会被公开</span></span><br><span class="line">    prometheus.MustRegister(cpuTemp)</span><br><span class="line">    prometheus.MustRegister(hdFailures)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cpuTemp.Set(<span class="number">65.3</span>)</span><br><span class="line">    hdFailures.With(prometheus.Labels&#123;<span class="string">"device"</span>:<span class="string">"/dev/sda"</span>&#125;).Inc()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handler 函数提供了默认的处理程序,以便通过 HTTP 服务公开指标.通常使用 "/metrics" 作为入口点.</span></span><br><span class="line">    http.Handle(<span class="string">"/metrics"</span>, promhttp.Handler())</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据指标"><a href="#数据指标" class="headerlink" title="数据指标"></a>数据指标</h3><p><code>prometheus</code> 包提供了四种基本的数据指标类型,<code>Counter</code>,<code>Gauge</code>,<code>Histogram</code> 和 <code>Summary</code>.可以在<a href="https://prometheus.io/docs/concepts/metric_types/" target="_blank" rel="noopener">Prometheus docs</a> 中找到对这四种度量标准类型的更全面的描述.</p>
<p>除了四种基本的数据指标类型外,Prometheus 数据模型的一个非常重要的部分是沿着称为 “标签” 的维度对数据指标样本进行划分,这就产生了数据指标向量(metric vectors).<code>prometheus</code> 分为为四种基本数据指标类型提供了相应的数据指标向量,分别是 <code>CounterVec</code>,<code>GaugeVec</code>,<code>HistogramVec</code> 和 <code>SummaryVec</code>.</p>
<p>数据指标向量的方法如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Collect(ch <span class="keyword">chan</span>&lt;- Metric)  <span class="comment">// 实现 Collector 接口的 Collect() 方法</span></span><br><span class="line">CurryWith(labels Labels)  <span class="comment">// 返回带有指定标签的向量指标及可能发生的错误.多用于 promhttp 包中的中间件.</span></span><br><span class="line">Delete(labels Labels)  <span class="comment">// 删除带有指定标签的向量指标.如果删除了指标,返回 true</span></span><br><span class="line">DeleteLabelValues(lvs ...<span class="keyword">string</span>)  <span class="comment">// 删除带有指定标签和标签值的向量指标.如果删除了指标,返回 true</span></span><br><span class="line">Describe(ch <span class="keyword">chan</span>&lt;- *Desc)  <span class="comment">// 实现 Collector 接口的 Describe() 方法</span></span><br><span class="line">GetMetricWith(labels Labels)  <span class="comment">// 返回带有指定标签的数据指标及可能发生的错误</span></span><br><span class="line">GetMetricWithLabelValues(lvs ...<span class="keyword">string</span>)  <span class="comment">// 返回带有指定标签和标签值的数据指标及可能发生的错误</span></span><br><span class="line">MustCurryWith(labels Labels)  <span class="comment">// 与 CurryWith 相同,但如果出现错误,则引发 panics</span></span><br><span class="line">Reset()  <span class="comment">// 删除此指标向量中的所有数据指标</span></span><br><span class="line">With(labels Labels)  <span class="comment">// 与 GetMetricWithLabels 相同,但如果出现错误,则引发 panics</span></span><br><span class="line">WithLabelValues(lvs ...<span class="keyword">string</span>)  <span class="comment">// 与 GetMetricWithLabelValues 相同,但如果出现错误,则引发 panics</span></span><br></pre></td></tr></table></figure>

<p>要创建 <code>Metrics</code> 及其向量版本的实例,您需要一个合适的<code>…Opts</code>结构,即 <code>GaugeOpts</code>,<code>CounterOpts</code>,<code>SummaryOpts</code> 或 <code>HistogramOpts</code>.结构体如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中 GaugeOpts, CounterOpts 实际上均为 Opts 的别名</span></span><br><span class="line"><span class="keyword">type</span> CounterOpts Opts</span><br><span class="line"><span class="keyword">type</span> GaugeOpts Opts</span><br><span class="line"><span class="keyword">type</span> Opts <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Namespace, Subsystem, and Name  是 Metric 名称的组成部分(通过 "_" 将这些组成部分连接起来),只有 Name 是必需的.</span></span><br><span class="line">    Namespace <span class="keyword">string</span></span><br><span class="line">    Subsystem <span class="keyword">string</span></span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Help 提供 Metric 的信息.具有相同名称的 Metric 必须具有相同的 Help 信息</span></span><br><span class="line">    Help <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConstLabels 用于将固定标签附加到该指标.很少使用.</span></span><br><span class="line">    ConstLabels Labels</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HistogramOpts <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Namespace, Subsystem, and Name  是 Metric 名称的组成部分(通过 "_" 将这些组成部分连接起来),只有 Name 是必需的.</span></span><br><span class="line">    Namespace <span class="keyword">string</span></span><br><span class="line">    Subsystem <span class="keyword">string</span></span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Help 提供 Metric 的信息.具有相同名称的 Metric 必须具有相同的 Help 信息</span></span><br><span class="line">    Help <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConstLabels 用于将固定标签附加到该指标.很少使用.</span></span><br><span class="line">    ConstLabels Labels</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Buckets 定义了观察值的取值区间.切片中的每个元素值都是区间的上限,元素值必须按升序排序.</span></span><br><span class="line">    <span class="comment">// Buckets 会隐式添加 `+Inf` 值作为取值区间的最大值</span></span><br><span class="line">    <span class="comment">// 默认值是 DefBuckets =  []float64&#123;.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10&#125;</span></span><br><span class="line">    Buckets []<span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SummaryOpts <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Namespace, Subsystem, and Name  是 Metric 名称的组成部分(通过 "_" 将这些组成部分连接起来),只有 Name 是必需的.</span></span><br><span class="line">    Namespace <span class="keyword">string</span></span><br><span class="line">    Subsystem <span class="keyword">string</span></span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Help 提供 Metric 的信息.具有相同名称的 Metric 必须具有相同的 Help 信息</span></span><br><span class="line">    Help <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConstLabels 用于将固定标签附加到该指标.很少使用.</span></span><br><span class="line">    ConstLabels Labels</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Objectives 定义了分位数等级估计及其各自的绝对误差.如果 Objectives[q] = e，则 q 报告的值将是 [q-e, q + e]之间某个 φ 的 φ 分位数</span></span><br><span class="line">    <span class="comment">// 默认值为空 map,表示没有分位数的摘要</span></span><br><span class="line">    Objectives <span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxAge 定义观察值与摘要保持相关的持续时间.必须是正数.默认值为 DefMaxAge = 10 * time.Minute</span></span><br><span class="line">    MaxAge time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AgeBuckets 用于从摘要中排除早于 MaxAge 的观察值的取值区间.默认值为 DefAgeBuckets = 5</span></span><br><span class="line">    AgeBuckets <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BufCap 定义默认样本流缓冲区大小.默认值为 DefBufCap = 500.</span></span><br><span class="line">    BufCap <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 <code>Counter</code>,<code>Gauge</code>,<code>Histogram</code>,<code>Summary</code> 都继承了 <code>Metric</code> 和 <code>Collector</code> 接口,其本身是接口类型.而 <code>CounterVec</code>,<code>GaugeVec</code>,<code>HistogramVec</code>, <code>SummaryVec</code> 均继承自 <code>metricVec</code> 结构体,其本身的是结构体,而它们只实现了 <code>Collector</code> 接口.</p>
<h3 id="自定义-Collectors-和常量指标"><a href="#自定义-Collectors-和常量指标" class="headerlink" title="自定义 Collectors 和常量指标"></a>自定义 Collectors 和常量指标</h3><p><code>prometheus</code> 包提供了 <code>NewConstMetric()</code>,<code>NewConstHistogram()</code>,<code>NewConstSummary()</code> 及其各自的 <code>Must…</code> 版本的函数 “动态” 创建 <code>Metric</code> 实例.其中 <code>NewConstMetric()</code> 函数用于创建仅以 float64 数据作为其值的数据指标类型对象,如 <code>Counter</code>,<code>Gauge</code> 及 <code>Untyped</code> 特殊类型对象.<code>Metric</code> 实例的创建在 <code>Collect()</code> 方法中进行.</p>
<p><code>prometheus</code> 包提供了 <code>NewDesc()</code> 函数创建用于描述以上 <code>Metric</code> 实例的 <code>Desc</code> 对象,其中主要包含  <code>Metric</code> 实例的名称与帮助信息.</p>
<p><code>prometheus</code> 包还提供了 <code>NewCounterFunc()</code>,<code>NewGaugeFunc()</code> 或 <code>NewUntypedFunc()</code> 函数用于创建实现了 <code>CounterFunc</code>, <code>GaugeFunc</code>, <code>UntypedFunc</code> 接口的 <code>valueFunc</code> 对象,用于只需要以传入函数的浮点数返回值作为数据指标值创建数据指标的场景.</p>
<h3 id="Registry-的高级用法"><a href="#Registry-的高级用法" class="headerlink" title="Registry 的高级用法"></a>Registry 的高级用法</h3><p><code>prometheus</code> 包提供了 <code>MustRegister()</code> 函数用于注册 <code>Collector</code>,但如果注册过程中发生错误,程序会引发 panics.而使用 <code>Register()</code> 函数可以实现注册 <code>Collector</code> 的同时处理可能发生的错误.</p>
<p><code>prometheus</code> 包中所有的注册都是在默认的注册表上进行的,可以在全局变量 <code>DefaultRegisterer</code> 中找到该对象.<code>prometheus</code> 包提供了 <code>NewRegistry()</code> 函数用于创建自定义注册表,甚至可以自己实现 <code>Registerer</code> 或 <code>Gatherer</code> 接口.</p>
<p> <code>prometheus</code> 通过 <code>NewGoCollector()</code> 和 <code>NewProcessCollector()</code> 函数创建 Go 运行时数据指标的 <code>Collector</code> 和进程数据指标的 <code>Collector</code>.而这两个 <code>Collector</code> 已在默认的注册表 <code>DefaultRegisterer</code> 中注册.使用自定义注册表,您可以控制并自行决定要注册的 <code>Collector</code>.</p>
<h3 id="HTTP-公开数据指标"><a href="#HTTP-公开数据指标" class="headerlink" title="HTTP 公开数据指标"></a>HTTP 公开数据指标</h3><p>注册表(<code>Registry</code> 结构体)实现了 <code>Gatherer</code> 接口,实现了 <code>Gather()</code> 方法.<code>Gather()</code> 方法的调用者可以以某种方式公开收集的数据指标.通常通过 <code>/metrics</code> 入口以 HTTP 方式提供.通过 HTTP 公开数据指标的工具在 <code>promhttp</code> 包中.</p>
<h3 id="推送数据指标到-Pushgateway"><a href="#推送数据指标到-Pushgateway" class="headerlink" title="推送数据指标到 Pushgateway"></a>推送数据指标到 Pushgateway</h3><p>在 <code>push</code> 子包中可以找到用于推送到 Pushgateway 的函数.</p>
<h2 id="promauto-包"><a href="#promauto-包" class="headerlink" title="promauto 包"></a><code>promauto</code> 包</h2><p>导入方式: <code>import &quot;github.com/prometheus/client_golang/prometheus/promauto&quot;</code></p>
<p><code>promauto</code> 包提供了 Prometheus 指标的基本数据类型及其 <code>…Vec</code> 和 <code>…Func</code> 变体数据类型的构造函数.与 <code>prometheus</code> 包中提供的构造函数不同的是,<code>promauto</code> 包中的构造函数返回已经注册的 <code>Collector</code> 对象.</p>
<p><code>promauto</code> 包中包含三组构造函数,<code>New&lt;Metric&gt;</code>, <code>New&lt;Metric&gt;Vec</code> 与 <code>New&lt;Metric&gt;Func</code>.</p>
<p><code>promauto</code> 包中 <code>NewXXX</code> 函数,其实都是调用了 <code>prometheus</code> 包中对应的 <code>NewXXX</code> 函数创建了 <code>Collector</code> 对象,并将此 <code>Collector</code> 对象在 <code>prometheus.DefaultRegisterer</code> 中调用 <code>MustRegister()</code> 方法注册.因此如果注册失败,所有构造函数都会引发 <code>panics</code>.</p>
<p>以 <code>promauto.NewCounter()</code> 为例,源代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// github.com/prometheus/client_golang@v1.7.1/prometheus/promauto/auto.go#L167</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCounter</span><span class="params">(opts prometheus.CounterOpts)</span> <span class="title">prometheus</span>.<span class="title">Counter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> With(prometheus.DefaultRegisterer).NewCounter(opts)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Factory)</span> <span class="title">NewCounter</span><span class="params">(opts prometheus.CounterOpts)</span> <span class="title">prometheus</span>.<span class="title">Counter</span></span> &#123;</span><br><span class="line">    c := prometheus.NewCounter(opts) <span class="comment">// 调用 prometheus 包中对应方法,创建 Counter 实现对象</span></span><br><span class="line">    <span class="keyword">if</span> f.r != <span class="literal">nil</span> &#123;</span><br><span class="line">        f.r.MustRegister(c) <span class="comment">// 调用 `prometheus.DefaultRegisterer.MustRegister()` 方法对 Counter 进行注册</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c <span class="comment">// 返回已注册的 Counter 实现对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 `promauto` 包中方法创建的 Collector 对象 histogramRegistered 已被注册,可直接被公开为数据指标</span></span><br><span class="line"><span class="keyword">var</span> histogramRegistered = promauto.NewHistogram(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">"random_number_registered"</span>,</span><br><span class="line">        Help:    <span class="string">"A histogram of normally distributed random numbers."</span>,</span><br><span class="line">        Buckets: prometheus.LinearBuckets(<span class="number">-3</span>, <span class="number">.1</span>, <span class="number">61</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 `prometheus` 包中方法创建的 Collector 对象 histogramNotRegistered 没有被注册,需要手动进行注册才被公开为数据指标</span></span><br><span class="line"><span class="keyword">var</span> histogramNotRegistered = prometheus.NewHistogram(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">"random_number_not_registered"</span>,</span><br><span class="line">        Help:    <span class="string">"A histogram of normally distributed random numbers."</span>,</span><br><span class="line">        Buckets: prometheus.LinearBuckets(<span class="number">-3</span>, <span class="number">.1</span>, <span class="number">61</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 `init()` 函数中对 histogramNotRegistered 对象进行注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    prometheus.Register(histogramNotRegistered)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时,<code>promauto</code> 包还提供了 <code>With()</code> 函数.该函数返回创建 <code>Collector</code> 的工厂对象.通过该工厂对象创建的 <code>Collector</code> 都在传入的 <code>Registerer</code> 中进行注册.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">With</span><span class="params">(r prometheus.Registerer)</span> <span class="title">Factory</span></span> &#123; <span class="keyword">return</span> Factory&#123;r&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    reg           = prometheus.NewRegistry()</span><br><span class="line">    factory       = promauto.With(reg) <span class="comment">// 使用 reg 定义工厂对象</span></span><br><span class="line">    <span class="comment">// 创建已在 reg 中注册的 histogram 类型的数据对象,该对象实现了 Histogram 接口与 Metric 接口</span></span><br><span class="line">    randomNumbers = factory.NewHistogram(prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">"random_numbers"</span>,</span><br><span class="line">        Help:    <span class="string">"A histogram of normally distributed random numbers."</span>,</span><br><span class="line">        Buckets: prometheus.LinearBuckets(<span class="number">-3</span>, <span class="number">.1</span>, <span class="number">61</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 创建已在 reg 中注册的带有标签的 counter 类型的数据对象,该对象实现了 Collector 接口</span></span><br><span class="line">    requestCount = factory.NewCounterVec(</span><br><span class="line">        prometheus.CounterOpts&#123;</span><br><span class="line">            Name: <span class="string">"http_requests_total"</span>,</span><br><span class="line">            Help: <span class="string">"Total number of HTTP requests by status code and method."</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"code"</span>, <span class="string">"method"</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="promhttp-包"><a href="#promhttp-包" class="headerlink" title="promhttp 包"></a><code>promhttp</code> 包</h2><p><code>promhttp</code> 包允许创建 <code>http.Handler</code> 实例通过 HTTP 公开 Prometheus 数据指标.</p>
<h3 id="Handler-与-HandlerFor-函数"><a href="#Handler-与-HandlerFor-函数" class="headerlink" title="Handler() 与 HandlerFor() 函数"></a><code>Handler()</code> 与 <code>HandlerFor()</code> 函数</h3><p><code>promhttp</code> 包提供了 <code>Handler()</code> 函数使用默认的 <code>prometheus.DefaultGatherer</code> 返回一个 <code>http.Handler</code>.它将第一个错误报告为 HTTP 错误,没有错误记录.返回的 <code>http.Handler</code> 已使用 <code>InstrumentMetricHandler()</code> 函数和默认的 <code>prometheus.DefaultRegisterer</code> 进行检测.如果调用多个 <code>Handler()</code> 函数创建多个 <code>http.Handler</code>,则用于检测的数据指标将在它们之间共享,从而提供全局采集计数.如 <code>promhttp_metric_handler_requests_total</code> 和 <code>promhttp_metric_handler_requests_in_flight</code> 数据指标.</p>
<p><code>promhttp</code> 包提供了<code>HandlerFor()</code> 函数,您可以为自定义注册表或实现 <code>Gatherer</code> 接口的任何内容创建处理程序,还允许通过传入 <code>HandlerOpts</code> 对象自定义错误处理行为或记录错误的对象.</p>
<h3 id="InstrumentHandlerX-包装器函数"><a href="#InstrumentHandlerX-包装器函数" class="headerlink" title="InstrumentHandlerX 包装器函数"></a><code>InstrumentHandlerX</code> 包装器函数</h3><p><code>promhttp</code> 包提供了通过中间件来检测 <code>http.Handler</code> 实例的工具.中间件包装器遵循 <code>InstrumentHandlerX</code> 命名方案,其中 <code>X</code> 描述了中间件的预期用途.有关详细信息,请参见每个函数的文档注释.</p>
<p><code>promhttp</code> 包提供以下中间件包装器:</p>
<ul>
<li><code>func InstrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler) http.HandlerFunc</code></li>
</ul>
<p><code>InstrumentHandlerCounter</code> 包装传入的 <code>http.Handler</code>,并通过传入的 <code>prometheus.CounterVec</code> 记录不同请求方法或响应状态分组的计数结果.</p>
<p><code>CounterVec</code> 可以通过 HTTP 状态码或方法对 <code>CounterVec</code> 中带有相应标签实例的数据指标进行分组,其允许的标签名称是 <code>&quot;code&quot;</code> 和 <code>&quot;method&quot;</code>,否则该函数会引发 panics.对于未分区的计数,可使用不带标签的 <code>CounterVec</code>.如果装饰的 <code>Handler</code> 未设置状态码,默认为 200.</p>
<ul>
<li><code>func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc</code></li>
</ul>
<p><code>InstrumentHandlerDuration</code> 包装传入的 <code>http.Handler</code>,并通过传入的 <code>prometheus.ObserverVec</code> 记录不同请求方法或响应状态分组的持续时间.持续时间以秒为单位.</p>
<p>与 <code>CounterVec</code> 类似,<code>ObserverVec</code> 可以通过 HTTP 状态码或方法对 <code>ObserverVec</code> 中带有相应标签实例的数据指标进行分组,其默认允许的标签名称是 <code>&quot;code&quot;</code> 和 <code>&quot;method&quot;</code>,如果除 <code>method,code</code> 外有其它标签,需要在包装器中调用 <code>CurryWith()</code> 或 <code>MustCurryWith()</code> 传入标签的值,否则该函数会引发 panics.对于未分区的计数,可使用不带标签的 <code>ObserverVec</code>.如果装饰的 <code>Handler</code> 未设置状态码,默认为 200.</p>
<ul>
<li><code>func InstrumentHandlerInFlight(g prometheus.Gauge, next http.Handler) http.Handler</code></li>
</ul>
<p><code>InstrumentHandlerInFlight</code> 包装传入的 <code>http.Handler</code>,它通过传入的 <code>prometheus.Gauge</code> 记录处理的请求数</p>
<ul>
<li><code>func InstrumentHandlerRequestSize(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc</code></li>
</ul>
<p><code>InstrumentHandlerRequestSize</code> 包装传入的 <code>http.Handler</code>,它通过传入的 <code>prometheus.ObserverVec</code> 记录不同请求方法或响应状态分组的请求大小.请求大小以字节为单位.</p>
<p>与 <code>CounterVec</code> 类似,<code>ObserverVec</code> 可以通过 HTTP 状态码或方法对 <code>ObserverVec</code> 中带有相应标签实例的数据指标进行分组,其默认允许的标签名称是 <code>&quot;code&quot;</code> 和 <code>&quot;method&quot;</code>,如果除 <code>method,code</code> 外有其它标签,需要在包装器中调用 <code>CurryWith()</code> 或 <code>MustCurryWith()</code> 传入标签的值,否则该函数会引发 panics.对于未分区的计数,可使用不带标签的 <code>ObserverVec</code>.如果装饰的 <code>Handler</code> 未设置状态码,默认为 200.</p>
<ul>
<li><code>func InstrumentHandlerResponseSize(obs prometheus.ObserverVec, next http.Handler) http.Handler</code></li>
</ul>
<p><code>InstrumentHandlerResponseSize</code> 包装传入的 <code>http.Handler</code>,它通过传入的 <code>prometheus.ObserverVec</code> 记录不同请求方法或响应状态分组的响应大小.响应大小以字节为单位.</p>
<p>与 <code>CounterVec</code> 类似,<code>ObserverVec</code> 可以通过 HTTP 状态码或方法对 <code>ObserverVec</code> 中带有相应标签实例的数据指标进行分组,其默认允许的标签名称是 <code>&quot;code&quot;</code> 和 <code>&quot;method&quot;</code>,如果除 <code>method,code</code> 外有其它标签,需要在包装器中调用 <code>CurryWith()</code> 或 <code>MustCurryWith()</code> 传入标签的值,否则该函数会引发 panics.对于未分区的计数,可使用不带标签的 <code>ObserverVec</code>.如果装饰的 <code>Handler</code> 未设置状态码,默认为 200.</p>
<ul>
<li><code>func InstrumentHandlerTimeToWriteHeader(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc</code></li>
</ul>
<p><code>InstrumentHandlerResponseSize</code> 包装传入的 <code>http.Handler</code>,它通过传入的 <code>prometheus.ObserverVec</code> 记录不同请求方法或响应状态分组的写入响应头部的时间.持续时间以秒为单位.</p>
<p>与 <code>CounterVec</code> 类似,<code>ObserverVec</code> 可以通过 HTTP 状态码或方法对 <code>ObserverVec</code> 中带有相应标签实例的数据指标进行分组,其默认允许的标签名称是 <code>&quot;code&quot;</code> 和 <code>&quot;method&quot;</code>,如果除 <code>method,code</code> 外有其它标签,需要在包装器中调用 <code>CurryWith()</code> 或 <code>MustCurryWith()</code> 传入标签的值,否则该函数会引发 panics.对于未分区的计数,可使用不带标签的 <code>ObserverVec</code>.如果装饰的 <code>Handler</code> 未设置状态码,默认为 200.</p>
<ul>
<li><code>func InstrumentMetricHandler(reg prometheus.Registerer, handler http.Handler) http.Handler</code></li>
</ul>
<p><code>InstrumentMetricHandler</code> 通常与 <code>HandlerFor</code> 函数返回的 <code>http.Handler</code> 一起使用.它使用两个数据指标为传入的 <code>http.Handler</code> 进行包装: <code>promhttp_metric_handler_requests_total</code>(<code>CounterVec</code> 类型) 对按 HTTP 响应状态码分组的请求进行计数,<code>promhttp_metric_handler_requests_in_flight</code>(<code>Gauge</code> 类型) 跟踪同时进行的请求数量.</p>
<p>如上两个数据指标对于查看多少数据指标采集请求发送到监控目标上以及它们的重复率(同时有多少个采集请求)非常有用.</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>中间件包装器示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inFlightGauge := prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">        Name: <span class="string">"in_flight_requests"</span>,</span><br><span class="line">        Help: <span class="string">"A gauge of requests currently being served by the wrapped handler."</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 带有 "code", "method" 标签的计数器</span></span><br><span class="line">    counter := prometheus.NewCounterVec(</span><br><span class="line">        prometheus.CounterOpts&#123;</span><br><span class="line">            Name: <span class="string">"api_requests_total"</span>,</span><br><span class="line">            Help: <span class="string">"A counter for requests to the wrapped handler."</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"code"</span>, <span class="string">"method"</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 带标签的 duration.如果除 `method,code` 外有其它标签,需要在包装器中调用 `CurryWith()` 或 `MustCurryWith()` 传入标签的值.</span></span><br><span class="line">    duration := prometheus.NewHistogramVec(</span><br><span class="line">        prometheus.HistogramOpts&#123;</span><br><span class="line">            Name:    <span class="string">"request_duration_seconds"</span>,</span><br><span class="line">            Help:    <span class="string">"A histogram of latencies for requests."</span>,</span><br><span class="line">            Buckets: []<span class="keyword">float64</span>&#123;<span class="number">.25</span>, <span class="number">.5</span>, <span class="number">1</span>, <span class="number">2.5</span>, <span class="number">5</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"handler"</span>, <span class="string">"method"</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 不带标签的 responseSize</span></span><br><span class="line">    responseSize := prometheus.NewHistogramVec(</span><br><span class="line">        prometheus.HistogramOpts&#123;</span><br><span class="line">            Name:    <span class="string">"response_size_bytes"</span>,</span><br><span class="line">            Help:    <span class="string">"A histogram of response sizes for requests."</span>,</span><br><span class="line">            Buckets: []<span class="keyword">float64</span>&#123;<span class="number">200</span>, <span class="number">500</span>, <span class="number">900</span>, <span class="number">1500</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建将被中间件包装的 Handlers</span></span><br><span class="line">    pushHandler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(<span class="string">"Push"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    pullHandler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(<span class="string">"Pull"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在默认的注册表中注册所有的数据指标</span></span><br><span class="line">    prometheus.MustRegister(inFlightGauge, counter, duration, responseSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照以上定义的数据指标将 Handler 分组,并通过 `ObserverVec` 接口的 `MustCurryWith()` 方法传入 "handler" 标签</span></span><br><span class="line">    pushChain := promhttp.InstrumentHandlerInFlight(inFlightGauge,</span><br><span class="line">        promhttp.InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels&#123;<span class="string">"handler"</span>: <span class="string">"push"</span>&#125;),</span><br><span class="line">            promhttp.InstrumentHandlerCounter(counter,</span><br><span class="line">                promhttp.InstrumentHandlerResponseSize(responseSize, pushHandler),</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    pullChain := promhttp.InstrumentHandlerInFlight(inFlightGauge,</span><br><span class="line">        promhttp.InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels&#123;<span class="string">"handler"</span>: <span class="string">"pull"</span>&#125;),</span><br><span class="line">            promhttp.InstrumentHandlerCounter(counter,</span><br><span class="line">                promhttp.InstrumentHandlerResponseSize(responseSize, pullHandler),</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    http.Handle(<span class="string">"/metrics"</span>, promhttp.Handler())</span><br><span class="line">    <span class="comment">// 对不同的 HTTP 入口端点请求应用到带有不同标签的 Handler 中间件包装器</span></span><br><span class="line">    http.Handle(<span class="string">"/pull"</span>, pullChain)</span><br><span class="line">    http.Handle(<span class="string">"/push"</span>, pushChain)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":3000"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-包"><a href="#push-包" class="headerlink" title="push 包"></a><code>push</code> 包</h2><p><code>push</code> 包提供了将数据指标推送到 Pushgateway 的函数,它使用构造其函数 <code>New()</code> 创建 <code>Pusher</code> 对象,然后使用其实例方法添加各种选项,最后调用 <code>Add()</code> 或 <code>Push()</code> 方法向 Pushgateway 推送数据指标.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">push.New(<span class="string">"http://example.org/metrics"</span>, <span class="string">"my_job"</span>).Gatherer(myRegistry).Push()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Complex case:</span></span><br><span class="line">push.New(<span class="string">"http://example.org/metrics"</span>, <span class="string">"my_job"</span>).</span><br><span class="line">    Collector(myCollector1).</span><br><span class="line">    Collector(myCollector2).</span><br><span class="line">    Grouping(<span class="string">"zone"</span>, <span class="string">"xy"</span>).</span><br><span class="line">    Client(&amp;myHTTPClient).</span><br><span class="line">    BasicAuth(<span class="string">"top"</span>, <span class="string">"secret"</span>).</span><br><span class="line">    Add()</span><br></pre></td></tr></table></figure>

<p>源码解析如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// github.com/prometheus/client_golang/prometheus/push/push.go</span></span><br><span class="line"><span class="comment">// 定义 Pusher 结构体及构造方法</span></span><br><span class="line"><span class="keyword">type</span> Pusher <span class="keyword">struct</span> &#123;</span><br><span class="line">    error error</span><br><span class="line">    url, job <span class="keyword">string</span></span><br><span class="line">    grouping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>  </span><br><span class="line">    gatherers  prometheus.Gatherers</span><br><span class="line">    registerer prometheus.Registerer=</span><br><span class="line">    client             HTTPDoer</span><br><span class="line">    useBasicAuth       <span class="keyword">bool</span></span><br><span class="line">    username, password <span class="keyword">string</span></span><br><span class="line">    expfmt expfmt.Format</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(url, job <span class="keyword">string</span>)</span> *<span class="title">Pusher</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        reg = prometheus.NewRegistry()</span><br><span class="line">        err error</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> job == <span class="string">""</span> &#123;</span><br><span class="line">        err = errJobEmpty</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !strings.Contains(url, <span class="string">"://"</span>) &#123;</span><br><span class="line">        url = <span class="string">"http://"</span> + url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> strings.HasSuffix(url, <span class="string">"/"</span>) &#123;</span><br><span class="line">        url = url[:<span class="built_in">len</span>(url)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;Pusher&#123;</span><br><span class="line">        error:      err,</span><br><span class="line">        url:        url,</span><br><span class="line">        job:        job,</span><br><span class="line">        grouping:   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">        gatherers:  prometheus.Gatherers&#123;reg&#125;,</span><br><span class="line">        registerer: reg,</span><br><span class="line">        client:     &amp;http.Client&#123;&#125;, <span class="comment">// 使用默认的 HTTP 客户端</span></span><br><span class="line">        expfmt:     expfmt.FmtProtoDelim, <span class="comment">// 默认使用 expfmt.FmtProtoDelim</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 Gatherer 对象到 Pusher 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Gatherer</span><span class="params">(g prometheus.Gatherer)</span> *<span class="title">Pusher</span></span> &#123;</span><br><span class="line">    p.gatherers = <span class="built_in">append</span>(p.gatherers, g)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 Collector 对象到 Pusher 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Collector</span><span class="params">(c prometheus.Collector)</span> *<span class="title">Pusher</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.error == <span class="literal">nil</span> &#123;</span><br><span class="line">        p.error = p.registerer.Register(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Pusher 添加键值对分组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Grouping</span><span class="params">(name, value <span class="keyword">string</span>)</span> *<span class="title">Pusher</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.error == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !model.LabelName(name).IsValid() &#123;</span><br><span class="line">            p.error = fmt.Errorf(<span class="string">"grouping label has invalid name: %s"</span>, name)</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        &#125;</span><br><span class="line">        p.grouping[name] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Pusher 向 Pushgateway 发送请求的 HTTP 客户端</span></span><br><span class="line"><span class="comment">// HTTP 客户端是 `HTTPDoer` 接口的实现类,也就是实现了 `Do(*http.Request)` 方法</span></span><br><span class="line"><span class="comment">// 默认的 http.Client 满足这个要求,因此可以直接使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Client</span><span class="params">(c HTTPDoer)</span> *<span class="title">Pusher</span></span> &#123;</span><br><span class="line">    p.client = c</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BasicAuth 配置 Pusher 使用 HTTP Basic Authentication</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">BasicAuth</span><span class="params">(username, password <span class="keyword">string</span>)</span> *<span class="title">Pusher</span></span> &#123;</span><br><span class="line">    p.useBasicAuth = <span class="literal">true</span></span><br><span class="line">    p.username = username</span><br><span class="line">    p.password = password</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Format 配置 Pusher 使用 `expfmt.Format` 的编码类型.默认为 `expfmt.FmtProtoDelim`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Format</span><span class="params">(format expfmt.Format)</span> *<span class="title">Pusher</span></span> &#123;</span><br><span class="line">    p.expfmt = format</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pusher 向 Pushgateway 发送 DELETE 请求,删除 URL 下所有数据指标.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Delete</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.error != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.error</span><br><span class="line">    &#125;</span><br><span class="line">    req, err := http.NewRequest(http.MethodDelete, p.fullURL(), <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p.useBasicAuth &#123;</span><br><span class="line">        req.SetBasicAuth(p.username, p.password)</span><br><span class="line">    &#125;</span><br><span class="line">    resp, err := p.client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusAccepted &#123;</span><br><span class="line">        body, _ := ioutil.ReadAll(resp.Body) <span class="comment">// Ignore any further error as this is for an error message only.</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected status code %d while deleting %s: %s"</span>, resp.StatusCode, p.fullURL(), body)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 从添加到此 Pusher 的所有 Collector 和 Gatherer 收集所有指标,然后使用配置的作业名称和分组标签作为分组键,将指标推送到配置的 Pushgateway</span></span><br><span class="line"><span class="comment">// 具有该作业和其他分组标签的所有先前推送的数据指标将被此调用推送的指标替换.一般用于第一次推送(类似于删除原来推送的数据,后重新推送)</span></span><br><span class="line"><span class="comment">// Push 方法向 Pushgateway 发送 PUT 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Push</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.push(http.MethodPut)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 的工作方式类似于 Push,但只会替换具有相同名称(以及相同的作业和其他分组标签)的先前推送的指标.一般用于后续推送(类似于对此次推送的数据做更新或添加)</span></span><br><span class="line"><span class="comment">// Add 方法向 Pushgateway 发送 POST 请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">Add</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.push(http.MethodPost)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// github.com/prometheus/client_golang/prometheus/push/push.goL236</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pusher)</span> <span class="title">push</span><span class="params">(method <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.error != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.error</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里应该是收集各个注册的 Collector 的数据指标</span></span><br><span class="line">    mfs, err := p.gatherers.Gather()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    buf := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">    enc := expfmt.NewEncoder(buf, p.expfmt)</span><br><span class="line">    <span class="comment">// Check for pre-existing grouping labels:</span></span><br><span class="line">    <span class="keyword">for</span> _, mf := <span class="keyword">range</span> mfs &#123;</span><br><span class="line">        <span class="keyword">for</span> _, m := <span class="keyword">range</span> mf.GetMetric() &#123;</span><br><span class="line">            <span class="keyword">for</span> _, l := <span class="keyword">range</span> m.GetLabel() &#123;</span><br><span class="line">                <span class="keyword">if</span> l.GetName() == <span class="string">"job"</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> fmt.Errorf(<span class="string">"pushed metric %s (%s) already contains a job label"</span>, mf.GetName(), m)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> _, ok := p.grouping[l.GetName()]; ok &#123;</span><br><span class="line">                    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">                        <span class="string">"pushed metric %s (%s) already contains grouping label %s"</span>,</span><br><span class="line">                        mf.GetName(), m, l.GetName(),</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里应该是将 mf 序列化后写入了请求体 buf</span></span><br><span class="line">        enc.Encode(mf)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 http 包创建新请求,请求使用指定的 方法,URL 与 请求体 buf,并配置请求的各种参数</span></span><br><span class="line">    req, err := http.NewRequest(method, p.fullURL(), buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p.useBasicAuth &#123;</span><br><span class="line">        req.SetBasicAuth(p.username, p.password)</span><br><span class="line">    &#125;</span><br><span class="line">    req.Header.Set(contentTypeHeader, <span class="keyword">string</span>(p.expfmt))</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    resp, err := p.client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="comment">// Depending on version and configuration of the PGW, StatusOK or StatusAccepted may be returned.</span></span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusAccepted &#123;</span><br><span class="line">        body, _ := ioutil.ReadAll(resp.Body) <span class="comment">// Ignore any further error as this is for an error message only.</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected status code %d while pushing to %s: %s"</span>, resp.StatusCode, p.fullURL(), body)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 类中类方法,静态方法与属性方法</title>
    <url>/2020/06/19/python-classmethod-staticmethod/</url>
    <content><![CDATA[<h2 id="类变量与实例变量"><a href="#类变量与实例变量" class="headerlink" title="类变量与实例变量"></a>类变量与实例变量</h2><ul>
<li>类变量: 定义类时定义的变量,类的所有实例共享的属性和方法.可以通过类的实例与类进行访问</li>
<li>实例变量: 在实例初始化时定义,是每个实例唯一的属性.只能通过类的实例进行访问</li>
</ul>
<p>如下是 Python 官方文档 - <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" target="_blank" rel="noopener">类变量和实例变量</a>中给出的示例.</p>
<p><code>Dog</code> 类中定义了类变量 <code>kind</code>,值为 <code>canine</code>,此后实例化的所有实例都具有这个共享的属性 <code>kind = &#39;canine&#39;</code></p>
<p>而 <code>Dog</code> 类在实例化(初始化)时,会传入 <code>name</code> 参数,并赋值给实例的 <code>name</code> 属性,此参数在每个实例中是唯一的.在访问时,只能通过 <code>self.name</code> (这里的 <code>self</code> 表示类的实例) 进行访问.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span>         <span class="comment"># 所有实例共享的类变量 class variable shared by all instances</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name    <span class="comment"># 每个实例唯一的实例变量 instance variable unique to each instance</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.kind</span><br><span class="line"><span class="string">'canine'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.kind</span><br><span class="line"><span class="string">'canine'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.name</span><br><span class="line"><span class="string">'Fido'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name</span><br><span class="line"><span class="string">'Buddy'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog.kind</span><br><span class="line"><span class="string">'canine'</span></span><br></pre></td></tr></table></figure>

<h2 id="类方法与静态方法"><a href="#类方法与静态方法" class="headerlink" title="类方法与静态方法"></a>类方法与静态方法</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>普通方法: Python 类中定义的普通方法,无需要任何额外的修饰符或装饰器.其第一个参数必须为 <code>self</code>,表示调用该方法的实例.只能通过类的实例进行调用.普通方法的方法体中可以使用类变量与实例变量</li>
<li>类方法: Python 类中通过 <a href="https://docs.python.org/3/library/functions.html#classmethod" target="_blank" rel="noopener"><code>@classmethod</code></a> 装饰器装饰的方法.其第一个参数必须为 <code>cls</code>,表示调用该方法的类.可以通过类名或类的实例进行调用.类方法的方法体中只能使用类变量,不能使用实例变量</li>
<li>静态方法: Python 类中通过 <a href="https://docs.python.org/3/library/functions.html#staticmethod" target="_blank" rel="noopener"><code>staticmethod</code></a> 装饰器修饰的方法.其可以传入任意参数.可以通过类名或类的实例进行调用.静态方法的方法体中均不能访问类变量与实例变量</li>
</ul>
<p>参考 stackflow 上有关<a href="https://stackoverflow.com/questions/136097/difference-between-staticmethod-and-classmethod" target="_blank" rel="noopener">静态方法与类方法的区别</a>的相关回答,示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing foo(%s, %s)"</span> % (self, x))</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls, x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing class_foo(%s, %s)"</span> % (cls, x))</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing static_foo(%s)"</span> % x)</span><br><span class="line"></span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure>

<ul>
<li>普通方法调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.foo(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># executing foo(&lt;__main__.A object at 0x0000016FC6A4BBA8&gt;, 1)</span></span><br><span class="line"></span><br><span class="line">print(a.foo)</span><br><span class="line"><span class="comment"># &lt;bound method A.foo of &lt;__main__.A object at 0x000002A2F312BB70&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用过程中,对象的实例 <code>a</code> 作为第一个参数 <code>self</code> 传入.</p>
<ul>
<li>类方法调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.class_foo(<span class="number">1</span>) <span class="comment"># 通过类的实例调用</span></span><br><span class="line"><span class="comment"># executing class_foo(&lt;class '__main__.A'&gt;,1)</span></span><br><span class="line">print(a.class_foo)</span><br><span class="line"><span class="comment"># &lt;bound method A.class_foo of &lt;class '__main__.A'&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">A.class_foo(<span class="number">1</span>) <span class="comment"># 通过类直接调用</span></span><br><span class="line"><span class="comment"># executing class_foo(&lt;class '__main__.A'&gt;,1)</span></span><br><span class="line">print(A.class_foo)</span><br><span class="line"><span class="comment"># &lt;bound method A.class_foo of &lt;class '__main__.A'&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>在使用类的实例进行调用时,类方法会将该实例的类作为第一个参数 <code>cls</code> 隐式传入.且类方法可以通过类直接调用,而无需实例化.</p>
<p>类方法的一个应用场景是通过类直接调用类方法创建可继承的替代构造函数.详细可以参考<a href="https://stackoverflow.com/questions/1950414/what-does-classmethod-do-in-this-code/1950927" target="_blank" rel="noopener">这里</a>.</p>
<ul>
<li>静态方法调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.static_foo(A) <span class="comment"># 通过类的实例调用</span></span><br><span class="line"><span class="comment"># executing static_foo(&lt;class '__main__.A'&gt;)</span></span><br><span class="line">print(a.static_foo)</span><br><span class="line"><span class="comment"># &lt;function static_foo at 0xb7d479cc&gt;</span></span><br><span class="line"></span><br><span class="line">A.static_foo(a) <span class="comment"># 通过类直接调用</span></span><br><span class="line"><span class="comment"># executing static_foo(&lt;__main__.A object at 0x000002A2F312BB70&gt;)</span></span><br><span class="line">print(A.static_foo)</span><br><span class="line"><span class="comment"># &lt;function static_foo at 0xb7d479cc&gt;</span></span><br></pre></td></tr></table></figure>

<p>静态方法可通过类的实例或类直接调用,而且其传入的参数为任意参数.看起来与直接在 Python 模块中定义方法没有什么区别.</p>
<p>静态方法用于具有与类的类中的一些逻辑连接的功能.</p>
<p>考虑如下场景,当每个类中分别包含一个只有在本类或对象中使用的函数时,如果将其定义在模块中,会导致模块中具有很多这种函数,从而变得臃肿,不容易代码组织,及重构.而定义为静态方法,只需要对类进行组织即可,重构时也会变得简单.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上,可总结如下:</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">定义方式</th>
<th align="center">参数</th>
<th align="center">调用方式</th>
<th align="center">访问属性的权限</th>
<th align="center">本质</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通方法</td>
<td align="center">在类中直接定义</td>
<td align="center">第一个参数必须传入 <code>self</code> 参数</td>
<td align="center">通过类的实例进行调用</td>
<td align="center">可以访问实例变量和类变量</td>
<td align="center">与对象实例绑定的方法</td>
<td align="center">实例调用</td>
</tr>
<tr>
<td align="center">类方法</td>
<td align="center">通过 <code>@classmethod</code> 装饰器</td>
<td align="center">第一个参数必须是 <code>cls</code> 参数</td>
<td align="center">通过类名或类的实例进行调用</td>
<td align="center">不能访问实例变量,可以访问类变量</td>
<td align="center">与类绑定的方法</td>
<td align="center">创建可继承的构造函数</td>
</tr>
<tr>
<td align="center">静态方法</td>
<td align="center">通过 <code>@staticmethod</code> 装饰器</td>
<td align="center">可传入任意参数</td>
<td align="center">通过类名或类的实例直接调用</td>
<td align="center">不能访问实例变量和类变量</td>
<td align="center">本质是逻辑上的类函数</td>
<td align="center">组织代码,而不是将所有函数的变体定义在模块中</td>
</tr>
</tbody></table>
<h2 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h2><p>Python 中支持使用 <code>@property</code>,<code>@&lt;property&gt;.setter</code>,<code>@&lt;property&gt;.deleter</code> 将类中定义的方法转换为类对象的属性.其中 <code>&lt;property&gt;</code> 表示被 <code>@property</code> 装饰的返回实例属性(包括类共享属性及实例唯一属性)的方法,且以上三个装饰器修饰的方法名必须一致.如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"><span class="meta">    @property # 添加装饰器,将 x 方法转换为 C 对象实例的一个属性,可通过 `c.x` 直接执行此方法体内容,从而返回属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""I'm the 'x' property."""</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"><span class="meta">    @x.setter # 添加装饰器,设置可通过 `c.x = xxx` 直接调用此方法体内容,从而修改属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"><span class="meta">    @x.deleter # 添加装饰器,设置可通过 `del c.x` 直接调用此方法体内容,从而删除或修改属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x = <span class="number">1</span> <span class="comment"># 可直接修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x <span class="comment"># 可直接访问</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c.x <span class="comment"># 可直接删除</span></span><br></pre></td></tr></table></figure>

<p>其实,Python 中内置了 <code>property</code> 类,其返回一个 <code>属性</code> 对象.其中 <code>fget</code> 是用于获取属性值的函数,<code>fset</code> 是用于设置属性值的函数,<code>fdel</code> 是用于删除该属性的函数,<code>doc</code> 是该属性的帮助文档<br>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span><span class="params">(fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>其使用方式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 协程之 yield 和 yield from 表达式</title>
    <url>/2020/06/15/python-coroutine-yield-and-yield-from-expression/</url>
    <content><![CDATA[<p>由于 GIL 的存在,Python 多线程性能甚至比单线程更糟.</p>
<p>协程是一种用户态的轻量级线程,它可以在两个函数或逻辑流中自由切换,但这一过程并没有函数调用.协程实际上是运行在单个线程中,因此没有线程上下文切换的开销.</p>
<p>协程拥有自己的寄存器上下文和栈,协程调度切换时,将寄存器上下文和栈保存到其他地方,在切回来的时候,恢复之前保存的寄存器上下文和栈.因此协程能够保留上一次调用时的状态,能够进入上一次切换时所处的逻辑流的位置.</p>
<p>从句法上看,协程与生成器类似,都是定义体中包含 <code>yield</code> 关键字的函数.可是,在协程中,</p>
<ul>
<li><code>yield</code> 关键字通常出现在表达式的右边(如 <code>datum = yield</code>)</li>
<li>可以产出值,也可以不产出(如果 <code>yield</code> 关键字后面没有表达式,那么产出 <code>None</code>)</li>
<li>协程可以从调用方通过调用 <code>.send(datum)</code> 函数接收数据,而不是 <code>next()</code> 函数</li>
</ul>
<p>不管数据流如何移动,可以把 <code>yield</code> 看作是一种流程控制工具.协程可以把控制器交给中心调度程序,从而激活其它协程.</p>
<h2 id="yield-表达式-由生成器进化为协程"><a href="#yield-表达式-由生成器进化为协程" class="headerlink" title="yield 表达式 - 由生成器进化为协程"></a>yield 表达式 - 由生成器进化为协程</h2><p>协程的底层架构在 <a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="noopener">PEP 342—Coroutines via Enhanced Generators</a> 中定义,并在 Python 2.5 实现了.自此之后 <code>yield</code> 关键字可以在表达式中使用,且生成器 API 增加了 <code>.send(value)</code> 方法.<strong>生成器的调用方可以使用 <code>.send(...)</code> 方法发送数据,发送数据会成为生成器函数中 <code>yield</code> 表达式的值.</strong>因此,生成器可以作为协程使用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span>  <span class="comment"># 定义生成器函数(带有 yield 关键字)</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    x = <span class="keyword">yield</span>  <span class="comment"># yield 在表达式中使用,此处协程只从调用方接收数据,产出值为 None</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine received:'</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()  <span class="comment"># 与创建生成器方式一样,调用生成器函数得到生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro</span><br><span class="line">&lt;generator object simple_coroutine at <span class="number">0x000001E193DC8AF0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro)  <span class="comment"># 首先调用 next() 函数,启动生成器,并在 yield 关键字处暂停,等待接收数据</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># 这一步骤做了两件事</span></span><br><span class="line"><span class="comment"># - 向生成器发送数据 42 后,发送数据作为 yield 关键字表达式产出数据,并赋值给变量 x.# - 协程恢复,一直运行到下一个 yield 表达式或终止.</span></span><br><span class="line">-&gt; coroutine received: 42</span><br><span class="line">Traceback (most recent call last):  <span class="comment"># 此处控制权流动到定义体的末尾,生成器像往常一样抛出异常.</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>协程一定处于如下四个状态中的一个,当前状态可使用 <code>inspect.getgeneratorstate(...)</code> 函数确定.</p>
<ul>
<li><code>GEN_CREATED</code>: 协程创建,等待开始执行</li>
<li><code>GEN_RUNNING</code>: 协程正在执行.(多线程应用才能看到这个状态)</li>
<li><code>GEN_SUSPENDED</code>: 在 <code>yield</code> 表达式处暂停</li>
<li><code>GEN_CLOSED</code>: 执行结束</li>
</ul>
<p><code>send()</code> 方法的参数会成为暂停的 <code>yield</code> 表达式的值,所以,仅当协程处于暂停状态时才能调用 <code>send()</code> 方法传入非空值.如果协程还没激活(即,状态是 ‘GEN_CREATED’),则需要调用 <code>next(my_coro)</code> 或 <code>my_coro.send(None)</code>,传入 None,激活协程.</p>
<blockquote>
<p>如果创建协程对象后立即把 None 之外的值发给它,会出现下述错误 <code>TypeError: can&#39;t send non-None value to a just-started generator</code>.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(<span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2) <span class="comment"># 通过 getgeneratorstate 函数查看协程状态为 GEN_CREATED</span></span><br><span class="line"><span class="string">'GEN_CREATED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2) <span class="comment"># 启动协程,执行到第一个 yield 表达式,然后产出 a 的值,并且暂停,等待传入值.</span></span><br><span class="line">-&gt; Started: a = 14</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2) <span class="comment"># 当前协程状态为暂停</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">28</span>) <span class="comment"># 将 28 发给暂停的协程,计算 yield 表达式,得到 28,并赋值给 b.并继续向下执行,直到下一个 yield 表达式,产出 a + b 的值,协程暂停.等待传入值.</span></span><br><span class="line">-&gt; Received: b = 28</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">99</span>) <span class="comment"># 向当前协程传入 99,计算 yield 表达式,并赋值给变量 c,向下执行,直到协程终止,导致生成器对象抛出 StopIteration 异常</span></span><br><span class="line">-&gt; Received: c = 99</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2) <span class="comment"># 此时协程处于关闭状态</span></span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>传统的生产者-消费者模型是一个线程写消息,一个线程取消息,通过锁机制控制队列和等待,但一不小心就可能死锁.</p>
<p>以下是使用协程实现的生产者消费者模型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure>

<p><code>consumer()</code> 函数是一个生成器函数,调用生成器函数得到生成器对象 <code>c</code>,传入 <code>produce()</code> 后:</p>
<ol>
<li>调用 <code>c.send(None)</code> 启动协程.流程控制跳转到 <code>consumer()</code> 函数中执行,直到遇到 <code>yield</code> 表达式.此时协程处于暂停状态,生成 <code>r</code>(为空字符串),并等待数据发送.</li>
<li><code>produce()</code> 继续执行,并调用 <code>c.send(n)</code> 向协程发送数据</li>
<li><code>consumer()</code> 函数通过 <code>yield</code> 接收到数据,赋值给变量 <code>n</code>,继续执行,打印消息 -&gt; 赋值变量 r -&gt; 进入下一次循环后生成 <code>r</code>(为 200 OK),直到遇到 <code>yield</code> 表达式</li>
<li><code>produce()</code> 继续生产下一条数据,重复上述生产消费模型,直到跳出循环</li>
<li><code>produce()</code> 调用 <code>c.close()</code> 关闭生成器/协程</li>
</ol>
<h3 id="预激协程的装饰器"><a href="#预激协程的装饰器" class="headerlink" title="预激协程的装饰器"></a>预激协程的装饰器</h3><p>调用 <code>my_coro.send(x)</code> 之前,记住一定要调用 <code>next(my_coro)</code> 或 <code>my_coro.send(None)</code>.为了简化协程的用法,有时会使用一个预激装饰器.示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args,**kwargs)</span>:</span> <span class="comment"># 把被装饰的生成器函数替换成这里的 primer 函数.调用 primer 函数时,返回预激后的生成器</span></span><br><span class="line">        gen = func(*args,**kwargs) <span class="comment"># 调用被装饰的函数,获取生成器对象</span></span><br><span class="line">        next(gen) <span class="comment"># 预激生成器</span></span><br><span class="line">        <span class="keyword">return</span> gen <span class="comment"># 返回</span></span><br><span class="line">    <span class="keyword">return</span> primer</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coro(<span class="number">14</span>) <span class="comment"># 生成器/协程在函数调用时就被预激了</span></span><br><span class="line">-&gt; Started: a = 14</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro) <span class="comment"># 此时协程状态为暂停状态</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">28</span>) <span class="comment"># 可以直接发送数据</span></span><br><span class="line">-&gt; Received: b = 28</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h3 id="终止协程及异常处理"><a href="#终止协程及异常处理" class="headerlink" title="终止协程及异常处理"></a>终止协程及异常处理</h3><p>协程中未处理的异常会向上冒泡,传给 <code>next()</code> 函数或 <code>send()</code> 方法的调用方(即触发协程的对象).未处理的异常会导致协程终止.如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coro(<span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro)</span><br><span class="line">-&gt; Started: a = 14</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="string">'spam'</span>) <span class="comment"># 发送数据后,在 a + b 过程中会抛出异常</span></span><br><span class="line">-&gt; Received: b = spam</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> simple_coro</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">60</span>)  <span class="comment"># 未处理的异常导致协程终止,再次发送数据,抛出 StopIteration</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> getgeneratorstate(my_coro) <span class="comment"># 查看此时协程状态为 GEN_CLOSED</span></span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure>

<p>从 Python 2.5 开始,客户端代码可以在生成器对象上调用如下两个方法,显示地将异常发送给协程.</p>
<ul>
<li><code>generator.throw(exc_type[, exc_value[, traceback]])</code></li>
</ul>
<p>生成器在暂停的 <code>yield</code> 表达式处显式地抛出异常.如果生成器处理了抛出的异常,代码会向前执行到下一个 <code>yield</code> 表达式;否则,异常会向上冒泡,传到调用方的上下文中.</p>
<ul>
<li><code>generator.close()</code></li>
</ul>
<p>使生成器在暂停的 <code>yield</code> 表达式处抛出 <code>GeneratorExit</code> 异常,并进行处理.如果生成器抛出 <code>StopIteration</code> 异常(通常指运行到结尾),调用方不会报错,从而关闭生成器.</p>
<p>如下是协程中处理异常的示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> DemoException: <span class="comment"># 处理自定义异常</span></span><br><span class="line">            print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 否则打印接收到的内容</span></span><br><span class="line">            print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro = demo_exc_handling()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(exc_coro)</span><br><span class="line">-&gt; coroutine started</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.send(<span class="number">11</span>)</span><br><span class="line">-&gt; coroutine received: 11</span><br><span class="line"> &gt;&gt;&gt; exc_coro.throw(DemoException) <span class="comment"># 显示抛出 DemoException 异常</span></span><br><span class="line">*** DemoException handled. Continuing...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)  <span class="comment"># 显示当前协程状态为 GEN_SUSPENDED,表示仍可以传入数据</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.send(<span class="number">22</span>) <span class="comment"># 仍可以继续发送数据</span></span><br><span class="line">-&gt; coroutine received: 22</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.throw(ZeroDivisionError) <span class="comment"># 显示传入无法处理的异常后,协程终止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">ZeroDivisionError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; exc_coro.close() # 或显示关闭后,查看状态为 GEN_CLOSED,此时不可以发送数据</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; getgeneratorstate(exc_coro)</span></span><br><span class="line"><span class="comment"># 'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure>

<h3 id="协程返回值"><a href="#协程返回值" class="headerlink" title="协程返回值"></a>协程返回值</h3><p>先看如下示例,<code>averager</code> 协程返回的结果是一个 <code>namedtuple</code>,两个字段分别是项数(count)和平均值(average).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 如果激活协程后,调用方发送 None.则跳出循环,返回 Result 对象</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)</span><br></pre></td></tr></table></figure>

<p>我们首先来看一下,向激活的协程发送 <code>None</code> 会返回什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(coro_avg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">6.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="literal">None</span>) <span class="comment"># 发送 None</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">StopIteration: Result(count=<span class="number">3</span>, average=<span class="number">15.5</span>) <span class="comment"># 可以看到 StopIteration 异常的值为我们想要返回的 Result 对象</span></span><br></pre></td></tr></table></figure>

<p>因此我们可以捕获 <code>StopIteration</code> 异常,获取 averager 返回的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(coro_avg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">6.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    coro_avg.send(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc: <span class="comment"># 捕获 StopIteration 异常,将其 value 赋值给 result</span></span><br><span class="line"><span class="meta">... </span>    result = exc.value</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">Result(count=<span class="number">3</span>, average=<span class="number">15.5</span>)</span><br></pre></td></tr></table></figure>

<p>以上获取带有 <code>yield</code> 关键字表达式的协程的返回值虽然要绕个圈子,但这是 PEP 380 定义的方式.而 <code>yield from</code> 结构会在内部自动捕获 <code>StopIteration</code> 异常.这种处理方式与 for 循环处理 <code>StopIteration</code> 异常的方式一样: 循环机制以用户易于理解的方式处理异常.对 <code>yield from</code> 结构来说,解释器不仅会捕获 <code>StopIteration</code> 异常,还会把异常的 <code>value</code> 属性的值变成 <code>yield from</code> 表达式的值.</p>
<h2 id="yield-from-表达式"><a href="#yield-from-表达式" class="headerlink" title="yield from 表达式"></a>yield from 表达式</h2><p>首先要知道,<code>yield from &lt;expr&gt;</code> 表达式是全新的语言结构,其中 <code>&lt;expr&gt;</code> 为可迭代对象.</p>
<h3 id="yield-from-表达式做了什么"><a href="#yield-from-表达式做了什么" class="headerlink" title="yield from 表达式做了什么"></a>yield from 表达式做了什么</h3><ul>
<li><code>yield from &lt;expr&gt;</code> 对 <code>&lt;expr&gt;</code> 可迭代对象所做的第一件事是调用 <code>iter(&lt;expr&gt;)</code>,从中获取迭代器.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'AB'</span>:</span><br><span class="line">        <span class="keyword">yield</span> c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以转化为如下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># `yield from` 可用于简化 for 循环中的 `yield` 表达式</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>yield from &lt;expr&gt;</code> 表达式会捕获 <code>&lt;expr&gt;</code> 可迭代对象迭代结束后的 <code>StopIteration</code> 异常,并把异常的 <code>value</code> 属性的值变成 <code>yield from</code> 表达式的值</p>
</li>
<li><p>当 <code>&lt;expr&gt;</code> 是另一个生成器时,允许子生成器执行带有返回值的 <code>return</code> 语句,并且该返回值将成为 <code>yield from</code> 表达式 的值</p>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>yield from</code> 的主要功能是打开双向通道,把最外层的调用方与最内层的子生成器连接起来,这样二者可以直接发送和产出值,还可以直接传入异常.而不用在位于中间的协程中添加大量处理异常的代码.</p>
<p><code>yield from</code> 表达式中包含 3 个概念:</p>
<ul>
<li>委派生成器: 包含 <code>yield from &lt;iterable&gt;</code> 表达式的生成器函数</li>
<li>子生成器: 从 <code>yield from</code> 表达式中 <code>&lt;iterable&gt;</code> 部分获取的生成器</li>
<li>调用方: PEP 380 使用”调用方”这个术语指代调用委派生成器的客户端代码</li>
</ul>
<p><img src="/images/yield-from.png" alt="yield-from"></p>
<p>委派生成器在 <code>yield from</code> 表达式处暂停时,调用方可以直接把数据发给子生成器,子生成器再把产出的值发给调用方.子生成器返回结束后(调用方传入向子生成器传入 None 时),子生成器会抛出 <code>StopIteration</code> 异常,并把返回值附加到异常对象上,此时委派生成器会恢复,并捕获异常.</p>
<p>如下代码示例描述起来可能更直观一点.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器, 带有 yield 表达式的生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> <span class="comment"># main 函数中的客户代码发送的各个值绑定到这里的 term 变量上</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 如果发送数据为 None,则跳出循环,返回 Result 对象</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average) <span class="comment"># 返回 Result 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器,带有 yield from 表达式的生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 每次迭代时会新建一个 averager 实例,每个实例都是作为协程使用的生成器对象</span></span><br><span class="line">        <span class="comment"># grouper 发送的每个值都会经由 yield from 处理,通过管道传给 averager 实例.</span></span><br><span class="line">        <span class="comment"># grouper 会在 yield from 表达式处暂停，等待 averager 实例处理客户端发来的值.</span></span><br><span class="line">        <span class="comment"># averager 实例运行完毕后,返回的值绑定到 results[key] 上.</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key) <span class="comment"># 调用 grouper 函数,返回生成器对象.group 作为协程使用</span></span><br><span class="line">        next(group) <span class="comment"># 启动/激活协程</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value) <span class="comment"># 将 data.key 中数据传给 group 协程.传入的值最终到达 averager 函数中 `term = yield` 那一行.grouper 函数永远不知道传入的值是什么</span></span><br><span class="line">        group.send(<span class="literal">None</span>) <span class="comment"># 重要!</span></span><br><span class="line">        <span class="comment"># 数据发送完毕后,传入 None ,终止当前的 averager 实例,返回 Result 对象.</span></span><br><span class="line">        <span class="comment"># 让 grouper 继续运行,再创建一个 averager 实例,处理下一组值</span></span><br><span class="line">    print(results) <span class="comment"># 待全部 key 循环完后,打印最终结果</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'girls;kg'</span>: [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>: [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>: [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>: [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure>

<p>上述示例阐明了如下四点,参见 <a href="https://www.python.org/dev/peps/pep-0380/#proposal" target="_blank" rel="noopener">PEP 380 Proposal</a>小节</p>
<ul>
<li>子生成器产生的任何值都将直接传递给调用方(如上示例中的 main 函数代码)</li>
<li>使用 <code>send()</code> 方法发给委派生成器的值都直接传给子生成器.如果发送的值是 None,那么会调用子生成器的 <code>__next__()</code> 方法.如果发送的值不是 None,那么会调用子生成器的 <code>send()</code> 方法.如果调用的方法抛出 <code>StopIteration</code> 异常,那么委派生成器恢复运行,而任何其他异常都会向上冒泡,传给委派生成器</li>
<li>生成器退出时,子生成器中的 <code>return expr</code> 表达式会触发 <code>StopIteration(expr)</code> 异常抛出</li>
<li><code>yield from</code> 表达式的值是子生成器终止时传给 <code>StopIteration</code> 异常的第一个参数</li>
</ul>
<p>以下是 <code>RESULT = yield from EXPR</code> 简化的伪代码,没有处理委派生成器调用 <code>.throw(...)</code> 和 <code>.close()</code> 方法,且只处理了 <code>StopIteration</code> 异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _i 子生成器</span></span><br><span class="line"><span class="comment"># _y 子生成器产出的值</span></span><br><span class="line"><span class="comment"># _r 最终返回结果,yield from 表达式的值</span></span><br><span class="line"><span class="comment"># _s 调用方发给委派生成器的值,这个值会转发给子生成器</span></span><br><span class="line"><span class="comment"># _e 异常对象,伪代码中始终是 StopIteration 实例</span></span><br><span class="line">_i = iter(EXPR) <span class="comment"># EXPR 是可迭代对象,因此调用 iter(EXPR) 获取迭代器 _i(这是子生成器)</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = next(_i) <span class="comment"># 预激子生成器,将产出结果保存在 _y 中</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value <span class="comment"># 如果抛出 StopIteration 异常,则获取异常对象的 value 属性,并赋值给 _r</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>: <span class="comment"># 运行循环,委派生成器会阻塞,只作为调用方和子生成器之间的通道</span></span><br><span class="line">        _s = <span class="keyword">yield</span> _y <span class="comment"># 产出子生成器当前产出的元素,并等待调用方发送数据(代码示例中为 `group.send`),并赋值给变量 _s</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _y = _i.send(_s) <span class="comment"># 将调用方发送的 _s 发送到子生成器中,尝试让子生成器向前执行</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e: <span class="comment"># 如果子生成器抛出 StopIteration 异常,获取其 value 属性的值,赋值给 _r,然后退出循环,让委派生成器恢复运行</span></span><br><span class="line">            _r = _e.value</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">RESULT = _r <span class="comment"># _r 是我们想要返回的结果,是整个 yield from 表达式的值</span></span><br></pre></td></tr></table></figure>

<p>另外可以参考 <a href="https://www.python.org/dev/peps/pep-0380/#formal-semantics" target="_blank" rel="noopener">PEP 380 Formal Semantics</a> 中对 <code>RESULT = yield from EXP</code> 表达式给出的完整伪代码.</p>
<hr>
<p>参考:</p>
<ul>
<li><a href="http://product.dangdang.com/25071121.html" target="_blank" rel="noopener">流畅的 Python</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824" target="_blank" rel="noopener">廖雪峰 Python 教程 - 异步IO - 协程</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 装饰器</title>
    <url>/2020/06/17/python-decorator/</url>
    <content><![CDATA[<p>在理解学习装饰器之前,首先要将 Python 中函数视作对象.如下我们在定义一个函数后,确定函数对象本身是 <code>function</code> 类的实例,并通过别的名称使用函数,将函数作为参数传递.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * func(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(func) <span class="comment"># 查看函数的类型为 function,我们定义的函数即为 function 的一个实例</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; fact = func # 通过别的名称使用函数</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact</span><br><span class="line">&lt;function func at <span class="number">0x000001C68E521E18</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(func, range(<span class="number">11</span>)) <span class="comment"># 函数可以作为参数传递</span></span><br><span class="line">&lt;map object at <span class="number">0</span>x...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, range(<span class="number">11</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>, <span class="number">3628800</span>]</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><blockquote>
<p>接受函数作为参数,或将函数作为结果返回的函数是高阶函数.</p>
</blockquote>
<p>如上述示例中的 <code>map</code> 函数,它以我们定义的 <code>func</code> 函数作为参数传递,实现高阶函数的效果.另外,内置函数 <code>sorted</code> 函数也是.可选的 <code>key</code> 参数用于提供一个函数,此函数会应用到各个元素上,并以函数的返回结果进行排序.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'strawberry'</span>, <span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'raspberry'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=len)</span><br><span class="line">[<span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'banana'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>]</span><br></pre></td></tr></table></figure>

<p>最为人熟知的高阶函数有 <code>map</code>,<code>filter</code>, <code>sorted</code>,<code>reduce</code>.其中 <code>map</code>,<code>filter</code> 可以被列表推导式或生成器推导式所替代.<code>reduce</code> 函数从 Python 3.0 开始就不会内置函数了,需要从 <code>functools</code> 包导入(<code>from functools import reduce</code>).</p>
<h2 id="装饰器原理"><a href="#装饰器原理" class="headerlink" title="装饰器原理"></a>装饰器原理</h2><p><strong>装饰器函数其实是这样一个接口约束,它必须接受一个可调用对象作为参数,然后返回一个可调用对象.使用装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能</strong>.</p>
<blockquote>
<p>可调用对象详见 <a href="/2020/06/17/python-object-classification/" title="Python 对象分类">Python 对象分类</a> 中可调用对象小节.</p>
</blockquote>
<p>假设有如下装饰器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此装饰器可能不能实现"面向切面编程"的效果,此处仅作为演示示例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'running inner()'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码的效果与下述写法一样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'running inner()'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line">target = decorate(target)</span><br><span class="line"><span class="comment"># 可以看到调用 target 实际上调用的不一定是原来的那个 target 函数,而是 decorate(target) 返回的可调用对象</span></span><br></pre></td></tr></table></figure>

<p>严格的来说,装饰器只是语法糖.装饰器可以像常规可调用对象那样调用,其参数是另一个函数.</p>
<ul>
<li>装饰器能将被装饰的函数替换成其它函数</li>
<li>装饰器在加载模块时立即执行</li>
</ul>
<h3 id="Python-何时执行装饰器"><a href="#Python-何时执行装饰器" class="headerlink" title="Python 何时执行装饰器"></a>Python 何时执行装饰器</h3><p>装饰器在被装饰的函数定义之后立即运行.这通常发生在导入模块时.如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># registration.py</span></span><br><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个装饰器,将被装饰的函数添加到 registry 中,然后返回该函数</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码 @register 可替换为</span></span><br><span class="line"><span class="comment"># f1 = register(f1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码 @register 可替换为</span></span><br><span class="line"><span class="comment"># f1 = register(f3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>直接执行,结果如下:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3 registration.py</span><br><span class="line">running register(&lt;function f1 at 0x100631bf8&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x100631c80&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x100631bf8&gt;, &lt;function f2 at 0x100631c80&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure>

<p>若作为模块导入,输出如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> registration</span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10063b1e0</span>&gt;)</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10063b268</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registration.registry  <span class="comment"># 查看 registry 的值</span></span><br><span class="line">[&lt;function f1 at <span class="number">0x10063b1e0</span>&gt;, &lt;function f2 at <span class="number">0x10063b268</span>&gt;]</span><br></pre></td></tr></table></figure>

<p>上述情况应该不难理解.装饰器若在导入的模块中应用,则相当于在导入的模块中调用了两次装饰器的定义函数(上述示例中为 <code>register</code>),并将函数的返回值赋值给了 <code>f1</code> 与 <code>f2</code>.具体可参见注释部分.</p>
<p>考虑到真实代码中的常用方式,上述代码有两个不同的地方:</p>
<ul>
<li>上述代码中装饰器函数与被装饰函数在同一模块中定义,而真实情况中,装饰器通常在一个模块中定义,然后应用到其它模块中的函数上.此时就不是导入时运行了,而可以理解为应用时运行(python 解释器解释到被装饰函数或类时,装饰器运行)</li>
<li><code>register</code> 装饰器返回的函数与通过参数传入的相同.但是,实际上,大多数装饰器会在内部定义一个函数,然后将其返回.</li>
</ul>
<h2 id="装饰器实现"><a href="#装饰器实现" class="headerlink" title="装饰器实现"></a>装饰器实现</h2><h3 id="计时器实现"><a href="#计时器实现" class="headerlink" title="计时器实现"></a>计时器实现</h3><p>如下示例实现了一个装饰器,用于计算被装饰函数的运行时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clockdeco_demo.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func()</span><br><span class="line">        name = func.__name__</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'%s function spent %s'</span> % (name, (end-start)))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>

<p>使用如上定义的装饰器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> clockdeco_demo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    target()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># target function spent 2.0003678798675537</span></span><br></pre></td></tr></table></figure>

<p>我们来分析一下如上装饰器的使用过程使用.可以转换为如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> clockdeco_demo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">target = clock(target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    target()</span><br></pre></td></tr></table></figure>

<p>后续分析如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># @clock 可以转换为如下代码,其中,`clock(target)`返回 `clocked` 函数,相当于对 clocked 函数添加了别名</span></span><br><span class="line">target = clock(target) -&gt; clocked</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用后,实际上是执行了 clocked 函数.</span></span><br><span class="line"><span class="comment"># 而 clocked 函数又通过闭包引用了在上一步骤中传入的参数 `func=target`,因此返回的结果仍然是 `target` 函数的返回结果</span></span><br><span class="line"><span class="comment"># 并在此过程中计算了函数的执行时间,并打印输出</span></span><br><span class="line">target() = clocked()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此如果我们要装饰带参数的函数时,只需要在 clocked 函数定义时添加相关参数即可.</span></span><br></pre></td></tr></table></figure>

<p>修改过的装饰器函数如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># 在函数定义时添加了变参,应对装饰函数带有参数的情况</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        name = func.__name__</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'%s function spent %s'</span> % (name, (end-start)))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>

<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>假设有这样一种场景,我想通过装饰器打印日志输出,并可以通过装饰器中参数来调整日志的输出级别.如 <code>@logging(level=&#39;INFO&#39;)</code>,<code>@logging(level=&#39;DEBUG&#39;)</code>,这要如何实现呢?</p>
<p>OK,我们先来看如下带参数的装饰器(与前一小节中差不多):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        name = func.__name__</span><br><span class="line">        print(<span class="string">'%s function loggging %s %s'</span> % (name,*args, *kwargs))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常使用</span></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    user=&#123;</span><br><span class="line">        <span class="string">'name'</span>:name,</span><br><span class="line">        <span class="string">'age'</span>: age,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误使用,会导致编译不通过</span></span><br><span class="line"><span class="comment"># @logging(level='INFO')</span></span><br><span class="line"><span class="comment"># def err_app(name, age):</span></span><br><span class="line">    <span class="comment"># user=&#123;</span></span><br><span class="line">        <span class="comment"># 'name':name,</span></span><br><span class="line">        <span class="comment"># 'age': age,</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># return user</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(app(<span class="string">'tom'</span>,<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># app function loggging tom 20</span></span><br><span class="line"><span class="comment"># &#123;'name': 'tom', 'age': 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么,我们如何在装饰器上使用添加函数呢?</p>
<p>在如上示例中,<code>@logging</code> 等价于 <code>app = logging(app) -&gt; wrapper</code>.如果装饰器带上函数,则可以理解为 <code>@logging(level=&#39;INFO&#39;)</code> 等价于 <code>app = logging(level=&#39;INFO&#39;)(app)-&gt; wrapper(app)</code>,就相当于继续调用内层函数 <code>wrapper</code>,并将 <code>app</code> 作为参数传入.很显然,上述代码中,内层函数 <code>wrapper</code> 返回结果为 <code>app</code> 函数的返回结果 <code>user</code>,是不可调用对象.因此,我们需要使内层函数 <code>wrapper</code> 继续返回一个可调用对象 <code>inner_wrapper</code>,而所有操作(打印日志,执行原始 <code>app</code> 函数)均在 <code>inner_wrapper</code> 中执行.代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            name = func.__name__</span><br><span class="line">            print(<span class="string">'%s: %s function loggging %s %s'</span> % (level, name,*args, *kwargs))</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>尝试使用一下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@logging('INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_app</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    user=&#123;</span><br><span class="line">        <span class="string">'name'</span>:name,</span><br><span class="line">        <span class="string">'age'</span>: age,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging('ERROR')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">err_app</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    user=&#123;</span><br><span class="line">        <span class="string">'name'</span>:name,</span><br><span class="line">        <span class="string">'age'</span>: age,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(app(<span class="string">'tom'</span>,<span class="number">20</span>))</span><br><span class="line">    print(err_app(<span class="string">'jerry'</span>,<span class="number">19</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">INFO: info_app function loggging tom <span class="number">20</span></span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'tom'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">ERROR: err_app function loggging jerry <span class="number">19</span></span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'jerry'</span>, <span class="string">'age'</span>: <span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>此时再来分析一下 <code>@logging(level=&#39;INFO&#39;)</code>,它可以做如下转换:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">app = logging(level='INFO')(app) -&gt; wrapper(app) -&gt; inner_wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 app,其实是调用 inner_wrapper,返回值为 result</span></span><br><span class="line">app() = inner_wrapper() -&gt; result</span><br></pre></td></tr></table></figure>

<p>上述代码的转换,其实是在不带参数的装饰器的基础上又在最外层嵌套了一层函数.</p>
<h3 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h3><p>装饰器类的实现其实与装饰器函数的实现大同小异.只要符合<strong>接受一个可调用对象作为参数,并返回一个可调用对象</strong>的可调用的类(<code>实现了 __call__() 方法</code>)就是一个装饰器类.</p>
<p>与装饰器函数类似,装饰器类的实现,需要我们:</p>
<ul>
<li>将被装饰的对象必须作为类的初始化参数传入装饰器类.</li>
<li>在装饰器类的 <code>__call__</code> 方法中定义装饰器进行的操作,修饰并调用被装饰的可调用对象,并返回被装饰对象的调用结果</li>
</ul>
<p>见如下实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        装饰器类的初始化函数,必须传入一个参数</span></span><br><span class="line"><span class="string">        :param func: 被装饰的对象</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        在此方法中定义装饰器的内容,并返回被装饰对象的调用结果</span></span><br><span class="line"><span class="string">        :param args, kwargs: 为被装饰对象的参数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        print(<span class="string">"[DEBUG]: enter function &#123;func&#125;()"</span>.format(func=self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">"say &#123;&#125;!"</span>.format(something))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say(<span class="string">'decorator class'</span>)</span><br></pre></td></tr></table></figure>

<p>在上述示例中,只要知道 <code>@logging</code> 等价于 <code>say = logging(say)</code> 就不难理解,这一步骤实际上做的事情是以 <code>say</code> 函数作为初始化参数创建了 <code>logging</code> 类的实例对象.在调用 <code>say(&#39;decorator class&#39;)</code> 时,实际上是对 <code>logging</code> 类的实例进行了调用.从而调用了实例的 <code>__call__</code> 方法.</p>
<h4 id="带参数的装饰器类"><a href="#带参数的装饰器类" class="headerlink" title="带参数的装饰器类"></a>带参数的装饰器类</h4><p>参参数的装饰器类可以看作是装饰器类与带参数的装饰器函数的结合体.</p>
<p>与装饰器函数类似,我们需要</p>
<ul>
<li>将装饰器类的参数传入装饰器类的初始化函数中</li>
<li>在装饰器类的 <code>__call__</code> 方法中定义装饰器进行的操作,修饰并调用被装饰的可调用对象,并返回一个可调用对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="string">'INFO'</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        在此方法中定义装饰器的内容,并返回可调用对象</span></span><br><span class="line"><span class="string">        :param func: 被装饰对象</span></span><br><span class="line"><span class="string">        :return: 返回可调用对象</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">"return &#123;&#125;!"</span>.format(something))</span><br><span class="line">    <span class="keyword">return</span> something</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(say(<span class="string">'tom'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="可通过方法自定义属性的装饰器"><a href="#可通过方法自定义属性的装饰器" class="headerlink" title="可通过方法自定义属性的装饰器"></a>可通过方法自定义属性的装饰器</h3><p>参考 <code>Python Cookbook 中文第 3 版 - &quot;9.5 可自定义属性的装饰器&quot;</code>章节.</p>
<ul>
<li>Q: 你想写一个装饰器来包装一个函数,并且在运行时允许用户提供参数控制装饰器行为</li>
<li>A: 引入一个访问函数,使用 nonlocal 来修改内部变量.然后这个访问函数被作为一个属性赋值给包装函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps, partial</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach_wrapper</span><span class="params">(obj, func=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(attach_wrapper, obj)</span><br><span class="line">        <span class="comment"># 在这里很巧妙的使用了 partial 函数,将 obj 默认传入 attach_wrapper 中,再次调用时,只需要传入一个 func 参数即可</span></span><br><span class="line">    setattr(obj, func.__name__, func) <span class="comment"># 将传入的func参数设置为obj的属性,并在后续将func返回</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        log = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @attach_wrapper(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_message</span><span class="params">(newmsg)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> logmsg</span><br><span class="line">            logmsg = newmsg</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set_message = attach_wrapper(wrapper)(set_message)</span></span><br><span class="line">        <span class="comment"># set_message = partial(attach_wrapper, wrapper)(set_message)</span></span><br><span class="line">        <span class="comment"># 这一步骤中的 partial(func,arg1)(arg2) 函数作用为将 arg1 使用作为 func 的参数传递,返回可调用对象,并在下次传参调用时,只需传入一个参数即可.如</span></span><br><span class="line">        <span class="comment"># 假设 `add = lambda x, y: x+y` 则有 `a = partial(add,1)(2)` 等价于 `add(1,2)</span></span><br><span class="line">        <span class="comment"># partial 函数的作用详见官方文档 https://docs.python.org/3/library/functools.html#functools.partial 或博客 https://blog.csdn.net/cassiepython/article/details/76653897</span></span><br><span class="line">        <span class="comment"># set_message = attach_wrapper(wrapper, set_message)</span></span><br><span class="line">        <span class="comment">#               setattr(wrapper, 'set_message', set_message) # 为 wrapper 添加 set_message 属性,为 set_message 函数,以备在 main 方法中可以调用 set_message()</span></span><br><span class="line">        <span class="comment">#               return set_message # 并返回原始函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="meta">@logged(logging.WARNING)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># add = logged(logging.WARNING)(add) -&gt; decorate(add) -&gt; wrapper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    add.set_message(<span class="string">'Add called'</span>)</span><br><span class="line">    add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="comment"># wrapper(10,20) -&gt; 打印日志信息,并返回原始函数的执行结果</span></span><br></pre></td></tr></table></figure>

<h2 id="装饰器注意事项"><a href="#装饰器注意事项" class="headerlink" title="装饰器注意事项"></a>装饰器注意事项</h2><h3 id="装饰器内代码的执行顺序"><a href="#装饰器内代码的执行顺序" class="headerlink" title="装饰器内代码的执行顺序"></a>装饰器内代码的执行顺序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'outer function begin'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'wrapper function begin'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'inner function begin'</span>)</span><br><span class="line">            print(<span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=level,</span><br><span class="line">                func=func.__name__))</span><br><span class="line">            print(<span class="string">'inner function end'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'wrapper function end'</span>)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    print(<span class="string">'outer function end'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='debug')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">   print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># outer function begin</span></span><br><span class="line"><span class="comment"># outer function end</span></span><br><span class="line"><span class="comment"># wrapper function begin</span></span><br><span class="line"><span class="comment"># wrapper function end</span></span><br><span class="line"><span class="comment"># inner function begin</span></span><br><span class="line"><span class="comment"># [debug]: enter function hello()</span></span><br><span class="line"><span class="comment"># inner function end</span></span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<h3 id="错误的属性"><a href="#错误的属性" class="headerlink" title="错误的属性"></a>错误的属性</h3><p>任何被装饰器装饰过的对象,其实已经变成装饰器函数返回的可调用对象.导致被装饰对象的所有内置属性,都会变成装饰器函数返回的可调用对象的内置属性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""print log before a function."""</span></span><br><span class="line">        print(<span class="string">"[DEBUG] &#123;&#125;: enter &#123;&#125;()"</span>.format(datetime.now(), func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging # 等同于 say=logging(say),导致 say 变量的所有内置属性,都会变成 wrapper 函数的内置属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="string">"""say something"""</span></span><br><span class="line">    print(<span class="string">"say &#123;&#125;!"</span>.format(something))</span><br><span class="line"></span><br><span class="line">print(say.__name__)  <span class="comment"># wrapper</span></span><br></pre></td></tr></table></figure>

<p>解决: 使用标准库里的 <code>functools.wraps</code> 装饰器对待返回的可调用对象进行装饰,可以基本解决这个问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">     <span class="comment"># 使用内置库里的 wraps 对内置函数进行装饰</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""print log before a function."""</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG] &#123;&#125;: enter &#123;&#125;()"</span>.format(datetime.now(), func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="string">"""say something"""</span></span><br><span class="line">    print(<span class="string">"say &#123;&#125;!"</span>.format(something))</span><br><span class="line"></span><br><span class="line">print(say.__name__)  <span class="comment"># say</span></span><br><span class="line">print(say.__doc__) <span class="comment"># say something</span></span><br></pre></td></tr></table></figure>

<h2 id="装饰器第三方库"><a href="#装饰器第三方库" class="headerlink" title="装饰器第三方库"></a>装饰器第三方库</h2><h3 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a><a href="https://decorator.readthedocs.io/en/latest/" target="_blank" rel="noopener">decorator</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG] &#123;&#125;: enter &#123;&#125;()"</span>.format(datetime.now(), func.__name__)</span><br><span class="line">    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="wrapt"><a href="#wrapt" class="headerlink" title="wrapt"></a><a href="https://wrapt.readthedocs.io/en/latest/" target="_blank" rel="noopener">wrapt</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wrapt</span><br><span class="line"></span><br><span class="line"><span class="comment"># without argument in decorator</span></span><br><span class="line"><span class="meta">@wrapt.decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(wrapped, instance, args, kwargs)</span>:</span>  <span class="comment"># instance is must</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(wrapped.__name__)</span><br><span class="line">    <span class="keyword">return</span> wrapped(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字典与集合</title>
    <url>/2020/06/19/python-dict-details/</url>
    <content><![CDATA[<p>Python 中字典有如下注意事项</p>
<ul>
<li>键必须是可散列的.一个可散列对象必须满足以下要求:<ol>
<li>支持 <code>hash()</code> 函数,并且通过 <code>__hash__()</code> 方法得到的散列值是不变的.</li>
<li>支持通过 <code>__eq__()</code> 方法检测相等性</li>
<li>若 <code>a == b</code> 为真,则 <code>hash(a) == hash(b)</code> 也为真</li>
</ol>
</li>
<li>字典在内存上的开销巨大.但键查询很快,dict 的实现是典型的空间换时间</li>
<li>键的次序取决于添加顺序,但如果添加相同的键值对到字典中,该字典是相等的.如</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">    (<span class="number">86</span>, <span class="string">'China'</span>),</span><br><span class="line">    (<span class="number">91</span>, <span class="string">'India'</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="string">'United States'</span>),</span><br><span class="line">    (<span class="number">62</span>, <span class="string">'Indonesia'</span>),</span><br><span class="line">    (<span class="number">55</span>, <span class="string">'Brazil'</span>),</span><br><span class="line">    (<span class="number">92</span>, <span class="string">'Pakistan'</span>),</span><br><span class="line">    (<span class="number">880</span>, <span class="string">'Bangladesh'</span>),</span><br><span class="line">    (<span class="number">234</span>, <span class="string">'Nigeria'</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">'Russia'</span>),</span><br><span class="line">    (<span class="number">81</span>, <span class="string">'Japan'</span>),</span><br><span class="line">]</span><br><span class="line">d1 = dict(DIAL_CODES)</span><br><span class="line">print(<span class="string">'d1:'</span>, d1.keys())</span><br><span class="line">d2 = dict(sorted(DIAL_CODES))</span><br><span class="line">print(<span class="string">'d2:'</span>, d2.keys())</span><br><span class="line">d3 = dict(sorted(DIAL_CODES, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]))</span><br><span class="line">print(<span class="string">'d3:'</span>, d3.keys())</span><br><span class="line"><span class="keyword">assert</span> d1 == d2 <span class="keyword">and</span> d2 == d3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下:</span></span><br><span class="line"><span class="comment"># d1: dict_keys([86, 91, 1, 62, 55, 92, 880, 234, 7, 81])</span></span><br><span class="line"><span class="comment"># d2: dict_keys([1, 7, 55, 62, 81, 86, 91, 92, 234, 880])</span></span><br><span class="line"><span class="comment"># d3: dict_keys([880, 55, 86, 91, 62, 81, 234, 92, 7, 1])</span></span><br><span class="line"><span class="comment"># 最后的 assert 为 True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>往字典里添加新键可能会改变已有键的顺序.<strong>不要对字典同时进行迭代和修改</strong></li>
</ul>
<p>无论何时往字典里添加新的键,Python 解释器都可能为字典进行扩容.扩容导致的结果就是要新建一个更大的散列表,并把字典里已有的元素添加到新表里.这个过程中可能会发生新的散列冲突,导致新散列表中键的次序变化.因此,<strong>不要对字典同时进行迭代和修改</strong></p>
<blockquote>
<p>由于集合与字典内部实现一致.以上提到的内容,同样适用于集合</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 单双下划线及魔术方法</title>
    <url>/2020/06/09/python-double-underscores-and-magic-method/</url>
    <content><![CDATA[<h2 id="Python中单下划线和双下划线"><a href="#Python中单下划线和双下划线" class="headerlink" title="Python中单下划线和双下划线"></a>Python中单下划线和双下划线</h2><p>首先看如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>        self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mc.__superprivate)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mc._semiprivate)</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mc.__dict__)</span><br><span class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_foo</code>: 单下划线是一种约定,用来指定变量私有(逻辑上的,其实仍可以访问).不能用 <code>from module import *</code> 导入,其他方面和公有一样访问.</li>
<li><code>__foo</code>: 解析器用 <code>_&lt;classname&gt;__foo</code> 来代替这个名字,以区别和其他类相同的命名,必须通过 <code>对象名._类名__xxx</code> 这样的方式进行访问.</li>
<li><code>__foo__</code>: Python 内部魔术方法,用来区别其他用户自定义的命名,以防冲突.例如 <code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code> 等.</li>
</ul>
<h2 id="Python-常用魔术方法或属性"><a href="#Python-常用魔术方法或属性" class="headerlink" title="Python 常用魔术方法或属性"></a>Python 常用魔术方法或属性</h2><h3 id="abs"><a href="#abs" class="headerlink" title="__abs__()"></a><code>__abs__()</code></h3><p>如果类实现了该方法,可通过 <code>abs()</code> 内置函数直接调用.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(int)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self._x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 通过 abs() 内置函数调用"""</span></span><br><span class="line">        print(<span class="string">"__abs__"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__abs__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    c = C(<span class="number">-2</span>)</span><br><span class="line">    print(abs(c))</span><br></pre></td></tr></table></figure>

<h3 id="eq"><a href="#eq" class="headerlink" title="__eq__()"></a><code>__eq__()</code></h3><p>如果类实现了该方法,可通过 <code>==</code> 判断两个对象是否相等.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self._x = x</span><br><span class="line">        self._y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        print(<span class="string">"__eq__"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._x == other._x <span class="keyword">and</span> self._y == other._y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = C(<span class="string">"x"</span>, <span class="string">"y"</span>)</span><br><span class="line">    d = C(<span class="string">"x"</span>, <span class="string">"y"</span>)</span><br><span class="line">    print(c == d)</span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="__hash__()"></a><code>__hash__()</code></h3><p>如果类实现了该方法,可通过 <code>hash()</code> 内置函数直接调用.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self._x = x</span><br><span class="line">        self._y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"__hash__"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__hash__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = C(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    print(hash(c))</span><br></pre></td></tr></table></figure>

<h3 id="iter"><a href="#iter" class="headerlink" title="__iter__()"></a><code>__iter__()</code></h3><blockquote>
<p>如果对象实现了可以返回迭代器的 <code>__iter__</code> 方法,那么对象就是可迭代的.</p>
</blockquote>
<p>如果对象实现了该方法,可通过 <code>iter()</code> 函数直接调用.更多信息参见 <a href="/2020/06/08/python-iterator-and-generator/" title="Python 迭代器与生成器">Python 迭代器与生成器</a>.</p>
<h3 id="mro"><a href="#mro" class="headerlink" title="mro"></a><strong>mro</strong></h3><p>此属性值为元组,子类在访问父类方法或属性时,会按照元组元素顺序寻找基类的方法或属性.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"a.foo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"c.foo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo()</span><br><span class="line">print(D.__mro__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line"><span class="comment"># c.foo</span></span><br><span class="line"><span class="comment"># (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span></span><br></pre></td></tr></table></figure>

<p>在方法解析期间寻找基类时要考虑的类的元组</p>
<h3 id="repr-与-str"><a href="#repr-与-str" class="headerlink" title="__repr__() 与 __str__()"></a><code>__repr__()</code> 与 <code>__str__()</code></h3><p>如果类实现了该方法,可通过 <code>str()</code> 内置函数直接调用.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self._x = x</span><br><span class="line">        self._y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"__repr__"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s,%s"</span> % (self._x, self._y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"__str__"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__str__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = C(<span class="string">"x"</span>, <span class="string">"y"</span>)</span><br><span class="line">    <span class="comment"># print(c)  # 会默认调用 __str__()</span></span><br><span class="line">    print(str(c))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下,可以看出调用顺序为 __str__ -&gt; __repr__</span></span><br><span class="line"><span class="comment"># __str__</span></span><br><span class="line"><span class="comment"># __repr__</span></span><br><span class="line"><span class="comment"># x,y</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 垃圾回收</title>
    <url>/2020/06/09/python-garbage-collection/</url>
    <content><![CDATA[<h2 id="Python-变量不是盒子"><a href="#Python-变量不是盒子" class="headerlink" title="Python 变量不是盒子"></a>Python 变量不是盒子</h2><p>首先看如下示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>如果把变量想象为盒子,那么无法解释 Python 中的赋值,应该将变量视作”便利贴”(标注),这样如上示例就好解释了.</p>
<p><img src="/images/variables-are-not-boxes.png" alt="变量不是盒子"></p>
<p>再看如下示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Gizmo id: %d'</span> % id(self))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Gizmo()</span><br><span class="line">Gizmo id: <span class="number">4301489152</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = Gizmo() * <span class="number">10</span>  <span class="comment"># 此时会报错,变量 y 不会创建</span></span><br><span class="line">Gizmo id: <span class="number">4301489432</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> *: <span class="string">'Gizmo'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir() <span class="comment"># 查看当前作用域中所有变量/函数/对象的名称,可以看到变量 y 不会被创建</span></span><br><span class="line">[<span class="string">'Gizmo'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>,</span><br><span class="line"><span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'x'</span>]</span><br></pre></td></tr></table></figure>

<p>Python 中的赋值语句,应该始终先读右边.对象在右边创建或获取,在此之后左边的变量才会绑定到对象上,这就像为对象贴上标注或为对象添加别名.</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote>
<p>对象绝不会自行销毁.但是,无法得到对象时,该对象可能会被当作垃圾回收</p>
</blockquote>
<p>在 CPython 中,垃圾回收采用的机制是<strong>引用计数</strong>机制为主,<strong>标记-清除</strong>和<strong>分代回收</strong>为辅的策略.</p>
<p>实际上,Python 中的每个对象维护一个名为 <code>ob_ref</code> 的字段,用来记录该对象当前被引用的次数,每当新的引用指向该对象时,它的引用计数 <code>ob_ref</code> 加 1,每当该对象的引用失效时,计数 <code>ob_ref</code> 减 1.一旦对象的引用计数为 0,CPython 会在对象上调用 <code>__del__</code> 方法(如果定义了),然后释放分配给对象的内存.</p>
<p>可以通过 <code>sys.getrefcount()</code> 函数查看对象的引用数量.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__del__ method in class A'</span>)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">del</span> a  <span class="comment"># del 关键字只是将对象的引用 a 删除,而不会对对象实例做任何操作.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A()  # 以此方式创建的对象会立即被销毁,因为没有对 A() 实例对象的引用</span></span><br></pre></td></tr></table></figure>

<h3 id="导致引用加减情况"><a href="#导致引用加减情况" class="headerlink" title="导致引用加减情况"></a>导致引用加减情况</h3><p>如下情况下,引用计数会加 1</p>
<ul>
<li>对象被创建,并为其添加别名(给变量贴上标签).如 <code>a = A()</code></li>
<li>对象为对象添加另一个别名.如 <code>b = a</code></li>
<li>对象被作为参数,传入到一个函数中.如 <code>func(a)</code></li>
<li>对象作为一个元素,存储在容器中.如 <code>list1=[a,a]</code></li>
</ul>
<p>如下情况下,引用计数会减 1</p>
<ul>
<li>对象的别名被显式销毁.如 <code>del a</code></li>
<li>对象的别名被赋予新的对象.如 <code>a = 24</code></li>
<li>对象离开它的作用域.如,<code>func</code> 函数执行完毕时,<code>func</code> 函数中的局部变量及传入的参数(全局变量不会)</li>
<li>对象所在的容器被销毁或从容器中删除对象.如 <code>list1.remove(a)</code></li>
</ul>
<h3 id="引用计数机制的优缺点"><a href="#引用计数机制的优缺点" class="headerlink" title="引用计数机制的优缺点"></a>引用计数机制的优缺点</h3><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>简单</li>
<li>实时性: 一旦没有引用,内存就直接释放了,不用像其他机制得等到特定时机.实时性还带来一个好处.处理回收内存的时间分摊到了平时</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>维护引用计数消耗资源</li>
<li>会出现循环引用问题</li>
</ul>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>循环引用是指当一个数据结构引用了它自身,即这个数据结构是个循环数据结构,那么它的引用计数值无法变为 0,也就是说这个数据结构占用的内存无法被自动回收</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aa = [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># aa 引用对象的引用计数 + 1</span></span><br><span class="line">bb = [<span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># bb 引用对象的引用计数 + 1</span></span><br><span class="line">aa.append(bb)  <span class="comment"># bb 引用对象的引用计数 + 1</span></span><br><span class="line">bb.append(aa)  <span class="comment"># aa 引用对象的引用计数 + 1</span></span><br><span class="line">print(aa, bb)  <span class="comment"># 会发现 aa,bb 是两个嵌套引用的列表</span></span><br><span class="line"><span class="keyword">del</span> aa  <span class="comment"># aa 引用对象的引用计数 - 1</span></span><br><span class="line"><span class="keyword">del</span> bb  <span class="comment"># bb 引用对象的引用计数 - 1</span></span><br></pre></td></tr></table></figure>

<p><code>del aa</code> 和 <code>del bb</code> 之后已经没有变量指向这个两个列表对象了,但是列表对象的引用计数却没有减少到零</p>
<p>为了解决对象的循环引用问题,Python 引入了<strong>标记-清除</strong>和<strong>分代回收</strong>两种垃圾回收机制.</p>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p>循环引用的问题只有在容器对象之间才有可能发生,比如列表,字典,类,元组.</p>
<p>首先,为了追踪容器对象,需要每个容器对象维护两个额外的指针,用来将容器对象组成一个链表,指针分别指向前后两个容器对象,方便插入和删除操作.</p>
<p>标记-清除采用的方法是在不改动真实的引用计数的前提下,将集合中对象的引用计数复制一份副本,改动该对象引用的副本.对于副本做任何的改动,都不会影响到对象生命周期的维护.</p>
<p>第一步,通过计数副本寻找 root object 集合(该集合中的对象是不能被回收的).例如: aa 和 bb 的循环引用,首先找到循环引用的一端 aa,因为它有一个对 bb 的引用,则将 bb 的引用计数减1.然后顺着引用达到 bb,因为 bb 有一个对 aa 的引用,同样将 aa 的引用减 1,这样就完成了循环引用对象间环摘除,并且判断 aa, bb 是不是属于 root object 集合.</p>
<p>第二步,当成功寻找到 root object 集合之后,首先将现在的内存链表一分为二,一条链表中维护 root object 集合,成为 root 链表,而另外一条链表中维护剩下的对象,成为 unreachable 链表.之所以要剖成两个链表,是基于这样的一种考虑：现在的 unreachable 可能存在被root链表中的对象,直接或间接引用的对象,这些对象是不能被回收的(例如：aa 引用了 bb, 而 bb 没有引用 aa),一旦在标记的过程中,发现这样的对象,就将其从 unreachable 链表中移到 root 链表中;当完成标记后,unreachable链表中剩下的所有对象就是名副其实的垃圾对象了,接下来的垃圾回收只需限制在 unreachable 链表中即可.</p>
<p>“标记-清除”执行前需要复制一份副本,这种额外操作实际上与系统中总的内存块的数量是成正相关.当需要回收的内存块越多时,垃圾检测带来的额外操作就越多.</p>
<h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>分代回收是一种以空间换时间的操作方式,Python将内存根据对象的存活时间划分为不同的集合,每个集合称为一个代,Python将内存分为了 3 “代”,分别为年轻代(第0代),中年代(第1代),老年代(第2代),他们对应的是3个链表,它们的垃圾收集频率与对象的存活时间的增大而减小.新创建的对象都会分配在年轻代,年轻代链表的总数达到上限时,Python垃圾收集机制就会被触发,把那些可以被回收的对象回收掉,而那些不会回收的对象就会被移到中年代去,依此类推,老年代中的对象是存活时间最久的对象,甚至是存活于整个系统的生命周期内.</p>
<hr>
<p>参考:</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/47489438" target="_blank" rel="noopener">Python - 垃圾回收</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/62282961" target="_blank" rel="noopener">Python 中的垃圾回收机制</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 迭代器与生成器</title>
    <url>/2020/06/08/python-iterator-and-generator/</url>
    <content><![CDATA[<blockquote>
<p>迭代器用于从集合中取出元素.而生成器用于”凭空”生成元素</p>
</blockquote>
<p>在 Python 中,所有集合都可以迭代.在 Python 语言内部,迭代器用于支持:</p>
<ul>
<li>for 循环</li>
<li>构建和扩展集合类型</li>
<li>逐行遍历文本文件</li>
<li>列表推导,字典推导和集合推导</li>
<li>元组拆包</li>
<li>调用函数时,使用 <code>*</code> 拆包实参</li>
</ul>
<blockquote>
<p>迭代协议要求对象的 <code>__iter__</code> 方法返回一个特殊的迭代器对象,这个迭代器对象实现了 <code>__next__</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成.</p>
</blockquote>
<h2 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象 Iterable"></a>可迭代对象 Iterable</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># collections.abc.Iterable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterable</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterable:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">"__iter__"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果对象实现了可以返回迭代器的 <code>__iter__</code> 方法,那么对象就是可迭代的.</p>
</blockquote>
<p>对可迭代对象使用 <code>iter</code> 函数,返回的对象就是迭代器.解释器需要迭代对象 x 时,会自动调用 <code>iter(x)</code></p>
<p><code>iter</code> 函数做了如下事情:</p>
<ol>
<li>检查对象是否实现了 <code>__iter__</code> 方法,如果实现了,则调用.返回并获取一个迭代器</li>
<li>如果没有实现 <code>__iter__</code> 方法,但是实现了 <code>__getitem__</code> 方法,Python 会创建一个迭代器,尝试按循序(从索引 0 开始)获取元素</li>
<li>如果尝试失败,Python 抛出 TypeError 异常,通常会提示 “C object is not iterable”( C 对象不可迭代),其中 C 是目标对象所属的类</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(self._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._children)</span><br></pre></td></tr></table></figure>

<h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># collections.abc.Iterator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'Return the next item from the iterator. When exhausted, raise StopIteration'</span></span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">'__iter__'</span>, <span class="string">'__next__'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>迭代器继承了 <code>Iterable</code> 类,实现了如下方法:</p>
<ul>
<li><code>__next__</code>: 返回序列中的下一个元素.如果没有元素了,那么抛出 <code>StopIteration</code> 异常</li>
<li><code>__iter__</code>: 返回 <code>self</code>,以便在应该使用可迭代对象的地方使用迭代器</li>
</ul>
<p>示例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'ABC'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 for 循环隐式创建迭代器</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">    print(char)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显式构建迭代器后,使用 while</span></span><br><span class="line">it = iter(s)  <span class="comment"># 使用可迭代对象显式构建迭代器</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(it))  <span class="comment"># 不断在迭代器调用 next() 函数,获取下一个元素</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:  <span class="comment"># 捕获 StopIteration 异常后,废弃迭代器对象,退出循环</span></span><br><span class="line">        <span class="keyword">del</span> it</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><code>StopIteration</code> 异常表明迭代器已经迭代到最后一个元素了.Python 语言内部会处理 for 循环和其他迭代上下文(如列表推导,元组拆包等等)中的 <code>StopIteration</code> 异常</p>
<blockquote>
<p>Python 中的迭代器与类型无关,而与协议有关.使用 <code>hasattr</code> 检查是否同时具有 <code>__iter__</code> 和<code>__next__</code> 属性</p>
</blockquote>
<p>如下是一个典型的迭代器示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 实现了 __iter__ 方法,该类可迭代</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)  <span class="comment"># 根据可迭代协议,__iter__ 方法实例化并返回一个迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span>  <span class="comment"># 实现 __next__ 方法,返回按循序索引的单词</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 实现 __iter__ 方法,返回迭代器实例,self</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># collections.abc.Generator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(Iterator)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the next item from the generator.</span></span><br><span class="line"><span class="string">        When exhausted, raise StopIteration.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""Send a value into the generator.</span></span><br><span class="line"><span class="string">        Return next yielded value or raise StopIteration.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">throw</span><span class="params">(self, typ, val=None, tb=None)</span>:</span></span><br><span class="line">        <span class="string">"""Raise an exception in the generator.</span></span><br><span class="line"><span class="string">        Return next yielded value or raise StopIteration.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> tb <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> typ</span><br><span class="line">            val = typ()</span><br><span class="line">        <span class="keyword">if</span> tb <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            val = val.with_traceback(tb)</span><br><span class="line">        <span class="keyword">raise</span> val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Raise GeneratorExit inside generator.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.throw(GeneratorExit)</span><br><span class="line">        <span class="keyword">except</span> (GeneratorExit, StopIteration):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"generator ignored GeneratorExit"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Generator:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">'__iter__'</span>, <span class="string">'__next__'</span>,</span><br><span class="line">                                  <span class="string">'send'</span>, <span class="string">'throw'</span>, <span class="string">'close'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>生成器可以理解为特殊的迭代器,它继承自 <code>Iterator</code>,实现了如下方法</p>
<ul>
<li><code>send</code>: 向生成器发送元素,在调用 <code>next(g)</code> 会生成该元素</li>
</ul>
<p>Python 函数的定义体中有 <code>yield</code> 关键字,该函数就是生成器函数.调用生成器函数时,会返回一个生成器对象.也就是说,生成器函数是生成器工厂.</p>
<p>生成器用于 “凭空” 生成元素,见如下示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span><span class="params">()</span>:</span>  <span class="comment"># 只要函数中包含 yield 关键字,则函数为生成器函数</span></span><br><span class="line">....    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">....    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">....    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen_123</span><br><span class="line">&lt;function gen_123 at <span class="number">0</span>x...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen_123() <span class="comment"># 调用生成器函数后,会返回一个 generator 生成器对象</span></span><br><span class="line">&lt;generator object gen_123 at <span class="number">0</span>x...&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> gen_123(): <span class="comment"># 生成器是可迭代对象,可以使用 for 循环进行迭代</span></span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen_123() <span class="comment"># 将生成器对象赋值给 g,调用 next(g) 会获取 yield 生成的下一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 生成器函数的定义体执行完毕后,生成器对象会抛出 StopIteration 异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>如下使用生成器代替上述 <code>SentenceIterator</code> 类,<code>Sentence</code> 就是一个生成器,而不用单独创建一个生成器类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)  <span class="comment"># 将单词全部找到后,赋值给 words 属性的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words: <span class="comment"># 迭代 self.word</span></span><br><span class="line">            <span class="keyword">yield</span> word  <span class="comment"># 使用 yield 关键字 "生成" 当前 word</span></span><br><span class="line">        <span class="comment"># return  # 此 return 语句是不必要的,可直接删除</span></span><br></pre></td></tr></table></figure>

<h3 id="惰性实现"><a href="#惰性实现" class="headerlink" title="惰性实现"></a>惰性实现</h3><p>上述示例在初始化 <code>__init__</code> 方法一次性构建好了文本中的单词列表,然后将其绑定为 <code>self.words</code> 属性.如下示例是 <code>Sentence</code> 类的惰性实现,在处理数据量较大的情况下,可以节省大量内存.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># 初始化时,不对 text 进行一次性处理,且不再需要 self.words 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):  <span class="comment"># finditer 函数构建一个迭代器,包含 MatchObject 实例</span></span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># match.group() 从 MatchObject 实例中取出匹配到的单词,并由 yield 产生</span></span><br></pre></td></tr></table></figure>

<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器表达式可以理解为列表推导的惰性版本,它并不会迫切的构建列表,而是返回一个生成器,按照需要惰性生成元素.如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>print(<span class="string">'start'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">yield</span> <span class="string">'A'</span></span><br><span class="line"><span class="meta">... </span>print(<span class="string">'continue'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">yield</span> <span class="string">'B'</span></span><br><span class="line"><span class="meta">... </span>print(<span class="string">'end.'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]  <span class="comment"># 列表推导式会自动执行 gen_AB 定义的函数体,输出内容并生成元素</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res1:  <span class="comment"># 对列表推导式生成的列表进行迭代</span></span><br><span class="line"><span class="meta">... </span>print(<span class="string">'--&gt;'</span>, i)</span><br><span class="line">...</span><br><span class="line">--&gt; AAA</span><br><span class="line">--&gt; BBB</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()) <span class="comment"># 生成器表达式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 <span class="comment"># 返回生成器对象</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10063c240</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2: <span class="comment"># for 循环迭代 res2,gen_AB() 定义实体才会真正执行</span></span><br><span class="line"><span class="meta">... </span>print(<span class="string">'--&gt;'</span>, i)</span><br><span class="line">...</span><br><span class="line">start</span><br><span class="line">--&gt; AAA</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; BBB</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两者都是可迭代对象,都可以使用 <code>next()</code> 内置函数返回迭代或生成的元素.在元素”耗尽”时,都会抛出 <code>StopIteration</code> 异常</p>
<ul>
<li>迭代器: 使用 <code>iter()</code> 函数创建.在创建时,所有待迭代的元素已经产生,且全部加载到内存中</li>
<li>生成器: 使用生成器函数或生成器表达式创建.在创建时所有待生成的元素没有产生,不会有内存的损耗.只有在迭代时,生成器函数的函数体或生成式表达式的逻辑体才会执行,生成元素(懒加载).</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 可变对象与不可变对象及其复制</title>
    <url>/2020/06/18/python-mutable-and-immutable-object/</url>
    <content><![CDATA[<h2 id="可变对象与不可变对象"><a href="#可变对象与不可变对象" class="headerlink" title="可变对象与不可变对象"></a>可变对象与不可变对象</h2><p>可变对象与不可变对象的区别在于对象本身是否可变.</p>
<p>在 Python 常用的数据类型中,</p>
<ul>
<li>可变对象: list, dict, set</li>
<li>不可变对象: int, float, str, bool, tuple</li>
</ul>
<p>如下示例直观的展示了 <code>list</code> 可变对象 与 <code>tuple</code> 不可变对象的区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 不可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>

<h3 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h3><p>元组与多数 Python 集合(list,dict,set 等等)一样,保存的是对象的引用.如果引用的元素是可变的,即便元组本身不可变,元素依然可变.也就是说,元组的不可变性其实是指 <code>tuple</code> 数据结构的物理内容(即保存的引用)不可变,与引用的对象无关</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])</span><br><span class="line"><span class="number">4302515784</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">99</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])</span><br><span class="line"><span class="number">4302515784</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>对于不可变对象来说,不管是深拷贝还是浅拷贝,都是对该对象添加一次引用,其内存地址及内部元素的内存地址均不会改变.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,打印其内存地址,并判断是否相同</span></span><br><span class="line"></span><br><span class="line">imutable_object = (<span class="string">'a'</span>, (<span class="string">'b'</span>, (<span class="string">'c'</span>, <span class="string">'d'</span>), <span class="string">'e'</span>), <span class="string">'f'</span>) <span class="comment"># 不可变对象</span></span><br><span class="line">imutable_copy_object = copy.copy(imutable_object)</span><br><span class="line">imutable_deepcopy_object = copy.deepcopy(imutable_object)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%s\t%s\t%s'</span> % (id(imutable_object), id(imutable_copy_object), id(imutable_deepcopy_object)))</span><br><span class="line">print(<span class="string">'%s\t%s\t%s'</span> % (id(imutable_object[<span class="number">1</span>]), id(imutable_copy_object[<span class="number">1</span>]), id(imutable_deepcopy_object[<span class="number">1</span>])))</span><br><span class="line">print(<span class="string">'%s\t%s\t%s'</span> % (id(imutable_object[<span class="number">1</span>][<span class="number">1</span>]), id(imutable_copy_object[<span class="number">1</span>][<span class="number">1</span>]), id(imutable_deepcopy_object[<span class="number">1</span>][<span class="number">1</span>])))</span><br><span class="line"><span class="comment"># 输出如下:</span></span><br><span class="line"><span class="number">2364244967072</span>   <span class="number">2364244967072</span>   <span class="number">2364244967072</span></span><br><span class="line"><span class="number">2364244737480</span>   <span class="number">2364244737480</span>   <span class="number">2364244737480</span></span><br><span class="line"><span class="number">2364244918728</span>   <span class="number">2364244918728</span>   <span class="number">2364244918728</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不管是深拷贝还是浅拷贝,不可变对象的每一层元素的地址不会改变</span></span><br></pre></td></tr></table></figure>

<p>而对于可变对象来说,深拷贝与浅拷贝的拷贝粒度是不相同的,如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">mutable_object = [<span class="string">'a'</span>, [<span class="string">'b'</span>, [<span class="string">'c'</span>, <span class="string">'d'</span>], <span class="string">'e'</span>], <span class="string">'f'</span>] <span class="comment"># 可变对象</span></span><br><span class="line">mutable_copy_object = copy.copy(mutable_object)</span><br><span class="line">mutable_deepcopy_object = copy.deepcopy(mutable_object)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%s\t%s\t%s'</span> % (id(mutable_object), id(mutable_copy_object), id(mutable_deepcopy_object)))</span><br><span class="line">print(<span class="string">'%s\t%s\t%s'</span> % (id(mutable_object[<span class="number">0</span>]), id(mutable_copy_object[<span class="number">0</span>]), id(mutable_deepcopy_object[<span class="number">0</span>])))</span><br><span class="line">print(<span class="string">'%s\t%s\t%s'</span> % (id(mutable_object[<span class="number">1</span>]), id(mutable_copy_object[<span class="number">1</span>]), id(mutable_deepcopy_object[<span class="number">1</span>])))</span><br><span class="line">print(<span class="string">'%s\t%s\t%s'</span> % (id(mutable_object[<span class="number">1</span>][<span class="number">1</span>]), id(mutable_copy_object[<span class="number">1</span>][<span class="number">1</span>]), id(mutable_deepcopy_object[<span class="number">1</span>][<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="number">1625855263240</span>   <span class="number">1625853920840</span>   <span class="number">1625855164296</span>  <span class="comment"># 对象的内存地址均发生改变</span></span><br><span class="line"><span class="number">1625816559208</span>   <span class="number">1625816559208</span>   <span class="number">1625816559208</span>  <span class="comment"># 对象中的不可变对象元素地址未发生改变,个人推测可能是 Python 在底层做了优化</span></span><br><span class="line"><span class="number">1625855263048</span>   <span class="number">1625855263048</span>   <span class="number">1625855164232</span>  <span class="comment"># 浅拷贝对象中可变对象元素地址未发生改变,深拷贝中可变对象元素地址发生改变</span></span><br><span class="line"><span class="number">1625846665032</span>   <span class="number">1625846665032</span>   <span class="number">1625855156360</span>  <span class="comment"># 浅拷贝对象中第二层可变对象元素地址未发生改变,深拷贝中第二层可变对象元素地址发生改变</span></span><br></pre></td></tr></table></figure>

<p>因此总结如下</p>
<ul>
<li>浅拷贝可以理解为对象中不可变对象元素进行一次完整拷贝,并直接引用原来的可变对象元素.原始对象与浅拷贝对象不是同一个对象,只是值相同而已.修改浅深贝对象中的可变对象会对原始对象造成影响.</li>
<li>深拷贝可以理解为对象中数据进行一次完整的拷贝,会重新分配内存地址.原始对象与深拷贝对象不是同一个对象,只是值相同而已.修改浅深贝对象不会对原始对象造成影响.</li>
</ul>
<p><img src="/images/copy-and-deep-copy.jpg" alt="深拷贝与浅拷贝"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">b.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">b[<span class="number">-1</span>].append(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/copy-and-deep-copy-modify.jpg" alt="深拷贝与浅拷贝的修改"></p>
<p>可在此<a href="http://www.pythontutor.com/live.html#mode=edit" target="_blank" rel="noopener">网址</a>查看如上代码完整的过程.</p>
<h3 id="什么时候发生深-浅拷贝-各自的应用场景有哪些"><a href="#什么时候发生深-浅拷贝-各自的应用场景有哪些" class="headerlink" title="什么时候发生深/浅拷贝,各自的应用场景有哪些"></a>什么时候发生深/浅拷贝,各自的应用场景有哪些</h3><p>以列表为例,如下情况发生浅拷贝:</p>
<ul>
<li>使用 copy 方法,如 <code>copy_list = copy.copy(list_1)</code></li>
<li>构造方法,如 <code>copy_list = list(list_1)</code></li>
<li>切片,如 <code>copy_list = list_1[:]</code></li>
</ul>
<p>应用如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造 person 模版,存款为0,并 copy 两个人,有共同 saving,比如说共同存款帐号</span></span><br><span class="line">person = [<span class="string">'name'</span>, [<span class="string">'saving'</span>, <span class="number">0</span>]]</span><br><span class="line">person_1 = person[:]</span><br><span class="line">person_2 = person[:]</span><br><span class="line">person_1[<span class="number">0</span>] = <span class="string">'name_1'</span></span><br><span class="line">person_2[<span class="number">0</span>] = <span class="string">'name_2'</span></span><br><span class="line">person_2[<span class="number">1</span>][<span class="number">1</span>] += <span class="number">100</span> <span class="comment"># 其中一个向其中存了 100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person <span class="comment"># 此时发现共同存款为 100</span></span><br><span class="line">[<span class="string">'name'</span>, [<span class="string">'saving'</span>, <span class="number">100</span>]]</span><br></pre></td></tr></table></figure>

<p>其它情况发生的都是深拷贝</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Python 中函数的传参与 Go 中函数参数传递类似.均可以理解为对变量值进行拷贝后进行传入函数中.只不过,对于不可变参数来说,传入的是对象的内存地址.而对于可变对象来说,传入的是指向对象内存地址的内存地址.</p>
<p>Python 唯一支持的参数传递模式是共享传参.共享传参指函数的各个形式参数获得实参中各个引用的副本.也就是说,函数内部的形参是实参的别名.</p>
<p>这种情况下,函数可能会修改作为参数传入的可变对象,但是无法修改那些对象的标识.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    a += b</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(x, y)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a, b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(t, u)</span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t, u</span><br><span class="line">((<span class="number">10</span>, <span class="number">20</span>), (<span class="number">30</span>, <span class="number">40</span>))</span><br></pre></td></tr></table></figure>

<p>对于上述示例,可以总结如下:</p>
<p>对于函数传参调用 <code>f(obj_1, obj_2)</code> 来说,函数内部其实是将 <code>obj_1</code> 添加了引用(或设置了别名/标签) <code>a</code>,<code>obj_2</code> 添加了引用(或设置了别名/标签)<code>b</code>,即执行了如下代码 <code>a=obj_1</code>,<code>b=obj_2</code>.因此,在函数中的 <code>+=</code> 操作会影响到原始对象.只不过对于不可变对象来说,<code>+=</code> 操作会重新分配内存空间,然后赋值给同名变量.</p>
<h3 id="不要使用可变对象作为参数的默认值"><a href="#不要使用可变对象作为参数的默认值" class="headerlink" title="不要使用可变对象作为参数的默认值"></a>不要使用可变对象作为参数的默认值</h3><p>如果使用可变对象作为默认值,则在新创建对象时,所有的赋值操作都是对该可变对象添加新的引用(或贴新的标签),而其实底层使用的是同一个对象.</p>
<p>如下是一个将空列表作为默认参数传入示例,简单说明可变默认值可能引发的问题.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="string">"""备受幽灵乘客折磨的校车"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>

<p>下面是对该类进行的引用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>]) <span class="comment"># bus1 不使用默认的参数值,对后续对象创建没有影响</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = HauntedBus() <span class="comment"># 一开始,bus2 是空的,因此把默认的空列表赋值给 self.passengers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = HauntedBus() <span class="comment"># bus3 一开始也是空的,因此还是赋值默认的列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers <span class="comment"># 但是默认列表不为空,原因是 bus2 和 bus3 使用了同一个空列表.赋值操作只是对该空列表添加了引用.</span></span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(<span class="string">'Dave'</span>) <span class="comment"># 修改 bus3 的列表,也会影响到 bus2 的列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers <span class="keyword">is</span> bus3.passengers <span class="comment"># bus2 bus3 中列表为同一个列表</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>为解决上述问题,我们做如下修改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></span><br><span class="line">    <span class="string">"""让乘客销声匿迹的校车"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = [] <span class="comment"># 如果不传入参数,则创建并使用空列表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = passengers <span class="comment"># 否则,使用传入的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = TwilightBus() <span class="comment"># 一开始,bus2 是空的,因此创建一个新的空列表并将其赋值给 self.passengers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = TwilightBus() <span class="comment"># bus3 一开始也是空的,因此创建一个新的空列表并将其赋值给 self.passengers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers <span class="comment"># 默认为空</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers <span class="comment"># 对 bus3 中 passengers 操作不会响应到 bus2 中的 passengers</span></span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; a = []</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; b = []</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; a is b</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>以上示例虽然解决了前一个示例中两个对象引用一个列表的问题,但是当传入参数是可变对象(如 list) 时,所有对该 list 的操作会影响到外部 list.如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team = [<span class="string">'Sue'</span>, <span class="string">'Tina'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>, <span class="string">'Pat'</span>] <span class="comment"># 假设我们这个队里有 5 个学生</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus = TwilightBus(basketball_team) <span class="comment"># 使用队学生初始化 TwilightBus</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Tina'</span>) <span class="comment"># 一个学生下车</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Pat'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team  <span class="comment"># 此时 basketball_team 变为了只有 3 个学生,显然是不符合逻辑的</span></span><br><span class="line">[<span class="string">'Sue'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>]</span><br></pre></td></tr></table></figure>

<p>产生上述问题的原因是由于对函数传入可变对象后,在函数中的所有操作都会影响到原始对象.因此做如下改进</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = list(passengers)</span><br><span class="line">            <span class="comment"># 对传入参数进行拷贝后复制给 self.passengers,函数内所有操作在 self.passengers 上进行,而不影响传入的 passengers 参数</span></span><br><span class="line">            <span class="comment"># 这种传入参数更为灵活,可以是元组或其他任何可迭代对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 对象分类</title>
    <url>/2020/06/17/python-object-classification/</url>
    <content><![CDATA[<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>可调用对象,顾名思意,就是可以通过调用运算符 <code>()</code> 调用的对象.可以使用内置的 <code>callable()</code> 判断对象能否调用.</p>
<p>Python 模型文档中列出了 7 种可调用对象</p>
<ul>
<li>用户使用 <code>def</code> 语句或 <code>lambda</code> 表达式定义的函数</li>
<li>内置函数: 使用 C (CPython)语言实现的函数,如 <code>len</code></li>
<li>内置方法: 使用 C 语言实现的方法,如 <code>dict.get</code></li>
<li>方法: 在类的定义体中定义的函数</li>
<li>类: 调用类时会运行类的 <code>__new__</code> 方法创建一个实例,然后运行 <code>__init__</code> 方法进行初始化.最后将实例返回给调用方.</li>
<li>类的的实例: 如果类定义了 <code>__call__</code> 方法,那么它的实例可以使用 <code>()</code> 调用.如</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A(<span class="string">'tom'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;__main__.A object at <span class="number">0x000002647592C240</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(a)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a()</span><br><span class="line"><span class="string">'tom'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成器函数: 带有 <code>yield</code> 或 <code>yield from</code> 表达式的函数或方法.调用生成器函数,返回生成器对象.如:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'AB'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(gen)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()</span><br><span class="line">&lt;generator object gen at <span class="number">0x000002647590A9E8</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><ul>
<li>如果对象实现了能返回迭代器的 <code>__iter__</code> 方法,那么对象就是可迭代的</li>
<li>实现了 <code>__getitem__</code> 方法,而且其参数是从零开始的索引,这种对象也是可迭代对象.如序列</li>
</ul>
<p>对可迭代对象调用 <code>iter()</code> 函数,会返回该对象的迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(<span class="string">'aaa'</span>)</span><br><span class="line">&lt;str_iterator object at <span class="number">0x000002647592CB00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&lt;list_iterator object at <span class="number">0x000002647592CB38</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&lt;tuple_iterator object at <span class="number">0x000002647592CBA8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">&lt;set_iterator object at <span class="number">0x0000026475928F30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(&#123;<span class="string">'a'</span> : <span class="string">'b'</span>&#125;)</span><br><span class="line">&lt;dict_keyiterator object at <span class="number">0x00000264756B9868</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self._data = data</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._data)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A(<span class="string">'string'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(a)</span><br><span class="line">&lt;str_iterator object at <span class="number">0x000002647592CB38</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="可散列对象"><a href="#可散列对象" class="headerlink" title="可散列对象"></a>可散列对象</h2><p>在 <a href="https://docs.python.org/3/glossary.html#term-hashable" target="_blank" rel="noopener">Python 词汇表</a>中,关于可散列类型的定义有这样一段话:</p>
<blockquote>
<p>如果一个对象是可散列的,那么在这个对象的生命周期中,它的散列值是不变的,而且这个对象需要实现 <code>__hash__()</code> 方法.</p>
</blockquote>
<p>Python 中原子不可变数据类型(<code>str</code>,<code>bytes</code> 和数值类型(如 <code>int,float</code>))都是可散列类型,<code>frozenset</code> 也是可散列的,因为根据其定义,<code>frozenset</code> 里只能容纳可散列类型.而对于元组,当一个元组包含的所有元素都是可散列类型的情况下,它才是可散列的.</p>
<p>见如下示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tt = (<span class="number">1</span>, <span class="number">2</span>, (<span class="number">30</span>, <span class="number">40</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(tt)</span><br><span class="line"><span class="number">8027212646858338501</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tl = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(tl)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf = (<span class="number">1</span>, <span class="number">2</span>, frozenset([<span class="number">30</span>, <span class="number">40</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(tf)</span><br><span class="line"><span class="number">-4118419923444501110</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(id(self)) <span class="comment"># 这里的数据必须是可散列对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A(<span class="string">'string'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(a)</span><br><span class="line"><span class="number">-2622071085978536803</span></span><br></pre></td></tr></table></figure>

<h2 id="可变对象与不可变对象"><a href="#可变对象与不可变对象" class="headerlink" title="可变对象与不可变对象"></a>可变对象与不可变对象</h2><p>详见 <a href="/2020/06/18/python-mutable-and-immutable-object/" title="Python 可变对象与不可变对象及其复制">Python 可变对象与不可变对象及其复制</a>.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 反射机制</title>
    <url>/2020/06/19/python-reflection/</url>
    <content><![CDATA[<p>Python 内置了一些有关反射机制的函数,方便</p>
<ul>
<li><code>hasattr(obj,attr_name)</code>: 判断 obj 对象中是否有 attr_name 属性/方法</li>
<li><code>getattr(obj,attr_name)</code>: 获取 obj 中 attr_name 的属性/方法</li>
<li><code>setattr(obj,attr_name, some_attr)</code>: 设置 obj 中 attr_name 属性/方法为 some_attr</li>
<li><code>delattr(obj,attr_name)</code>: 删除指定 obj 的 attr_name 属性/方法</li>
</ul>
<p>反射机制为动态导入模块或动态执行函数提供了方便.</p>
<p>如下示例是对 <code>Crawler</code> 类添加以 <code>crawl_</code> 开头的方法获取代理的示例,代码参考自 <a href="https://github.com/Germey/ProxyPool" target="_blank" rel="noopener">崔庆才丨静觅 的 GitHub</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crawler.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># 重写 `__new__` 方法后,会在新建的 `Crawler` 中添加'__CrawlFunc__'和'__CrawlFuncCount__' 属性,其中'__CrawlFuncCount__' 为新建Crawler对象的方法个数(本例中是以'crawl_'开头的方法),'__CrawlFunc__'是新建Crawler对象的方法列表</span></span><br><span class="line">    <span class="comment"># 如果添加或删除代理,只需要在 Crawler 类中添加以'crawl_'开头的方法即可</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        attrs[<span class="string">'__CrawlFunc__'</span>] = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'crawl_'</span> <span class="keyword">in</span> k:</span><br><span class="line">                attrs[<span class="string">'__CrawlFunc__'</span>].append(k)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        attrs[<span class="string">'__CrawlFuncCount__'</span>] = count</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span><span class="params">(object, metaclass=ProxyMetaclass)</span>:</span> <span class="comment"># 设置 metaclass(原类) 为 ProxyMetaclass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_proxies</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">        proxies = []</span><br><span class="line">        <span class="keyword">for</span> proxy <span class="keyword">in</span> eval(<span class="string">"self.&#123;&#125;()"</span>.format(callback)): <span class="comment"># 这里使用 `eval` 执行了参数内容,并返回表达式的值,很巧妙的传入 `callback` 参数,从而使得实例可以调用多个方法,从而从多个网站中获取代理</span></span><br><span class="line">            print(<span class="string">'成功获取到代理'</span>, proxy)</span><br><span class="line">            proxies.append(proxy)</span><br><span class="line">        <span class="keyword">return</span> proxies</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def crawl_daxiang(self):</span></span><br><span class="line">    <span class="comment">#     url = 'http://vtp.daxiangdaili.com/ip/?tid=559363191592228&amp;num=50&amp;filter=on'</span></span><br><span class="line">    <span class="comment">#     html = get_page(url)</span></span><br><span class="line">    <span class="comment">#     if html:</span></span><br><span class="line">    <span class="comment">#         urls = html.split('\n')</span></span><br><span class="line">    <span class="comment">#         for url in urls:</span></span><br><span class="line">    <span class="comment">#             yield url</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl_daili66</span><span class="params">(self, page_count=<span class="number">4</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        从代理 66 获取代理</span></span><br><span class="line"><span class="string">        :param page_count: 页码</span></span><br><span class="line"><span class="string">        :return: 代理</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start_url = <span class="string">'http://www.66ip.cn/&#123;&#125;.html'</span></span><br><span class="line">        urls = [start_url.format(page) <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, page_count + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            print(<span class="string">'Crawling'</span>, url)</span><br><span class="line">            html = get_page(url)</span><br><span class="line">            <span class="keyword">if</span> html:</span><br><span class="line">                doc = pq(html)</span><br><span class="line">                trs = doc(<span class="string">'.containerbox table tr:gt(0)'</span>).items()</span><br><span class="line">                <span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">                    ip = tr.find(<span class="string">'td:nth-child(1)'</span>).text()</span><br><span class="line">                    port = tr.find(<span class="string">'td:nth-child(2)'</span>).text()</span><br><span class="line">                    <span class="keyword">yield</span> <span class="string">':'</span>.join([ip, port])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl_proxy360</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        从 Proxy360 获取代理</span></span><br><span class="line"><span class="string">        :return: 代理</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start_url = <span class="string">'http://www.proxy360.cn/Region/China'</span></span><br><span class="line">        print(<span class="string">'Crawling'</span>, start_url)</span><br><span class="line">        html = get_page(start_url)</span><br><span class="line">        <span class="keyword">if</span> html:</span><br><span class="line">            doc = pq(html)</span><br><span class="line">            lines = doc(<span class="string">'div[name="list_proxy_ip"]'</span>).items()</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                ip = line.find(<span class="string">'.tbBottomLine:nth-child(1)'</span>).text()</span><br><span class="line">                port = line.find(<span class="string">'.tbBottomLine:nth-child(2)'</span>).text()</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">':'</span>.join([ip, port])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Getter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.redis = RedisClient()</span><br><span class="line">        self.crawler = Crawler()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_over_threshold</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断是否达到了代理池限制</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.redis.count() &gt;= POOL_UPPER_THRESHOLD:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'获取器开始执行'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_over_threshold():</span><br><span class="line">            <span class="keyword">for</span> callback_label <span class="keyword">in</span> range(self.crawler.__CrawlFuncCount__):</span><br><span class="line">                callback = self.crawler.__CrawlFunc__[callback_label]</span><br><span class="line">                <span class="comment"># 获取代理</span></span><br><span class="line">                proxies = self.crawler.get_proxies(callback)</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line">                <span class="keyword">for</span> proxy <span class="keyword">in</span> proxies:</span><br><span class="line">                    self.redis.add(proxy)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 单例模式</title>
    <url>/2020/06/08/python-singleton-mode/</url>
    <content><![CDATA[<p>单例模式是一种常用的软件设计模式.在它的核心结构中只包含一个被称为单例类的特殊类.通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问,从而方便对实例个数的控制并节约系统资源.</p>
<p>以下是实现单例模式的几种方式:</p>
<h2 id="使用共享的类变量"><a href="#使用共享的类变量" class="headerlink" title="使用共享的类变量"></a>使用共享的类变量</h2><p>下面 <code>__new__</code> 方法中使用共享的类变量 <code>_instance</code> 用于保存实例.若为空,则创建新的,否则返回此实例.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            cls._instance = super().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: %s, age: %s"</span> % (self.name, self.age)</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'p1'</span>, <span class="number">10</span>)</span><br><span class="line">p2 = Person(<span class="string">'p2'</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(p1, p2)</span><br><span class="line">print(p1 <span class="keyword">is</span> p2) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h2 id="装饰器实现"><a href="#装饰器实现" class="headerlink" title="装饰器实现"></a>装饰器实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: %s, age: %s"</span> % (self.name, self.age)</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'p1'</span>, <span class="number">10</span>)</span><br><span class="line">p2 = Person(<span class="string">'p2'</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(p1, p2)</span><br><span class="line">print(p1 <span class="keyword">is</span> p2) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h2 id="创建实例后-import-到其它模块"><a href="#创建实例后-import-到其它模块" class="headerlink" title="创建实例后 import 到其它模块"></a>创建实例后 import 到其它模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># person.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: %s, age: %s"</span> % (self.name, self.age)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(id(self))</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"p1"</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> persion <span class="keyword">import</span> p</span><br><span class="line"></span><br><span class="line">print(p)</span><br><span class="line">p.foo()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 切片扩容</title>
    <url>/2023/04/01/slice-grows-in-golang/</url>
    <content><![CDATA[<h2 id="容量计算"><a href="#容量计算" class="headerlink" title="容量计算"></a>容量计算</h2><p>在 golang 中,当切片中元素个数大于其容量时,该切片会触发切片扩容.那么扩容后,切片的容量是多少呢?我们应该如何计算呢?</p>
<p>现有如下代码,以 <code>int32</code> 与 <code>int64</code> 为例分别计算切片扩容后的长度和容量.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"flag"</span></span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> arr32 []<span class="keyword">int32</span></span><br><span class="line"> <span class="keyword">var</span> arr64 []<span class="keyword">int64</span></span><br><span class="line"> <span class="keyword">var</span> num = flag.Int(<span class="string">"num"</span>, <span class="number">0</span>, <span class="string">"append element num"</span>)</span><br><span class="line"> flag.Parse()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *num; i++ &#123;</span><br><span class="line">  arr32 = <span class="built_in">append</span>(arr32, <span class="keyword">int32</span>(i))</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="built_in">len</span>(arr32), <span class="built_in">cap</span>(arr32))</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; *num; i++ &#123;</span><br><span class="line">  arr64 = <span class="built_in">append</span>(arr64, <span class="keyword">int64</span>(i))</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="built_in">len</span>(arr64), <span class="built_in">cap</span>(arr64))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在 go/1.18.1 版本之前执行结果如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go version before 1.18.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 513</span></span><br><span class="line">513 1024</span><br><span class="line">513 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num  1025</span></span><br><span class="line">1025 1344</span><br><span class="line">1025 1280</span><br></pre></td></tr></table></figure>

<p>在 go/1.18.1 版本之后执行结果如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go version after 1.18.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 257</span></span><br><span class="line">257 512</span><br><span class="line">257 512</span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 513</span></span><br><span class="line">513 864</span><br><span class="line">513 848</span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 1024</span></span><br><span class="line">1024 1344</span><br><span class="line">1024 1280</span><br></pre></td></tr></table></figure>

<p>可以看到切片的扩容后容量大小与 golang 版本及切片中元素类型(主要是元素所占的 bytes 数)有一定的关系.</p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>下面我们通过阅读 golang 切片相关源码来搞清楚产生上述差异的原因</p>
<h3 id="1-18-之前"><a href="#1-18-之前" class="headerlink" title="1.18 之前"></a>1.18 之前</h3><p>以 go/1.17.10 为例,我们来尝试阅读切片扩容的逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码,扩容开始</span></span><br><span class="line">    <span class="comment">// 1. 主要是计算 newcap 的值</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.1 当 cap 小于 1024 时,扩容为双倍</span></span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 当 cap 大于 1024 时,扩容为之前的 1.25 倍</span></span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.3 当 newcap 溢出时,设置为当前的容量</span></span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = <span class="built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 内存对齐.大概计算公式如下:</span></span><br><span class="line">    <span class="comment">// 2.1 计算保存扩容后切片所需的所有 bit 数,计算公式为 `capmem = newcap * element_size`</span></span><br><span class="line">    <span class="comment">// 2.2 将 `capmem` 带入 `roundupsize` 函数,根据此函数取得对应数组中对应的值,该值即内存对齐后该切片所需的最小字节数. `roundupsize` 函数的计算结果可以在 `runtime/sizeclasses.go` 中的注释表中查到,计算结果为表中 `bytes/obj` 列不小于 `capmem` 的最小值</span></span><br><span class="line">    <span class="comment">// 2.3 最后将所需字节数 / element_size 即为扩容后切片的容量</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem)</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 分配内存,并将原来的元素移到新的切片中</span></span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">    memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此计算步骤大致可以总结如下:</p>
<ol>
<li>根据计算公式获取应该扩容的容量.<ol>
<li>如果当前切片容量小于 1024,扩容切片容量 <code>newcap = oldcap * 2</code></li>
<li>如果当前切片容量大于等于 1024,扩容切片容量 <code>newcap = oldcap * 1.25</code></li>
</ol>
</li>
<li>内存对齐<ol>
<li>根据上一步得到的容量及元素计算出所需要的字节数 <code>newcap * element_size</code>.如 <code>bytes= newcap * 4(int32)</code>, <code>bytes=newcap * 8(int64)</code>.</li>
<li>通过 <code>runtime/sizeclasses.go</code> 查表,找到 <code>bytes/obj</code> 列中大于该 bytes 的最小值.</li>
<li>使用该值除以 <code>element_size</code> 即为扩容后的容量大小</li>
</ol>
</li>
</ol>
<h3 id="1-18-之后"><a href="#1-18-之后" class="headerlink" title="1.18 之后"></a>1.18 之后</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// 1. 与之前的版本类似,同样是计算 newcap 的值,只是在计算公式上有所变动</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.1 当容量 &lt;256 时,默认为 2 倍扩容</span></span><br><span class="line">        <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                <span class="comment">// 1.2 当旧切片容量不小于 256 时,按照如下公式扩容.这样保证可以在容量较小时双倍扩容,在容量较大时,少量扩容</span></span><br><span class="line">                newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.3 同样的,当 newcap 溢出时,设置为当前的容量</span></span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = <span class="built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 与 1.18.1 之前一样,做内存对齐</span></span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 对齐方式与之前一样,不再赘述</span></span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem)</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 分配内存,并将原来的元素移到新的切片中</span></span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">    memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此计算步骤大致可以总结如下:</p>
<ol>
<li>根据计算公式获取应该扩容的容量.<ol>
<li>如果当前切片容量小于 256 时,扩容切片容量 <code>newcap = oldcap * 2</code></li>
<li>如果当前切片容量大于等于 1024,扩容切片容量 <code>newcap = oldcap + (oldcap + 256 * 3) /4</code></li>
</ol>
</li>
<li>内存对齐<ol>
<li>根据上一步得到的容量及元素计算出所需要的字节数 <code>newcap * element_size</code>.如 <code>bytes= newcap * 4(int32)</code>, <code>bytes=newcap * 8(int64)</code>.</li>
<li>通过 <code>runtime/sizeclasses.go</code> 查表,找到 <code>bytes/obj</code> 列中大于该 bytes 的最小值.</li>
<li>使用该值除以 <code>element_size</code> 即为扩容后的容量大小</li>
</ol>
</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在 1.18.1 版本之前</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go version before 1.18.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 513</span></span><br><span class="line">513 1024</span><br><span class="line"><span class="comment"># 对于 int32 类型的切片来说, newcap = 512 * 2 = 1024, bytes = 1024 * 4 = 4096. 查表不小于 bytes 的值刚好为 4096, 因此最终容量为 4096 / 4 = 1024</span></span><br><span class="line">513 1024</span><br><span class="line"><span class="comment"># 对于 int64 类型的切片来说, newcap = 512 * 2 = 1024. bytes = 1024 * 8 = 8192. 查表不小于 bytes 的值刚好为 8192, 因此最终容量为 8192 / 8 = 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num  1025</span></span><br><span class="line">1025 1344</span><br><span class="line"><span class="comment"># 对于 int32 类型的切片来说, newcap = 1024 * 1.25 = 1280, bytes = 1280 * 4 = 5120. 查表不小于 bytes 的值为 5376, 因此最终容量为 5376 / 4 = 1344</span></span><br><span class="line">1025 1280</span><br><span class="line"><span class="comment"># 对于 int64 类型的切片来说, newcap = 1024 * 1.25 = 1280, bytes = 1280 * 8 = 10240. 查表不小于 bytes 的值刚好为 10240, 因此最终容量为 10240 / 8 = 1280</span></span><br></pre></td></tr></table></figure>

<p>在 1.18.1 版本之后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go version after 1.18.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 257</span></span><br><span class="line">257 512</span><br><span class="line"><span class="comment"># 对于 int32 类型的切片来说, newcap = 256 + (256 + 256 * 3) / 4 = 512, bytes = 512 * 4 = 2048. 查表不小于 bytes 的值刚好为 2048, 因此最终容量为 2048 / 4 = 512</span></span><br><span class="line">257 512</span><br><span class="line"><span class="comment"># 对于 int32 类型的切片来说, newcap = 256 + (256 + 256 * 3) / 4 = 512, bytes = 512 * 8 = 4096. 查表不小于 bytes 的值刚好为 4096, 因此最终容量为 4096 / 8 = 512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 513</span></span><br><span class="line">513 864</span><br><span class="line"><span class="comment"># 对于 int32 类型的切片来说, newcap = 512 + (512 + 256 * 3) / 4 = 832, bytes = 832 * 4 = 3328. 查表不小于 bytes 的值为 3456, 因此最终容量为 3456 / 4 = 864</span></span><br><span class="line">513 848</span><br><span class="line"><span class="comment"># 对于 int32 类型的切片来说, newcap = 512 + (512 + 256 * 3) / 4 = 832, bytes = 832 * 8 = 6656. 查表不小于 bytes 的值为 6784, 因此最终容量为 6784 / 8 = 848</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go run main.go -num 1024</span></span><br><span class="line">1024 1344</span><br><span class="line"><span class="comment"># 需要注意, 当 num 为 1024 时, 对于 int32 类型的切片来说, oldcap = 864.</span></span><br><span class="line"><span class="comment"># newcap = 864 + (864 + 256 * 3) / 4 = 1272 , bytes = 832 * 4 = 5088. 查表不小于 bytes 的值为 5376, 因此最终容量为 5376 / 4 = 1344</span></span><br><span class="line">1024 1280</span><br><span class="line"><span class="comment"># 需要注意, 当 num 为 1024 时, 对于 int32 类型的切片来说, oldcap = 848.</span></span><br><span class="line"><span class="comment"># newcap = 848 + (848 + 256 * 3) / 4 = 1252 , bytes = 1252 * 8 = 10016. 查表不小于 bytes 的值为 10240, 因此最终容量为 10240 / 8 = 1280</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://yufengbiji.com/posts/golang-slice" target="_blank" rel="noopener">浅谈 Go 1.18.1的切片扩容机制</a></li>
<li><a href="https://github.com/golang/go/blob/go1.17.10/src/runtime/slice.go#L162-L277" target="_blank" rel="noopener">go1.17.10-growslice</a></li>
<li><a href="https://github.com/golang/go/blob/go1.18.1/src/runtime/slice.go#L166-L288" target="_blank" rel="noopener">go1.18.1-growslice</a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/sizeclasses.go" target="_blank" rel="noopener">sizeclasses 表</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>源码阅读</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS 加密机制</title>
    <url>/2020/06/09/ssl-tls-encryption-details/</url>
    <content><![CDATA[<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="为什么需要加密"><a href="#为什么需要加密" class="headerlink" title="为什么需要加密"></a>为什么需要加密</h3><p>HTTP 的内容是明文传输层的,明文数据会经过中间代理服务器,路由器,通信服务运行商等多个物理节点,信息在传输过程中很容易被劫持</p>
<h3 id="什么是中间人攻击"><a href="#什么是中间人攻击" class="headerlink" title="什么是中间人攻击"></a>什么是中间人攻击</h3><p>由于 HTTP 是明文传输的,传输内容完全暴露在互联网上,代理服务器,路由器等中间人可以直接篡改传输信息不被双方察觉,这就是中间人攻击.</p>
<h3 id="什么是对称加密"><a href="#什么是对称加密" class="headerlink" title="什么是对称加密"></a>什么是对称加密</h3><p>对称加密使用同一密钥对明文和密文进行加密和解密.</p>
<p>对称加密最大的问题是这个密钥怎么让传输双方知晓,同时不被中间人劫持篡改.</p>
<h3 id="什么是非对称加密"><a href="#什么是非对称加密" class="headerlink" title="什么是非对称加密"></a>什么是非对称加密</h3><p>非对称加密包含两把密钥,公钥和私钥.用公钥加密的内容必须用私钥才能解开,私钥加密的内容只有公钥能解开.</p>
<p>采用非对称加密的客户端向服务端发起请求,服务端将公钥明文传输给客户端.客户端得到公钥后,使用公钥进行加密并传输到服务端,保证了单向传输的安全性.</p>
<p>那么如何将非对称加密过程中服务端公钥传输给客户端,而不会被中间人劫持/篡改?</p>
<blockquote>
<ul>
<li>数字证书</li>
</ul>
</blockquote>
<p>网站在使用 HTTPS 之前,需要向 CA 机构申请颁发一份数字证书,数字证书里有证书持有者信息,公钥信息,服务端将证书传输给客户端,客户端从证书中取得公钥.</p>
<p>那么如何防止证书在传输过程中被篡改呢?</p>
<blockquote>
<ul>
<li>数字签名</li>
</ul>
</blockquote>
<p>证书内容生成一份签名,比对证书内容和签名是否一致就能察觉是否被篡改.这种技术叫做数字签名</p>
<p>数字签名的制作过程如下:</p>
<ul>
<li>CA 证书拥有非对称加密的私钥和公钥</li>
<li>CA 对证书明文信息进行 hash(hash 后再加密可以提升性能.其它原因参见<a href="crypto.stackexchange.com/a/12780">这里</a>)</li>
<li>对 hash 后的值用私钥加密,得到数字签名</li>
</ul>
<p>上述证书明文与数字签名共同组成了数字证书,客户端验证过程如下:</p>
<ul>
<li>CA 证书已经保存在客户端中,如浏览器或命令行指定证书</li>
<li>客户端发起请求,服务端响应证书明文信息 T 和数字签名 S</li>
<li>使用 CA 证书的公钥对数字签名 S 进行解密,得到 S’</li>
<li>使用 CA 证书中说明的 hash 算法对明文进行 hash 得到 T’</li>
<li>比较 S’ 是否与 T’ 相同,判断证书是否可信</li>
</ul>
<h3 id="HTTPS-必须在每次请求中都要先在-SSL-TLS-层进行握手传输密钥吗"><a href="#HTTPS-必须在每次请求中都要先在-SSL-TLS-层进行握手传输密钥吗" class="headerlink" title="HTTPS 必须在每次请求中都要先在 SSL/TLS 层进行握手传输密钥吗"></a>HTTPS 必须在每次请求中都要先在 SSL/TLS 层进行握手传输密钥吗</h3><p>服务器会为每个客户端软件维护一个 session ID,在 TSL 握手阶段传给浏览器,浏览器生成好密钥传给服务器后,服务器会把该密钥存到相应的 session ID 下,之后浏览器每次请求都会携带 session ID,服务器会根据 session ID 找到相应的密钥并进行解密加密操作,这样就不必要每次重新制作/传输密钥了.</p>
<h2 id="SSL-TLS-加密总览"><a href="#SSL-TLS-加密总览" class="headerlink" title="SSL/TLS 加密总览"></a>SSL/TLS 加密总览</h2><p>SSL/TLS 安全层协议位于应用层和 TCP/IP 层之间,可以使得通信双方建立安全的通信通道,实现安全的数据传输.</p>
<p>SSL/TLS 协议可分为两层.如下:</p>
<ul>
<li>握手协议层,由三个子协议组成: 握手协议(Handshake Protocol),密钥交换协议(Change Cipher Spec Protocol)和告警协议(Alert Protocol).</li>
<li>记录协议层(不做详细介绍)</li>
</ul>
<p><img src="/images/ssl-tls-protocol-layers.gif" alt="SSL/TLS Protocol Layers"></p>
<h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><h4 id="子协议"><a href="#子协议" class="headerlink" title="子协议"></a>子协议</h4><p>握手协议层包含如下子协议</p>
<ul>
<li>握手协议</li>
</ul>
<p>此子协议用于协商客户端与服务端之间的会话信息,包括会话 ID,证书协商,要使用的密钥规范,压缩算法以及用于生成密钥的共享加密信息等</p>
<ul>
<li>密钥交换</li>
</ul>
<p>此子协议用于更改客户端和服务端用于加密的元数据,子协议包含一条用于告知 SSL/TLS 会话中的另一方希望更改为一组新的密钥的消息.根据握手子协议的交换信息来计算密钥.</p>
<ul>
<li>告警协议</li>
</ul>
<p>告警消息用于向另一方指示状态更改或错误信息.警报可以将正常情况和错误情况通知给另一方.高兴消息的完整列表可以在 RFC 2246 “TLS 协议版本 1.0 中找到.在关闭连接,接收到无效消息,无法解密消息或用户取消操作时,通常会发送告警信息.</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><blockquote>
<p>身份认证</p>
</blockquote>
<p>握手协议使用 X.509 证书进行身份认证</p>
<blockquote>
<p>加密</p>
</blockquote>
<p>SSL/TLS 同时使用了对称加密与非对称加密.</p>
<p>SSL/TLS 客户端使用公钥对服务端进行认证,生成一个会话密钥.服务端与客户端使用会话密钥加密/加密传输的数据.</p>
<blockquote>
<p>哈希算法</p>
</blockquote>
<p>在握手过程中,对数据使用的哈希算法也必须达成一致.哈希算法用于检查所传输数据的完整性.</p>
<h2 id="SSL-TLS-握手过程详解"><a href="#SSL-TLS-握手过程详解" class="headerlink" title="SSL/TLS 握手过程详解"></a>SSL/TLS 握手过程详解</h2><p>握手协议是一系列已经排序的消息,用于协商数据传输会话中的参数信息.下图说明了握手协议中的消息序列.</p>
<p><img src="/images/handshake-protocol-message.gif" alt="Handshake Protocol Messages"></p>
<h3 id="第一阶段-Initial-Client-Message-to-Server"><a href="#第一阶段-Initial-Client-Message-to-Server" class="headerlink" title="第一阶段: Initial Client Message to Server"></a>第一阶段: Initial Client Message to Server</h3><p>客户端向服务端发送请求包含如下信息:</p>
<h4 id="Client-Hello-Client-Hello-消息"><a href="#Client-Hello-Client-Hello-消息" class="headerlink" title="Client Hello: Client Hello 消息"></a><code>Client Hello</code>: Client Hello 消息</h4><p>客户端通过向服务端发送 <code>Client Hello</code> 消息来启动会话.<code>Client Hello</code> 消息包括</p>
<ul>
<li><strong>Version Number</strong>: 客户端发送其支持的 SSL/TLS 安全通信协议的最高版本号.<ul>
<li>2 表示 SSL 2.0</li>
<li>3 表示 SSL 3.0</li>
<li>3.1 表示 TLS</li>
</ul>
</li>
<li><strong>Randomly Generated Data</strong>: <code>ClientRandom[32]</code>.一个随机值,由客户端的日期和时间 4 字节的数字和 28 字节随机数字组成.该随机值将与服务端随机值一起生成 master secret,用于从中分发加密密钥.</li>
<li><strong>Session Identification</strong>: 会话标识(如果有).包含 Session ID 可以使客户端恢复上一次会话.恢复上一次会话很有用,因为创建新会话需要占用大量处理器资源.</li>
<li><strong>Cipher Suite</strong>: 加密套件.客户端上支持的加密套件列表.如,<code>TLS_RSA_WITH_DES_CBC_SHA</code>.</li>
<li><strong>Compression Algorithm</strong>: 压缩算法.请求的压缩算法,当前阶段为空.</li>
</ul>
<p><code>Client Hello</code> 消息示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClientVersion 3,1</span><br><span class="line">ClientRandom[32]</span><br><span class="line">SessionID: None (new session)</span><br><span class="line">Suggested Cipher Suites:</span><br><span class="line">   TLS_RSA_WITH_3DES_EDE_CBC_SHA</span><br><span class="line">   TLS_RSA_WITH_DES_CBC_SHA</span><br><span class="line">Suggested Compression Algorithm: NONE</span><br></pre></td></tr></table></figure>

<h3 id="第二阶段-Server-Response-to-Client"><a href="#第二阶段-Server-Response-to-Client" class="headerlink" title="第二阶段: Server Response to Client"></a>第二阶段: Server Response to Client</h3><p>服务端向客户端发送响应包含如下信息:</p>
<h4 id="Server-Hello-Server-Hello-消息"><a href="#Server-Hello-Server-Hello-消息" class="headerlink" title="Server Hello: Server Hello 消息"></a><code>Server Hello</code>: Server Hello 消息</h4><p>服务端响应包含 <code>Server Hello</code> 消息,<code>Server Hello</code> 消息包括</p>
<ul>
<li><strong>Version Number</strong>: 服务端发送通信双方都支持的 SSL/TLS 安全通信协议的最高版本号.<ul>
<li>2 表示 SSL 2.0</li>
<li>3 表示 SSL 3.0</li>
<li>3.1 表示 TLS</li>
</ul>
</li>
<li><strong>Randomly Generated Data</strong>: <code>ServerRandom[32]</code>.由服务端的日期和时间 4 字节的数字和 28 字节随机数字组成.该随机值将与客户端随机值一起生成 master secret,用于从中分发加密密钥.</li>
<li><strong>Session Identification</strong>: 会话标识(如果有).有如下三个类别<ul>
<li>New session ID: 客户端未指定要恢复的会话,由服务端生成新的 ID.当客户端指要恢复会话,但服务端无法恢复会话时,也会生成一个新会话 ID</li>
<li>Resumed Session ID: 客户端指定要恢复的会话,且服务端愿意恢复该会话</li>
<li>Null: 创建一个新会话,但服务端不会在以后恢复它,因此不会返回任何 ID</li>
</ul>
</li>
<li><strong>Cipher Suite</strong>: 加密套件.服务端与客户端均支持的最高加密套件.如果为空,则会话以 “handshake failure” 告警结束</li>
<li><strong>Compression Algorithm</strong>: 压缩算法.指定压缩算法,当前阶段为空.</li>
</ul>
<p><code>Server Hello</code> 消息示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Version 3,1</span><br><span class="line">ServerRandom[32]</span><br><span class="line">SessionID: bd608869f0c629767ea7e3ebf7a63bdcffb0ef58b1b941e6b0c044acb6820a77</span><br><span class="line">Use Cipher Suite:</span><br><span class="line">TLS_RSA_WITH_3DES_EDE_CBC_SHA</span><br><span class="line">Compression Algorithm: NONE</span><br></pre></td></tr></table></figure>

<h4 id="Server-Certificate-服务端证书"><a href="#Server-Certificate-服务端证书" class="headerlink" title="Server Certificate: 服务端证书"></a><code>Server Certificate</code>: 服务端证书</h4><p>服务端将其证书发送给客户端,服务端证书包含服务的公钥.客户端将使用此公钥对服务端进行身份验证,并加密 master secret.</p>
<h4 id="Server-Key-Exchange-服务端密钥交换消息-可选"><a href="#Server-Key-Exchange-服务端密钥交换消息-可选" class="headerlink" title="Server Key Exchange: 服务端密钥交换消息(可选)"></a><code>Server Key Exchange</code>: 服务端密钥交换消息(可选)</h4><p>服务端创建一个临时密钥并将其发送给客户端.客户端使用此密钥在此后过程加密客户端密钥交换消息.</p>
<p>仅当公钥算法未提供加密客户端密钥交换消息所需的密钥材料时(如,服务端证书不包含公钥时),才执行此步骤.</p>
<h4 id="Client-Certificate-Request-客户端证书请求-可选"><a href="#Client-Certificate-Request-客户端证书请求-可选" class="headerlink" title="Client Certificate Request: 客户端证书请求(可选)"></a><code>Client Certificate Request</code>: 客户端证书请求(可选)</h4><p>服务端请求客户端身份认证.</p>
<p>此步骤用于服务端需要确认客户端身份的场景,多用于敏感场景下的双向认证.如,银行客户端与服务端要求双向认证</p>
<h4 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a><code>Server Hello Done</code></h4><p>此消息表明服务端响应已完成,等待客户端响应</p>
<h3 id="第三阶段-Client-Response-to-Server"><a href="#第三阶段-Client-Response-to-Server" class="headerlink" title="第三阶段: Client Response to Server"></a>第三阶段: Client Response to Server</h3><p>客户端向服务端发送响应包含如下信息:</p>
<h4 id="Client-Certificate-客户端证书-可选"><a href="#Client-Certificate-客户端证书-可选" class="headerlink" title="Client Certificate: 客户端证书(可选)"></a><code>Client Certificate</code>: 客户端证书(可选)</h4><p>客户端证书,如果服务端发送了客户端证书请求,则客户端将其证书发送到服务器以进行客户端身份验证.客户的证书包含客户端的公钥</p>
<h4 id="Client-Key-Exchange-客户端密钥交换"><a href="#Client-Key-Exchange-客户端密钥交换" class="headerlink" title="Client Key Exchange: 客户端密钥交换"></a><code>Client Key Exchange</code>: 客户端密钥交换</h4><p>客户端使用 Hello 阶段的两个随机值计算 master secret 后,将发送客户端密钥交换消息.master secret 会先通过服务端证书的公钥加密,然后再传输到服务器.双方在本地计算 master secret,并从中获取会话密钥.</p>
<h4 id="Certificate-Verify-证书认证消息-可选"><a href="#Certificate-Verify-证书认证消息-可选" class="headerlink" title="Certificate Verify: 证书认证消息(可选)"></a><code>Certificate Verify</code>: 证书认证消息(可选)</h4><p>客户端发送了客户端认证消息时,才发送此消息</p>
<h4 id="Change-Cipher-Spec-加密套件修改消息"><a href="#Change-Cipher-Spec-加密套件修改消息" class="headerlink" title="Change Cipher Spec: 加密套件修改消息"></a><code>Change Cipher Spec</code>: 加密套件修改消息</h4><p>此消息通知服务器,将使用刚刚协商的密钥和算法对”Client Finished”消息之后的所有消息进行加密.</p>
<h4 id="Client-Finished-客户端握手结束消息"><a href="#Client-Finished-客户端握手结束消息" class="headerlink" title="Client Finished: 客户端握手结束消息"></a><code>Client Finished</code>: 客户端握手结束消息</h4><p>此消息是前面发送的所有内容的 hash 值,供服务器校验.此消息表示客户端的握手阶段已经结束.</p>
<h3 id="第四阶段-Server-Final-Response-to-Client"><a href="#第四阶段-Server-Final-Response-to-Client" class="headerlink" title="第四阶段: Server Final Response to Client"></a>第四阶段: Server Final Response to Client</h3><h4 id="Change-Cipher-Spec-Message-加密套件修改消息"><a href="#Change-Cipher-Spec-Message-加密套件修改消息" class="headerlink" title="Change Cipher Spec Message: 加密套件修改消息"></a><code>Change Cipher Spec Message</code>: 加密套件修改消息</h4><p>此消息通知客户端服务器将开始使用刚刚协商的密钥对消息进行加密</p>
<h4 id="Server-Finished-Message-服务端握手结束消息"><a href="#Server-Finished-Message-服务端握手结束消息" class="headerlink" title="Server Finished Message: 服务端握手结束消息"></a><code>Server Finished Message</code>: 服务端握手结束消息</h4><p>此消息是前面发送的所有内容的 hash 值,供客户端校验.此消息表示服务端的握手阶段已经结束</p>
<p>至此,整个握手阶段全部结束.接下来,客户端与服务器进入加密通信,完全是使用普通的 HTTP 协议,只不过用”会话密钥”加密内容.</p>
<h2 id="事件驱动的-Alert-Messages"><a href="#事件驱动的-Alert-Messages" class="headerlink" title="事件驱动的 Alert Messages"></a>事件驱动的 Alert Messages</h2><p>告警子协议是握手协议的组件,该协议可以从任何一方发送事件驱动的告警消息.收到告警消息后,会话要么结束,要么让接收者选择是否接受会话.</p>
<p>下表列出了告警消息及说明,已备后续查阅</p>
<table>
<thead>
<tr>
<th align="center">Alert Message</th>
<th align="center">Fatal?</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unexpected_message</td>
<td align="center">Yes</td>
<td align="center">非法消息</td>
</tr>
<tr>
<td align="center">bad_record_mac</td>
<td align="center">Yes</td>
<td align="center">错误的 MAC</td>
</tr>
<tr>
<td align="center">decryption_failed</td>
<td align="center">Yes</td>
<td align="center">无法解密 TLSCiphertext TLS 密文</td>
</tr>
<tr>
<td align="center">record_overflow</td>
<td align="center">Yes</td>
<td align="center">记录超过 2^14+1024 字节</td>
</tr>
<tr>
<td align="center">handshake_failure</td>
<td align="center">Yes</td>
<td align="center">不可接受的加密套件</td>
</tr>
<tr>
<td align="center">bad_certificate</td>
<td align="center">Yes</td>
<td align="center">证书出现问题</td>
</tr>
<tr>
<td align="center">unsupported_certificate</td>
<td align="center">No</td>
<td align="center">不支持的证书</td>
</tr>
<tr>
<td align="center">certificate_revoked</td>
<td align="center">No</td>
<td align="center">证书已被吊销</td>
</tr>
<tr>
<td align="center">certificate_expired</td>
<td align="center">No</td>
<td align="center">证书已过期</td>
</tr>
<tr>
<td align="center">certificate_unknown</td>
<td align="center">No</td>
<td align="center">证书不受信任</td>
</tr>
<tr>
<td align="center">illegal_parameter</td>
<td align="center">Yes</td>
<td align="center">非法加密参数</td>
</tr>
<tr>
<td align="center">unknown_ca</td>
<td align="center">Yes</td>
<td align="center">CA 不受信任</td>
</tr>
<tr>
<td align="center">access_denied</td>
<td align="center">Yes</td>
<td align="center">发送方不同意协商</td>
</tr>
<tr>
<td align="center">decode_error</td>
<td align="center">Yes</td>
<td align="center">无法解码消息</td>
</tr>
<tr>
<td align="center">decrypt_error</td>
<td align="center">Yes</td>
<td align="center">握手加密操作失败</td>
</tr>
<tr>
<td align="center">export_restriction</td>
<td align="center">Yes</td>
<td align="center">Not in compliance with export regulations</td>
</tr>
<tr>
<td align="center">protocol_version</td>
<td align="center">Yes</td>
<td align="center">双方不都支持的协议版本</td>
</tr>
<tr>
<td align="center">insufficient_security</td>
<td align="center">Yes</td>
<td align="center">没有达到安全要求</td>
</tr>
<tr>
<td align="center">internal_error</td>
<td align="center">Yes</td>
<td align="center">与协议无关的错误</td>
</tr>
<tr>
<td align="center">user_canceled</td>
<td align="center">Yes</td>
<td align="center">与协议无关的失败</td>
</tr>
<tr>
<td align="center">no_renegotiation</td>
<td align="center">No</td>
<td align="center">协商请求被拒绝</td>
</tr>
</tbody></table>
<h2 id="HTTPS-连接过程"><a href="#HTTPS-连接过程" class="headerlink" title="HTTPS 连接过程"></a>HTTPS 连接过程</h2><p>上面描述的 HTTPS 连接过程太繁琐了.下面简化一下,方便记忆:</p>
<ol>
<li>客户端通过发送 <code>Client Hello</code> 报文开始 SSL 通信.报文中包含客户端支持的 SSL 的版本和加密组件(Cipher Suite)列表</li>
<li>服务端发送 <code>Server Hello</code> 报文作为响应.同样的,报文中包含 SSL 版本以及加密组件</li>
<li>服务端发送 <code>Certificate</code> 报文,报文中包含公钥证书.并发送 <code>Server Hello Done</code> 报文通知客户端,最初阶段 SSL 握手协商结束</li>
<li>客户端密钥交换,以 <code>Client Key Exchange</code> 报文作为回应.报文中包含通信加密时使用的一种被称为 <code>Pre-master secret</code> 的随机密码串.该报文已用步骤 3 中公钥进行加密</li>
<li>客户端继续发送 <code>Change Cipher Spec</code> 报文.该报文会提示服务器,在此报文之后的通信会采用 <code>Pre-master secret</code> 密钥加密</li>
<li>客户端发送 <code>Finished</code> 报文.该报文包含连接至今全部报文的整体校验值</li>
<li>服务器同样发送 <code>Change Cipher Spec</code> 报文和 <code>Finished</code> 报文</li>
<li>SSL 连接建立完成,后续发送 HTTP 请求</li>
</ol>
<hr>
<p>参考:</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener">彻底搞懂HTTPS的加密机制</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc781476(v=ws.10)" target="_blank" rel="noopener">Overview of SSL/TLS Encryption</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc785811(v=ws.10)" target="_blank" rel="noopener">SSL/TLS in Detail</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 之 systemd 的工作原理及使用</title>
    <url>/2020/06/11/systemd-details/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>兼容 SysVinit 和 LSB init scripts</li>
<li>以并行方式启动,启动速度更快<ul>
<li>尽可能启动更少的进程</li>
<li>尽可能将更多进程并行启动</li>
</ul>
</li>
<li>提供按需启动能力,只有在某个服务被真正请求的时候才启动它</li>
<li>采用 Linux的 Cgroup 特性跟踪和管理进程的生命周期.Systemd 只需要简单地遍历指定的 CGroup 即可正确地找到所有的相关进程</li>
<li>实现事务性依赖关系管理.系统启动过程是由很多的独立工作共同组成的,这些工作之间可能存在依赖关系.Systemd 维护一个”事务一致性”的概念,保证所有相关的服务都可以正常启动而不会出现互相依赖,以至于死锁的情况.</li>
<li>使用 systemd-journald 提供日志服务.有便于管理,零维护,高性能,统一化的特点</li>
<li>向后兼容 SysV 的服务脚本</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>系统初始化需要做的事情非常多,如启动后台服务以及做一些配置工作.这个过程中的每一步都被 Systemd 抽象为一个配置单元,即 <code>unit</code>.它主要包含如下几种类型</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">文件扩展名</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>service unit</code></td>
<td align="left"><code>.service</code></td>
<td align="left">用于定义系统类服务</td>
</tr>
<tr>
<td align="left"><code>target unit</code></td>
<td align="left"><code>.target</code></td>
<td align="left">用于实现模拟”运行级别”</td>
</tr>
<tr>
<td align="left"><code>mount unit</code></td>
<td align="left"><code>.mount</code></td>
<td align="left">用于定义文件系统挂载点</td>
</tr>
<tr>
<td align="left"><code>socket unit</code></td>
<td align="left"><code>.socket</code></td>
<td align="left">用于标识进程间通信的 socket 文件</td>
</tr>
<tr>
<td align="left"><code>snapshot unit</code></td>
<td align="left"><code>.snapshot</code></td>
<td align="left">管理系统快照</td>
</tr>
<tr>
<td align="left"><code>swap unit</code></td>
<td align="left"><code>.swap</code></td>
<td align="left">用于标识 swap 设备</td>
</tr>
<tr>
<td align="left"><code>automount unit</code></td>
<td align="left"><code>.automount</code></td>
<td align="left">文件系统自动挂载设备</td>
</tr>
<tr>
<td align="left"><code>path unit</code></td>
<td align="left"><code>.path</code></td>
<td align="left">用于定义文件系统中的一个文件或目录</td>
</tr>
<tr>
<td align="left"><code>timer unit</code></td>
<td align="left"><code>.timer</code></td>
<td align="left">用来定时触发用户定义的操作</td>
</tr>
</tbody></table>
<h3 id="Target和运行级别的对应关系"><a href="#Target和运行级别的对应关系" class="headerlink" title="Target和运行级别的对应关系"></a>Target和运行级别的对应关系</h3><table>
<thead>
<tr>
<th align="left">sysvinit</th>
<th align="left">systemd target</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">poweroff.target</td>
<td align="left">关闭系统</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">rescue.target</td>
<td align="left">单用户模式</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">multi-user.target</td>
<td align="left">多用户模式,无网络</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">multi-user.target</td>
<td align="left">多用户模式</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">-</td>
<td align="left">没有用到</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">graphical.target</td>
<td align="left">多用户,图形化界面</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">reboot.target</td>
<td align="left">重启</td>
</tr>
</tbody></table>
<h2 id="service-unit-file"><a href="#service-unit-file" class="headerlink" title="service unit file"></a>service unit file</h2><p>文件通常由三部分组成</p>
<h3 id="Unit"><a href="#Unit" class="headerlink" title="[Unit]"></a>[Unit]</h3><p><code>Unit</code> 配置块通常是配置文件的第一个配置块,用来定义 Unit 的元数据,以及配置与其他 Unit 的依赖关系.它的主要字段如下:</p>
<ul>
<li><code>Description</code>: 简短描述</li>
<li><code>Documentation</code>: 文档地址</li>
<li><code>Requires</code>: 当前 Unit 依赖的其他 Unit,如果它们没有运行,当前 Unit 会启动失败</li>
<li><code>Wants</code>: 与当前 Unit 配合的其他 Unit,如果它们没有运行,当前 Unit 不会启动失败</li>
<li><code>BindsTo</code>: 与 Requires 类似,它指定的 Unit 如果退出,会导致当前 Unit 停止运行</li>
<li><code>Before</code>: 当前 Unit 必须在指定的 Unit 之前启动</li>
<li><code>After</code>: 当前 Unit 必须在指定的 Unit 之后启动</li>
<li><code>Conflicts</code>: 这里指定的 Unit 不能与当前 Unit 同时运行</li>
<li><code>Condition...</code>: 当前 Unit 运行必须满足的条件，否则不会运行</li>
<li><code>Assert...</code>:当前 Unit 运行必须满足的条件，否则会报启动失败</li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="[Service]"></a>[Service]</h3><p><code>Service</code> 配置块用来定义 Service 的属性,只有 Service 类型的 Unit 才有这个配置块.它的主要字段如下:</p>
<ul>
<li><code>Type</code>: 定义启动时的进程行为.可选值为<ul>
<li><code>simple</code>: 默认值,执行 ExecStart 指定的命令,启动主进程</li>
<li><code>forking</code>: 以 fork 方式从父进程创建子进程,创建后父进程会立即退出</li>
<li><code>oneshot</code>: 一次性进程,Systemd 会等当前服务退出,再继续往下执行</li>
<li><code>dbus</code>: 当前服务通过 D-Bus 启动</li>
<li><code>notify</code>: 当前服务启动完毕,会通知 Systemd,再继续往下执行</li>
<li><code>idle</code>: 若有其他任务执行完毕,当前服务才会运行</li>
</ul>
</li>
<li><code>Environment</code>: 指定环境变量</li>
<li><code>ExecStart</code>: 启动当前服务的命令</li>
<li><code>ExecStartPre</code>: 启动当前服务之前执行的命令</li>
<li><code>Restart</code>: 定义何种情况 Systemd 会自动重启当前服务.可选值为 <code>always</code>,<code>on-success</code>,<code>on-failure</code>,<code>on-abnormal</code>,<code>on-abort</code>,<code>on-watchdog</code></li>
<li><code>ExecReload</code>: 重新加载当前服务时执行的命令</li>
<li><code>ExecStop</code>: 停止当前服务时执行的命令</li>
<li><code>ExecStartPost</code>: 启动当前服务之后执行的命令</li>
<li><code>ExecStopPost</code>: 停止当其服务之后执行的命令</li>
<li><code>RestartSec</code>: 自动重启当前服务间隔的秒数</li>
<li><code>TimeoutSec</code>: 定义 Systemd 停止当前服务之前等待的秒数</li>
</ul>
<h3 id="Install"><a href="#Install" class="headerlink" title="[Install]"></a>[Install]</h3><p><code>Install</code> 配置块通常在文件最后,用来定义如何启动,以及是否开机启动.它的主要字段如下</p>
<ul>
<li><code>WantedBy</code>: 它的值是一个或多个 <code>Target</code>,当前 Unit enable 时(服务开机启动时),会在 <code>/etc/systemd/system</code> 目录及指定 <code>${target}.wants</code> 子目录下创建软链接</li>
<li><code>RequiredBy</code>: 它的值是一个或多个 <code>Target</code>,当前 Unit enable 时(服务开机启动时),会在 <code>/etc/systemd/system</code> 目录及指定 <code>${target}.required</code> 子目录下创建软链接<br><code>Alias</code>: 当前 Unit 可用于启动的别名<br><code>Also</code>: 当前 Unit enable 时(服务开机启动时),同时激活的其他 Unit</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 远程存储 VictoriaMetrics</title>
    <url>/2021/11/04/victoriametrics-quick-start/</url>
    <content><![CDATA[<p><a href="https://github.com/VictoriaMetrics/VictoriaMetrics" target="_blank" rel="noopener">VictoriaMetrics</a> 是一个快速、经济高效且可扩展的监控解决方案和时间序列数据库,不仅可以作为 <a href="https://github.com/prometheus/prometheus" target="_blank" rel="noopener">Prometheus</a> 的远程存储,还可以使用其组件完全替换 Prometheus.它主要有以下特性:</p>
<ul>
<li>支持 <a href="https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#prometheus-querying-api-usage" target="_blank" rel="noopener">Prometheus querying API</a>,<a href="https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#graphite-api-usage" target="_blank" rel="noopener">Graphite API</a>. 可以在 Grafana 中直接使用</li>
<li>实现了基于 PromQL 的查询语言 - <a href="https://docs.victoriametrics.com/MetricsQL.html" target="_blank" rel="noopener">MetricsQL</a>,提供了一些高级功能</li>
<li>提供了全局视图,支持多个 Prometheus 实例或任何其他数据源同时向 VictoriaMetrics 写入数据,查询时数据可以保证唯一</li>
<li>占用资源少,且高性能.</li>
<li>支持多种方式获取 metrics. 如:<ul>
<li><a href="https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#how-to-scrape-prometheus-exporters-such-as-node-exporter" target="_blank" rel="noopener">从 exporter 直接获取</a>.与prometheus 完全兼容.除 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config" target="_blank" rel="noopener">static_config</a> 外,还支持多种服务发现方式,如:<ul>
<li><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config" target="_blank" rel="noopener">file_sd_config</a></li>
<li><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config" target="_blank" rel="noopener">kubernetes_sd_config</a></li>
<li><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config" target="_blank" rel="noopener">consul_sd_config</a></li>
</ul>
</li>
<li><a href="https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#prometheus-setup" target="_blank" rel="noopener">通过 Prometheus 远程写入</a></li>
<li><a href="https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#how-to-import-data-in-json-line-format" target="_blank" rel="noopener">通过 Post 请求将指定 JSON 格式的数据直接写入</a></li>
</ul>
</li>
<li>支持 <a href="https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#relabeling" target="_blank" rel="noopener">metrics relabel</a>.与 prometheus 完全兼容</li>
<li>支持单机模式与集群模式</li>
</ul>
<h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><p>单机模式比较简单,直接下载<a href="https://github.com/VictoriaMetrics/VictoriaMetrics/releases" target="_blank" rel="noopener">二进制</a>或 <a href="https://hub.docker.com/r/victoriametrics/victoria-metrics/" target="_blank" rel="noopener">Docker 镜像</a> 并使用指定的命令行启动.</p>
<p>单机模式可能用到的组件.</p>
<ul>
<li>victoria-metrics: metrics 数据抓取或存储</li>
<li>vmalert: 按照指定的规则将 metrics 数据聚合或向 alertmanager 发送告警</li>
<li>vmauth: 启用用户认证功能</li>
</ul>
<p>以二进制为例,可以通过</p>
<ul>
<li><code>-storageDataPath</code> 参数指定数据存储的目录.默认为 <code>victoria-metrics-data</code></li>
<li><code>-retentionPeriod</code> 参数指定数据保存的时长.默认为 <code>1 month</code></li>
<li><code>-httpListenAddr</code> 参数指定监听的 HTTP 套接字.默认为 <code>:8428</code></li>
<li><code>-loggerTimezon</code> 参数指定日志的时区,默认为 <code>UTC</code>.建议设置为 <code>Asia/Shanghai</code></li>
<li><code>-maxInsertRequestSize</code> 参数限制 Prometheus remote_write API 的请求大小. 默认为 <code>33554432 byte</code>.支持可选的单位为 <code>KB, MB, GB, KiB, MiB, GiB</code></li>
<li><code>-promscrape.config</code> 参数指定 Prometheus 配置文件路径.该配置文件只需要包含 <code>scrape_configs</code> 部分配置即可.(经测试  VictoriaMetrics 支持 <code>scrape_configs</code> 中的 <code>relabel_configs</code> 和 <code>metric_relabel_configs</code> )</li>
<li><code>-promscrape.config.strictParse</code> 参数设置是否会严格校验 <code>-promscrape.config</code> 指定的配置文件.默认情况下,不支持的字段会跳过,兼容 Prometheus 的配置文件</li>
<li><code>-promscrape.configCheckInterval</code> 参数设置检查 Prometheus 配置文件是否变更的时间间隔.若变更,则重新加载.默认关闭</li>
<li><code>-relabelConfig</code> 参数指定 relabel 的规则.</li>
<li><code>-relabelDebug</code> 参数指定日志中是否指定 relabel 前后的 metrics.多用于调试.</li>
<li><code>-selfScrapeInstance</code> 参数设置抓取自身 metrics 时,<code>instance</code> 标签的值.默认 <code>self</code></li>
<li><code>-selfScrapeInterval</code> 参数设置抓取自身 metrics 的时间间隔</li>
<li><code>-selfScrapeJob</code> 参数设置设置抓取自身 metrics 时,<code>instance</code> 标签的值.默认 <code>victoria-metrics</code></li>
</ul>
<p>从参数看来,单机模式下的 <code>VictoriaMetrics</code> 可以</p>
<ol>
<li>作为  Prometheus 的远程存储</li>
</ol>
<p>启动 VictoriaMetrics 脚本如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start_VictoriaMetrics.sh</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;victoria-metrics-home&#125;</span></span><br><span class="line">./victoria-metrics \</span><br><span class="line">  -storageDataPath &lt;storageDataPath&gt; \</span><br><span class="line">  -retentionPeriod &lt;dataKeepTime&gt; \</span><br><span class="line">  -maxInsertRequestSize &lt;req_size&gt; \</span><br><span class="line">  -httpListenAddr &lt;IP:port&gt; \</span><br><span class="line">  -loggerTimezon Asia/Shanghai &amp;&gt; victoria-metrics.log &amp;</span><br></pre></td></tr></table></figure>

<p>Prometheus 远程写入相关配置如下:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prometheus.yml</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">http://&lt;victoriametrics-addr&gt;:8428/api/v1/write</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指定 <code>promscrape.config</code> 直接抓取并存储 metrics.</li>
</ol>
<p>这种方式启动与作为远程存储启动方式基本与存储方式大同小异,只需要指定对应配置文件即可.在直接抓取 metrics 过程中,VictoriaMetrics 需要一些其他的组件去实现 Prometheus 中的功能.比如</p>
<ul>
<li>Prometheus 中规则(包括 metrics 聚合规则与告警规则) 需要 <code>vmalert</code> 组件来实现.且 <code>vmalert</code> 只是发送告警到 <code>Alertmanager</code>.<code>vmalert</code> 支持的规则与 Prometheus 的规则一致.有关 <code>vmalert</code> 的使用,参见<a href="https://docs.victoriametrics.com/vmalert.html" target="_blank" rel="noopener">官方文档</a></li>
<li>Prometheus 中认证相配置 需要 <code>vmauth</code> 组件来实现,参见<a href="https://docs.victoriametrics.com/vmauth.html" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;victoria-metrics-home&#125;</span></span><br><span class="line"></span><br><span class="line">./victoria-metrics \</span><br><span class="line">  -storageDataPath &lt;storageDataPath&gt; \</span><br><span class="line">  -retentionPeriod &lt;dataKeepTime&gt; \</span><br><span class="line">  -maxInsertRequestSize &lt;req_size&gt; \</span><br><span class="line">  -httpListenAddr &lt;metrics_IP:port&gt; \</span><br><span class="line">  -promscrape.config &lt;prometheus.yml&gt; \</span><br><span class="line">  -promscrape.configCheckInterval 1m \</span><br><span class="line">  -loggerTimezon Asia/Shanghai &amp;&gt; victoria-metrics.log &amp;</span><br><span class="line"></span><br><span class="line">./vmalert \</span><br><span class="line">  -httpListenAddr <span class="string">":8880"</span> \</span><br><span class="line">  -rule &lt;record_rule_file or alert_rule_file&gt; \</span><br><span class="line">  -datasource.url &lt;metrics_IP:port&gt; \</span><br><span class="line">  -notifier.url &lt;AlertManager URL&gt; \ <span class="comment"># AlertManager URL</span></span><br><span class="line">  -remoteWrite.url &lt;metrics_IP:port&gt; \ <span class="comment"># 聚合后的 metrics 写入的位置,一般为 victoria-metrics 的端口</span></span><br><span class="line">  -remoteRead.url &lt;metrics_IP:port&gt; \</span><br><span class="line">  -external.label &lt;key=value&gt; <span class="comment"># 为聚合后的 metrics 添加标签</span></span><br><span class="line"></span><br><span class="line">./vmauth \</span><br><span class="line">  -httpListenAddr <span class="string">":8427"</span> \</span><br><span class="line">  -auth.config &lt;auth_config&gt;</span><br></pre></td></tr></table></figure>

<p>为了加强数据的安全性,可以将 victoria-metrics 存储监听在 localhost.启用 auth. 配置一些自定义用户信息. <code>vmauth</code> 配置文件示例如下. Grafana 可使用该用户获取数据.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">username:</span> <span class="string">"local-single-node"</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">"***"</span></span><br><span class="line">  <span class="attr">url_prefix:</span> <span class="string">"http://localhost:8428"</span></span><br></pre></td></tr></table></figure>

<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>VictoriaMetrics 集群模式相对来说比较复杂.主要由 <code>vmstorage</code> ,<code>vminsert</code>,<code>vmselect</code> 三部分组成, 这三个组件每个组件都可以单独进行扩展.其中:</p>
<ul>
<li>vmstorage 负责提供数据存储服务</li>
<li>vminsert 是数据存储 vmstorage 的代理,使用一致性 hash 算法进行写入分片</li>
<li>vmselect 负责数据查询,根据输入的查询条件从 vmstorage 中查询数据</li>
</ul>
<p>vmstorage 采用 shared-nothing 架构,优点是 vmstorage 的节点相互之间无感知,相互之间无需通信,不共享任何数据,增加了集群的可用性,简化了集群的扩展的难度与运维工作.</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>VictoriaMetrics 集群模式支持</p>
<ol>
<li><a href="https://docs.victoriametrics.com/Cluster-VictoriaMetrics.html#cluster-resizing-and-scalability" target="_blank" rel="noopener">性能和容量水平扩展</a></li>
</ol>
<ul>
<li><code>vminsert</code> 和 <code>vmselect</code> 是无状态的.可以随时添加/删除.添加更多的 <code>vminsert</code> 和 <code>vmselect</code> 节点可以扩展数据写入与查询的效率</li>
<li><code>vmstorage</code> 节点保存抓取的数据,因此无法在不丢失数据的情况下删除它们.添加更多 <code>vmstorage</code> 节点可扩展集群容量.添加 <code>vmstorage</code> 的步骤如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 使用与集群中现有节点相同的 -retentionPeriod 启动新的 vmstorage 节点</span><br><span class="line">2. 使用包含 &lt;new_vmstorage_host&gt; 的新 -storageNode 参数逐渐重新启动所有 vmselect 节点</span><br><span class="line">3. 使用包含 &lt;new_vmstorage_host&gt; 的新 -storageNode 参数逐渐重新启动所有 vminsert 节点</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://docs.victoriametrics.com/Cluster-VictoriaMetrics.html#multitenancy" target="_blank" rel="noopener">支持时间序列数据的多个名称空间(租户)</a>.多个租户之间相互隔离</li>
</ol>
<p>VictoriaMetrics 集群支持多个独立的租户.租户由 <code>accountID</code> 或 <code>accountID:projectID</code> 标识,他们放在 url 中.如 <code>http://&lt;vminsert&gt;:8480/insert/&lt;accountID&gt;/&lt;suffix&gt;</code>,<code>http://&lt;vmselect&gt;:8481/select/&lt;accountID&gt;/prometheus/&lt;suffix&gt;</code> 等.</p>
<ul>
<li>每个 accountID 和 projectID 由范围 [0 .. 2^32) 中的任意 32 位整数标识.如果不指定,则默自动分配为 0.</li>
<li>当第一个数据点写入给定租户时,会自动创建租户</li>
<li>所有租户的数据均匀分布在可用的 vmstorage 节点中.这保证了当不同租户具有不同的数据量和不同的查询负载时,vmstorage 节点之间的负载均匀</li>
<li>数据库性能依赖于租户的数量,主要取决于所有租户中活动的时间序列的总数.</li>
<li>VictoriaMetrics 不支持在单个请求中查询多个租户</li>
</ul>
<ol start="3">
<li><a href="https://docs.victoriametrics.com/Cluster-VictoriaMetrics.html#replication-and-data-safety" target="_blank" rel="noopener">支持数据副本</a></li>
</ol>
<p>默认情况下,VictoriaMetrics 将副本写入到 <code>-storageDataPath</code> 指向的底层存储.</p>
<p>可以通过 <code>vminsert</code> 指定 <code>-replicationFactor=N</code> 标志位来启用数据副本.这保证在最多 <code>N-1</code> 个 vmstorage 节点不可用时,所有数据扔可用于查询.集群必须至少包含 <code>2*N-1</code> 个 vmstorage 节点.</p>
<p>启用复制后,<code>vmselect</code> 必须指定 <code>-dedup.minScrapeInterval=1ms</code> 命令行标志.</p>
<h3 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h3><p>使用 3 个节点部署相关服务.节点 IP 分别为 IP1, IP2, IP3</p>
<p>在每个节点上运行如下脚本来启动 <code>vmstroage</code>,<code>vminsert</code>,<code>vmselect</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">victoria_home=<span class="string">"/data1/victoria-metrics"</span></span><br><span class="line">bin=<span class="variable">$&#123;victoria_home&#125;</span>/bin</span><br><span class="line">conf=<span class="variable">$&#123;victoria_home&#125;</span>/conf</span><br><span class="line">data=<span class="variable">$&#123;victoria_home&#125;</span>/data</span><br><span class="line"><span class="built_in">log</span>=<span class="variable">$&#123;victoria_home&#125;</span>/<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">LOG_LEVEL=INFO</span><br><span class="line">TIMEZONE=<span class="string">"Asia/Shanghai"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;victoria_home&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;bin&#125;</span>/vmstorage-prod \</span><br><span class="line">  -httpListenAddr <span class="string">"nodeIP:8482"</span> \</span><br><span class="line">  -storageDataPath <span class="variable">$&#123;data&#125;</span> \</span><br><span class="line">  -retentionPeriod 30d \</span><br><span class="line">  -vminsertAddr <span class="string">"nodeIP:8400"</span> \  <span class="comment"># insert 端口,由 vminsert 连接</span></span><br><span class="line">  -vmselectAddr <span class="string">"nodeIP:8401"</span> \   <span class="comment"># select 端口,由 vmselect 连接</span></span><br><span class="line">  -loggerTimezone <span class="variable">$&#123;TIMEZONE&#125;</span> \</span><br><span class="line">  -loggerLevel <span class="variable">$&#123;LOG_LEVEL&#125;</span> &amp;&gt; <span class="variable">$&#123;log&#125;</span>/storage.log &amp;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;bin&#125;</span>/vminsert-prod \</span><br><span class="line">  -httpListenAddr <span class="string">"nodeIP:8480"</span> \</span><br><span class="line">  -storageNode IP1:8400,IP2:8400,IP3:8400 \</span><br><span class="line">  -loggerTimezone <span class="variable">$&#123;TIMEZONE&#125;</span> \</span><br><span class="line">  -loggerLevel <span class="variable">$&#123;LOG_LEVEL&#125;</span> &amp;&gt; <span class="variable">$&#123;log&#125;</span>/insert.log &amp;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;bin&#125;</span>/vmselect-prod \</span><br><span class="line">  -httpListenAddr <span class="string">"nodeIP:8481"</span> \</span><br><span class="line">  -selectNode IP1:8481,IP2:8481,IP3:8481 \</span><br><span class="line">  -storageNode IP1:8401,IP2:8401,IP3:8401 \</span><br><span class="line">  -loggerTimezone <span class="variable">$&#123;TIMEZONE&#125;</span> \</span><br><span class="line">  -loggerLevel <span class="variable">$&#123;LOG_LEVEL&#125;</span> &amp;&gt; <span class="variable">$&#123;log&#125;</span>/select.log &amp;</span><br></pre></td></tr></table></figure>

<p>启动后,可以分别配置 Prometheus 和 Grafana 对 metrics 数据写入读取.详见<a href="https://docs.victoriametrics.com/Cluster-VictoriaMetrics.html#url-format" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prometheus.yml</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">"http://&lt;vminsert&gt;:8480/insert/&lt;accountID&gt;/&lt;suffix&gt;"</span></span><br><span class="line">   <span class="comment"># accountID 默认为 0</span></span><br><span class="line">   <span class="comment"># suffix 可以为 `prometheus` 或 `prometheus/api/v1/write`</span></span><br><span class="line">    <span class="attr">write_relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__name__]</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">'go_.*'</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure>

<p>Grafana 数据源地址可配置为 <code>http://&lt;vmselect&gt;:8481/select/&lt;accountID&gt;/prometheus</code>.此时 <code>accountID</code> 必须与 <code>prometheus.yml</code> 中配置的 <code>accountID</code> 一致.</p>
<p>最后可使用 <code>vmauth</code> 对数据读取时进行验证,保证数据安全性.</p>
<hr>
<p>参考:</p>
<ul>
<li><a href="https://docs.victoriametrics.com/" target="_blank" rel="noopener">VictoriaMetrics 官方文档</a></li>
<li><a href="https://github.com/VictoriaMetrics/VictoriaMetrics" target="_blank" rel="noopener">VictoriaMetrics/VictoriaMetrics(github.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/368912946" target="_blank" rel="noopener">浅析下开源时序数据库VictoriaMetrics的存储机制 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>VictoriaMetrics</tag>
      </tags>
  </entry>
  <entry>
    <title>判断一个链表是否有环</title>
    <url>/2020/06/28/whether-linkedlist-has-ring/</url>
    <content><![CDATA[<h2 id="判断一个链表是否有环-如果有-则找到环的入口点"><a href="#判断一个链表是否有环-如果有-则找到环的入口点" class="headerlink" title="判断一个链表是否有环,如果有,则找到环的入口点"></a>判断一个链表是否有环,如果有,则找到环的入口点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        retrun <span class="string">'%s'</span> % self.value</span><br><span class="line"></span><br><span class="line">node1 = Node(<span class="number">1</span>)</span><br><span class="line">node2 = Node(<span class="number">2</span>)</span><br><span class="line">node3 = Node(<span class="number">3</span>)</span><br><span class="line">node4 = Node(<span class="number">4</span>)</span><br><span class="line">node5 = Node(<span class="number">5</span>)</span><br><span class="line">node1.next = node2</span><br><span class="line">node2.next = node3</span><br><span class="line">node3.next = node4</span><br><span class="line">node4.next = node5</span><br><span class="line">node5.next = node2</span><br></pre></td></tr></table></figure>

<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>不允许修改链表结构</li>
<li>时间复杂度O(n),空间复杂度O(1)</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>创建一个存储节点 ID 为的集合,来存储曾经遍历过的节点.从头节点开始,依次遍历单链表的每一个节点.每遍历到一个新节点,就用新节点和集合当中存储的节点作比较,如果发现集合中存在相同节点 ID,则说明链表有环;否则存入新的节点.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whether_has_ring</span><span class="params">(node)</span>:</span></span><br><span class="line">    node_set = set()</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> node_set:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        node_set.add(node)</span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>或利用集合没有重复元素的特性,通过判断集合长度来判断链表是否具有环型结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whether_has_ring</span><span class="params">(node)</span>:</span></span><br><span class="line">    node_set = set()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        node_set.add(node)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len(node_set) != n:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>使用 slow,fast 两个指针对链表进行遍历.slow 指针一次遍历 1个节点,fast 指针一次遍历 2 个节点.当快慢指针相交时,则表示链表有环.</p>
<p>若有环,则使用一个指针指向链表头节点,一个指针指向第一次的交汇点,一起向后遍历,当两个指针相等时,此时相交的位置即为环的入口点.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whether_has_ring</span><span class="params">(node)</span>:</span></span><br><span class="line">    slow = node</span><br><span class="line">    fast = node</span><br><span class="line">    <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow == fast: <span class="comment"># 如果快慢指针相交,则表示有环.并</span></span><br><span class="line">            slow = node</span><br><span class="line">            <span class="keyword">while</span> slow.next <span class="keyword">and</span> fast.next:</span><br><span class="line">                slow = slow.next <span class="comment"># 使慢从头开始遍历</span></span><br><span class="line">                fast = fast.next <span class="comment"># 快指针从相交位置开始遍历</span></span><br><span class="line">                <span class="keyword">if</span> slow == fast: <span class="comment"># 再次相交的位置为环的入口点</span></span><br><span class="line">                    <span class="keyword">return</span> slow</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="判断两个单链表是否相交"><a href="#判断两个单链表是否相交" class="headerlink" title="判断两个单链表是否相交"></a>判断两个单链表是否相交</h2><h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><p>如果两个链表相交,那么它们一定会有公共的结点.</p>
<p>创建一个存储节点 ID 为的集合,来存储链表 A 中节点.从链表 B 头节点开始,依次遍历单链表的每一个节点.每遍历到一个新节点,就用新节点和集合当中存储的节点作比较,如果发现集合中存在相同节点 ID,则说明链表相交;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whether_intersect</span><span class="params">(node1, node2)</span>:</span></span><br><span class="line">    node_set = set()</span><br><span class="line">    node = node1</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        node_set.add(node)</span><br><span class="line">        node = node.next</span><br><span class="line">    node = node2</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> node_set:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(m + n) = O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="尾节点法"><a href="#尾节点法" class="headerlink" title="尾节点法"></a>尾节点法</h3><p>如果两个链表相交,那么它们的最后一个节点一定相等.</p>
<p>首先判断两个链表尾节点是否相等,并获得两个链表的长度,l1,l2.若相等,使长链表先遍历 l1-l2 的绝对值长度.然后长短链表依次遍历.节点相等则为链表相交的位置.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whether_intersect2</span><span class="params">(node1, node2)</span>:</span></span><br><span class="line">    l1 = <span class="number">1</span> <span class="comment"># l1 表示 node1 的长度</span></span><br><span class="line">    l2 = <span class="number">1</span> <span class="comment"># l1 表示 node2 的长度</span></span><br><span class="line">    node_a = node1 <span class="comment"># node_a 表示遍历 node1 的指针</span></span><br><span class="line">    node_b = node2 <span class="comment"># node_b 表示遍历 node2 的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># node_a, node_b 分别遍历到结尾,并判断是否相等</span></span><br><span class="line">    <span class="keyword">while</span> node_a.next:</span><br><span class="line">        node_a = node_a.next</span><br><span class="line">        l1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> node_b.next:</span><br><span class="line">        node_b = node_b.next</span><br><span class="line">        l2 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> node_a == node_b: <span class="comment"># 如果相等,则都从头开始</span></span><br><span class="line">        node_a = node1</span><br><span class="line">        node_b = node2</span><br><span class="line">        <span class="keyword">if</span> l1 &gt; l2: <span class="comment"># l1 &gt; l2,则 node_a 遍历 l1 -  l2 长度</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l1 - l2):</span><br><span class="line">                node_a = node_a.next</span><br><span class="line">        <span class="keyword">if</span> l1 &lt; l2: <span class="comment"># l1 &lt; l2,则 node_b 遍历 l2 -  l1 长度</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l2 - l1):</span><br><span class="line">                node_b = node_b.next</span><br><span class="line">        <span class="keyword">while</span> node_a <span class="keyword">and</span> node_b: <span class="comment"># 然后开始遍历,并判断是否相交</span></span><br><span class="line">            <span class="keyword">if</span> node_a == node_b:</span><br><span class="line">                <span class="keyword">return</span> node_a</span><br><span class="line">            node_a = node_a.next</span><br><span class="line">            node_b = node_b.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(2(m+n)) = O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="利用有环链表"><a href="#利用有环链表" class="headerlink" title="利用有环链表"></a>利用有环链表</h3><p>将其中一个链表首位相接,若相交,则剩下的结构为有环链表.利用判断是否是有环链表及获取有环链表的入口点即可解决问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whether_intersect3</span><span class="params">(node1, node2)</span>:</span></span><br><span class="line">    <span class="comment"># 将 node1 转换为环</span></span><br><span class="line">    node_a = node1</span><br><span class="line">    <span class="keyword">while</span> node1.next:</span><br><span class="line">        node1 = node1.next</span><br><span class="line">    node1.next = node_a</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用上面的函数,判断 node2 是否有环</span></span><br><span class="line">    <span class="keyword">return</span> whether_has_ring(node2)</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(2(m+n)) = O(n)</li>
<li>空间复杂度: O(1) 或 O(n)</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能日志库 zap</title>
    <url>/2021/11/17/zap/</url>
    <content><![CDATA[<p><a href="https://github.com/uber-go/zap" target="_blank" rel="noopener"><code>zap</code></a> 是 uber 开源的高性能日志库,提供了快速的、结构化的、可分级的日志记录.</p>
<p>目前常见的 log 库中,大多使用 <code>json.Marshal</code> 和 <code>fmt.Fprintf</code> 来记录大量 <code>interface{}</code>,这种基于反射的序列化和字符串格式化会占用大量 CPU 资源并进行许多小的内存的分配,这会使得日志记录变慢,从而影响整体应用程序.</p>
<p>而 <code>zap</code> 采用了上述不同的方法.它包含一个无反射、零分配的 JSON 编码器,并提供了基础 <code>Logger</code> 力求尽可能避免序列化开销和内存分配.</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p><code>zap</code> 库的使用与其他的日志库非常相似.先创建一个 <code>logger</code>,然后调用各个级别的方法记录日志(Debug/Info/Error/Warn).我们可以通过<a href="https://pkg.go.dev/go.uber.org/zap" target="_blank" rel="noopener">文档</a> 中提供的一些示例来快速了解该库的使用方式.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"time"</span></span><br><span class="line"> <span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> sugar := zap.NewExample().Sugar()</span><br><span class="line"> <span class="keyword">defer</span> sugar.Sync()</span><br><span class="line"> sugar.Infow(<span class="string">"failed to fetch URL"</span>,</span><br><span class="line">  <span class="string">"url"</span>, <span class="string">"http://example.com"</span>,</span><br><span class="line">  <span class="string">"attempt"</span>, <span class="number">3</span>,</span><br><span class="line">  <span class="string">"backoff"</span>, time.Second,</span><br><span class="line"> )</span><br><span class="line"> sugar.Infof(<span class="string">"failed to fetch URL: %s"</span>, <span class="string">"http://example.com"</span>)</span><br><span class="line"></span><br><span class="line"> logger := zap.NewExample()</span><br><span class="line"> <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"> logger.Info(<span class="string">"failed to fetch URL"</span>,</span><br><span class="line">   <span class="comment">// 需要使用 zap 内置的 Field 对象来强制定义字段的类型</span></span><br><span class="line">  zap.String(<span class="string">"url"</span>, <span class="string">"http://example.com"</span>),</span><br><span class="line">  zap.Int(<span class="string">"attempt"</span>, <span class="number">3</span>),</span><br><span class="line">  zap.Duration(<span class="string">"backoff"</span>, time.Second),</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上示例中,使用 <code>zap</code> 包提供的 <code>NewExample()</code> 方法创建 <code>Logger</code> 对象,并打印日志.相比于 <code>sugar</code>,<code>logger</code> 对象更快,分配的资源也少的多,但是它只支持强类型,结构化的日志记录.</p>
<p>另外,<code>zap</code> 提供了几个快速创建 <code>logger</code> 的方法: <code>zap.NewExample()</code>,<code>zap.NewDevelopment()</code>,<code>zap.NewProduction()</code> 以及高度定制化的 <code>zap.New()</code>.在使用前 3 个 logger 时, zap 会使用一些预定义的配置.详情可通过 <a href="https://github.com/uber-go/zap/blob/v1.19.1/logger.go#L98-L125" target="_blank" rel="noopener">Github</a> 查看.</p>
<h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><p>在通过以上方法创建 <code>logger</code> 对象时,zap 支持传入一些 <code>Option</code> 对象来调整 logger 对象的内部属性,从而定制 Logger 对象的行为.<code>zap</code> 库提供了丰富的构建 <code>Option</code> 对象的方法供我们选择.常用的如</p>
<h4 id="打印日志的行号"><a href="#打印日志的行号" class="headerlink" title="打印日志的行号"></a>打印日志的行号</h4><p>可以通过添加 <code>zap.AddCaller()</code> 返回的 <code>Options</code> 对象对日志添加行号.该 <code>Options</code> 不适用于 <code>zap.NewExample()</code> 返回的 <code>logger</code> 对象(因为该对象的 <code>Config</code> 没有 <code>CallerKey</code> 属性)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ := zap.NewProduction(zap.AddCaller())</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">  logger.Info(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;"level":"info","ts":1637302341.770313,"caller":"zap/main.go:11","msg":"hello world"&#125;</span></span><br></pre></td></tr></table></figure>

<p>再看下面,我们对日志进行了一些封装.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logger *zap.Logger, msg <span class="keyword">string</span>)</span> <span class="params">()</span></span> &#123;</span><br><span class="line"> logger.Info(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> logger, _ := zap.NewProduction(zap.AddCaller())</span><br><span class="line"> <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"> log(logger, <span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;"level":"info","ts":1637302670.685756,"caller":"zap/main.go:8","msg":"hello world"&#125;</span></span><br></pre></td></tr></table></figure>

<p>此时再看输出的行号就不准确了,因此需要跳过一些调用.<code>zap</code> 包提供了 <code>AddCallerSkip(skip int)</code> 函数跳过一些调用.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logger *zap.Logger, msg <span class="keyword">string</span>)</span> <span class="params">()</span></span> &#123;</span><br><span class="line"> logger.Info(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> logger, _ := zap.NewProduction(zap.AddCaller(),zap.AddCallerSkip(<span class="number">1</span>))</span><br><span class="line"> <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"> log(logger, <span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;"level":"info","ts":1637302912.6387358,"caller":"zap/main.go:14","msg":"hello world"&#125;</span></span><br></pre></td></tr></table></figure>

<p>此时再看输出日志的调用就准确了.</p>
<h4 id="添加调用栈"><a href="#添加调用栈" class="headerlink" title="添加调用栈"></a>添加调用栈</h4><p>有时在出现错误时,我们希望输出代码的调用栈信息.<code>zap</code> 包提供了 <code>AddStackTrace(lvl zapcore.LevelEnabler)</code> 实现这个功能.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logger *zap.Logger, msg <span class="keyword">string</span>)</span> <span class="params">()</span></span> &#123;</span><br><span class="line"> logger.Error(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> logger, _ := zap.NewProduction(zap.AddCallerSkip(<span class="number">1</span>), zap.AddStacktrace(zapcore.ErrorLevel))</span><br><span class="line"> <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"> log(logger, <span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出了调用栈信息</span></span><br><span class="line"><span class="comment">// &#123;"level":"error","ts":1637303198.4552681,"caller":"zap/main.go:15","msg":"hello world","stacktrace":"main.main\n\t//code/go/src/go-notes/zap/main.go:15\nruntime.main\n\t/usr/local/go/src/runtime/proc.go:255"&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Filed"><a href="#Filed" class="headerlink" title="Filed"></a>Filed</h3><p><code>logger</code> 对象在记录日志时,需要将 zap 提供的格式化的 <code>Filed</code> 对象来强制定义字段的类型,避免了 <code>interface{}</code> 反射所造成的性能损失.<code>zap</code> 包中提供了很多构造各种类型 <code>Filed</code> 对象的方法.如 <code>Bool</code>,<code>String</code> 等.zap 还支持形如 <code>Boolp</code>,<code>Bools</code> 的方法,用于传入该对象的指针与切片对象.如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bool</span><span class="params">(key <span class="keyword">string</span>, val <span class="keyword">bool</span>)</span> <span class="title">Field</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Boolp</span><span class="params">(key <span class="keyword">string</span>, val *<span class="keyword">bool</span>)</span> <span class="title">Field</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bools</span><span class="params">(key <span class="keyword">string</span>, bs []<span class="keyword">bool</span>)</span> <span class="title">Field</span></span></span><br></pre></td></tr></table></figure>

<h2 id="定制-Logger"><a href="#定制-Logger" class="headerlink" title="定制 Logger"></a>定制 Logger</h2><p>我们可以通过调用 <code>NexExample()/NewDevelopment()/NewProduction()</code> 方法创建 <code>zap</code> 内置的默认的 <code>Logger</code> 对象.我们也可以通过自定义 <code>Config</code> 对象,并通过其 <code>Build</code> 方法构建自定义的 <code>Logger</code> 对象.其中,<code>Config</code> 结构体定义如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="comment">// 日志级别</span></span><br><span class="line"> Level AtomicLevel <span class="string">`json:"level" yaml:"level"`</span></span><br><span class="line"> <span class="comment">// 是否是开发环境</span></span><br><span class="line"> Development <span class="keyword">bool</span> <span class="string">`json:"development" yaml:"development"`</span></span><br><span class="line"> <span class="comment">// 是否禁用 caller 记录</span></span><br><span class="line"> DisableCaller <span class="keyword">bool</span> <span class="string">`json:"disableCaller" yaml:"disableCaller"`</span></span><br><span class="line"> <span class="comment">// 是否禁用调用栈</span></span><br><span class="line"> DisableStacktrace <span class="keyword">bool</span> <span class="string">`json:"disableStacktrace" yaml:"disableStacktrace"`</span></span><br><span class="line"> <span class="comment">// 日志输出格式</span></span><br><span class="line"> Encoding <span class="keyword">string</span> <span class="string">`json:"encoding" yaml:"encoding"`</span></span><br><span class="line"> <span class="comment">// 编码配置</span></span><br><span class="line"> EncoderConfig zapcore.EncoderConfig <span class="string">`json:"encoderConfig" yaml:"encoderConfig"`</span></span><br><span class="line"> <span class="comment">// 日志输出位置,可以定义多个,多用于文件路径和 stdout</span></span><br><span class="line"> OutputPaths []<span class="keyword">string</span> <span class="string">`json:"outputPaths" yaml:"outputPaths"`</span></span><br><span class="line"> <span class="comment">// 错误输出位置</span></span><br><span class="line"> ErrorOutputPaths []<span class="keyword">string</span> <span class="string">`json:"errorOutputPaths" yaml:"errorOutputPaths"`</span></span><br><span class="line"> <span class="comment">// 初始化字段,每条日志中都会包含这个字段</span></span><br><span class="line"> InitialFields <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:"initialFields" yaml:"initialFields"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过定义 <code>Config</code> 后进行构建 <code>Logger</code> 对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> rawJSON := []<span class="keyword">byte</span>(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "level":"debug",</span></span><br><span class="line"><span class="string">    "encoding":"json",</span></span><br><span class="line"><span class="string">    "outputPaths": ["stdout", "server.log"],</span></span><br><span class="line"><span class="string">    "errorOutputPaths": ["stderr"],</span></span><br><span class="line"><span class="string">    "initialFields":&#123;"name":"dj"&#125;,</span></span><br><span class="line"><span class="string">    "encoderConfig": &#123;</span></span><br><span class="line"><span class="string">      "messageKey": "message",</span></span><br><span class="line"><span class="string">      "levelKey": "level",</span></span><br><span class="line"><span class="string">      "levelEncoder": "lowercase"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;`</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> cfg zap.Config</span><br><span class="line"> <span class="keyword">if</span> err := json.Unmarshal(rawJSON, &amp;cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line"> &#125;</span><br><span class="line"> logger, err := cfg.Build()</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line"> logger.Info(<span class="string">"server start work successfully!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到标准输出 std 和 server.log 的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;message&quot;:&quot;server start work successfully!&quot;,&quot;name&quot;:&quot;dj&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭配标准日志库"><a href="#搭配标准日志库" class="headerlink" title="搭配标准日志库"></a>搭配标准日志库</h2><p>如果项目一开始使用的是标准日志库 <code>log</code>,后面想转为 <code>zap</code>.我们可以调用 <code>zap.NewStdLog(l *Logger) *log.Logger</code>返回一个标准的 <code>log.Logger</code>,内部实际上写入的还是我们之前创建的 <code>zap.Logger</code>.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> logger := zap.NewExample()</span><br><span class="line"> <span class="keyword">defer</span> logger.Sync()</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// NewStdLog 返回包装后的 *log.Logger 对象</span></span><br><span class="line"> std := zap.NewStdLog(logger)</span><br><span class="line"> std.Print(<span class="string">"standard logger wrapper"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用函数及方法"><a href="#常用函数及方法" class="headerlink" title="常用函数及方法"></a>常用函数及方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回标准库 *log.Logger 对象,实现无缝替换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStdLog</span><span class="params">(l *Logger)</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 info 级别的 AtomicLevel 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAtomicLevel</span><span class="params">()</span> <span class="title">AtomicLevel</span></span></span><br><span class="line"><span class="comment">// 可以使用上述 AtomicLevel 对象修改级别.包含 DebugLevel,InfoLevel,WarnLevel,ErrorLevel,DPanicLevel,PanicLevel,FatalLevel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lvl AtomicLevel)</span> <span class="title">SetLevel</span><span class="params">(l zapcore.Level)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Logger 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(core zapcore.Core, options ...Option)</span> *<span class="title">Logger</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 开发,示例,生产环境的 Logger 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDevelopment</span><span class="params">(options ...Option)</span> <span class="params">(*Logger, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewExample</span><span class="params">(options ...Option)</span> *<span class="title">Logger</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProduction</span><span class="params">(options ...Option)</span> <span class="params">(*Logger, error)</span></span></span><br><span class="line"><span class="comment">// logger 对象完成工作后,一般需要使用 defer logger.Sync() 同步</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span> <span class="title">Sync</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加字段或添加一些 options</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span> <span class="title">With</span><span class="params">(fields ...Field)</span> *<span class="title">Logger</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span> <span class="title">WithOptions</span><span class="params">(opts ...Option)</span> *<span class="title">Logger</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由强类型的 Logger 对象转化为弱类型的 SugaredLogger 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span> <span class="title">Sugar</span><span class="params">()</span> *<span class="title">SugaredLogger</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同级别的记录日志的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span> <span class="title">Info</span><span class="params">(msg <span class="keyword">string</span>, fields ...Field)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 option 对象</span></span><br><span class="line"><span class="comment">// 添加调用行,调用栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCaller</span><span class="params">()</span> <span class="title">Option</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCaller</span><span class="params">(enabled <span class="keyword">bool</span>)</span> <span class="title">Option</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCallerSkip</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="title">Option</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddStacktrace</span><span class="params">(lvl zapcore.LevelEnabler)</span> <span class="title">Option</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Field 对象</span></span><br><span class="line"><span class="comment">// 3种构建指定类型的 Field 字段,可以传入到日志记录中,实现快速记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bool</span><span class="params">(key <span class="keyword">string</span>, val <span class="keyword">bool</span>)</span> <span class="title">Field</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Boolp</span><span class="params">(key <span class="keyword">string</span>, val *<span class="keyword">bool</span>)</span> <span class="title">Field</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bools</span><span class="params">(key <span class="keyword">string</span>, bs []<span class="keyword">bool</span>)</span> <span class="title">Field</span></span></span><br></pre></td></tr></table></figure>

<h2 id="zap-高性能的秘诀"><a href="#zap-高性能的秘诀" class="headerlink" title="zap 高性能的秘诀"></a>zap 高性能的秘诀</h2><ul>
<li>避免 GC: 对象复用</li>
<li>内建的 Encoder: 避免反射</li>
<li>使用写时复制机制,避免竞态</li>
</ul>
<p>具体可参见 <a href="https://mp.weixin.qq.com/s/i0bMh_gLLrdnhAEWlF-xDw" target="_blank" rel="noopener">深度 | 从Go高性能日志库zap看如何实现高性能Go组件</a></p>
<hr>
<p>参考:</p>
<ul>
<li><a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">uber-go/zap (github.com)</a></li>
<li><a href="https://pkg.go.dev/go.uber.org/zap" target="_blank" rel="noopener">zap - pkg.go.dev</a></li>
<li><a href="https://segmentfault.com/a/1190000022461706" target="_blank" rel="noopener">Go 每日一库之 zap</a></li>
<li><a href="https://mp.weixin.qq.com/s/i0bMh_gLLrdnhAEWlF-xDw" target="_blank" rel="noopener">深度 | 从Go高性能日志库zap看如何实现高性能Go组件</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>3rd</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper 基础</title>
    <url>/2020/03/26/zookeeper-basis/</url>
    <content><![CDATA[<h2 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp <span class="variable">$ZK_HOME</span>/conf/&#123;zoo_sample.cfg,zoo.cfg&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># zookeeper配置文件简单解释</span></span><br><span class="line">tickTime=2000 <span class="comment"># 心跳基本时间单位,毫秒级</span></span><br><span class="line">initLimit=10 <span class="comment"># 初始化的超时时间,initLimit*tickTime</span></span><br><span class="line">syncLimit=5 <span class="comment"># Leader 与 Follower的超时时间,syncLimit*tickTime</span></span><br><span class="line">clientPort=2181 <span class="comment"># 端口</span></span><br><span class="line">dataDir=<span class="variable">$&#123;ZK_HOME&#125;</span>/data <span class="comment"># 数据目录</span></span><br><span class="line">ataLogDir=<span class="variable">$&#123;ZK_HOME&#125;</span>/logs <span class="comment"># 日志目录</span></span><br><span class="line"><span class="comment"># 集群配置</span></span><br><span class="line">server.1=zk_server_1:2888:3888</span><br><span class="line">server.2=zk_server_2:2888:3888</span><br><span class="line">server.3=zk_server_3:2888:3888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要注意的是,在每一个zookeeper server节点的dataDir目录下有一个 myid 的文件,对应 server.1</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; <span class="variable">$&#123;dataDir&#125;</span>/myid</span><br></pre></td></tr></table></figure>

<h2 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">connect host:port   <span class="comment"># 连接到指定服务</span></span><br><span class="line">get path [watch]    <span class="comment"># 获取指定节点信息(包括内容和状态), watch 表示是否对该参数进行监听</span></span><br><span class="line">ls path [watch]     <span class="comment"># 列出节点下的子节点</span></span><br><span class="line">ls2 path [watch]    <span class="comment"># 列出节点下的子节点,及该节点的信</span></span><br><span class="line"><span class="built_in">set</span> path data [version] <span class="comment"># 设置节点数据</span></span><br><span class="line">rmr path            <span class="comment"># 删除节点及其子节点数据</span></span><br><span class="line">create [-s] [-e] path data acl  <span class="comment"># 创建节点. -s 表示顺序节点,-e 表示临时节点</span></span><br><span class="line"><span class="built_in">stat</span> path [watch]   <span class="comment"># 获取节点的元数据信息</span></span><br><span class="line">listquota path      <span class="comment"># 显示节点配额</span></span><br><span class="line">setAcl path acl     <span class="comment"># 设置 ACL 访问控制</span></span><br><span class="line">getAcl path         <span class="comment"># 获取 ACL 访问控制</span></span><br><span class="line">delete path [version] <span class="comment"># 删除节点</span></span><br></pre></td></tr></table></figure>

<h2 id="znode-节点类型"><a href="#znode-节点类型" class="headerlink" title="znode 节点类型"></a>znode 节点类型</h2><p>每个 znode 都有不同的生命周期,而生命周期长短取决于 znode 的节点类型.Zoookeeper 提供了如下4种节点类型:</p>
<table>
<thead>
<tr>
<th align="left">节点类型</th>
<th align="left">特性</th>
<th align="left">创建方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">持久节点</td>
<td align="left">会话关闭后,该节点仍然存在,可以创建子节点</td>
<td align="left"><code>create &lt;path&gt; &lt;data&gt;</code></td>
</tr>
<tr>
<td align="left">持久顺序节点</td>
<td align="left">在持久节点特性的基础上.节点名后缀为自增数字</td>
<td align="left"><code>create -s &lt;path&gt; &lt;data&gt;</code></td>
</tr>
<tr>
<td align="left">临时节点</td>
<td align="left">会话关闭后,该节点不存在,不可以创建子节点</td>
<td align="left"><code>create -e &lt;path&gt; &lt;data&gt;</code></td>
</tr>
<tr>
<td align="left">临时顺序节点</td>
<td align="left">在临时节点特性的基础上,节点名后缀为自增数字</td>
<td align="left"><code>create -s -e &lt;path&gt; &lt;data&gt;</code></td>
</tr>
</tbody></table>
<h2 id="ACL-访问控制列表"><a href="#ACL-访问控制列表" class="headerlink" title="ACL 访问控制列表"></a>ACL 访问控制列表</h2><p>ZooKeeper 提供了一套完善的 ACL 权限控制机制保障数据安全性.其实 ACL 规则由<code>Scheme:id:permission</code>格式组成,其中,对于身份认证,提供了以下几种方式:</p>
<table>
<thead>
<tr>
<th align="left">身份认证方式</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">world</td>
<td align="left">默认方式,所有用户都可无条件访问,组合形式为: <code>world:anyone:[permissions]</code></td>
</tr>
<tr>
<td align="left">digest</td>
<td align="left">用户名:密码认证方式,最常用.组合形式为: <code>digest:username:BASE64(SHA1(password)):[permissions]</code></td>
</tr>
<tr>
<td align="left">ip</td>
<td align="left">对指定ip进行限制,组合形式为: <code>ip:127.0.0.1:[permissions]</code></td>
</tr>
<tr>
<td align="left">auth</td>
<td align="left">认证登录形式,需要用户获取权限后才可访问,组合形式为: <code>auth:user:password:[permissions]</code></td>
</tr>
</tbody></table>
<p>对于 znode 的 <code>permissions</code> 权限,提供了以下 5 种操作权限:</p>
<table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">简写</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CREATE</td>
<td align="left">C</td>
<td align="left">允许授权对象在当前节点下创建子节点</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">D</td>
<td align="left">允许授权对象在当前节点下删除子节点</td>
</tr>
<tr>
<td align="left">WRITE</td>
<td align="left">W</td>
<td align="left">允许授权对象在当前节点进行更新操作</td>
</tr>
<tr>
<td align="left">READ</td>
<td align="left">R</td>
<td align="left">允许授权对象在当前节点获取节点内容或获取子节点列表</td>
</tr>
<tr>
<td align="left">ADMIN</td>
<td align="left">A</td>
<td align="left">允许授权对象对当前节点进行 ACL 相关的设置操作</td>
</tr>
</tbody></table>
<h2 id="zookeeper-四字命令"><a href="#zookeeper-四字命令" class="headerlink" title="zookeeper 四字命令"></a>zookeeper 四字命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> conf | nc 192.168.0.68 2181 <span class="comment"># 查看状态信息</span></span><br><span class="line"><span class="built_in">echo</span> cons | nc 192.168.0.68 2181 <span class="comment"># 查看客户端连接信息</span></span><br><span class="line"><span class="built_in">echo</span> envi | nc 192.168.0.68 2181 <span class="comment"># 查看环境变量信息</span></span><br><span class="line"><span class="built_in">echo</span> mntr | nc 192.168.0.68 2181 <span class="comment"># 查看 zk 的健康信息</span></span><br><span class="line"><span class="built_in">echo</span> ruok | nc 192.168.0.68 2181 <span class="comment"># 查看 zk 是否启动</span></span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">stat</span> | nc 192.168.0.68 2181 <span class="comment"># 查看状态信息</span></span><br><span class="line"><span class="built_in">echo</span> wchs | nc 192.168.0.68 2181 <span class="comment"># 查看 watch 信息</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
</search>
