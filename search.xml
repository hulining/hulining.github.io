<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go 学习笔记之类型</title>
    <url>/2020/04/30/go-study-notes-basis/</url>
    <content><![CDATA[<h1 id="Go-中支持的数据类型有哪些"><a href="#Go-中支持的数据类型有哪些" class="headerlink" title="Go 中支持的数据类型有哪些?"></a>Go 中支持的数据类型有哪些?</h1><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">长度</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">1</td>
<td align="center">false</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">uint8 (alias for uint8)</td>
</tr>
<tr>
<td align="center">int, uint</td>
<td align="center">4,8</td>
<td align="center">0</td>
<td align="center">默认整数类型,根据目标平台 32 位或 64 位置</td>
</tr>
<tr>
<td align="center">int8, uint8</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">-127 ~ 128, 0 ~ 255</td>
</tr>
<tr>
<td align="center">int16, uint16</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">-32768 ~ 32767, 0 ~ 65535</td>
</tr>
<tr>
<td align="center">int32, uint32</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">-2^31 ~ 2^31 -1, 0~2^32</td>
</tr>
<tr>
<td align="center">int64, uint64</td>
<td align="center">8</td>
<td align="center">0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float32</td>
<td align="center">4</td>
<td align="center">0.0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float64</td>
<td align="center">8</td>
<td align="center">0.0</td>
<td align="center">默认浮点类型数据</td>
</tr>
<tr>
<td align="center">complex64</td>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">complex128</td>
<td align="center">16</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rune</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">int32 (alias for uint8)</td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">4, 8</td>
<td align="center">0</td>
<td align="center">足够存储指针的 uint</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center"></td>
<td align="center">“”</td>
<td align="center">字符串, 默认为空字符串, 而非 nil</td>
</tr>
<tr>
<td align="center">array</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">struct</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">结构体</td>
</tr>
<tr>
<td align="center">function</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">函数</td>
</tr>
<tr>
<td align="center">interface</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">接口</td>
</tr>
<tr>
<td align="center">map</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">字典, 引用类型</td>
</tr>
<tr>
<td align="center">slice</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">切片, 引用类型</td>
</tr>
<tr>
<td align="center">channel</td>
<td align="center"></td>
<td align="center">nil</td>
<td align="center">通道, 引用类型</td>
</tr>
</tbody></table>
<h1 id="常量和变量有什么不同"><a href="#常量和变量有什么不同" class="headerlink" title="常量和变量有什么不同"></a>常量和变量有什么不同</h1><ul>
<li>常量在定义的时候必须初始化</li>
<li>常量在相同作用域下是唯一且不可修改的. 一经声明并赋值后, 常量变为”只读”</li>
<li>常量智能修饰 <code>bool</code>, 数值类型(int, float 系列), <code>string</code> 类型</li>
<li>常量不会被分配存储空间, 无法像变量那样通过内存寻址来取值, 因此无法获取其地址, 见如下代码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name <span class="keyword">string</span> = <span class="string">"name"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    age := <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p"</span>, &amp;name)  <span class="comment">// cannot take the address of name </span></span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, &amp;age)  <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="iota-是什么-如何使用"><a href="#iota-是什么-如何使用" class="headerlink" title="iota 是什么? 如何使用?"></a><code>iota</code> 是什么? 如何使用?</h1><p><code>iota</code> 是 Go 语言的常量计数器, 只能在 <code>const</code> 常量声明中使用, 多用于 <code>const</code> 常量声明块(<code>const ()</code> 定义多个常量的格式). 它有如下特点:</p>
<ul>
<li><code>iota</code> 在 <code>const</code> 常量声明第一次出现时将被重置为 0</li>
<li><code>const</code> 常量声明块中每新增一<strong>行</strong>常量声明将使 <code>iota</code> 计数一次(值增加 1).</li>
</ul>
<p>使用 <code>iota</code> 能简化常量定义, 在定义枚举时很有用. 举例如下:</p>
<ul>
<li>每次 <code>const</code> 出现时, <code>iota</code> 初始化为0</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">iota</span> <span class="comment">// a = 0 </span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	b = <span class="literal">iota</span> <span class="comment">// b = 0 </span></span><br><span class="line">	c        <span class="comment">// c = 1   相当于 c = iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>每<strong>行</strong>变量声明计数器加 1</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">// iota = 0, a = 0</span></span><br><span class="line">    b         <span class="comment">// iota = 1, b = iota, 即 b = 1</span></span><br><span class="line">    c = <span class="number">100</span>   <span class="comment">// iota = 2, c = 100</span></span><br><span class="line">    d = <span class="literal">iota</span>  <span class="comment">// iota = 3, d = 3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	A, B = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// iota = 0, A = 1, B = 2</span></span><br><span class="line">	C, D                      <span class="comment">// iota = 1, C, D = iota + 1, iota + 2, C, D = 2, 3</span></span><br><span class="line">	E, F                      <span class="comment">// iota = 2, E, F = iota + 1, iota + 2, E, F = 3, 4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义枚举类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> color <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    red color = <span class="literal">iota</span></span><br><span class="line">    yellow</span><br><span class="line">    blue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可通过如下方式定义数量级</span></span><br><span class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_           = <span class="literal">iota</span>             <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">	KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 1 &lt;&lt; (10*1)</span></span><br><span class="line">	MB                             <span class="comment">// 1 &lt;&lt; (10*2)</span></span><br><span class="line">	GB                             <span class="comment">// 1 &lt;&lt; (10*3)</span></span><br><span class="line">	TB                             <span class="comment">// 1 &lt;&lt; (10*4)</span></span><br><span class="line">	PB                             <span class="comment">// 1 &lt;&lt; (10*5)</span></span><br><span class="line">	EB                             <span class="comment">// 1 &lt;&lt; (10*6)</span></span><br><span class="line">	ZB                             <span class="comment">// 1 &lt;&lt; (10*7)</span></span><br><span class="line">	YB                             <span class="comment">// 1 &lt;&lt; (10*8)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Sunday = <span class="literal">iota</span></span><br><span class="line">	Monday</span><br><span class="line">	Tuesday</span><br><span class="line">	Wednesday</span><br><span class="line">	Thursday</span><br><span class="line">	Friday</span><br><span class="line">	Saturday</span><br><span class="line">	numberOfDays <span class="comment">// 这个常量没有导出</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>引用类型包括 <code>slice</code>, <code>map</code>, <code>channel</code> 这 3 种数据类型</p>
<p>相比数字, 数组等类型, 引用类型拥有更复杂的数据结构. 除了分配内存外, 还需要初始化一系列属性, 如指针, 长度, 甚至包括哈希分布, 数据队列等.</p>
<p>引用类型使用 <code>make()</code> 函数创建, 以确保完成内存分配和相关属性初始化.</p>
<p>引用类型之所以可以引用, 是因为我们创建引用类型的变量其实是一个包含指向底层数据结构指针的变量. 当我们在函数中传递引用类型时，其实传递的是这个变量的副本, 它所指向的底层结构并没有被复制传递, 函数中对引用类型所做的所有操作可以理解为操作该对象的内存地址, 都会作用到其底层数据结构上, 这也是引用类型传递高效的原因</p>
<p>本质上，我们可以理解函数传递参数都是值拷贝,只不过引用类型传递的是一个指向底层数据的指针, 所以我们在函数中操作的时候, 实际操作的是共享的底层数据值, 进而影响到所有引用到这个共享底层数据的变量</p>
<p><img src="/2020/04/30/go-study-notes-basis/difference_between_valueType_and_referenceType.jpg" alt="值类型与引用类型的区别"></p>
<p>同理, 在进行拷贝操作时, 值类型和引用类型会将变量的值进行拷贝, 值类型中变量的值是真实的数据, 因此可以理解为深拷贝. 引用类型中变量的值是真实存储数据的内存地址, 拷贝后变量的值也是该内存地址, 二者仍然共享同一底层数据, 因此可以理解为浅拷贝.</p>
<h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><p>使用 <code>type</code> 关键字自定义类型, 包括现有基础类型创建, 结构体, 函数类型等.</p>
<p>即便自定义类型使用了基础类型, 如 <code>type integer int</code>, 也只表明它们有相同的底层数据结构, 两者之间不存在任何关系, 属于完全不同的两种数据类型.<br>除操作符外, 自定义类型不会继承基础类型的其它信息(包括方法). 不能视作别名, 不能隐式转换, 不能直接用于比较表达式.</p>
<h1 id="未命名类型-匿名类型"><a href="#未命名类型-匿名类型" class="headerlink" title="未命名类型(匿名类型)"></a>未命名类型(匿名类型)</h1><p>与有明确标识符 <code>bool</code>, <code>int</code>, <code>string</code> 等类型相比, <code>array</code>, <code>slice</code>, <code>map</code>, <code>channel</code> 等类型与具体元素类型或长度等属性有关, 故称作未命名类型</p>
<p>具有相同声明的未命名类型被视为同一类型, 如:</p>
<ul>
<li>具有相同基类型的指针</li>
<li>具有相同元素类型和长度的数组</li>
<li>具有相同元素类型的切片</li>
<li>具有相同键值类型的字典</li>
<li>具有相同数据类型及操作方向的通道</li>
<li>具有相同字段序列(字段名,字段类型,标签,字段顺序)的匿名结构体</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">        y <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">        y <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span></span><br><span class="line">    fmt.Println(a == b)  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之常用数据类型</title>
    <url>/2020/04/30/go-study-notes-data-type/</url>
    <content><![CDATA[<h1 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 <code>string</code></h1><p>字符串 <code>string</code> 是 Go 中的基本类型, 它是一个不可变的 UTF-8 字符(byte)序列.</p>
<p>特点和注意事项如下:</p>
<ul>
<li>字符串默认值不是 <code>nil</code>, 而是 <code>&quot;&quot;</code></li>
<li>允许以索引方式访问字节数组, 但不能获取元素地址或对其中元素修改</li>
<li>可以使用反引号(`)定义不做任何转义处理的原始字符串, 支持跨行</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">    fmt.Println(str) <span class="comment">// ""</span></span><br><span class="line">    str = <span class="string">"string"</span></span><br><span class="line">    fmt.Print(str[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment">// tr</span></span><br><span class="line">    <span class="comment">// fmt.Printf("%p", &amp;str[1]) // 报错 cannot take the address of 'str[1]', 不能获取 str[1] 的指针地址</span></span><br><span class="line">    <span class="comment">// str[1] = 'x'              // 报错, cannot assign to str[1], 字符串是不可变的, 不能对其中元素进行修改</span></span><br><span class="line">    multiLine := <span class="string">`line \n</span></span><br><span class="line"><span class="string">    	    line2`</span></span><br><span class="line">    fmt.Println(multiLine)    <span class="comment">// 会按照  multiLine 的原始字符输出,不做任何转义操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 for 循环遍历字符串时, 分 <code>byte</code> 和 <code>rune</code> 两种方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    str := <span class="string">"Hello 北京!"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">    	fmt.Printf(<span class="string">"%v: %v\n"</span>, i, str[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%v: %v\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到 for-range (rune)方式输出可以看到中文字符, 而 for-i (byte)方式则不能</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要修改字符串, 需要将其转换为 <code>[]rune</code> 或 <code>[]byte</code> 数组, 待修改完成后再使用 <code>string()</code> 强制转换回来.</li>
</ul>
<h1 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 <code>array</code></h1><p>数组的一般形式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name [<span class="built_in">len</span>]Type = [<span class="built_in">len</span>]Type&#123;element1, element2, element3...&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>数组用于保存相同类型元素的集合, 数组是有长度的. 只有元素类型与长度都相同的数组才属于同一种类型.</li>
<li>数组支持使用索引访问元素内容</li>
<li>对于定义时不确定长度的数组, 可用 <code>[...]Type</code> 进行定义, 但一旦初始化赋值, 其长度也会随之确定. 定义多维数组时, 仅允许第一维数组长度使用 <code>...</code></li>
<li>内置函数 <code>len()</code>, <code>cap()</code> 均返回数组的第一维长度</li>
<li>指针数组是指元素为指针的数组, 如 <code>arr := [3]*int{&amp;x, &amp;y}</code> , 数组指针是内存中数组的地址, 如<code>&amp;arr</code>. 数组指针可来操作元素</li>
<li>数组是值类型, 赋值和传参都会复制整个数组数据, 可以使用指针或切片,避免数据复制</li>
</ul>
<p>代码示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(x [2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"x: %p, %v\n"</span>, &amp;x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(p *[2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"p: %p, %v\n"</span>, p, *p)</span><br><span class="line">    p[<span class="number">1</span>] += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	b := a</span><br><span class="line">	fmt.Printf(<span class="string">"a: %p, %v\n"</span>, &amp;a, a)</span><br><span class="line">	fmt.Printf(<span class="string">"b: %p, %v\n"</span>, &amp;b, b)</span><br><span class="line">	test1(a)</span><br><span class="line">    test2(&amp;a)</span><br><span class="line">    fmt.Printf(<span class="string">"a: %p, %v\n"</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a: 0xc00000a0d0, [1 2]</span></span><br><span class="line"><span class="comment">// b: 0xc00000a0e0, [1 2]</span></span><br><span class="line"><span class="comment">// x: 0xc00000a130, [1 2]</span></span><br><span class="line"><span class="comment">// p: 0xc00000a0d0, [1 2]</span></span><br><span class="line"><span class="comment">// a: 0xc00000a0d0, [1 102]</span></span><br></pre></td></tr></table></figure>

<h1 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 <code>slice</code></h1><p>切片的一般形式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sliceName []Type = []Type&#123;element1, element2, element3...&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>可使用内置函数 <code>make([]Type, len, cap)</code> 初始化一个长度为 <code>len</code> 元素值为默认值的切片, 并完成长度为 <code>cap</code> 用于存储底层数据的数组的内存分配. 其中 <code>cap</code> 为容量, 可以省略(默认为 <code>len</code>), 否则必须大于等于 <code>len</code>. 切片的长度及容量均可超过其初始定义时的长度和容量, 此时会为底层数组重新分配内存地址空间</li>
<li>切片是<strong>引用类型</strong>, 所有在函数内的对其元素的操作都会作用到其底层数据结构上</li>
<li>可基于数组或数组指针创建切片, 以开始索引或结束索引确定切片所引用的数据字段. 不支持反向索引</li>
<li>使用形如 <code>var s []int</code> 创建的切片为 <code>nil</code> </li>
<li>切片支持使用索引号访问元素内容</li>
<li><code>append()</code> 可用于向切片尾部添加数据, 返回对象的内存地址不会发生改变, 但是如果 <code>append</code> 后的切片超过 <code>cap</code> 容量, 则会为底层数组重新分配内存空间. 新分配的 <code>cap</code> 容量为一般初始 <code>cap</code> 容量的整数倍</li>
<li><code>copy(dst, src []Type)</code> 可用于在两个切片对象间复制数据, 最终所复制的数据以较短的切片长度为准.</li>
</ul>
<p>代码示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nilSli []<span class="keyword">int</span></span><br><span class="line">	fmt.Println(nilArr == <span class="literal">nil</span>)  <span class="comment">// true</span></span><br><span class="line">	sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%p,%v,%v,%p\n"</span>, &amp;sli, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli), &amp;sli[<span class="number">0</span>])</span><br><span class="line">	arr = <span class="built_in">append</span>(arr, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;...)</span><br><span class="line">	fmt.Printf(<span class="string">"%p,%v,%v,%p\n"</span>, &amp;sli, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli), &amp;sli[<span class="number">0</span>])  </span><br><span class="line">    <span class="comment">// 可以看到 append 前后 `&amp;arr` 没有变化, 但是 `cap(arr) 变为原来的 2 倍,实际上是对底层数组重新分配了新的内存空间(原来数组的内存空间也会被重新分配)</span></span><br><span class="line">	p := &amp;sli</span><br><span class="line">	p0 := &amp;sli[<span class="number">0</span>]</span><br><span class="line">	p1 := &amp;sli[<span class="number">1</span>]</span><br><span class="line">	fmt.Printf(<span class="string">"%p,%p,%p\n"</span>, p, p0, p1)</span><br><span class="line">	(*p)[<span class="number">0</span>] += <span class="number">100</span></span><br><span class="line">	*p1 += <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">"%v\n"</span>, sli) <span class="comment">// [100 100 1 2 3 4 5 6]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 0xc0000044c0,2,5,0xc00000c300</span></span><br><span class="line"><span class="comment">// 0xc0000044c0,8,10,0xc000014190</span></span><br><span class="line"><span class="comment">// 0xc0000044c0,0xc000014190,0xc000014198</span></span><br><span class="line"><span class="comment">// [100 100 1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] += <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v,%p\n"</span>, s, &amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">32</span>&#125;  <span class="comment">// 等价于 var s = make([]int, 3, 3); s = []int&#123;1, 20, 32&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v,%p\n"</span>, s, &amp;s)</span><br><span class="line">    change(s)</span><br><span class="line">    fmt.Printf(<span class="string">"%v,%p\n"</span>, s, &amp;s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// [1 20 32],0xc0000044c0</span></span><br><span class="line"><span class="comment">// [101 20 32],0xc000004520</span></span><br><span class="line"><span class="comment">// [101 20 32],0xc0000044c0</span></span><br></pre></td></tr></table></figure>

<h1 id="字典-map"><a href="#字典-map" class="headerlink" title="字典 map"></a>字典 <code>map</code></h1><p>字典的一般形式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mapName <span class="keyword">map</span>[KeyType]ValueType = <span class="keyword">map</span>[KeyType]ValueType&#123;</span><br><span class="line">    KeyType: ValueType,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>字典是引用类型, 一般使用 <code>make(map[KeyType]ValueType, size)</code> 或初始化语句表达式创建. 内容为空的字典已经做了初始化操作, 与 <code>nil</code> 是不同的</li>
<li>函数 <code>len()</code> 返回当前键值对数量</li>
<li>Key 必须支持等值比较(<code>==</code>, <code>!=</code>), 类型可以为数字,字符串,指针,数组,结构体,接口等类型.常见的一般为字符串</li>
<li>访问键值时, 推荐使用 <code>v, ok := m[key]</code> 模式. 可以通过 <code>ok</code> 判断键是否存在. 如果存在, <code>ok</code> 会返回 <code>true</code>; 否则, 返回 <code>false</code></li>
<li>字典是一种无序键值对集合, 对字典进行 for-range 遍历, 每次遍历的次序都不相同</li>
<li>因为访问安全和哈希算法的缘故, 字典被设计为 “not addressable”, 因此不能直接修改 <code>value</code> 成员(结构体或数组). 只能返回整个 <code>value</code>, 修改后重新对字典赋值. 或直接使用指针类型</li>
</ul>
<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nilMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	fmt.Println(nilMap == <span class="literal">nil</span>)</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]user, <span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%p,%v\n"</span>, &amp;m, m)</span><br><span class="line">	m[<span class="string">"tom"</span>] = user&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;</span><br><span class="line">	m[<span class="string">"jack"</span>] = user&#123;<span class="string">"jack"</span>, <span class="number">21</span>&#125;</span><br><span class="line">	m[<span class="string">"lucy"</span>] = user&#123;<span class="string">"lucy"</span>, <span class="number">19</span>&#125;</span><br><span class="line">	v, ok := m[<span class="string">"liming"</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%p,%v\n"</span>, &amp;m, m)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, v)  <span class="comment">// 每次输出循序都不一样</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//m["lucy"].age += 1 // 报错, cannot assign to `m["lucy"].age`, 不能对字典值的成员变量直接赋值</span></span><br><span class="line">	lucy := m[<span class="string">"lucy"</span>]</span><br><span class="line">	lucy.age += <span class="number">1</span></span><br><span class="line">	m[<span class="string">"lucy"</span>] = lucy</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 0xc000006030,map[]</span></span><br><span class="line"><span class="comment">// 0xc000006030,map[jack:&#123;jack 21&#125; lucy:&#123;tom 19&#125; tom:&#123;tom 20&#125;]</span></span><br><span class="line"><span class="comment">// tom &#123;tom 20&#125;</span></span><br><span class="line"><span class="comment">// jack &#123;jack 21&#125;</span></span><br><span class="line"><span class="comment">// lucy &#123;tom 19&#125;</span></span><br><span class="line"><span class="comment">// map[jack:&#123;jack 21&#125; lucy:&#123;tom 20&#125; tom:&#123;tom 20&#125;]</span></span><br></pre></td></tr></table></figure>

<h1 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 <code>struct</code></h1><p><code>struct</code> 将多个不通类型的字段序列打包成一个复合类型, 类似于<code>类</code>的概念. 一般定义方式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> structName <span class="keyword">struct</span>&#123;</span><br><span class="line">    fieldName fieldType</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>字段名必须唯一, 支持使用 <code>_</code> 补位字段名(忽略该字段). 支持直接指定字段类型, 从而使用匿名字段, 实际上是使用与类型名相同的字段</li>
<li>可直接使用 <code>structName.fieldName</code> 访问结构体字段. 对于匿名字段, 可以使用 <code>structName.fieldType</code> 访问该匿名字段</li>
<li>由于 Go 语言底层的优化, 可使用结构体指针直接操作结构体字段 如, 如果 <code>p := &amp;structName</code>, 则 <code>*(p).fieldName</code> 等价于 <code>p.fieldName</code></li>
<li>结构体支持多个结构体嵌套, 可以理解为:<strong>内层结构体作为外层结构体一个或多个匿名或非匿名字段</strong>.</li>
<li><strong>结构体嵌套过程中, 如果内层结构体(innerStructName)与外层结构体(outerStructName)有相同的字段 <code>fieldName</code>, 则 <code>outerStructName.fieldName</code> 表示访问外层结构体. 内层结构体 <code>fieldName</code> 字段只能通过 <code>outerStructName.innerStructFieldName.fieldName</code> 访问.<br>如果外层结构体没有内层结构体字段<code>innerFieldName</code>, 则可以通过 <code>outerStructName.innerFieldName</code> 访问 <code>innerFieldName</code> 字段.其实就是就近原则</strong></li>
<li>如果多个内层结构体有相同的字段, 则必须指定内层结构体名称才能访问到该字段,否则会编译报错</li>
</ul>
<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">	_    <span class="keyword">string</span></span><br><span class="line">	_    <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">	<span class="comment">//int  // 报错, 重复定义 int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	inneruser1</span><br><span class="line">	inneruser2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> inneruser1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> inneruser2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	age   <span class="keyword">int</span></span><br><span class="line">	score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := test&#123;</span><br><span class="line">		Name: <span class="string">"test"</span>,</span><br><span class="line">		Age:  <span class="number">20</span>,</span><br><span class="line">		<span class="keyword">int</span>:  <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">	u := user&#123;</span><br><span class="line">		name:       <span class="string">"outeruser"</span>,</span><br><span class="line">		inneruser1: inneruser1&#123;<span class="string">"inneruser1"</span>, <span class="number">10</span>&#125;,</span><br><span class="line">		inneruser2: inneruser2&#123;<span class="string">"inneruser2"</span>, <span class="number">20</span>, <span class="number">89.5</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(u.name)</span><br><span class="line">	<span class="comment">// fmt.Println(u.age) // 报错, Ambiguous reference 'age', 编译器搞不清使用哪个 age</span></span><br><span class="line">	fmt.Println(u.inneruser1.age)</span><br><span class="line">	fmt.Println(u.score)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;test 20   4&#125;</span></span><br><span class="line"><span class="comment">// outeruser</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 89.5</span></span><br></pre></td></tr></table></figure>

<h2 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h2><p>字段标签并不是注释, 而是用来对字段进行描述的元数据. </p>
<ul>
<li>在运行期间, 可用反射获取标签信息, 常被用作格式校验, 数据库关系映射等.</li>
<li>由于 Go 中私有变量与可导入变量是通过首字母大小写区分的. 因此对于可导入变量, 还可以用作 json 格式化输出字段</li>
</ul>
<p>示例如下: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// `` 反引号中的内容为该字段的 tag 标签</span></span><br><span class="line">	Age  <span class="keyword">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := user&#123;</span><br><span class="line">		Name: <span class="string">"tom"</span>,</span><br><span class="line">		Age:  <span class="number">10</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	val := reflect.ValueOf(u)</span><br><span class="line">	valType := val.Type()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%v: %v\n"</span>, valType.Field(i).Tag.Get(<span class="string">"json"</span>), val.Field(i))</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    str, err := json.Marshal(u)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	fmt.Println(<span class="string">"格式转换出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(str))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// name: tom</span></span><br><span class="line"><span class="comment">// age: 10</span></span><br><span class="line"><span class="comment">// &#123;"name":"tom","age":10&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之并发</title>
    <url>/2020/04/30/go-study-notes-concurrency/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先理解一下并发(concurrency) 与并行(parallesim)</p>
<ul>
<li>并发: 在一段时间内交替做不同事情的能力, 可以理解为单线程(协程)/多线程运行在单核处理器上, 如果有其中一个任务/线程阻塞, CPU 立即切换, 执行另一个任务/线程的代码逻辑</li>
<li>并行: 在同一时刻做不同事情的能力, 可以理解为多线程运行在多核处理器上, 一个线程绑定一个 CPU, 多个 CPU 同时处理代码逻辑</li>
</ul>
<p>我们通常所说的程序是并发设计的, 允许多个任务同时执行. 但实际上,在单核处理器上, 某一时刻, 一个 CPU 只能处理一个任务. 而多个任务是以切换方式进行的, 只不过切换时间非常短, 我们无法感知. </p>
<p>而并行依赖多核处理器, 让多个任务真正在同一时刻进行. 因此多线程或多进程是并行的基本条件.</p>
<p>Go 语言中采用 <code>goroutine</code> 来处理并发任务, <code>goroutine</code> 是建立在线程之上的轻量级抽象, 它允许我们以非常低的代价在同一地址空间中并行地执行多个函数或方法. 相比于线程, 它的创建和销毁的代价要小很多. <code>goroutine</code> 所需要的内存通常只有 2KB, 线程所需要的内存默认 MB 级别</p>
<p>在 Go 中创建一个 <code>goroutine</code> 非常简单, 在函数调用前加 <code>go</code> 关键字即可创建并发任务.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>  // 创建一个并发任务</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是, <code>go</code> 关键字并非执行并发操作, 而是创建一个并发任务单元. 新建的任务被放置在系统队列中, 等待调度器安排合适的系统线程执行. 当前任务流程不会阻塞, 不会等待该任务启动或结束, 且运行时也不保证并发任务的执行次序.</p>
<p>与 <code>defer</code> 定义的延迟调用函数一样, <code>go</code> 定义的 <code>goroutine</code> 函数也会立即计算并记录当时上下文中参数对象的状态, 并复制参数对象用于真正调用时隐式传入.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	c++</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">"main: %p,%v\n"</span>, &amp;a, a)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)                <span class="comment">// 让 goroutine 在 mian 逻辑之后执行</span></span><br><span class="line">		fmt.Printf(<span class="string">"go: %p,%v,%v\n"</span>, &amp;x, x, y) <span class="comment">// 立即计算并复制参数</span></span><br><span class="line">	&#125;(a, counter())</span><br><span class="line"></span><br><span class="line">	a += <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">"main: %p,%v,%v\n"</span>, &amp;a, a, counter())</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// main: 0xc000062090,100</span></span><br><span class="line"><span class="comment">// main: 0xc000062090,200,2</span></span><br><span class="line"><span class="comment">// go: 0xc00000a038,100,1</span></span><br><span class="line"><span class="comment">// 可以看到 goroutine 中 a 的内存地址与 main 中不一样, 说明传入 goroutine 中的参数是复制后的对象</span></span><br></pre></td></tr></table></figure>

<p>以上代码只能通过 <code>time.sleep()</code> 的方式等待 <code>goroutine</code> 执行完毕, 我们不能判断 <code>goroutine</code> 中的任务何时执行结束, <code>main</code> 函数 <code>sleep</code> 的时间也就不能确定.</p>
<h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p>为了解决以上问题, 我们使用 <code>channel</code> 阻塞 <code>main</code> 函数, 然后发出退出信号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 创建 channel</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"goroutine done"</span>)</span><br><span class="line">		<span class="built_in">close</span>(exit) <span class="comment">// 关闭 channel, 发出信号</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"main..."</span>)</span><br><span class="line">	&lt;-exit <span class="comment">// 如果 channel 关闭, 解除阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">"main exit..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要等待多个任务结束, 推荐使用 <code>sync.WaitGroup</code>. 通过设定计数器, 让每个 goroutine 在退出时递减, 直到归 0 时解除阻塞.</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 每次新创建一个 goroutine, 计数器加 1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done() <span class="comment">// 每个 goroutine 执行完成后, 计数器减 1</span></span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			fmt.Printf(<span class="string">"goroutine %v done\n"</span>, id)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"main..."</span>)</span><br><span class="line">	wg.Wait() <span class="comment">// 阻塞, 直到计数器归 0</span></span><br><span class="line">	fmt.Println(<span class="string">"main exit..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WaitGroup.Add</code> 实现了原子操作, 但仍然建议在 goroutine 外累加计数器, 防止累加(Add)操作尚未执行, 阻塞(Wait)已经退出</p>
<h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a><code>channel</code></h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Go 鼓励使用 CSP(Communicating Sequential Process) channel, 以通信来代替内存共享, 实现并发安全.</p>
<blockquote>
<p>Don’t communicate by sharing memory, share memory by communicating. 不要以共享内存来进行通信, 而是通过通信来共享内存.</p>
</blockquote>
<p>作为 CSP 核心, channel 是显示的, 要求操作双方必须知道数据类型和具体通道, 并不关心另一端操作者身份和数量. 可如果另一端未准备妥当或消息未及时处理时, 会阻塞当前端.</p>
<p>channel 定义方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channelName = <span class="built_in">make</span>(<span class="keyword">chan</span> Type, <span class="built_in">cap</span>)  <span class="comment">// 初始化容量为 cap 的 channel, 用于传递 Type 类型的对象</span></span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>缓冲区大小仅是内部属性, 不属于类型组成部分. channel 本身就是指针, 可用相等操作符判断是否为同一对象或 nil</li>
<li>内置函数 cap() 和 len() 返回缓冲区大小和当前已缓冲数量. 而对于同步通道则都返回 0, 据此可判断通道是同步(0)还是异步(非0).</li>
<li>同步模式必须有成对的 goroutine 出现, 否则会一直阻塞</li>
<li>支持使用 ok-idom 或 for-range 模式处理数据. ok-idom 模式处理未关闭的 channel, for-range 模式处理已关闭的 channel, 否则会引发死锁 <code>fatal error: all goroutines are asleep - deadlock</code></li>
<li>向已关闭的 channel 发送数据, 会引发 panic.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(intChan)  <span class="comment">// 关闭 intChan</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		intChan &lt;- i  <span class="comment">// 向 intChan 发送数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPrime</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> value &lt;= <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value &gt;= <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> value%<span class="number">2</span> == <span class="number">0</span> || value%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">5</span>; i*i &lt;= value; i += <span class="number">6</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> value%i == <span class="number">0</span> || value%(i+<span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>, outChan <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> value := <span class="keyword">range</span> intChan &#123;  <span class="comment">// 通过 for-range 遍历 intChan 中的数据</span></span><br><span class="line">		<span class="keyword">if</span> isPrime(value) &#123;</span><br><span class="line">			outChan &lt;- value  <span class="comment">// 向 outChan 发送数据</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> inChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">var</span> outChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> putNum(inChannel)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> getNum(inChannel, outChannel, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(outChannel)</span><br><span class="line">	<span class="keyword">for</span> x := <span class="keyword">range</span> outChannel &#123;</span><br><span class="line">		fmt.Println(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h2><p>channel 默认是双向的, 并不区分发送和接收端. 但我们可在定义时, 指定其为单向 channel, 且不能在单向 channel 上做逆向操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// &lt;-send // 报错, invalid operation: &lt;-send (recevice from send-only type chan&lt;- int), 无效操作</span></span><br><span class="line"><span class="comment">// recv &lt;- 1</span></span><br></pre></td></tr></table></figure>

<h3 id="select-选择"><a href="#select-选择" class="headerlink" title="select 选择"></a><code>select</code> 选择</h3><p>如要同时处理多个 channel, 可选用 <code>select</code> 语句. </p>
<p><code>select</code> 语句与 <code>switch</code> 语句类似, 它要求每个 case 必须是一个通信操作, 要么发送要么接收. 它会随机执行一个可运行的 case. 如果没有 case 可运行, 则会执行 default 或一直阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	a, b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> (</span><br><span class="line">				name <span class="keyword">string</span></span><br><span class="line">				x    <span class="keyword">int</span></span><br><span class="line">				ok   <span class="keyword">bool</span></span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> x, ok = &lt;-a:</span><br><span class="line">				name = <span class="string">"a"</span></span><br><span class="line">			<span class="keyword">case</span> x, ok = &lt;-b:</span><br><span class="line">				name = <span class="string">"b"</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(name, x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(a)</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(b)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> a &lt;- i:</span><br><span class="line">			<span class="keyword">case</span> b &lt;- i * <span class="number">10</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>default 可用于 处理一些默认逻辑, 如添加新的缓存 channel 等.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	data := []<span class="keyword">chan</span> <span class="keyword">int</span>&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> data[<span class="built_in">len</span>(data)<span class="number">-1</span>] &lt;- i:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				data = <span class="built_in">append</span>(data, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>))  <span class="comment">// default 语句用于添加新的 channel 等.</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-done <span class="comment">// 阻塞, 直到 goroutine 执行结束</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">		c := data[i]</span><br><span class="line">		<span class="built_in">close</span>(c)</span><br><span class="line">		<span class="keyword">for</span> x := <span class="keyword">range</span> c &#123;</span><br><span class="line">			fmt.Println(x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>channel 本身就是一个并发安全的队列, 可用作 ID 生成器, Pool 等用途</p>
<p>如下是 Pool 的简单实现:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">type</span> pool <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newPool</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">pool</span></span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="built_in">cap</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p pool)</span> <span class="title">get</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"> 	<span class="keyword">var</span> bytes []<span class="keyword">byte</span></span><br><span class="line"> 	<span class="keyword">select</span> &#123;</span><br><span class="line"> 	<span class="keyword">case</span> bytes = &lt;-p:</span><br><span class="line"> 		fmt.Println(<span class="string">"获取成功并返回"</span>)</span><br><span class="line"> 	<span class="keyword">default</span>:</span><br><span class="line"> 		fmt.Println(<span class="string">"获取失败, 返回默认"</span>)</span><br><span class="line"> 		bytes = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> bytes</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p pool)</span> <span class="title">put</span><span class="params">(bytes []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"> 	<span class="keyword">select</span> &#123;</span><br><span class="line"> 	<span class="keyword">case</span> p &lt;- bytes:</span><br><span class="line"> 		fmt.Println(<span class="string">"放回成功"</span>)</span><br><span class="line"> 	<span class="keyword">default</span>:</span><br><span class="line"> 		fmt.Println(<span class="string">"放回失败"</span>)</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之语言陷阱</title>
    <url>/2020/05/17/go-study-notes-maybe-trap/</url>
    <content><![CDATA[<h2 id="range-复用临时变量"><a href="#range-复用临时变量" class="headerlink" title="range 复用临时变量"></a><code>range</code> 复用临时变量</h2><p>先来看一段简单的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    arr := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"(%v,%v)"</span>, i, v)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// (3,3)(3,3)(3,3)(3,3)</span></span><br></pre></td></tr></table></figure>

<p>程序并没有像我们预期的一样遍历切片 <code>arr</code>,而是全部打印其索引下标.其实有两点原因会导致这个问题</p>
<ul>
<li><code>for range</code> 下的迭代变量 i, v 的值是共用的</li>
<li>main 函数所在的 goroutine 与后续启动的 goroutine 存在竞争关系,可通过 <code>go run -race main.go</code> 看到 goroutine 之间的竞争关系</li>
</ul>
<p>因此,<code>range</code> 在迭代写过程中,多个 goroutine 并发地去读,导致传入闭包中 i,v 数据一直在做更改,从而出现上述情况</p>
<p>可以使用函数函数参数做一次数据复制,而不是闭包.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    arr := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 这里有一个实参到形参的值拷贝</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i, v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"(%v,%v)"</span>, i, v)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i, v)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下: 随着 goroutine 执行完成顺序不同,输出顺序也会发生改变</span></span><br><span class="line">(<span class="number">3</span>,<span class="number">3</span>)(<span class="number">0</span>,<span class="number">0</span>)(<span class="number">1</span>,<span class="number">1</span>)(<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到新程序的结果符合预期.其实质是在迭代过程中,向函数传参时, <code>i,v</code> 的值已经传递给 <code>a,b</code>(值拷贝),因此输出的值也是遍历之后的值</p>
<h2 id="defer-陷阱"><a href="#defer-陷阱" class="headerlink" title="defer 陷阱"></a><code>defer</code> 陷阱</h2><p>先来看一下如下几个函数的执行结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += <span class="number">5</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        r += <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"f1=%v,f2=%v,f3=%v"</span>, f1(), f2(), f3())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line">f1=<span class="number">3</span>,f2=<span class="number">5</span>,f3=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个理解起来可能有些难度,我们逐个进行分析</p>
<p>首先,我们要明白在以上函数中, <code>r</code> 作为返回值,在函数定义时,已经被定义并赋值为 <code>return</code> 关键字返回的值.因此</p>
<ol>
<li>在 <code>f1</code> 中, <code>r</code> 的初始值为 2.在函数返回之前 <code>defer</code> 修饰的闭包函数对 <code>r</code> 的值做了修改.通过本篇文章中第一个示例可以看出,闭包函数中的操作会影响到函数的返回值.因此 <code>f1</code> 在返回之前会执行闭包函数而修改 <code>r</code> 的值(自增).因此返回 3</li>
<li>在 <code>f2</code> 中, <code>r</code> 的初始值为变量 <code>t</code> 的值(变量 <code>t</code> 做值拷贝后将值传给 <code>r</code>), 为 5.在函数返回之前 <code>defer</code> 修饰的闭包函数对 <code>t</code> 的值做了修改,而 <code>r</code> 的值没有受到影响.因此 <code>f2</code> 的返回值是 5</li>
<li>在 <code>f3</code> 中, <code>r</code> 的初始值为 1.在函数返回之前, 将 <code>r</code> 做值拷贝后将值作为参数传递给 <code>defer</code> 修饰的函数(非闭包),<code>defer</code> 修饰的函数中的操作对外部参数 <code>r</code> 没有影响.因此 <code>f3</code> 的返回值是 1</li>
</ol>
<p>其实以上主要是闭包函数在使用过程中可能忽略的陷阱,而我们要始终知道的是 <strong>Go 中所有的变量赋值及参数传递均为值拷贝,变量值可能是具体的一个对象,也可能是指向某一对象的内存地址.而闭包不会进行参数传递,闭包函数内与外的变量都使用同一内存地址</strong></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h2 id="创建方式与底层数据结构"><a href="#创建方式与底层数据结构" class="headerlink" title="创建方式与底层数据结构"></a>创建方式与底层数据结构</h2><p>切片的创建方式如下:</p>
<ul>
<li>通过数组创建</li>
<li>通过内置的 make 函数创建</li>
<li>直接声明</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s1 := arr[:]</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s4 []<span class="keyword">int</span>  <span class="comment">// s4 = nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是以哪种类型创建,其数据的底层存储都是数组.且由 <code>runtime/slice.go</code> 可以看出切片的数据结构有 3 个成员,分别是指向底层数组的指针,切片的当前大小和底层数组的大小.当 len 增长超过 cap 时,会申请一个更大容量的底层数组,并将数据复制过来</p>
<p>需要注意的是 <code>var s = make([]int, 0)</code> 与 <code>var s []int</code> 创建的对象是有区别的,前者会对底层数组进行内存分配,并初始化为没有值的切片,后者不会进行内存分配,其实为 nil.</p>
<h3 id="多个切片引用同一底层数组引发的混乱"><a href="#多个切片引用同一底层数组引发的混乱" class="headerlink" title="多个切片引用同一底层数组引发的混乱"></a>多个切片引用同一底层数组引发的混乱</h3><p>使用内置函数 <code>append</code> 扩展切片过程中可能会修改底层数组的元素,间接影响其它切片的值,也可能引发数组重建,可能会引发意想不到的错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [<span class="number">7</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    a := arr[:]</span><br><span class="line">    b := arr[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">    as := (*reflect.SliceHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">    bs := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"a=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a), &amp;a, as.Data)</span><br><span class="line">    fmt.Printf(<span class="string">"b=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b), &amp;b, bs.Data)</span><br><span class="line"></span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"arr=%v,len=%d,cap=%d,pointer=%p\n"</span>, arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br><span class="line">    fmt.Printf(<span class="string">"a=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a), &amp;a, as.Data)</span><br><span class="line">    fmt.Printf(<span class="string">"b=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b), &amp;b, bs.Data)</span><br><span class="line"></span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">13</span>, <span class="number">14</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"a=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a), &amp;a, as.Data)</span><br><span class="line">    fmt.Printf(<span class="string">"b=%v,len=%d,cap=%d,pointer=%p, type=%d\n"</span>, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b), &amp;b, bs.Data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// arr=[0 1 2 3 4 5 6],len=7,cap=7,pointer=0xc00000e280</span></span><br><span class="line"><span class="comment">// a=[0 1 2 3 4 5 6],len=7,cap=7,pointer=0xc0000044a0, type=824633778816</span></span><br><span class="line"><span class="comment">// b=[0 1 2 3],len=4,cap=7,pointer=0xc0000044c0, type=824633778816</span></span><br><span class="line"><span class="comment">// arr=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc00000e280</span></span><br><span class="line"><span class="comment">// a=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc0000044a0, type=824633778816</span></span><br><span class="line"><span class="comment">// b=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc0000044c0, type=824633778816</span></span><br><span class="line"><span class="comment">// arr=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc00000e280</span></span><br><span class="line"><span class="comment">// a=[0 1 2 3 10 11 12],len=7,cap=7,pointer=0xc0000044a0, type=824633778816</span></span><br><span class="line"><span class="comment">// b=[0 1 2 3 10 11 12 13 14],len=9,cap=14,pointer=0xc0000044c0, type=824633786816</span></span><br></pre></td></tr></table></figure>

<p>由输出可以看出:</p>
<ul>
<li>在第一次调用 <code>append</code> 函数向切片 b 追加元素后,底层数组 arr 的值发生改变.从而导致切片 a 的值也发生改变</li>
<li>第二次调用 <code>append</code> 函数向切片 b 追加元素后,由于 <code>len(b) &gt; cap(b)</code>,底层数组重新分配内存空间,产生更大容量的数组结构,并将原来数组值复制到新数组</li>
</ul>
<h2 id="传值还是传引用"><a href="#传值还是传引用" class="headerlink" title="传值还是传引用"></a>传值还是传引用</h2><p>Go 中所有的变量赋值及参数传递均为值拷贝.</p>
<ul>
<li>当变量赋值或参数传递为指针时,同样是值拷贝,但是指针及其副本指向的地址是同一个地址,因此操作的是同一数据</li>
<li>当变量赋值或参数传递为引用类型数据时(<code>chan,map,slice</code>),其内部都是通过指针指向具体的数据,实际上相当于传递了指针的副本</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之表达式</title>
    <url>/2020/04/30/go-study-notes-expression/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针会分配内存空间, 相当于一个专门用来保存对象地址的整型变量. 它有自身的内存地址, 其值为另外一个对象的内存地址</p>
<ul>
<li>取址运算符 <code>&amp;</code> 用于获取对象地址.</li>
<li>指针运算符 <code>*</code> 用于间接引用目标对象.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    p := &amp;x</span><br><span class="line">    fmt.Printf(<span class="string">"p 的类型为:%T, p 的地址为:%p\n"</span>, p, &amp;p) <span class="comment">// p 为 *int 类型,有自己的地址,</span></span><br><span class="line">    fmt.Printf(<span class="string">"p 的值为:%v, x 的地址为:%p\n"</span>, p, &amp;x)  <span class="comment">// 变量 p 保存了 x 的内存地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"x 的值为:%v, p 的引用值为:%v\n"</span>, x, *p) <span class="comment">// p 的引用为变量 x 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在结构体指针引用使用过程中, 由于 Go 语言底层做了优化, 对结构体属性的访问可直接使用指针变量进行, 如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        age <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    stu := Student&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;</span><br><span class="line">    p := &amp;stu</span><br><span class="line">    (*p).Name=<span class="string">"jack"</span>  <span class="comment">// 先使用指针进行引用后, 对引用对象属性进行修改, 但是看起来比较复杂</span></span><br><span class="line">    p.Name = <span class="string">"jack"</span>   <span class="comment">// 与上述引用相同, Go 语言在底层做了优化, 看起来/写起来比较简单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h1><p>主要有两种形式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> x &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 其中, index 表示 x 的索引下标, value 为 x 对应索引下标的值</span></span><br><span class="line">    <span class="comment">// 可使用 _ 对其中元素进行站位操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 中没有 <code>while</code>, <code>until</code> 等关键字, 因此没有 <code>while true</code> 或 <code>do...until</code> 等形式, 我们可以使用 <code>for</code> + <code>if</code> 条件判断达到类似的效果. 如下:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 一直循环</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> <span class="keyword">do</span>...<span class="keyword">while</span> 形式</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">    <span class="keyword">if</span> expression &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="if-else-流程控制"><a href="#if-else-流程控制" class="headerlink" title="if-else 流程控制"></a><code>if-else</code> 流程控制</h1><p><code>if-else</code> 控制比较简单, 一般形式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="switch-流程控制"><a href="#switch-流程控制" class="headerlink" title="switch 流程控制"></a><code>switch</code> 流程控制</h1><p>与 <code>if-else</code> 类似相同, <code>switch</code> 语句也用于选择执行, 但具体使用场景会有所不同</p>
<p>一般来说具有以下特点:</p>
<ul>
<li>支持 <code>switch</code> 代码块内赋值等初始化语句</li>
<li><code>case</code> 语句支持多个匹配条件逻辑或</li>
<li>只有全部 <code>case</code> 语句匹配失败时才会执行 <code>default</code> 块</li>
<li>相邻的空 <code>case</code> 表示执行的代码块为空</li>
<li>无需显示指定 <code>break</code> 语句, <code>case</code> 执行完毕后自动中断</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> x := <span class="number">5</span>; x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">// 隐式 "case 0: break;"</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">		fmt.Println(<span class="string">"工作日"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">		fmt.Println(<span class="string">"周末"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"错误输入"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 可以用来替换 <code>if</code> 语句, 被省略的 <code>switch</code> 条件表达式默认为 <code>true</code>, 继而与 <code>case</code> 表达式结果匹配: 如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">20</span></span><br><span class="line">	<span class="keyword">switch</span>  &#123;</span><br><span class="line">	<span class="keyword">case</span> x &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">18</span>:</span><br><span class="line">		fmt.Println(<span class="string">"未成年人"</span>)</span><br><span class="line">	<span class="keyword">case</span> x &gt;= <span class="number">18</span>:</span><br><span class="line">		fmt.Println(<span class="string">"成年人"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"错误输入"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select-随机选择控制"><a href="#select-随机选择控制" class="headerlink" title="select 随机选择控制"></a><code>select</code> 随机选择控制</h2><p><code>select</code> 是 Go 中的一个控制结构,其语法与 <code>switch</code> 流程控制类似.<code>select</code> 会随机执行一个可运行的 case.如果没有 case 可执行,则执行 default 语句块或阻塞直到有 case 可运行</p>
<p>一般来说语法结构如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> communicating_1:</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">case</span> communicating_2:</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 可选</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说具有以下特点:</p>
<ul>
<li>每个 case 都必须是一个通信过程</li>
<li>如果有多个 case 可运行, select 会随机选择一个执行,其它不会被执行</li>
<li>如果没有 case 可执行,则如果有 default 子句,执行该语句块;否则阻塞,直到某个通信可进行</li>
</ul>
<p>示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    data := []<span class="keyword">chan</span> <span class="keyword">int</span>&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> data[<span class="built_in">len</span>(data)<span class="number">-1</span>] &lt;- i:</span><br><span class="line">                fmt.Println(<span class="string">"case 1 执行"</span>)</span><br><span class="line">            <span class="keyword">case</span> data[<span class="built_in">len</span>(data)<span class="number">-1</span>] &lt;- i:</span><br><span class="line">                fmt.Println(<span class="string">"case 2 执行"</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                data = <span class="built_in">append</span>(data, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>))  <span class="comment">// default 语句用于添加新的 channel 等.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-done <span class="comment">// 阻塞, 直到 goroutine 执行结束</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">        c := data[i]</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> c &#123;</span><br><span class="line">            fmt.Println(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可看到 case 1 2 随机执行</span></span><br></pre></td></tr></table></figure>


<h2 id="fallthrough-关键字"><a href="#fallthrough-关键字" class="headerlink" title="fallthrough 关键字"></a><code>fallthrough</code> 关键字</h2><p><code>fallthrough</code> 关键字用于继续执行<strong>下一个</strong> <code>case</code> 语句, 必须放在 <code>case</code> 代码块末尾</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> x := <span class="number">0</span>; x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"0"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">		fmt.Println(<span class="string">"工作日"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">		fmt.Println(<span class="string">"周末"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"错误输入"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 工作日</span></span><br></pre></td></tr></table></figure>

<h1 id="goto-continue-break-关键字"><a href="#goto-continue-break-关键字" class="headerlink" title="goto, continue, break 关键字"></a><code>goto</code>, <code>continue</code>, <code>break</code> 关键字</h1><ul>
<li><code>goto</code> 用于定点跳转, 代码跳转到指定标签的代码位置, 但不能跳转到其他函数或内层代码块内</li>
<li><code>continue</code> 仅用于 <code>for</code> 循环, 终止本次循环逻辑, 立即进入下一轮循环.</li>
<li><code>break</code> 用于 <code>switch</code>, <code>for</code>, <code>select</code> 语句, 跳出整个语句块</li>
</ul>
<p>配合标签, <code>continue</code> 和 <code>break</code> 可在多层嵌套中指定目标层级.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">outer:</span><br><span class="line">	<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">5</span>; x++ &#123;</span><br><span class="line">		<span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">			<span class="keyword">if</span> y &gt; <span class="number">2</span> &#123;</span><br><span class="line">				fmt.Println()</span><br><span class="line">				<span class="keyword">continue</span> outer</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> x &gt; <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> outer</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v:%v "</span>, x, y)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// 0:0 0:1 0:2 </span></span><br><span class="line"><span class="comment">// 1:0 1:1 1:2 </span></span><br><span class="line"><span class="comment">// 2:0 2:1 2:2</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 go 命令</title>
    <url>/2020/04/30/go-study-notes-go-command/</url>
    <content><![CDATA[<p>安装配置好 Go 语言环境之后, 让我们先来看一看 go 为我们提供了哪些命令, 以及这些命令可以做什么吧</p>
<p>查看 go 命令行帮助可以了解到 <code>go</code> 是用于管理 Go 代码的命令行工具.</p>
<p>它提供了很多子命令来实现各种功能. 使用方式为 <code>go &lt;command&gt; [arguments]</code>, 使用 <code>go help &lt;command&gt;</code> 可以查看子命令的帮助信息</p>
<p>以下是 go 的子命令及其简单描述</p>
<table>
<thead>
<tr>
<th align="center">子命令</th>
<th align="left">简单解释</th>
<th align="left">详细描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bug</td>
<td align="left">bug/issue 报告</td>
<td align="left">它会收集当前系统及 Go 语言信息, 在 <code>github/golang/go</code> 代码仓库中帮助你创建一个 issues</td>
</tr>
<tr>
<td align="center">build</td>
<td align="left">编译软件包和依赖</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">clean</td>
<td align="left">删除旧的对象文件和缓存文件</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">doc</td>
<td align="left">显示包及其内容或符号的帮助文档</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">env</td>
<td align="left">打印当前 Go 环境信息</td>
<td align="left">包括 <code>GO111MODULE</code>, <code>GOARCH</code>, <code>GOBIN</code>, <code>GOHOSTARCH</code>, <code>GOHOSTOS</code>, <code>GOPATH</code>, <code>GOPROXY</code>, <code>GOROOT</code>, <code>GOTOOLDIR</code>,<code>GOMOD</code> 等环境变量</td>
</tr>
<tr>
<td align="center">fix</td>
<td align="left">更新软件包以使用新的 API</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">fmt</td>
<td align="left">用于格式化 go 源代码</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">generate</td>
<td align="left">通过预处理源生成 Go 代码文件</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">get</td>
<td align="left">将依赖项添加到当前模块并安装它们</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">install</td>
<td align="left">编译并安装软件包和依赖</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">list</td>
<td align="left">列出软件包或模块</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">mod</td>
<td align="left">提供对模块的操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">run</td>
<td align="left">编译并运行 Go 程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">test</td>
<td align="left">测试包</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">tool</td>
<td align="left">运行指定的 go 工具</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">version</td>
<td align="left">打印 Go 版本信息</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">vet</td>
<td align="left">报告包中可能的错误</td>
<td align="left">一些语法上虽然没有错误, 但是逻辑上可能存在问题的错误, 如死循环</td>
</tr>
</tbody></table>
<p>它还提供了一些额外的话题帮助. 使用 <code>go help &lt;topic&gt;</code> 可以查看关于该话题的更多帮助.</p>
<table>
<thead>
<tr>
<th align="left">topic</th>
<th align="left">简单描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">buildmode</td>
<td align="left">构建模式</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">Go 与 C 语言间的调用</td>
</tr>
<tr>
<td align="left">cache</td>
<td align="left">简历并测试缓存</td>
</tr>
<tr>
<td align="left">environment</td>
<td align="left">环境变量</td>
</tr>
<tr>
<td align="left">filetype</td>
<td align="left">文件类型</td>
</tr>
<tr>
<td align="left">go.mod</td>
<td align="left">go.mod 文件, 该文件保存了项目依赖的模块, 类似于依赖包的集合(python 中的 requirements.txt 文件)</td>
</tr>
<tr>
<td align="left">gopath</td>
<td align="left"><code>GOPATH</code> 环境变量</td>
</tr>
<tr>
<td align="left">gopath-get</td>
<td align="left">早期的 go get 的 GOPATH</td>
</tr>
<tr>
<td align="left">goproxy</td>
<td align="left">访问 go module 的代理</td>
</tr>
<tr>
<td align="left">importpath</td>
<td align="left">import 导入包路径的语法</td>
</tr>
<tr>
<td align="left">modules</td>
<td align="left">模块, 模块版本等</td>
</tr>
<tr>
<td align="left">module-get</td>
<td align="left">go get 的模块感知</td>
</tr>
<tr>
<td align="left">module-auth</td>
<td align="left">使用 go.sum 进行身份认证</td>
</tr>
<tr>
<td align="left">module-private</td>
<td align="left">非公共模块的相关配置</td>
</tr>
<tr>
<td align="left">packages</td>
<td align="left">包</td>
</tr>
<tr>
<td align="left">testflag</td>
<td align="left">测试的标志</td>
</tr>
<tr>
<td align="left">testfunc</td>
<td align="left">测试函数</td>
</tr>
</tbody></table>
<h1 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a><code>go build</code></h1><p>构建编译包及其依赖, 但是不会安装</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">build</span> <span class="selector-attr">[-o output]</span> <span class="selector-attr">[-i]</span> <span class="selector-attr">[build flags]</span> <span class="selector-attr">[packages]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果要构建的参数是单个目录中的 <code>.go</code> 列表文件, 则 build 会将其视为指定单个程序包的源文件列表</li>
<li>编译软件包时, build 会忽略以 <code>_test.go</code> 结尾的文件</li>
<li>编译单个 main 包时, build 将生成的可执行文件输出为第一个源代码文件名或源代码目录名文件(如 <code>go build ed.go rx.go</code> 生成 <code>ed</code>/<code>ed.exe</code>, <code>go build unix/sam</code> 生成 <code>sam</code>/<code>sam.exe</code>). 编译 Windows 系统可以执行文件时, 会添加 “.exe” 后缀 </li>
<li>编译多个软件包或单个非 main 软件包时, build 会编译软件包, 但是会丢弃生成的对象. 仅用作检查是否可以构建软件包</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-o</code></td>
<td align="left">将生成的可执行文件或对象输出为指定的文件名或输出到指定目录</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="left">安装依赖的软件包</td>
</tr>
</tbody></table>
<p>以下标志是 <code>build</code>, <code>clean</code>, <code>get</code>, <code>install</code>, <code>list</code>, <code>run</code>, <code>test</code> 命令共享的</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-a</code></td>
<td align="left">强制重新构建编译已更新的软件包</td>
</tr>
<tr>
<td align="center"><code>-n</code></td>
<td align="left">打印命令, 但不运行</td>
</tr>
<tr>
<td align="center"><code>-p n</code></td>
<td align="left">可以并行运行的程序数量, 默认是可用的 CPU 数量</td>
</tr>
<tr>
<td align="center"><code>-race</code></td>
<td align="left">启用数据竞争检测, 仅支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64</td>
</tr>
<tr>
<td align="center"><code>-msan</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>-v</code></td>
<td align="left">在编译时打印软件包名称</td>
</tr>
<tr>
<td align="center"><code>-work</code></td>
<td align="left">打印临时工作目录名, 退出时不要删除它</td>
</tr>
<tr>
<td align="center"><code>-x</code></td>
<td align="left">打印命令</td>
</tr>
<tr>
<td align="center"><code>-asm</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>-buildmode mode</code></td>
<td align="left">构建的模式选择, 可选模式为 <code>archive</code>, <code>c-archive</code>, <code>c-shared</code>, <code>default</code>, <code>shared</code>, <code>exe</code>, <code>pie</code>, <code>plugin</code>. 详见 <code>go help buildmode</code></td>
</tr>
<tr>
<td align="center"><code>-compiler name</code></td>
<td align="left">编译器的名称 如 <code>runtime.Compiler</code>(gccgo 或 gc)</td>
</tr>
<tr>
<td align="center"><code>-mod mode</code></td>
<td align="left">模块的下载模式: readonly 或 vendor</td>
</tr>
<tr>
<td align="center"><code>-pkgdir dir</code></td>
<td align="left">从指定目录安装和加载所有软件包, 在非标准配置进行构建时, 使用 -pkgdir 将生成的软件包保存在单独的位置</td>
</tr>
<tr>
<td align="center"><code>-tags tag,list</code></td>
<td align="left">以逗号分割的构建标记列表</td>
</tr>
</tbody></table>
<h1 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a><code>go clean</code></h1><p>从软件包源目录中删除目标文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">clean</span> <span class="selector-attr">[clean flags]</span> <span class="selector-attr">[build flags]</span> <span class="selector-attr">[packages]</span></span><br></pre></td></tr></table></figure>
<p>go 命令在临时目录中构建大多数对象, 因此 <code>go clean</code> 主要与其它工具或手动调用 <code>go build</code> 留下的对象文件有关</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-i</code></td>
<td align="left">删除相应的已安装的归档文件或二进制文件</td>
</tr>
<tr>
<td align="center"><code>-n</code></td>
<td align="left">打印即将执行的删除命令, 但不运行</td>
</tr>
<tr>
<td align="center"><code>-r</code></td>
<td align="left">递归应用于包的所有依赖项</td>
</tr>
<tr>
<td align="center"><code>-x</code></td>
<td align="left">在执行删除命令时打印它们</td>
</tr>
<tr>
<td align="center"><code>-cache</code></td>
<td align="left">删除所有 <code>go build</code> 缓存</td>
</tr>
<tr>
<td align="center"><code>-modcache</code></td>
<td align="left">删除所有模块下载缓存, 包括源代码的版本依赖</td>
</tr>
</tbody></table>
<h1 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a><code>go doc</code></h1><p>显示帮助文档</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">go doc <span class="comment">[-u]</span> <span class="comment">[-c]</span> <span class="comment">[package|<span class="comment">[package.]</span>symbol<span class="comment">[.methodOrField]</span>]</span></span><br></pre></td></tr></table></figure>

<p>打印指定对象的注释文档(package, const, func, type, var, method, struct), 然后打印其下属对象的单行摘要</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-all</code></td>
<td align="left">显示包所有的帮助文档</td>
</tr>
<tr>
<td align="center"><code>-c</code></td>
<td align="left">匹配符号时要注意大小写</td>
</tr>
<tr>
<td align="center"><code>-cmd</code></td>
<td align="left">将 command (package main) 视为常规程序包, 否则, 显示软件包的顶级文档时, 软件包主要的导出符号将被隐藏</td>
</tr>
<tr>
<td align="center"><code>-src</code></td>
<td align="left">显示该链接的完整源代码</td>
</tr>
<tr>
<td align="center"><code>-u</code></td>
<td align="left">显示未导出以及已导出符号, 方法和字段的文档</td>
</tr>
</tbody></table>
<h1 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a><code>go env</code></h1><p>输出 Go 环境变量信息</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">env</span> <span class="selector-attr">[-json]</span> <span class="selector-attr">[-u]</span> <span class="selector-attr">[-w]</span> <span class="selector-attr">[var ...]</span></span><br></pre></td></tr></table></figure>

<p>默认情况下, env 将信息作为 shell 脚本输出(在 Windows 中为批处理文件). 如果给定一个或多个变量的名称作为参数, 则输出每个变量的值</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-json</code></td>
<td align="left">以 JSON 格式输出环境变量</td>
</tr>
<tr>
<td align="center"><code>-u &lt;arg&gt; ...</code></td>
<td align="left">会取消 <code>go env -w NAME=VALUE</code> 设置的指定环境变量</td>
</tr>
<tr>
<td align="center"><code>-w &lt;NAME=VALUE&gt; ...</code></td>
<td align="left">修改默认环境变量值(不能新添自定义环境变量)</td>
</tr>
</tbody></table>
<h1 id="go-fix"><a href="#go-fix" class="headerlink" title="go fix"></a><code>go fix</code></h1><p>更新软件包以使用新的 API</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">fix</span> [packages]</span><br></pre></td></tr></table></figure>

<h1 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a><code>go fmt</code></h1><p>格式化 go 代码包, 在指定包中运行 <code>gofmt -l -w</code>. 返回已修改文件的名称</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">fmt</span> <span class="selector-attr">[-n]</span> <span class="selector-attr">[-x]</span> <span class="selector-attr">[packages]</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-n</code></td>
<td align="left">只打印将要执行的命令</td>
</tr>
<tr>
<td align="center"><code>-x</code></td>
<td align="left">打印并执行命令</td>
</tr>
</tbody></table>
<h1 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a><code>go get</code></h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">get</span> <span class="selector-attr">[-d]</span> <span class="selector-attr">[-f]</span> <span class="selector-attr">[-t]</span> <span class="selector-attr">[-u]</span> <span class="selector-attr">[-v]</span> <span class="selector-attr">[-fix]</span> <span class="selector-attr">[-insecure]</span> <span class="selector-attr">[build flags]</span> <span class="selector-attr">[packages]</span></span><br></pre></td></tr></table></figure>

<p>下载指定包及其依赖项, 然后安装它</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-d</code></td>
<td align="left">只下载包, 不要安装</td>
</tr>
<tr>
<td align="center"><code>-f</code></td>
<td align="left">仅在 <code>-u</code> 设置后才有效, 强制 <code>-u</code> 不验证每个包是否已从其导入路径所隐含的代码仓库导出. 如果是本地的 fork 源文件将很有用</td>
</tr>
<tr>
<td align="center"><code>-fix</code></td>
<td align="left">在解决依赖关系或构建代码之前, 先对下载的包运行 fix 工具</td>
</tr>
<tr>
<td align="center"><code>-insecure</code></td>
<td align="left">允许使用非安全方式从代码库中获取信息并解析自定义域名. 谨慎使用</td>
</tr>
<tr>
<td align="center"><code>-t</code></td>
<td align="left">对包生成测试所需的模块</td>
</tr>
<tr>
<td align="center"><code>-u</code></td>
<td align="left">使用网络更新指定的包及其依赖关系. 默认情况下, 使用网络检查丢失的软件包, 而不使用它来查找对现有包的更新</td>
</tr>
<tr>
<td align="center"><code>-v</code></td>
<td align="left">启用输出详细进度和调试信息</td>
</tr>
</tbody></table>
<p>checkout 新的包时, get 将创建目录 <code>GOPATH/src/&lt;import-path&gt;</code>. 如果 <code>GOPATH</code> 包含多个条目, 则默认使用第一个. 详见 <code>go help gopath</code>.</p>
<p>在 checkout 或更新软件包时, get 查找与本地安装的 Go 版本匹配的 brach 或 tag. 如果不存在这样的版本, 将获取包的默认分支.</p>
<p>当 go get checkout 或更新 git 仓库时, 它还会更新该存储库引用的所有 git 子模块</p>
<p>get 永远不会 checkout 或更新保存在 vendor 目录中的代码</p>
<h1 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a><code>go install</code></h1><p>编译并安装指定的软件包</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">install</span> <span class="selector-attr">[-i]</span> <span class="selector-attr">[build flags]</span> <span class="selector-attr">[packages]</span></span><br></pre></td></tr></table></figure>

<p>可执行文件安装在环境变量 <code>GOBIN</code> 所命名的目录中, 默认为 <code>$GOPATH/bin</code>. 如果没有设置 <code>GOPATH</code>, 则设置为 <code>$HOME/go/bin</code>. <code>$GOROOT</code> 中的可执行文件安装在 <code>$GOROOT/bin</code> 或 <code>$GOTOOLDIR</code> 中, 而不是 <code>$GOBIN</code>.</p>
<p>禁用 module-aware, 其它包安装在 <code>$GOPATH/pkg/$GOOS_$GOARCH</code>. 启用 module-aware, 将构建并缓存其它包, 但不安装.</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-i</code></td>
<td align="left">同时安装指定包的依赖</td>
</tr>
</tbody></table>
<h2 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a><code>go list</code></h2><p>列出指定包或其子包包名，每行一个</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">list</span> <span class="selector-attr">[-f format]</span> <span class="selector-attr">[-json]</span> <span class="selector-attr">[-m]</span> <span class="selector-attr">[list flags]</span> <span class="selector-attr">[build flags]</span> <span class="selector-attr">[packages]</span></span><br></pre></td></tr></table></figure>

<p>默认打印包的导入路径, 每行一个. 使用 <code>...</code> 可以输出指定包及其子包. 如 <code>go list net/...</code> 列出 “net” 及其子包的导入路径, 每行一个</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-f</code></td>
<td align="left">使用包模版的语法指定列出包的输出格式</td>
</tr>
<tr>
<td align="center"><code>-json</code></td>
<td align="left">使用 json 格式输出列出的包的信息</td>
</tr>
<tr>
<td align="center"><code>-deps</code></td>
<td align="left">遍历包名及其依赖, 依赖以深度优先的后续遍历访问它们.</td>
</tr>
<tr>
<td align="center"><code>-export</code></td>
<td align="left">将给定包的信息导出到包的 <code>Export</code> 字段设置的文件名</td>
</tr>
<tr>
<td align="center"><code>-find</code></td>
<td align="left">列出指定的包, 但不解析其依赖关系, <code>Imports</code> 和 <code>Deps</code> 列表为空</td>
</tr>
<tr>
<td align="center"><code>-test</code></td>
<td align="left">列出指定的包及其测试二进制文件, 以将测试二进制文件的确切构造传达给代码分析工具</td>
</tr>
<tr>
<td align="center"><code>-m</code></td>
<td align="left">列出模块 , 而不是包</td>
</tr>
</tbody></table>
<p>最常用的标志是 <code>-f</code> , 它根据包和模块定义信息, 按照指定格式输出所需信息. 如 <code>&#39;\{\{ .ImportPath }}&#39;</code>(删除反斜线) 显示包的导入路径(默认), <code>&#39;\{\{ .Name }}&#39;</code>(删除反斜线)显示包的名称等. </p>
<p>包的详细定义信息见如下结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Package <span class="keyword">struct</span> &#123;</span><br><span class="line">        Dir           <span class="keyword">string</span>   <span class="comment">// 包含包源代码的目录</span></span><br><span class="line">        ImportPath    <span class="keyword">string</span>   <span class="comment">// 包在目录中的导入路径, `go list` 的默认输出格式 </span></span><br><span class="line">        ImportComment <span class="keyword">string</span>   <span class="comment">// package语句的import注释中的路径</span></span><br><span class="line">        Name          <span class="keyword">string</span>   <span class="comment">// 包名称</span></span><br><span class="line">        Doc           <span class="keyword">string</span>   <span class="comment">// 包文档字符串</span></span><br><span class="line">        Target        <span class="keyword">string</span>   <span class="comment">// 安装路径</span></span><br><span class="line">        Shlib         <span class="keyword">string</span>   <span class="comment">// 包含此包的共享库（仅在-linkshared时设置）</span></span><br><span class="line">        Goroot        <span class="keyword">bool</span>     <span class="comment">// 这个包在GOROOT目录下吗?</span></span><br><span class="line">        Standard      <span class="keyword">bool</span>     <span class="comment">// 这个包是标准go库的一部分吗?</span></span><br><span class="line">        Stale         <span class="keyword">bool</span>     <span class="comment">// `go install`对这个包有什么作用码?</span></span><br><span class="line">        StaleReason   <span class="keyword">string</span>   <span class="comment">// explanation for Stale==true</span></span><br><span class="line">        Root          <span class="keyword">string</span>   <span class="comment">// 包含这个包的GOROOT或GOPATH目录</span></span><br><span class="line">        ConflictDir   <span class="keyword">string</span>   <span class="comment">// $GOPATH中的这个目录shadows dir</span></span><br><span class="line">        BinaryOnly    <span class="keyword">bool</span>     <span class="comment">// binary-only package (no longer supported)</span></span><br><span class="line">        ForTest       <span class="keyword">string</span>   <span class="comment">// package is only for use in named test</span></span><br><span class="line">        Export        <span class="keyword">string</span>   <span class="comment">// file containing export data (when using -export)</span></span><br><span class="line">        Module        *Module  <span class="comment">// info about package's containing module, if any (can be nil)</span></span><br><span class="line">        Match         []<span class="keyword">string</span> <span class="comment">// command-line patterns matching this package</span></span><br><span class="line">        DepOnly       <span class="keyword">bool</span>     <span class="comment">// package is only a dependency, not explicitly listed</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Source files</span></span><br><span class="line">        GoFiles         []<span class="keyword">string</span> <span class="comment">// .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)</span></span><br><span class="line">        CgoFiles        []<span class="keyword">string</span> <span class="comment">// .go source files that import "C"</span></span><br><span class="line">        CompiledGoFiles []<span class="keyword">string</span> <span class="comment">// .go files presented to compiler (when using -compiled)</span></span><br><span class="line">        IgnoredGoFiles  []<span class="keyword">string</span> <span class="comment">// .go source files ignored due to build constraints</span></span><br><span class="line">        CFiles          []<span class="keyword">string</span> <span class="comment">// .c source files</span></span><br><span class="line">        CXXFiles        []<span class="keyword">string</span> <span class="comment">// .cc, .cxx and .cpp source files</span></span><br><span class="line">        MFiles          []<span class="keyword">string</span> <span class="comment">// .m source files</span></span><br><span class="line">        HFiles          []<span class="keyword">string</span> <span class="comment">// .h, .hh, .hpp and .hxx source files</span></span><br><span class="line">        FFiles          []<span class="keyword">string</span> <span class="comment">// .f, .F, .for and .f90 Fortran source files</span></span><br><span class="line">        SFiles          []<span class="keyword">string</span> <span class="comment">// .s source files</span></span><br><span class="line">        SwigFiles       []<span class="keyword">string</span> <span class="comment">// .swig files</span></span><br><span class="line">        SwigCXXFiles    []<span class="keyword">string</span> <span class="comment">// .swigcxx files</span></span><br><span class="line">        SysoFiles       []<span class="keyword">string</span> <span class="comment">// .syso object files to add to archive</span></span><br><span class="line">        TestGoFiles     []<span class="keyword">string</span> <span class="comment">// _test.go files in package</span></span><br><span class="line">        XTestGoFiles    []<span class="keyword">string</span> <span class="comment">// _test.go files outside package</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cgo directives</span></span><br><span class="line">        CgoCFLAGS    []<span class="keyword">string</span> <span class="comment">// cgo: flags for C compiler</span></span><br><span class="line">        CgoCPPFLAGS  []<span class="keyword">string</span> <span class="comment">// cgo: flags for C preprocessor</span></span><br><span class="line">        CgoCXXFLAGS  []<span class="keyword">string</span> <span class="comment">// cgo: flags for C++ compiler</span></span><br><span class="line">        CgoFFLAGS    []<span class="keyword">string</span> <span class="comment">// cgo: flags for Fortran compiler</span></span><br><span class="line">        CgoLDFLAGS   []<span class="keyword">string</span> <span class="comment">// cgo: flags for linker</span></span><br><span class="line">        CgoPkgConfig []<span class="keyword">string</span> <span class="comment">// cgo: pkg-config names</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dependency information</span></span><br><span class="line">        Imports      []<span class="keyword">string</span>          <span class="comment">// import paths used by this package</span></span><br><span class="line">        ImportMap    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// map from source import to ImportPath (identity entries omitted)</span></span><br><span class="line">        Deps         []<span class="keyword">string</span>          <span class="comment">// all (recursively) imported dependencies</span></span><br><span class="line">        TestImports  []<span class="keyword">string</span>          <span class="comment">// imports from TestGoFiles</span></span><br><span class="line">        XTestImports []<span class="keyword">string</span>          <span class="comment">// imports from XTestGoFiles</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error information</span></span><br><span class="line">        Incomplete <span class="keyword">bool</span>            <span class="comment">// this package or a dependency has an error</span></span><br><span class="line">        Error      *PackageError   <span class="comment">// error loading package</span></span><br><span class="line">        DepsErrors []*PackageError <span class="comment">// errors loading dependencies</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块的详细定义信息见如下结构体:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Module <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path      <span class="keyword">string</span>       <span class="comment">// 模块路径</span></span><br><span class="line">    Version   <span class="keyword">string</span>       <span class="comment">// 模块版本</span></span><br><span class="line">    Versions  []<span class="keyword">string</span>     <span class="comment">// 可用的模块版本 (with -versions)</span></span><br><span class="line">    Replace   *Module      <span class="comment">// 替换为指定模块</span></span><br><span class="line">    Time      *time.Time   <span class="comment">// 创建的时间版本信息</span></span><br><span class="line">    Update    *Module      <span class="comment">// 可用的任何更新 (with -u)</span></span><br><span class="line">    Main      <span class="keyword">bool</span>         <span class="comment">// 是否是主模块</span></span><br><span class="line">    Indirect  <span class="keyword">bool</span>         <span class="comment">// 是否只是主模块的间接依赖吗?</span></span><br><span class="line">    Dir       <span class="keyword">string</span>       <span class="comment">// 模块的保存文件目录</span></span><br><span class="line">    GoMod     <span class="keyword">string</span>       <span class="comment">// go.mod 文件路径</span></span><br><span class="line">    GoVersion <span class="keyword">string</span>       <span class="comment">// 模块使用的 Go 版本信息</span></span><br><span class="line">    Error     *ModuleError <span class="comment">// 加载模块的错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ModuleError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Err <span class="keyword">string</span> <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a><code>go mod</code></h1><p>提供对模块的操作</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">go <span class="keyword">mod</span> &lt;<span class="keyword">command</span>&gt; [<span class="title">arguments</span>]</span><br></pre></td></tr></table></figure>

<p>包含如下子命令</p>
<table>
<thead>
<tr>
<th align="center">command</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">download</td>
<td align="left">下载模块到本地缓存(默认为 GOPATH/pkg/mod 目录)</td>
</tr>
<tr>
<td align="center">edit</td>
<td align="left">通过工具或脚本编辑 go.mod</td>
</tr>
<tr>
<td align="center">graph</td>
<td align="left">打印模块依赖图</td>
</tr>
<tr>
<td align="center">init</td>
<td align="left">在当前目录下初始化新模块, 创建 go.mod</td>
</tr>
<tr>
<td align="center">tidy</td>
<td align="left">增加缺少的包,删除没有用到的包</td>
</tr>
<tr>
<td align="center">vendor</td>
<td align="left">将依赖复制到 vendor 目录下</td>
</tr>
<tr>
<td align="center">verify</td>
<td align="left">校验依赖</td>
</tr>
<tr>
<td align="center">why</td>
<td align="left">解释为什么需要软件包或模块</td>
</tr>
</tbody></table>
<h2 id="download"><a href="#download" class="headerlink" title="download"></a><code>download</code></h2><p>下载指定模块, 这些模块是主模块依赖的模块, 也可以是 <code>path@version</code> 形式的模块查询. 如果没有参数, 则下载主模块的所有依赖.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">mod</span> <span class="selector-tag">download</span> <span class="selector-attr">[-json]</span> <span class="selector-attr">[modules]</span></span><br></pre></td></tr></table></figure>

<p>go 命令在正常执行期间根据需要自动下载模块. <code>go mod download</code> 命令主要用于预填充本地缓存或得到 go 模块代理的响应</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-json</code></td>
<td align="left">打印一系列 json 对象到标准输出, 模数每个下载的模块信息. 与下面 Go Module 结构体相对应</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Module <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path     <span class="keyword">string</span> <span class="comment">// module path</span></span><br><span class="line">    Version  <span class="keyword">string</span> <span class="comment">// module version</span></span><br><span class="line">    Error    <span class="keyword">string</span> <span class="comment">// error loading module</span></span><br><span class="line">    Info     <span class="keyword">string</span> <span class="comment">// absolute path to cached .info file</span></span><br><span class="line">    GoMod    <span class="keyword">string</span> <span class="comment">// absolute path to cached .mod file</span></span><br><span class="line">    Zip      <span class="keyword">string</span> <span class="comment">// absolute path to cached .zip file</span></span><br><span class="line">    Dir      <span class="keyword">string</span> <span class="comment">// absolute path to cached source root directory</span></span><br><span class="line">    Sum      <span class="keyword">string</span> <span class="comment">// checksum for path, version (as in go.sum)</span></span><br><span class="line">    GoModSum <span class="keyword">string</span> <span class="comment">// checksum for go.mod (as in go.sum)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="edit"><a href="#edit" class="headerlink" title="edit"></a><code>edit</code></h2><p>提供了一个用于编辑 go.mod 的命令行界面, 主要供工具或脚本使用. 它只读取 go.mod, 不查找所涉及的模块信息.</p>
<p>默认情况下, edit 读写主模块的 go.mod 文件,但可以指定其它目标文件</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-fmt</code></td>
<td align="left">重新格式化 go.mod 文件, 而不进行其它更改</td>
</tr>
<tr>
<td align="center"><code>-module</code></td>
<td align="left">更改模块的路径</td>
</tr>
<tr>
<td align="center"><code>-require=path@version</code>/<code>-droprequire=path</code></td>
<td align="left">添加给定的 <code>path@version</code> 的模块/删除指定 path 的模块</td>
</tr>
<tr>
<td align="center"><code>-exclude=path@version</code>/<code>-dropexclude=path@version</code></td>
<td align="left">为给定的 <code>path@version</code> 模块添加/删除 exclude 信息</td>
</tr>
<tr>
<td align="center"><code>-replace=old[@v]=new[@v]</code>/<code>-dropreplace=old[@v]</code></td>
<td align="left">添加和删除对给定 <code>path@version</code> 模块的替换</td>
</tr>
<tr>
<td align="center"><code>-go=version</code></td>
<td align="left">设置预期的 Go 语言版本</td>
</tr>
<tr>
<td align="center"><code>-print</code></td>
<td align="left">以文本格式打印最终的 go.mod, 而不是将其写回到 go.mod</td>
</tr>
<tr>
<td align="center"><code>-json</code></td>
<td align="left">以 JSON 格式打印最终的 go.mod, 而不是将其写回到 go.mod. JSON 格式对应的 Go 结构体如下</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Module <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    Version <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GoMod <span class="keyword">struct</span> &#123;</span><br><span class="line">	Module  Module</span><br><span class="line">    Go      <span class="keyword">string</span></span><br><span class="line">    Require []Require</span><br><span class="line">    Exclude []Module</span><br><span class="line">    Replace []Replace</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Require <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    Version <span class="keyword">string</span></span><br><span class="line">    Indirect <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Replace <span class="keyword">struct</span> &#123;</span><br><span class="line">    Old Module</span><br><span class="line">    New Module</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h2><p>初始化一个新的 go.mod 保存在当前目录, 实际上是创建了一个以当前目录为 <code>/</code> 的新模块. go.mod 文件必须不存在</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">go mod init [<span class="class"><span class="keyword">module</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="tidy"><a href="#tidy" class="headerlink" title="tidy"></a><code>tidy</code></h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">mod</span> tidy [-v]</span><br></pre></td></tr></table></figure>

<p>确保 go.mod 与模块中的源代码匹配, 它添加了构建当前模块的程序包和依赖项所需的所有缺少的模块, 并删除程序包的未使用模块. 它还会将所有缺少的条目添加到 go.sum 中, 并删除所有不必要的条目.</p>
<p><code>-v</code> 标志将有关已删除模块的信息打印为标准错误</p>
<h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a><code>vendor</code></h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">mod</span> vendor [-v]</span><br></pre></td></tr></table></figure>

<p>用于重置主模块的 vendor 目录, 以使其包含主模块构建和测试所需要的所有包. 它不包括已 vendored 软件包的测试代码.</p>
<p><code>-v</code> 标志将已 vendored 模块和包因为到标准错误</p>
<h1 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a><code>go run</code></h1><p>编译并运行指定的 Go 主程序包</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">run</span> <span class="selector-attr">[build flags]</span> <span class="selector-attr">[-exec xprog]</span> <span class="selector-tag">package</span> <span class="selector-attr">[arguments...]</span></span><br></pre></td></tr></table></figure>

<p>通常, 该软件包被指定为来自单个目录的 .go 源文件列表, 但也可以是导入路径, 文件系统路径或模式匹配单个已知包.</p>
<p>默认情况下, <code>go run</code> 直接运行编译的二进制文件. 如果添加 <code>-exec</code> 标志, 那么 <code>go run</code> 使用 xprog 调用二进制文件. 如果未提供 <code>-exec</code> 标志, 则 GOOS 或 <code>GOARCH</code> 与系统不同的情况下, 可以找到名为 <code>go_$GOOS_$GOARCH_exec</code> 的程序文件</p>
<h1 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a><code>go test</code></h1><p>自动测试由导入路径命名的包, 输出测试结果的摘要信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> [build/<span class="built_in">test</span> flags] [packages] [build/<span class="built_in">test</span> flags &amp; <span class="built_in">test</span> binary flags]</span><br></pre></td></tr></table></figure>

<p><code>go test</code> 重新编译每个包以及文件名与 <code>*_test.go</code> 模式匹配的文件. 这些附加文件可以包含测试函数,压力测试和示例函数. 每个列出的包都会导致执行单独的测试二进制文件. 文件名以 <code>_</code> 或 <code>.</code> 开头的文件(包括<code>_test.go</code>)将被忽略</p>
<p>用后缀 <code>_test</code> 声明包的测试文件将被编译为单独的包, 然后与主测试二进制链接并运行. go 工具将会忽略名为 testdata 的目录, 使其可以保存测试所需的辅助数据</p>
<p>go test 有两种不同的运行模式:</p>
<ul>
<li>本地目录模式: 在没有指定 package 包参数的情况下调用 go test 采用的模式. 在此模式下, go test 编译当前目录中包的源码和测试文件, 然后运行生成的二进制测试文件. 在此模式下, 将禁用缓存. 测试完成后, 输出测试的摘要信息, 包括测试状态(ok 或 FAIL), 包名和测试时间</li>
<li>包列表模式: 在显示指定 package 包参数的情况下调用 go test 采用的模式. 在此模式下, go test 编译并测试命令行中列出的每个包, 如果测试通过, 则只输出 ok 摘要行. 否则, 输出完整的测试输出.</li>
</ul>
<p>在包列表模式下, go test 缓存成功的测试结果, 避免运行不必要的重复测试. </p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-args</code></td>
<td align="left">将命令行其余部分(-args 之后的所有内容)传递给测试二进制文件. 一般放在所有参数最后</td>
</tr>
<tr>
<td align="center"><code>-c</code></td>
<td align="left">将测试二进制文件编译为 <code>pkg.test</code>, 但不运行它(pkg 是包导入路径的最后一个元素). 可以使用 <code>-o</code> 更改文件名</td>
</tr>
<tr>
<td align="center"><code>-exec xprog</code></td>
<td align="left">使用 xprog 运行测试二进制文件</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="left">安装测试依赖项的包, 不运行测试</td>
</tr>
<tr>
<td align="center"><code>-json</code></td>
<td align="left">将测试输出转换为适合自动处理的 JSON 文本</td>
</tr>
<tr>
<td align="center"><code>-o file</code></td>
<td align="left">将测试二进制文件编译为指定命名的文件, 仍然运行测试(除非指定了 -c 或 -i)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之函数</title>
    <url>/2020/04/30/go-study-notes-func/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>关键字 <code>func</code> 用于定义函数. Go 语言中函数有以下特点:</p>
<ul>
<li>无须前置声明</li>
<li>不支持命名嵌套定义</li>
<li>不支持同名函数重载</li>
<li>不支持默认参数</li>
<li>支持不定长变参</li>
<li>支持多返回值</li>
<li>支持命名返回值</li>
<li>支持匿名函数和闭包</li>
</ul>
<p>一般来说,表示方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(函数参数)</span> <span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带参数</span></span><br><span class="line"><span class="comment">// `args... argsType` 本质上是一个切片, 表示可以传入多个参数, 该参数形式只能放在参数的最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">(arg argType, args ...argsType)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带返回值</span></span><br><span class="line"><span class="comment">// returnName 可省略, 返回值可以为逗号 `,` 分割的多个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">()</span> <span class="params">(returnName returnType)</span></span> &#123; </span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="comment">// 匿名函数只是没有名称, 其使用方式基本与普通函数没有区别, 多用于只调用一次或定义后立即调用的情况</span></span><br><span class="line">a := <span class="function"><span class="keyword">func</span> <span class="params">(arg argType)</span> <span class="params">(returnName returnType)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">FuncName(args)</span><br><span class="line">a(args)</span><br></pre></td></tr></table></figure>

<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>函数的参数可视作局部变量, 因此不能在相同层次定义同名变量</p>
<blockquote>
<p>函数的形参是指函数中定义的参数, 实参则是函数调用时所传递的参数.</p>
</blockquote>
<p>不管传入的参数是指针,引用类型,还是其它类型参数,都是值拷贝传递.区别在于是拷贝指针, 还是拷贝目标对象. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Change</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChangePtr</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *x = <span class="number">200</span></span><br><span class="line">    fmt.Println(*x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    Change(x)       <span class="comment">// 100</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    ChangePtr(&amp;x)   <span class="comment">// 200</span></span><br><span class="line">    fmt.Println(x)  <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不定长变参"><a href="#不定长变参" class="headerlink" title="不定长变参"></a>不定长变参</h2><p>变参本质上是一个切片,只能接收一到多个同类型的参数,且必须放在参数列表末尾</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `args... argsType` 本质上是一个切片, 表示可以传入多个参数, 该参数形式只能放在参数的最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">(arg argType, args ...argsType)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将切片作为变参传入函数时,需进行展开操作.如果是数组,则需要将其转化为切片. 切片作为引用类型, 其在函数中所做的一切操作会影响到底层的数据. 如果需要可以使用内置函数 <code>copy()</code> 复制底层数据.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> a &#123;</span><br><span class="line">        a[i] += <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">    s := arr[:]</span><br><span class="line">    scopy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(scopy, s)  <span class="comment">// 将切片 s 底层数据复制一份到 scopy</span></span><br><span class="line">    test(s...)</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><ul>
<li>有返回值的语句, 必须有明确的 <code>return</code> 终止语句</li>
<li>Go 函数支持多返回值模式</li>
<li>返回值在命名时, 其实已经在函数内部隐式创建了指定类型和名称的变量, 可当作局部变量使用, 且不能在函数体内对已经命名的返回值变量 <code>a</code> 使用形如 <code>a := xxx</code> 的变量定义表达式</li>
<li>返回值在命名时, 需要对全部返回值命名, 否则会编译出错</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出 0</span></span><br><span class="line">    a := <span class="number">10</span>        <span class="comment">// 报错,No new variables on left side of :=, 表示 a 不是一个新定义的变量, 只能使用 = 对其赋值</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>除没有名字外, 匿名函数与普通函数完全相同. 匿名函数可以直接被调用, 保存到变量, 作为参数或返回值</p>
<ul>
<li><p>直接执行或赋值给变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接执行</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;(<span class="string">"hello world"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值给变量</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span> <span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为参数传递</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作为返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add := test()</span><br><span class="line">    fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>示例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := test(<span class="number">123</span>)</span><br><span class="line">    f()  <span class="comment">// 输出 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就上述代码而言, <code>test</code> 返回的匿名函数会引用上下文环境变量 <code>x</code>. 当该函数在 <code>main</code> 中执行时, 它依然可以读取 <code>x</code> 的值, 这种现象就称作闭包.</p>
<p>闭包通过指针引用环境变量, 那么可能导致其生命周期延长, 还有可能发生 “延迟求值”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(&amp;i, i)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> test() &#123;</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// 0xc000062090 2</span></span><br><span class="line"><span class="comment">// 0xc000062090 2</span></span><br></pre></td></tr></table></figure>

<p>在以上示例中, for 循环复用局部变量 i, 每次添加的匿名函数引用的变量是同一变量. 添加仅仅是将匿名函数放入列表, 并未执行. 因此在 main 函数调用这些函数时, 它们读取的是环境变量 i 最后一次循环时的值,为 2.</p>
<p>解决方法就是每次使用不同的环境变量或传参复制, 让各自的闭包环境各不相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        x := i <span class="comment">// x 在每次循环都重新定义</span></span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(&amp;x, x)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="defer-语句延迟调用"><a href="#defer-语句延迟调用" class="headerlink" title="defer 语句延迟调用"></a><code>defer</code> 语句延迟调用</h1><ul>
<li><code>defer</code> 语句定义的语句直到当前函数执行结束前在被执行, 常用于资源释放, 解除绑定, 错误处理等操作. 多个 <code>defer</code> 语句会按照”先进后出”(FILO)的次序执行. </li>
<li><code>defer</code> 语句定义的语句会被延迟调用, 其中传入的参数被复制并被缓存起来. 调用时使用的参数为 <code>defer</code> 语句定义时的参数值. 如</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"传入 defer 语句中 a b 值分别为 "</span>, a, b)  <span class="comment">// 只有传入的参数保存了当时的状态</span></span><br><span class="line">		fmt.Println(<span class="string">"不以 defer 语句参数方式输出 x y 值分别为"</span>, x, y)</span><br><span class="line">    &#125;(x, y)</span><br><span class="line">	x += <span class="number">100</span></span><br><span class="line">	y += <span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">"函数结束前 x y 值为"</span>, x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下:</span></span><br><span class="line"><span class="comment">// 函数结束前 x y 值为 101 102</span></span><br><span class="line"><span class="comment">// 传入 defer 语句中 a b 值分别为  1 2</span></span><br><span class="line"><span class="comment">// 不以 defer 语句参数方式输出 x y 值分别为 101 102</span></span><br></pre></td></tr></table></figure>

<h2 id="误用"><a href="#误用" class="headerlink" title="误用"></a>误用</h2><p><code>defer</code> 语句在函数结束时才被执行. 不合理的使用方式会浪费资源.</p>
<p>如下案例是在 for 循环中不恰当使用 <code>defer</code> 语句导致文件关闭时间延长</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		path := fmt.Sprintf(<span class="string">"log/%d.txt"</span>, i)</span><br><span class="line">		file, err := os.Open(path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 这个文件关闭操作在 main 函数结束时才会执行,而不是在当前循环结束后执行</span></span><br><span class="line">		<span class="keyword">defer</span> file.Close()</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们应该将带有 <code>defer</code> 语句的循环体重构为函数,在循环中调用. 这样, 在每次循环执行后, <code>defer</code> 语句都会被执行一次, 即时释放资源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">		path := fmt.Sprintf(<span class="string">"log/%d.txt"</span>, n)</span><br><span class="line">		file, err := os.Open(path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 这个文件关闭操作在该函数结束时调用</span></span><br><span class="line">		<span class="keyword">defer</span> file.Close()</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        do()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="error"><a href="#error" class="headerlink" title="error"></a><code>error</code></h2><p>官方推荐的做法是返回 <code>error</code></p>
<p>标准库将 <code>error</code> 定义为接口类型, 以便实现自定义错误类型. 我们在自定义错误类型时, 只需实现该接口即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Go 内置的 error 接口</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Error</span></span><br><span class="line"><span class="keyword">type</span> DivError <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(divError *DivError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> divError.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库也提供了创建 <code>error</code> 的函数, 可以方便地创建包含错误文本的 <code>error</code> 对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">"some description for error"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="panic-revover-内置函数"><a href="#panic-revover-内置函数" class="headerlink" title="panic(), revover() 内置函数"></a><code>panic()</code>, <code>revover()</code> 内置函数</h2><ul>
<li><code>panic()</code> 内置函数接收 <code>interface</code> 作为参数, 会立即中断当前函数流程, 执行延迟调用并将 <code>panice</code> 向外传递</li>
<li><code>revover()</code> 内置函数返回 <code>interface</code> 对象, 多用于捕获 <code>panic()</code> 函数引发的错误. <strong>该函数必须在延迟调用函数中才能正常工作</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">catch</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">recover</span>()</span><br><span class="line">	fmt.Println(<span class="string">"捕获成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> catch()                <span class="comment">// 捕获成功</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>()) <span class="comment">// 捕获失败</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">recover</span>()              <span class="comment">// 捕获失败</span></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之方法</title>
    <url>/2020/04/30/go-study-notes-method/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>方法是与对象实例绑定的特殊函数. 方法与函数定义的语法区别在于前者有前置实例接收参数, 编译器以此确定方法所属类型. 一般来说定义方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> structName <span class="keyword">struct</span>&#123;</span><br><span class="line">    fieldName fieldType</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver structName)</span> <span class="title">MethodName</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    <span class="comment">// func expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点和注意事项如下:</p>
<ul>
<li>可以为当前包,已经除接口和指针以外的任何类型定义方法</li>
<li>方法被看作特殊的函数, 同样不支持重载, receiver 类型可以是基础类型或指针类型, 这关系到调用时对象实例是否被复制</li>
<li>可以使用实例值或指针值调用方法, 编译器会根据方法 receiver 类型自动在基础实例和指针类型间转换</li>
<li>对于结构体嵌套, 外层结构体可以直接重载或直接调用内层结构体的方法</li>
</ul>
<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;</span><br><span class="line">    N</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">value</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n++</span><br><span class="line">	fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span> <span class="title">pointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	(*n)++</span><br><span class="line">	fmt.Printf(<span class="string">"%p, %v\n"</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n N = <span class="number">20</span></span><br><span class="line">	n.value()                     <span class="comment">// 0xc00000a0d0, 21</span></span><br><span class="line">	fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;n, n) <span class="comment">// 0xc00000a0b8 ,20</span></span><br><span class="line">	n.pointer()                   <span class="comment">// 0xc00000a0b8,21</span></span><br><span class="line">	fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;n, n) <span class="comment">// 0xc00000a0b8, 21</span></span><br><span class="line">    </span><br><span class="line">	s := S&#123;<span class="number">23000</span>&#125;</span><br><span class="line">	s.value()                     <span class="comment">// 0xc00000a120, 23001</span></span><br><span class="line">	fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;s, s) <span class="comment">// 0xc00000a118, &#123;23000&#125;</span></span><br><span class="line">	s.pointer()                   <span class="comment">// 0xc00000a118, 23001</span></span><br><span class="line">	fmt.Printf(<span class="string">"%p, %v\n"</span>, &amp;s, s) <span class="comment">// 0xc00000a118, &#123;23001&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>面向对象的三大特征 “封装”, “继承” “多态”, Go 仅实现了部分特征, 它更倾向于 “组合优于继承” 这种思想. 将模块分解成相互独立的更小单元, 分别处理不同方面的需求, 最后以匿名嵌入方式组合到一起, 共同实现对外接口. 而其简短一致的调用方式, 更是隐藏了内部实现细节.</p>
</blockquote>
<h2 id="方法转化为表达式"><a href="#方法转化为表达式" class="headerlink" title="方法转化为表达式"></a>方法转化为表达式</h2><p>方法和函数一样, 除直接调用外, 还可以作为参数传递, 依照具体引用方式不同, 可以分为 expression 和 value 两种状态.</p>
<h2 id="表达式类型"><a href="#表达式类型" class="headerlink" title="表达式类型"></a>表达式类型</h2><p>通过类型引用的 method expression 会被还原为普通函数样式, receiver 是第一参数, 需要显示传参. 至于类型, 可以是 T 或 *T.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">    fmt.Printf(<span class="string">"main.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">    f1 := N.test        <span class="comment">// 也可以直接调用 N.test(n)</span></span><br><span class="line">    f1(n)</span><br><span class="line">    f2 := (*N).test     <span class="comment">// 也可以直接调用 (*N).test(&amp;n)</span></span><br><span class="line">    f2(&amp;n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// main.n: 0xc00000a0b8, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a0f0, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a100, 25</span></span><br></pre></td></tr></table></figure>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul>
<li>基于实例或指针引用的 method value, 依旧按照正常方式调用. 但当 method value 被赋值给变量或作为参数传递时, 会立即计算并<strong>复制</strong>该方法执行所需的 receiver 对象, 并与其绑定. 在后续调用时, 能够隐式传入 receiver 对象</li>
<li>如果目标方法的 receiver 是指针类型, 那么被复制的仅是指针. 会在调用时寻找该指针指向的对象, 所以传入的对象参数为调用时的上下文中的对象</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">value</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *n)</span> <span class="title">pointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">	p := &amp;n</span><br><span class="line">	n++  <span class="comment">// 101</span></span><br><span class="line">	f1 := n.value       <span class="comment">// 记录此时上下文中变量 n 的状态,并以此状态复制后一个新的对象, 将该对象隐式传入到 test 函数</span></span><br><span class="line">    f3 := n.pointer     <span class="comment">// 记录并复制此时上下文中变量 n 的指针 &amp;n</span></span><br><span class="line">	n++  <span class="comment">// 102</span></span><br><span class="line">	f2 := p.value       <span class="comment">// 记录此时上下文中指针 p 指向的内存地址对象, 并以此地址状态复制后一个新的内存地址对象, 将该对象隐式传入到 test 函数</span></span><br><span class="line">    f4 := m.pointer     <span class="comment">// 记录并复制此时上下文中变量 n 的指针 &amp;n</span></span><br><span class="line">	n++  <span class="comment">// 103</span></span><br><span class="line">	fmt.Printf(<span class="string">"main.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">	f1()</span><br><span class="line">    f3()    <span class="comment">// 达到延迟调用的效果 *n = 103</span></span><br><span class="line">	f2()</span><br><span class="line">    f4()    <span class="comment">// 达到延迟调用的效果 *n = 103</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// main.n: 0xc00000a0b8, 103</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a100, 101</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a0b8, 103</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a118, 102</span></span><br><span class="line"><span class="comment">// test.n: 0xc00000a0b8, 103</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之接口</title>
    <url>/2020/04/30/go-study-notes-interface/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一般来说, 定义方式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interfaceName <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 方法名(参数列表) (返回值列表)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口内如果没有方法声明, 则该接口为空接口(<code>interface{}</code>). 空接口是所有类型均实现的接口, 可被赋值为任何类型的对象</li>
<li>接口的结构体内不能有字段</li>
<li>只能声明方法, 不能实现, 不能包含任何方法体</li>
<li>可嵌入其它接口类型, 相当于将其其它接口申明的方法集导入, 这要求不能有同名方法.</li>
<li>目标类型必须定义了接口中包含的全部方法才算实现了该接口. 如果两个接口定义的方法相同, 且目标类型实现了其中方法, 则该类型同时实现了两个接口</li>
<li>通过 <code>var i1 = interface{}</code> 声明的接口, 默认值为 <code>nil</code></li>
<li>将对象赋值给接口变量时, 会复制该对象, 此时不能通过接口修改原始对象的值; 将对象指针赋值给接口, 那么接口内存储的就是指针的复制品, 可以通过接口修改原始对象的值</li>
</ul>
<h1 id="类型转换-断言"><a href="#类型转换-断言" class="headerlink" title="类型转换/断言"></a>类型转换/断言</h1><p>类型推断可将接口变量转换为原始类型, 或判断是否实现了某个更具体的接口类型. 一般来说类型推断表达式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type, ok := x.(Type)    <span class="comment">// 判断是否可以转换为原始类型</span></span><br><span class="line">Type, ok := x.(interfaceName)  <span class="comment">// 判断是否实现某个接口</span></span><br></pre></td></tr></table></figure>

<p>示例代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> interfaceName <span class="keyword">interface</span> &#123;</span><br><span class="line">	test() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n N = <span class="number">100</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = n</span><br><span class="line">    <span class="comment">// 在 `switch` 语句中使用 `x.(type)` 对 x 类型进行判断</span></span><br><span class="line">    <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    	fmt.Println(<span class="string">"nil"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">string</span>, N:</span><br><span class="line">    	fmt.Println(x)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">string</span>:</span></span><br><span class="line">    	fmt.Println(<span class="string">"func"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	fmt.Println(<span class="string">"unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 x 是否可以转换为 N 类型</span></span><br><span class="line">	<span class="keyword">if</span> n, ok := x.(N); ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%T, %v\n"</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 判断 n 是否也实现了 interfaceName 接口</span></span><br><span class="line">	<span class="keyword">if</span> n, ok := x.(interfaceName); ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%T, %v\n"</span>, n, n)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 bufio 包</title>
    <url>/2020/05/02/go-study-notes-package-bufio/</url>
    <content><![CDATA[<p><code>bufio</code> 包实现了缓冲的 IO. 它包含分别实现 <code>io.Reader()</code> 和 <code>io.Writer()</code> 接口的 <code>Reader</code> 和 <code>Writer</code>对象,提供了 IO 缓冲区和文本类型 IO 的一些支持.导入方式为 <code>import &quot;bufio&quot;</code></p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader 是实现了 `io.Reader` 接口的缓冲对象</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer 是实现了 `io.Writer` 接口的缓冲对象.</span></span><br><span class="line"><span class="comment">// 如果在写入 Writer 时发生错误,将不再接收数据,所有后续写入和 `Flush()`` 都将返回错误</span></span><br><span class="line"><span class="comment">// 写入所有数据后,客户端应显示调用 `Flush()` 方法确保所有数据都发送到基本 `io.Writer`</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scanner 提供了一些方便的接口来扫描缓冲区数据,如用换行符分隔行的文件.</span></span><br><span class="line"><span class="comment">// 通过连续调用 `Scan()` 方法将逐步浏览文件 'token'(文件内容),并跳过 token 之间的字节.token 的规范是由 `SplitFunc` 类型的分割函数定义的.默认的分割函数将输入分割成行,并去掉行尾的换行标志.</span></span><br><span class="line"><span class="comment">// 预定义的分割函数可以将输入分割成行,字节,unicode,空白分隔的 word.调用者可以定制自己的分割函数</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 需要更多对错误管理的控制或 token 很大,或必须从 reader 连续读取的程序,应使用 `bufio.Reader`代替</span></span><br><span class="line"><span class="keyword">type</span> Scanner <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于 Scanner 做词法分析的分割函数</span></span><br><span class="line"><span class="comment">// 函数的返回值是每次扫描的长度,分割后的字符(token)的切片表示及可能发生的错误</span></span><br><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h1 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 用于缓冲一个 token,实际需要的最大 token 尺寸可能小一些,例如缓冲中需要保存一整行内容</span></span><br><span class="line">    MaxScanTokenSize = <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="bufio-包函数"><a href="#bufio-包函数" class="headerlink" title="bufio 包函数"></a><code>bufio</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个带有默认大小缓冲区的 `Reader` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="comment">// 返回一个带有指定大小缓冲区的 `Reader` 对象,默认值为 4096,最小值为 16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="comment">// 返回一个带有默认大小缓冲区的 `Writer` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// 返回一个带有指定大小缓冲区的 `Writer` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// 使用 Reader,Writer 对象创建一个新的 ReadWriter 对象 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReadWriter</span><span class="params">(r *Reader, w *Writer)</span> *<span class="title">ReadWriter</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下预定义函数用于 `scanner.Split()` 参数传递,是 Scanner 的分割函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区数据流按照字节分割作为 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanBytes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲区数据流按照 runes 分割作为 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanRunes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲区数据流按照单词分割作为 token,分割符号为空白字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanWords</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲区数据流按行分割作为 token,分割符号为 '\n'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanLines</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Reader-结构体方法"><a href="#Reader-结构体方法" class="headerlink" title="Reader 结构体方法"></a><code>Reader</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 丢弃缓冲区中的数据,清除任何错误,将 b 设置为从 r 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Reset</span><span class="params">(r io.Reader)</span></span></span><br><span class="line"><span class="comment">// 返回缓冲区现有的可读取的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回缓冲区的下 n 个字节及可能发生的错误.此函数不会移动读取指针位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 读取缓冲区数据写入到 p.返回写入 p 的字节数及可能发生的错误.读取到结尾时,n 为 0 且 err 为 io.EOF</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 读取缓冲区数据并返回一个字节及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按行读取,返回读取到的 byte 切片(不包括行尾换行符号),是否未读到行尾及发生的错误</span></span><br><span class="line"><span class="comment">// 如果行超过缓冲区大小,则一次只读取缓冲区大小的数据,且 isPrefix 为 true.本行的剩下的数据留作下一次读取,直到行读取结束,isPrefix 返回 false</span></span><br><span class="line"><span class="comment">// 多使用 `ReadBytes('\n')` 或 `ReadString('\n')` 方法代替</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 读取数据遇到 delim 字符.返回读取的字符切片及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 读取缓冲区数据直到遇到 delim 字符.返回读取到的字符串表示及可能发生的错误.实际是调用了 ReadBytes 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将缓冲数据流写入到 w</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Writer-结构体方法"><a href="#Writer-结构体方法" class="headerlink" title="Writer 结构体方法"></a><code>Writer</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span>  // 丢弃缓冲中的数据,清除任何错误,将 <span class="title">b</span> 设置为向 <span class="title">w</span> 写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span>  // 返回缓冲中现有的可写入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span>  // 将 <span class="title">p</span> 的内容写入缓冲.返回写入的字节数及可能发生的错误.如果 <span class="title">nn</span> &lt; <span class="title">len</span><span class="params">(p)</span>,<span class="title">err</span> 不为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span>  // 将 <span class="title">s</span> 写入缓冲.返回写入的字节数及可能发生的错误.如果 <span class="title">nn</span> &lt; <span class="title">len</span><span class="params">(p)</span>,<span class="title">err</span> 不为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span>  // 将单个字节 <span class="title">c</span> 写入缓冲,返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span>  // 将缓冲区数据持久化到文件中.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span>  // 实现 `<span class="title">io</span>.<span class="title">ReaderFrom</span>` 接口.从 <span class="title">r</span> 中读取数据到缓冲区</span></span><br></pre></td></tr></table></figure>

<h2 id="Scanner-结构体方法"><a href="#Scanner-结构体方法" class="headerlink" title="Scanner 结构体方法"></a><code>Scanner</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 Scanner 的分割函数.必须在 `Scan()` 之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Split</span><span class="params">(split SplitFunc)</span></span></span><br><span class="line"><span class="comment">// 获取当前位置的 token.让 Scanner 的扫描位置移动到下一个 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Scan</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 返回字符切片格式的最近一次 `Scan()` 方法调用生成的 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="comment">// 返回字符串格式的最近一次 `Scan()` 方法调用生成的 token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Text</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回 Scanner 扫描过程中发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>现有一文件 <code>filename</code> 内容如下:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line"><span class="keyword">the</span> <span class="keyword">second</span> <span class="built_in">line</span>: nice <span class="built_in">to</span> meet you</span><br><span class="line"><span class="keyword">the</span> <span class="keyword">third</span> <span class="built_in">line</span>: see you next <span class="built_in">time</span></span><br></pre></td></tr></table></figure>

<h2 id="bufio-读写示例"><a href="#bufio-读写示例" class="headerlink" title="bufio 读写示例"></a><code>bufio</code> 读写示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `bufio.Writer.WriteString()` 方法使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriterExample</span><span class="params">(bw *bufio.Writer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> bw.Flush() <span class="comment">// 需要显式将缓冲区中数据持久化到文件</span></span><br><span class="line">    bw.WriteString(<span class="string">"this new add line\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `bufio.Reader.ReadLine()` 方法使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadLineExample</span><span class="params">(br *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, isPrefix, err := br.ReadLine()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> isPrefix &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"该行未结束,读到内容为: %v"</span>, <span class="keyword">string</span>(line))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"该行结束,读到或剩余内容为: %v"</span>, <span class="keyword">string</span>(line))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println() <span class="comment">// 读取内容行尾的换行符不被保留,需手动换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `bufio.Reader.ReadString()` 方法使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadStringExample</span><span class="params">(br *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := br.ReadString(<span class="string">'\n'</span>) <span class="comment">// 使用 ReadString 按行读取</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            fmt.Print(line) <span class="comment">// 最后一行若没有换行符号,err 为 io.EOF,需要打印最后一行</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">"filename"</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"err"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    br := bufio.NewReaderSize(reader, <span class="number">16</span>) <span class="comment">// 设置为最小缓冲区,用于演示效果</span></span><br><span class="line">    ReadLineExample(br)</span><br><span class="line">    file.Seek(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment">// 将文件指针移到开始位置</span></span><br><span class="line">    fmt.Println(<span class="string">"------"</span>)</span><br><span class="line">    ReadStringExample(br)</span><br><span class="line">    file.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    bw := bufio.NewWriter(file)</span><br><span class="line">    WriterExample(bw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为以下内容: </span></span><br><span class="line"><span class="comment">// 该行结束,读到或剩余内容为: hello</span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为: the second line:</span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为:  nice to meet yo</span></span><br><span class="line"><span class="comment">// 该行结束,读到或剩余内容为: u</span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为: the third line: </span></span><br><span class="line"><span class="comment">// 该行未结束,读到内容为: see you next tim</span></span><br><span class="line"><span class="comment">// 该行结束,读到或剩余内容为: e</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// the second line: nice to meet you</span></span><br><span class="line"><span class="comment">// the third line: see you next time</span></span><br></pre></td></tr></table></figure>
<p>通过以上示例可以看到:</p>
<ul>
<li><code>ReadLine()</code> 超过缓冲区大小的数据被分为多次读取,且行尾的换行符不被保留</li>
<li>文件增加 “this new add line\n” 内容</li>
</ul>
<h2 id="bufio-Scanner-扫描示例"><a href="#bufio-Scanner-扫描示例" class="headerlink" title="bufio.Scanner 扫描示例"></a><code>bufio.Scanner</code> 扫描示例</h2><ul>
<li><p>统计单词个数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    scanner.Split(bufio.ScanWords) <span class="comment">// 为 scanner 设置分割函数</span></span><br><span class="line">    <span class="comment">// 统计单个个数</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintln(os.Stderr, <span class="string">"reading input:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用自定义分割函数</p>
</li>
</ul>
<p>如下示例尝试将分割分割的字符串转换为数字格式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"1234 5678 5681 1234567890123456"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    <span class="comment">// 创建自定义分割函数</span></span><br><span class="line">    split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        advance, token, err = bufio.ScanWords(data, atEOF)  <span class="comment">// 获取到以空格分割的 token</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; token != <span class="literal">nil</span> &#123;</span><br><span class="line">            _, err = strconv.ParseInt(<span class="keyword">string</span>(token), <span class="number">10</span>, <span class="number">32</span>)  <span class="comment">// 尝试转换为十进制数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置分割函数为自定义的分割函数 split</span></span><br><span class="line">    scanner.Split(split)</span><br><span class="line">    <span class="comment">// 开始扫描,并打印扫描到的文本</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Invalid input: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 context 包</title>
    <url>/2020/05/04/go-study-notes-package-context/</url>
    <content><![CDATA[<p>context 包定义了 Context 类型,该类型在 API 边界之间及进程基建传递截止日期,取消信号和其它请求范围的信息.导入方式为 <code>import context</code></p>
<p>向服务发送请求应该创建一个 <code>Context</code> 上下文对象,而对服务的传出调用应该接受一个上下文对象.它们之间的函数调用链必须传播 <code>Context</code>,可以使用 <code>WithCancel</code>, <code>WithDeadline</code>,<code>WithTimeout</code> 或 <code>WithValue</code> 创建派生上下文作为替换.取消上下文后,从该上下文派生的所有上下文也会被取消</p>
<blockquote>
<p>应用场景：在 Go http 包的 Server 中,每一个请求在都有一个对应的 goroutine 去处理.请求处理函数通常会启动额外的 goroutine 用来访问后端服务,比如数据库和 RPC 服务.用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据,比如终端用户的身份认证信息,验证相关的 token,请求的截止时间等.当一个请求被取消或超时时,所有用来处理该请求的 goroutine 都应该迅速退出,然后系统才能释放这些 goroutine 占用的资源</p>
</blockquote>
<p><code>WithCancel</code>,<code>WithDeadline</code> 和 <code>WithTimeout</code> 函数接受 Context(parent)对象并返回派生的 <code>Context</code>(child)对象和 <code>CancelFunc</code>.调用 <code>CancelFunc</code> 会取消该子上下文及其子上下文,删除 parent 上下文对 child 上下文的引用,并停止所有关联计时器.</p>
<h1 id="遵循规则"><a href="#遵循规则" class="headerlink" title="遵循规则"></a>遵循规则</h1><p>使用 Contexts 上下文的程序都应该遵循以下规则,使各个包之间的接口保持一致:</p>
<ul>
<li>不要将上下文存储在结构体类型,而是将上下文显式传递给需要它的函数.且 Context 应该是第一个参数,通常命名为 <code>ctx</code>:<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... use ctx ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>即使函数支持,也不要传递 nil 上下文对象.如果不确定使用哪个上下文,请使用 <code>context.TODO</code></li>
<li>仅将上下文中的值用于传递过程和 API 的请求范围的数据,而不是作为可选参数传递给函数</li>
<li>可以将相同的上下文传递给在不同 goroutine 中运行的函数.上下文对于由多个 goroutine 同时使用是安全的</li>
</ul>
<h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消函数,会取消其上下文.多个 goroutine 可同时调用 CancelFunc,在第一个调用之后,随后对其调用将什么也不做</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文接口</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回取消该上下文的时间.如果未设置截止日期,则 ok 返回 false</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 返回一个取消此上下文或超时的通道</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 如果 Done() 返回的通道尚未关闭,返回 nil.否则返回非 nil 错误,用于解释原因</span></span><br><span class="line">    Err() error</span><br><span class="line">    <span class="comment">// 返回指定上下文中指定 key 的值.如果没有则返回 nil</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回具有新 Done 通道的 parent 上下文副本.</span></span><br><span class="line"><span class="comment">// 当调用返回的 cancel 函数或关闭 parent 上下文的 Done 通道时,关闭返回的上下文的 Done 通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回带有取消时间的 parent 上下文的副本</span></span><br><span class="line"><span class="comment">// 如果 parent 上下文的截止时间早于 d,则该函数返回的上下文在语义上等同于 parent.</span></span><br><span class="line"><span class="comment">// 当截止时间到期,调用返回的 cancel 函数或关闭 parent 上下文的 Done 通道时,将关闭返回的上下文的 Done 通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 WithDeadline(parent, time.Now().Add(timeout)),返回带有超时时间的 parent 上下文副本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个非空 Context 上下文,它永远不会被取消.它通常用于主函数,初始化和测试,用作传入请求的顶级上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个非空 Context 上下文,当不清楚要使用哪个上下文或尚不可用时,应使用 `context.TODO`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与 parent 上下文关联的副本,其中包含 key=val 变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 encoding 包</title>
    <url>/2020/05/15/go-study-notes-package-encoding/</url>
    <content><![CDATA[<p><code>encoding</code> 包定义了其它包共享的接口,其子包实现了数据与字节表示形式和文本形式的互相转换,主要包括:</p>
<ul>
<li><code>encoding/bash64</code> 实现了bas64 格式编码与解码.</li>
<li><code>encoding/json</code> 实现了 json 格式数据的编码与解码.</li>
<li><code>encoding/pem</code> 实现了 PEM 数据编码,常用于 TLS 密钥和证书中</li>
<li><code>encoding/xml</code> 实现了 xml 格式数据的编码与解码</li>
</ul>
<h1 id="encoding-base64-包"><a href="#encoding-base64-包" class="headerlink" title="encoding/base64 包"></a><code>encoding/base64</code> 包</h1><h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> encodeStd = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span></span><br><span class="line"><span class="keyword">const</span> encodeURL = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StdPadding <span class="keyword">rune</span> = <span class="string">'='</span> <span class="comment">// 标准填充字符</span></span><br><span class="line">    NoPadding  <span class="keyword">rune</span> = <span class="number">-1</span>  <span class="comment">// 不填充</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 未填充的标准原生编码格式</span></span><br><span class="line"><span class="keyword">var</span> RawStdEncoding = StdEncoding.WithPadding(NoPadding)</span><br><span class="line"><span class="comment">// 未填充的 URL 编码格式,常用于 URL 或文件名中</span></span><br><span class="line"><span class="keyword">var</span> RawURLEncoding = URLEncoding.WithPadding(NoPadding)</span><br><span class="line"><span class="comment">// 标准原生编码格式</span></span><br><span class="line"><span class="keyword">var</span> StdEncoding = NewEncoding(encodeStd)</span><br><span class="line"><span class="comment">// 标准 URL 编码格式,常用于 URL 或文件名中</span></span><br><span class="line"><span class="keyword">var</span> URLEncoding = NewEncoding(encodeURL)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul>
<li>包函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回给定字母定义的填充 Encoding 对象,可以使用该对象的 WithPadding 方法修改填充字符或禁用填充字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoding</span><span class="params">(encoder <span class="keyword">string</span>)</span> *<span class="title">Encoding</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Encoding</code> 结构体方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对已编码的数据 src 进行解码,最多将 DecodedLen(len(src)) 个字节写入 dst</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">Decode</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 对已编码后的 s 进行解码,返回解码后的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">DecodeString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 对数据 src 进行编码,最多将 DecodedLen(len(src)) 个字节写入 dst</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">Encode</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span></span><br><span class="line"><span class="comment">// 对数据 src 进行编码,返回编码后的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span> <span class="title">EncodeToString</span><span class="params">(src []<span class="keyword">byte</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 修改填充字符或禁用填充字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc Encoding)</span> <span class="title">WithPadding</span><span class="params">(padding <span class="keyword">rune</span>)</span> *<span class="title">Encoding</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/base64"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dataForEncoding := []<span class="keyword">byte</span>(<span class="string">"string for encoding"</span>)</span><br><span class="line">	strAfterEncode := base64.StdEncoding.EncodeToString(dataForEncoding)</span><br><span class="line">    fmt.Println(strAfterEncode)</span><br><span class="line">    </span><br><span class="line">    strForDecode := <span class="string">"c29tZSBkYXRhIHdpdGggACBhbmQg77u/"</span></span><br><span class="line">	dataAfterDecode, err := base64.StdEncoding.DecodeString(strForDecode)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%q\n"</span>, dataAfterDecode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="encoding-json-包"><a href="#encoding-json-包" class="headerlink" title="encoding/json 包"></a><code>encoding/json</code> 包</h1><p><code>encoding/json</code> 实现了 json 格式数据的编码与解码.主要用于对象实例与 JSON 格式数据间的相互转换.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将对象实例转换为 JSON 格式数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将对象实例转换为 JSON 格式数据,每个 JSON 元素以新的缩进行及 prefix 开头,且根据嵌套深度跟一个或多个 indent 副本,可用于美化输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将 JSON 格式数据转换为对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>当结构体定义时,字段带有 <code>json: &quot;jsonField&quot;</code> 格式的标签,则会按照 <code>jsonField</code> 名称解析对象字段.示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span>      <span class="string">`json:"id"`</span></span><br><span class="line">	Name   <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">	Colors []<span class="keyword">string</span> <span class="string">`json:"colors"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	group := ColorGroup&#123;</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Name:   <span class="string">"Reds"</span>,</span><br><span class="line">		Colors: []<span class="keyword">string</span>&#123;<span class="string">"Crimson"</span>, <span class="string">"Red"</span>, <span class="string">"Ruby"</span>, <span class="string">"Maroon"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	b, err := json.MarshalIndent(group, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	os.Stdout.Write(b)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	color := []<span class="keyword">byte</span>(<span class="string">`&#123;"id":2,"name":"Greens","colors":["Crimson","Green"]&#125;`</span>)</span><br><span class="line">	<span class="keyword">var</span> colorGroup ColorGroup</span><br><span class="line">	err = json.Unmarshal(color, &amp;colorGroup)</span><br><span class="line">	fmt.Println(colorGroup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="encoding-pem-包"><a href="#encoding-pem-包" class="headerlink" title="encoding/pem 包"></a><code>encoding/pem</code> 包</h1><p><code>pem</code> 包实现了 PEM 数据编码,常用于 TLS 密钥和证书中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以用于 PEM 编码的结构体,编码后格式如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-----BEGIN Type-----</span></span><br><span class="line"><span class="comment">Headers</span></span><br><span class="line"><span class="comment">base64-encoded Bytes</span></span><br><span class="line"><span class="comment">-----END Type-----</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="keyword">string</span>            <span class="comment">// The type, taken from the preamble (i.e. "RSA PRIVATE KEY").</span></span><br><span class="line">    Headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// Optional headers.</span></span><br><span class="line">    Bytes   []<span class="keyword">byte</span>            <span class="comment">// The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 b PEM 编码后的数据写入 out</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(out io.Writer, b *Block)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 对 PEM 编码后的数据进行解码,返回 Block 对象,一般带有 TLS 私钥或公钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(p *Block, rest []<span class="keyword">byte</span>)</span></span></span><br></pre></td></tr></table></figure>


<h1 id="encoding-xml-包"><a href="#encoding-xml-包" class="headerlink" title="encoding/xml 包"></a><code>encoding/xml</code> 包</h1><p>与 <code>encoding/json</code> 类似,<code>encoding/xml</code> 实现了 xml 格式数据的编码与解码.主要用于对象实例与 xml 格式数据间的相互转换.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将对象实例转换为 xml 格式数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将对象实例转换为 xml 格式数据,每个 xml 元素以新的缩进行及 prefix 开头,且根据嵌套深度跟一个或多个 indent 副本,可用于美化输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 将 xml 格式数据转换为对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>当结构体定义时,字段带有 <code>xml: &quot;xmlField&quot;</code> 格式的标签,则会按照 <code>xmlField</code> 名称解析对象字段.示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/xml"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	City, State <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName   xml.Name <span class="string">`xml:"person"`</span></span><br><span class="line">	Id        <span class="keyword">int</span>      <span class="string">`xml:"id,attr"`</span></span><br><span class="line">	FirstName <span class="keyword">string</span>   <span class="string">`xml:"name&gt;first"`</span></span><br><span class="line">	LastName  <span class="keyword">string</span>   <span class="string">`xml:"name&gt;last"`</span></span><br><span class="line">	Age       <span class="keyword">int</span>      <span class="string">`xml:"age"`</span></span><br><span class="line">	Height    <span class="keyword">float32</span>  <span class="string">`xml:"height,omitempty"`</span></span><br><span class="line">	Married   <span class="keyword">bool</span></span><br><span class="line">	Address</span><br><span class="line">	Comment <span class="keyword">string</span> <span class="string">`xml:",comment"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	person := &amp;Person&#123;Id: <span class="number">13</span>, FirstName: <span class="string">"John"</span>, LastName: <span class="string">"Doe"</span>, Age: <span class="number">42</span>&#125;</span><br><span class="line">	person.Comment = <span class="string">" Need more details. "</span></span><br><span class="line">	person.Address = Address&#123;<span class="string">"Hanga Roa"</span>, <span class="string">"Easter Island"</span>&#125;</span><br><span class="line"></span><br><span class="line">	output, err := xml.MarshalIndent(person, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	os.Stdout.Write(output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 crypto 包</title>
    <url>/2020/05/05/go-study-notes-package-crypto/</url>
    <content><![CDATA[<h1 id="crypto-包"><a href="#crypto-包" class="headerlink" title="crypto 包"></a><code>crypto 包</code></h1><p>crypto 包包含了通用加密算法的集合,提供了一些加密过程中基本对象的封装或基本接口的定义.导入方式为 <code>import &quot;crypto&quot;</code>.</p>
<p>当前我们项目中常用的加解密的方式无非三种.</p>
<ul>
<li>对称加密: 加解密都使用的是同一个密钥,其中的代表就是 AES,DES(已被攻破)</li>
<li>非对加解密: 加解密使用不同的密钥,其中的代表就是 RSA</li>
<li>签名算法: 主要用于验证,防止信息被修改,多用于文件校验,数字签名,鉴权协议的等,其中算法主要有 MD5,SHA1,HMAC 等</li>
</ul>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>它主要包含如下加密过程中的基本类型定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decrypter 是非公开私钥的接口,可用于非对称解密操作.一个示例是保存在硬件模块中的 RSA 密钥</span></span><br><span class="line"><span class="keyword">type</span> Decrypter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回与非公开私钥相对应的公钥</span></span><br><span class="line">    Public() PublicKey</span><br><span class="line">    <span class="comment">// 解密 msg.opts 参数应该是所使用的加密算法函数.详情参见每个实现文档</span></span><br><span class="line">    Decrypt(rand io.Reader, msg []<span class="keyword">byte</span>, opts DecrypterOpts) (plaintext []<span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DecrypterOpts <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash 标识在其它包中实现的加密哈希函数</span></span><br><span class="line"><span class="keyword">type</span> Hash <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示未指定算法的私钥</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示未指定算法的公钥</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signer 是非公开私钥的接口,可用于签名操作.</span></span><br><span class="line"><span class="keyword">type</span> Signer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回与非公开私钥相对应的公钥</span></span><br><span class="line">    Public() PublicKey</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用私钥对 digest 进行签名</span></span><br><span class="line">    Sign(rand io.Reader, digest []<span class="keyword">byte</span>, opts SignerOpts) (signature []<span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于使用 Signer 签名的参数</span></span><br><span class="line"><span class="keyword">type</span> SignerOpts <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回用于生成传递给 `Signer.Sign` 的消息的哈希函数,或零表示没有哈希完成</span></span><br><span class="line">    HashFunc() Hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MD4         Hash = <span class="number">1</span> + <span class="literal">iota</span> <span class="comment">// import golang.org/x/crypto/md4</span></span><br><span class="line">    MD5                         <span class="comment">// import crypto/md5</span></span><br><span class="line">    SHA1                        <span class="comment">// import crypto/sha1</span></span><br><span class="line">    SHA224                      <span class="comment">// import crypto/sha256</span></span><br><span class="line">    SHA256                      <span class="comment">// import crypto/sha256</span></span><br><span class="line">    SHA384                      <span class="comment">// import crypto/sha512</span></span><br><span class="line">    SHA512                      <span class="comment">// import crypto/sha512</span></span><br><span class="line">    MD5SHA1                     <span class="comment">// no implementation; MD5+SHA1 used for TLS RSA</span></span><br><span class="line">    RIPEMD160                   <span class="comment">// import golang.org/x/crypto/ripemd160</span></span><br><span class="line">    SHA3_224                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA3_256                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA3_384                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA3_512                    <span class="comment">// import golang.org/x/crypto/sha3</span></span><br><span class="line">    SHA512_224                  <span class="comment">// import crypto/sha512</span></span><br><span class="line">    SHA512_256                  <span class="comment">// import crypto/sha512</span></span><br><span class="line">    BLAKE2s_256                 <span class="comment">// import golang.org/x/crypto/blake2s</span></span><br><span class="line">    BLAKE2b_256                 <span class="comment">// import golang.org/x/crypto/blake2b</span></span><br><span class="line">    BLAKE2b_384                 <span class="comment">// import golang.org/x/crypto/blake2b</span></span><br><span class="line">    BLAKE2b_512                 <span class="comment">// import golang.org/x/crypto/blake2b</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="子包"><a href="#子包" class="headerlink" title="子包"></a>子包</h2><p>它包含众多子包,如下</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aes</td>
<td align="left">实现了 AES加密</td>
</tr>
<tr>
<td align="left">cipher</td>
<td align="left">实现了标准分组密码模式(CBC,ECB 等),可以将其包装在低级分组密码实现中</td>
</tr>
<tr>
<td align="left">des</td>
<td align="left">实现了数据加密标准(DES)和三重数据加密算法(TDEA)</td>
</tr>
<tr>
<td align="left">dsa</td>
<td align="left">实现了 FIPS 186-3 中定义的数字签名算法</td>
</tr>
<tr>
<td align="left">ecdsa</td>
<td align="left">实现了 FIPS 186-3 中定义的椭圆曲线数字签名算法</td>
</tr>
<tr>
<td align="left">ed25519</td>
<td align="left">实现了 ED25519签名算法</td>
</tr>
<tr>
<td align="left">elliptic</td>
<td align="left">实现了在素数域上的几个标准椭圆曲线</td>
</tr>
<tr>
<td align="left">hmac</td>
<td align="left">实现了 Keyed-Hash 消息认证码</td>
</tr>
<tr>
<td align="left">md5</td>
<td align="left">实现了 RFC 1321 中定义的 MD5 哈希算法</td>
</tr>
<tr>
<td align="left">rand</td>
<td align="left">实现了加密安全的随机数生成器</td>
</tr>
<tr>
<td align="left">rc4</td>
<td align="left">实现了 RC4 加密</td>
</tr>
<tr>
<td align="left">rsa</td>
<td align="left">实现了 PKCS#1 中定义的 RSA 加密</td>
</tr>
<tr>
<td align="left">sha1</td>
<td align="left">实现了 RFC 3174 中定义的 SHA-1 哈希算法</td>
</tr>
<tr>
<td align="left">sha256</td>
<td align="left">实现了 FIPS 180-4 中定义的 SHA224 和 SHA256 哈希算法</td>
</tr>
<tr>
<td align="left">sha512</td>
<td align="left">实现了 FIPS 180-4 中定义的 SHA-384, SHA-512, SHA-512/224 和 SHA-512/256 哈希算法</td>
</tr>
<tr>
<td align="left">tls</td>
<td align="left">部分实现了 RFC 5246 中指定的 TLS 1.2 和 RFC 8446 中指定的 TLS 1.3</td>
</tr>
<tr>
<td align="left">x509</td>
<td align="left">解析 X.509 编码的密钥和证书</td>
</tr>
<tr>
<td align="left">x509/pkix</td>
<td align="left">包含用于X.509证书,CRL 和 OCSP 的 ASN.1 解析和序列化的共享低级结构</td>
</tr>
</tbody></table>
<h1 id="crypto-aes"><a href="#crypto-aes" class="headerlink" title="crypto/aes"></a><code>crypto/aes</code></h1><p>aes 包实现了 AES 对称加密.导入方式为 <code>import &quot;crypto/aes&quot;</code></p>
<h2 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AES 块大小.以字节为单位</span></span><br><span class="line"><span class="keyword">const</span> BlockSize = <span class="number">16</span></span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并返回新的 `cipher.Block`</span></span><br><span class="line"><span class="comment">// 参数 key 是 AES 密钥,支持 16,24 或 32 个字节选择使用 AES-128, AES-192 或 AES-256 加密算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br></pre></td></tr></table></figure>

<h1 id="crypto-cipher"><a href="#crypto-cipher" class="headerlink" title="crypto/cipher"></a><code>crypto/cipher</code></h1><p>cipher 包实现标准的分组加密模式(CBC,ECB 等),可以将其包装在低级分组加密实现中.导入方式为 <code>import &quot;crypto/cipher&quot;</code></p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AEAD 加密模式接口,对关联数据进行身份验证加密</span></span><br><span class="line"><span class="keyword">type</span> AEAD <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回必须传递给 Seal 和 Open 的随机数的大小</span></span><br><span class="line">    NonceSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回明文长度与密文长度间的最大差值</span></span><br><span class="line">    Overhead() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对明文进行加密,返回密文内容</span></span><br><span class="line">    <span class="comment">// 对于给定的密钥,nonce 的长度必须为 NonceSize() 返回的长度</span></span><br><span class="line">    <span class="comment">// 对于一个完整的加密解密过程而言,nonce始终是唯一的</span></span><br><span class="line">    Seal(dst, nonce, plaintext, additionalData []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对密文进行解密,返回明文内容</span></span><br><span class="line">    <span class="comment">// 对于给定的密钥,nonce 的长度必须为 NonceSize() 返回的长度</span></span><br><span class="line">    <span class="comment">// 对于一个完整的加密解密过程而言,nonce始终是唯一的</span></span><br><span class="line">    Open(dst, nonce, ciphertext, additionalData []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示使用给定密钥分组加密的接口.它提供了加密或解密单个分组的功能.模式的实现将该功能扩展为流式分组</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密的分组大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 将 src 中第一个分组加密为 dst. dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    Encrypt(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">    <span class="comment">// 将 src 中第一个分组解密为 dst. dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    Decrypt(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示基于指定分组模式加密的接口</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回分组模式加密的分组大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密多个分组. src 的长度必须是分组的整数倍,且dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示流加密</span></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 对给定切片中的每个字节与密码密钥流中的字节进行 XOR.dst 和 src 必须完全重叠或不重叠</span></span><br><span class="line">    XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StreamReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    S Stream</span><br><span class="line">    R io.Reader</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StreamWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    S   Stream</span><br><span class="line">    W   io.Writer</span><br><span class="line">    Err error <span class="comment">// unused</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="cipher-包方法"><a href="#cipher-包方法" class="headerlink" title="cipher 包方法"></a><code>cipher</code> 包方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回以GCM模式下以标准随机数长度(12)包装的 128 位 AEAD 分组加密模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGCM</span><span class="params">(cipher Block)</span> <span class="params">(AEAD, error)</span></span></span><br><span class="line"><span class="comment">// 返回以GCM模式下以指定随机数长度(12)包装的 128 位 AEAD 分组加密模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGCMWithNonceSize</span><span class="params">(cipher Block, size <span class="keyword">int</span>)</span> <span class="params">(AEAD, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以分组加密链接模式(CBC)解密的分组模式</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与加密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line"><span class="comment">// 返回以分组解密链接模式(CBC)解密的分组模式</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以加密反馈模式(CFB)解密的分组模式</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCFBDecrypter</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br><span class="line"><span class="comment">// 返回以加密反馈模式(CFB)加密的 Stream</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCFBEncrypter</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以计数器模式下进行加密/解密的 Stream</span></span><br><span class="line"><span class="comment">// iv 的长度必须与分组大小相同且必须与解密数据的 iv 相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以输出反馈模式(OFB)加密或解密的 Stream</span></span><br><span class="line"><span class="comment">// iv 的长度必须与等于 b 的分组大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOFB</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="AES-GCM-模式认证加密解密"><a href="#AES-GCM-模式认证加密解密" class="headerlink" title="AES GCM 模式认证加密解密"></a>AES GCM 模式认证加密解密</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/aes"</span></span><br><span class="line">    <span class="string">"crypto/cipher"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESGCMEncrypt</span><span class="params">(plaintextStr <span class="keyword">string</span>, keyStr <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将明文和密钥转换为字节切片</span></span><br><span class="line">    plaintext := []<span class="keyword">byte</span>(plaintextStr)</span><br><span class="line">    key := []<span class="keyword">byte</span>(keyStr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建加密分组</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 GCM 模式的 AEAD</span></span><br><span class="line">    aesgcm, err := cipher.NewGCM(block)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建随机数,这里在实际应用中让它只生成一次.不然每次都需要进行修改</span></span><br><span class="line">    nonce := <span class="built_in">make</span>([]<span class="keyword">byte</span>, aesgcm.NonceSize())</span><br><span class="line">    <span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, nonce); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成密文</span></span><br><span class="line">    ciphertext := aesgcm.Seal(<span class="literal">nil</span>, nonce, plaintext, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 返回密文及随机数的 base64 编码</span></span><br><span class="line">    fmt.Println(ciphertext, nonce, key)</span><br><span class="line">    <span class="keyword">return</span> base64.RawURLEncoding.EncodeToString(ciphertext), base64.RawURLEncoding.EncodeToString(nonce)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESGCMDecrypt</span><span class="params">(ciphertextStr <span class="keyword">string</span>, keyStr <span class="keyword">string</span>, nonceStr <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将密文,密钥和生成的随机数转换为字节切片</span></span><br><span class="line">    ciphertext, _ := base64.RawURLEncoding.DecodeString(ciphertextStr)</span><br><span class="line">    nonce, _ := base64.RawURLEncoding.DecodeString(nonceStr)</span><br><span class="line">    key := []<span class="keyword">byte</span>(keyStr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建加密分组</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 GCM 模式的 AEAD</span></span><br><span class="line">    aesgcm, err := cipher.NewGCM(block)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 明文内容</span></span><br><span class="line">    plaintext, err := aesgcm.Open(<span class="literal">nil</span>, nonce, ciphertext, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(plaintext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    plaintext := <span class="string">"hello world"</span></span><br><span class="line">    key := <span class="string">"123456781234567812345678"</span> <span class="comment">// 16,24,32 位的密钥</span></span><br><span class="line">    fmt.Println(<span class="string">"原文："</span>, plaintext)</span><br><span class="line">    ciphertext, nonce := AESGCMEncrypt(plaintext, key)</span><br><span class="line">    fmt.Println(<span class="string">"密文: "</span>, ciphertext, nonce)</span><br><span class="line">    fmt.Println(<span class="string">"解密结果: "</span>, AESGCMDecrypt(ciphertext, key, nonce))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AES-CBC-模式加密解密"><a href="#AES-CBC-模式加密解密" class="headerlink" title="AES CBC 模式加密解密"></a>AES CBC 模式加密解密</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/aes"</span></span><br><span class="line">    <span class="string">"crypto/cipher"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESCBCEncrypt</span><span class="params">(plaintextStr <span class="keyword">string</span>, keyStr <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 转成字节数组</span></span><br><span class="line">    plaintext := []<span class="keyword">byte</span>(plaintextStr)</span><br><span class="line">    key := []<span class="keyword">byte</span>(keyStr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组秘钥</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取秘钥块的长度</span></span><br><span class="line">    blockSize := block.BlockSize()</span><br><span class="line">    <span class="comment">// 补全码</span></span><br><span class="line">    plaintext = PKCS7Padding(plaintext, blockSize)</span><br><span class="line">    <span class="comment">// 加密模式</span></span><br><span class="line">    blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    ciphertext := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(plaintext))</span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    blockMode.CryptBlocks(ciphertext, plaintext)</span><br><span class="line">    <span class="comment">//使用 RawURLEncoding,不要使用 StdEncoding,放在url参数中会导致错误</span></span><br><span class="line">    <span class="keyword">return</span> base64.RawURLEncoding.EncodeToString(ciphertext)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESCBCDecrypt</span><span class="params">(ciphertextStr <span class="keyword">string</span>, key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用 RawURLEncoding,不要使用 StdEncoding 放在url参数中回导致错误</span></span><br><span class="line">    ciphertext, _ := base64.RawURLEncoding.DecodeString(ciphertextStr)</span><br><span class="line">    k := []<span class="keyword">byte</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组秘钥</span></span><br><span class="line">    block, err := aes.NewCipher(k)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取秘钥块的长度</span></span><br><span class="line">    blockSize := block.BlockSize()</span><br><span class="line">    <span class="comment">// 加密模式</span></span><br><span class="line">    blockMode := cipher.NewCBCDecrypter(block, k[:blockSize])</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    plaintext := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(ciphertext))</span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    blockMode.CryptBlocks(plaintext, ciphertext)</span><br><span class="line">    <span class="comment">// 去补全码</span></span><br><span class="line">    plaintext = PKCS7UnPadding(plaintext)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(plaintext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//补码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7Padding</span><span class="params">(plaintext []<span class="keyword">byte</span>, blocksize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    padding := blocksize - <span class="built_in">len</span>(plaintext)%blocksize</span><br><span class="line">    padtext := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(plaintext, padtext...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7UnPadding</span><span class="params">(plaintext []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(plaintext)</span><br><span class="line">    unpadding := <span class="keyword">int</span>(plaintext[length<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> plaintext[:(length - unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    plaintext := <span class="string">"hello world"</span></span><br><span class="line">    key := <span class="string">"123456781234567812345678"</span> <span class="comment">// 16,24,32 位的密钥</span></span><br><span class="line">    fmt.Println(<span class="string">"原文: "</span>, plaintext)</span><br><span class="line">    ciphertext := AESCBCEncrypt(plaintext, key)</span><br><span class="line">    fmt.Println(<span class="string">"密文: "</span>, ciphertext)</span><br><span class="line">    plaintext2 := AESCBCDecrypt(ciphertext, key)</span><br><span class="line">    fmt.Println(<span class="string">"解密结果: "</span>, plaintext2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CFB 模式加密用法与 CBC 加密模式用法基本一致,在创建 <code>blockMode</code> 时调用对应的方法即可</p>
<h1 id="crypto-md5"><a href="#crypto-md5" class="headerlink" title="crypto/md5"></a><code>crypto/md5</code></h1><p>md5 包实现了 RFC 1321 中定义的 MD5 哈希算法.导入方式 <code>import &quot;crypto/md5&quot;</code>. <code>sha1</code>,<code>sha256</code>,<code>sha512</code> 变量定义与相关方法与 <code>md5</code> 类似,不再赘述</p>
<h2 id="常量及变量-1"><a href="#常量及变量-1" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MD5的块大小,以字节为单位</span></span><br><span class="line"><span class="keyword">const</span> BlockSize = <span class="number">64</span></span><br><span class="line"><span class="comment">// MD5 校验和的大小</span></span><br><span class="line"><span class="keyword">const</span> Size = <span class="number">16</span></span><br></pre></td></tr></table></figure>
<h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 `hash.Hash`,用于计算 MD5校验和.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">hash</span>.<span class="title">Hash</span></span></span><br><span class="line"><span class="comment">// 返回 data 的 MD5 校验和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(data []<span class="keyword">byte</span>)</span> [<span class="title">Size</span>]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="计算字符串的校验和"><a href="#计算字符串的校验和" class="headerlink" title="计算字符串的校验和"></a>计算字符串的校验和</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 `hash.Hash`</span></span><br><span class="line">    h := md5.New()</span><br><span class="line">    <span class="comment">// 向其中写入数据</span></span><br><span class="line">    io.WriteString(h, <span class="string">"The fog is getting thicker!"</span>)</span><br><span class="line">    io.WriteString(h, <span class="string">"And Leon's getting laaarger!"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>)) <span class="comment">// h.Sum() 用于计算校验和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或直接使用包函数 md5.Sum(data []byte) 计算校验和</span></span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">"These pretzels are making me thirsty."</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%x"</span>, md5.Sum(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算文件的校验和"><a href="#计算文件的校验和" class="headerlink" title="计算文件的校验和"></a>计算文件的校验和</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"file.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    h := md5.New()</span><br><span class="line">    <span class="comment">// 其实还是将文件中数据读出来,写入到 h 对象中</span></span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(h, f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%x"</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="crypto-rand"><a href="#crypto-rand" class="headerlink" title="crypto/rand"></a><code>crypto/rand</code></h1><p>rand 包实现了加密安全的随机数生成器.它在包中定义了全局唯一的 <code>var Reader io.Reader</code> 变量提供了以下方法用于生成随机数</p>
<h2 id="常量及变量-2"><a href="#常量及变量-2" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密安全的随机数生成其的全局共享实例</span></span><br><span class="line"><span class="keyword">var</span> Reader io.Reader</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回范围为 [0,max) 的随机整数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">(rand io.Reader, max *big.Int)</span> <span class="params">(n *big.Int, err error)</span></span></span><br><span class="line"><span class="comment">// 将随机数传入 b.其实是调用了 io.ReadFull(Reader, b),是该函数的辅助函数.</span></span><br><span class="line"><span class="comment">// 当且仅当 n=len(b)时,返回 err=nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建随机数的切片,使用 `io.ReadFull` 将 rand.Reader 产生的随机数写入 nonce 中</span></span><br><span class="line">nonce := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, nonce); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="crypto-rsa"><a href="#crypto-rsa" class="headerlink" title="crypto/rsa"></a><code>crypto/rsa</code></h1><p>rsa 实现了 RSA 非对称加密算法,该算法通过生成密钥对实现加密和加密,公钥文件用于加密,私钥用于解密.</p>
<p>RSA 是一个基本操作,在此程序包中用于实现公钥加密或公钥签名.此包中的 RSA 操作未使用固定时间算法实现.</p>
<h2 id="常量及变量-3"><a href="#常量及变量-3" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// PSSSaltLengthAuto 会使 RSA-PSS 签名中的盐在签名时尽可能大,并在验证时自动检测</span></span><br><span class="line">    PSSSaltLengthAuto = <span class="number">0</span></span><br><span class="line">    <span class="comment">// PSSSaltLengthEqualsHash 使盐的长度等于签名中使用的哈希的长度</span></span><br><span class="line">    PSSSaltLengthEqualsHash = <span class="number">-1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="类型定义-1"><a href="#类型定义-1" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RSA 私钥的结构体定义,可通过 `rsa.GenerateKey` 生成对象</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey            <span class="comment">// 公钥部分</span></span><br><span class="line">    D         *big.Int   <span class="comment">// private exponent</span></span><br><span class="line">    Primes    []*big.Int <span class="comment">// prime factors of N, has &gt;= 2 elements.</span></span><br><span class="line">    <span class="comment">// Precomputed contains precomputed values that speed up private operations, if available.</span></span><br><span class="line">    Precomputed PrecomputedValues</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA 公钥结构体定义,包含在私钥中</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    N *big.Int <span class="comment">// modulus</span></span><br><span class="line">    E <span class="keyword">int</span>      <span class="comment">// public exponent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于使用 `crypto.Decrypter` 解密的 OAEP 选项结构体</span></span><br><span class="line"><span class="keyword">type</span> OAEPOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 生成掩码时使用的哈希函数.</span></span><br><span class="line">    Hash crypto.Hash</span><br><span class="line">    <span class="comment">// 任意字节字符,必须等于加密时使用的 Label</span></span><br><span class="line">    Label []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于使用 `crypto.Decrypter` PKCS#1 v1.5 解密的 PKCS1v15 选项结构体</span></span><br><span class="line"><span class="keyword">type</span> PKCS1v15DecryptOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 要解密的会话密钥的长度. 如果不为零,解密期间的错误将返回此长度的随机明文,而不是返回错误</span></span><br><span class="line">    SessionKeyLen <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建和验证 RSA-PSS 签名的选项结构体</span></span><br><span class="line"><span class="keyword">type</span> PSSOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 控制 PSS 签名中使用盐的长度,可以是一个数字,也可以是特殊 PSSSaltLength 常量之一</span></span><br><span class="line">    SaltLength <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖传递给 SignPSS 的 hash 函数</span></span><br><span class="line">    <span class="comment">// 这是使用 crypto.Signer 接口时指定哈希函数的唯一方法</span></span><br><span class="line">    Hash crypto.Hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="rsa-包函数"><a href="#rsa-包函数" class="headerlink" title="rsa 包函数"></a><code>rsa</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用随机树源 random 生成指定 bits 的 RSA 密钥对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(random io.Reader, bits <span class="keyword">int</span>)</span> <span class="params">(*PrivateKey, error)</span></span></span><br><span class="line"><span class="comment">// 使用 RSA-OAEP 对 msg 进行加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptOAEP</span><span class="params">(hash hash.Hash, random io.Reader, pub *PublicKey, msg []<span class="keyword">byte</span>, label []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 使用 RSA-OAEP 对 ciphertext 进行解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptOAEP</span><span class="params">(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []<span class="keyword">byte</span>, label []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RSA 和 PKCS#1 v1.5 中的补充协议对给定 msg 进行加密解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptPKCS1v15</span><span class="params">(rand io.Reader, pub *PublicKey, msg []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, ciphertext []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用来自 RSA PKCS＃1 v1.5 的 RSASSA-PKCS1-V1_5-SIGN 计算 hashed 的签名及认证</span></span><br><span class="line"><span class="comment">// hashed 必须是使用 hash 函数对 msg 进行哈希的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyPKCS1v15</span><span class="params">(pub *PublicKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用 RSASSA-PSS [1]计算 hashed 的签名及认证</span></span><br><span class="line"><span class="comment">// hashed 必须是使用 hash 函数对 msg 进行哈希的结果.opts参数可以为nil,使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignPSS</span><span class="params">(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>, opts *PSSOptions)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="PrivateKey-结构体方法"><a href="#PrivateKey-结构体方法" class="headerlink" title="PrivateKey 结构体方法"></a><code>PrivateKey</code> 结构体方法</h3><p><code>PrivateKey</code> 结构体实现了 <code>crypto.Decrypter</code> 和 <code>crypto.Signer</code> 接口.具有以下方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 priv 对指定 ciphertext 密文解密,返回解密后的明文即可能产生的错误</span></span><br><span class="line"><span class="comment">// 如果 opts 为空或 *PKCS1v15DecryptOptions,则使用 PKCS#1 v1.5 解密.否则必须为 *OAEPOptions 使用 OAEP 解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Decrypt</span><span class="params">(rand io.Reader, ciphertext []<span class="keyword">byte</span>, opts crypto.DecrypterOpts)</span> <span class="params">(plaintext []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 执行一些运算,加快将来私钥操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Precompute</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 返回公钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Public</span><span class="params">()</span> <span class="title">crypto</span>.<span class="title">PublicKey</span></span></span><br><span class="line"><span class="comment">// 使用私钥签名,从 rand 读取随机数</span></span><br><span class="line"><span class="comment">// 如果 opts 是 *PSSOptions 将使用 PSS签名,否则使用 PKCS#1 v1.5 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Sign</span><span class="params">(rand io.Reader, digest []<span class="keyword">byte</span>, opts crypto.SignerOpts)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 对密钥执行基本的完整性检查.返回检查过程中可能出现的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(priv *PrivateKey)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><h3 id="对数据进行加密解密"><a href="#对数据进行加密解密" class="headerlink" title="对数据进行加密解密"></a>对数据进行加密解密</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    privateKey, err := rsa.GenerateKey(rand.Reader, <span class="number">2048</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    msg := []<span class="keyword">byte</span>(<span class="string">"send reinforcements, we're going to advance"</span>)</span><br><span class="line">    label := []<span class="keyword">byte</span>(<span class="string">"orders"</span>)</span><br><span class="line">    rng := rand.Reader</span><br><span class="line">    <span class="comment">// 使用公钥对数据进行加密</span></span><br><span class="line">    ciphertext, err := rsa.EncryptOAEP(sha256.New(), rng, &amp;privateKey.PublicKey, msg, label)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from encryption: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Ciphertext: %x\n"</span>, ciphertext)</span><br><span class="line">    <span class="comment">// 使用私钥对数据进行解密</span></span><br><span class="line">    plaintext, err := rsa.DecryptOAEP(sha256.New(), rng, privateKey, ciphertext, label)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from deecryption: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Plaintext: %s\n"</span>, <span class="keyword">string</span>(plaintext))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对数据进行签名认证"><a href="#对数据进行签名认证" class="headerlink" title="对数据进行签名认证"></a>对数据进行签名认证</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    privateKey, err := rsa.GenerateKey(rand.Reader, <span class="number">2048</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    message := []<span class="keyword">byte</span>(<span class="string">"message to be signed"</span>)</span><br><span class="line">    hashed := sha256.Sum256(message)  <span class="comment">// 使用 sha256 进行哈希</span></span><br><span class="line">    <span class="comment">// 使用 rsa 私钥进行签名</span></span><br><span class="line">    signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hashed[:])</span><br><span class="line">    <span class="comment">// 或使用 rsa PSS 进行签名</span></span><br><span class="line">    <span class="comment">// signature, err := rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, hashed[:], nil)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from signing: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Signature: %x\n"</span>, signature)</span><br><span class="line">    <span class="comment">// 使用 rsa 公钥进行认证</span></span><br><span class="line">    err = rsa.VerifyPKCS1v15(&amp;privateKey.PublicKey, crypto.SHA256, hashed[:], signature)</span><br><span class="line">    <span class="comment">// 或使用 rsa PSS 进行认证</span></span><br><span class="line">    <span class="comment">// err = rsa.VerifyPSS(&amp;privateKey.PublicKey, crypto.SHA256, hashed[:], signature, nil)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Error from verification: %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"认证通过"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 fmt 包</title>
    <url>/2020/05/16/go-study-notes-package-fmt/</url>
    <content><![CDATA[<p>fmt 包采用占位符的方式实现了格式化的 I/O.主要占位符如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: <span class="string">"name"</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常规占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%v</td>
<td align="center">默认格式的值</td>
<td align="center"><code>Printf(&quot;%v&quot;, user)</code></td>
<td align="center">{name}</td>
</tr>
<tr>
<td align="center">%+v</td>
<td align="center">打印结构体时,会添加字段名</td>
<td align="center"><code>Printf(&quot;%+v&quot;, user)</code></td>
<td align="center">{Name:name}</td>
</tr>
<tr>
<td align="center">%#v</td>
<td align="center">Go 语法表示的值</td>
<td align="center"><code>Printf(&quot;%#v&quot;, user)</code></td>
<td align="center">main.User{Name:”name”}</td>
</tr>
<tr>
<td align="center">%T</td>
<td align="center">Go 语法表示的值的类型</td>
<td align="center"><code>Printf(&quot;%T&quot;, user)</code></td>
<td align="center">main.User</td>
</tr>
<tr>
<td align="center">%%</td>
<td align="center">百分号</td>
<td align="center"><code>Printf(&quot;%%&quot;)</code></td>
<td align="center">%</td>
</tr>
</tbody></table>
<ul>
<li>布尔占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%t</td>
<td align="center">true 或 false</td>
<td align="center"><code>Printf(&quot;%t&quot;, true)</code></td>
<td align="center">true</td>
</tr>
</tbody></table>
<ul>
<li>整型占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%b</td>
<td align="center">二进制表示(不以 0 开头,且只有 01)</td>
<td align="center"><code>Printf(&quot;%b&quot;, 8)</code></td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">十进制表示(不以 0 开头,且只有0-9)</td>
<td align="center"><code>Printf(&quot;%b&quot;, 8)</code></td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">%o</td>
<td align="center">八进制表示(以 0 开头,且只有 0-7)</td>
<td align="center"><code>Printf(&quot;%o&quot;, 32)</code></td>
<td align="center">40</td>
</tr>
<tr>
<td align="center">%x</td>
<td align="center">十六进制的小写表示(以 0x 开头)</td>
<td align="center"><code>Printf(&quot;%x&quot;, 223)</code></td>
<td align="center">df</td>
</tr>
<tr>
<td align="center">%X</td>
<td align="center">十六进制的大写表示(以 0X 开头)</td>
<td align="center"><code>Printf(&quot;%X&quot;, 223)</code></td>
<td align="center">DF</td>
</tr>
</tbody></table>
<ul>
<li>浮点型占位符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%e</td>
<td align="center">科学计数,小写表示</td>
<td align="center"><code>Printf(&quot;%.2e&quot;, 1024.5)</code></td>
<td align="center">1.02e+03</td>
</tr>
<tr>
<td align="center">%E</td>
<td align="center">科学计数,大写表示</td>
<td align="center"><code>Printf(&quot;%.2E&quot;, 1024.5)</code></td>
<td align="center">1.02E+03</td>
</tr>
<tr>
<td align="center">%f</td>
<td align="center">浮点数表示,多用于限制小数位数</td>
<td align="center"><code>Printf(&quot;%.2f&quot;, 22.2335)</code></td>
<td align="center">2.23</td>
</tr>
</tbody></table>
<ul>
<li>字符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%s</td>
<td align="center">字符串或字符切片的字符串表示</td>
<td align="center"><code>Printf(&quot;%s,%s&quot;, &quot;str&quot;, []byte(&quot;str&quot;)</code></td>
<td align="center">str,str</td>
</tr>
</tbody></table>
<ul>
<li>指针</li>
</ul>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%p</td>
<td align="center">对象的指针表示,切片为也为第一个元素的指针地址</td>
<td align="center">Printf(“%p”, []byte(“string”))</td>
<td align="center">0xc0000160b0</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定格式将数据进行格式化,并写入 w</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描从 r 读取的数据,以空格为分隔符存储到参数中,返回成功扫描的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出到标准输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从标准输入扫描数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 format 给出的格式,返回格式化后的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描 str 参数,以空格为分隔符存储到参数中,返回成功扫描的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="keyword">string</span>, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 io 包</title>
    <url>/2020/05/02/go-study-notes-package-io/</url>
    <content><![CDATA[<p><code>io</code> 包提供了对 IO 原语的基本接口. 它主要封装了一些已有的实现(如 os 包中的),并将这些抽象为使用性的功能和一些其它相关接口.</p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读相关接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">     <span class="comment">// 从数据流里将 len(p) 个字节读入 p.返回读取的字节数(0&lt;=n&lt;=len(p)和可能发生的错误.在文件读取时, 返回 0和 io.EOF 表示读取到文件结尾</span></span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 从数据流里 off 位置开始将 len(p) 个字节读入 p.返回读取的字节数(0&lt;=n&lt;=len(p)和可能发生的错误</span></span><br><span class="line">    ReadAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 从 r 读取数据直到发生错误或文件结束(EOF). 返回读取的字节数 n 及遇到的错误(EOF除外)</span></span><br><span class="line">    ReadFrom(r Reader) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回读取的单个字节及可能发生的错误</span></span><br><span class="line">    ReadByte() (c <span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写相关接口</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 将 p 的 len(p) 个字节写入数据流.返回写入的字节数(0&lt;=n&lt;=len(p)和可能发生的错误.</span></span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 从数据流 off 位置开始,将 p 的 len(p) 个字节写入数据流.返回写入的字节数(0&lt;=n&lt;=len(p)和可能发生的错误.</span></span><br><span class="line">    WriteAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 写入数据到 w 直到发生错误.返回读取的字节数 n 及遇到的错误</span></span><br><span class="line">    WriteTo(w Writer) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串 s 写入到数据流中,返回写入的字节数(0&lt;=n&lt;=len(s)和可能发生的错误</span></span><br><span class="line">    WriteString(s <span class="keyword">string</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写接口</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭接口</span></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭数据流</span></span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写指针移位接口</span></span><br><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 设置下一次读写的位置,whence 设置参照点,offset 设置偏移量.</span></span><br><span class="line">    <span class="comment">// whence 可选值为 `io.SeekStart`(0,文件开始),`io.SeekCurrent`(1,当前位置),`io.SeekEnd`(2,结尾位置).</span></span><br><span class="line">    Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SeekStart   = <span class="number">0</span> <span class="comment">// 相对于文件开始位置</span></span><br><span class="line">    SeekCurrent = <span class="number">1</span> <span class="comment">// 相对于文件当前位置</span></span><br><span class="line">    SeekEnd     = <span class="number">2</span> <span class="comment">// 相对于文件结尾位置</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当无法得到更多输入时,Read 方法返回 EOF.可以作为文件读取结束的表示</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h1 id="io-包方法"><a href="#io-包方法" class="headerlink" title="io 包方法"></a><code>io</code> 包方法</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 src 的数据拷贝到 dst.返回拷贝的字节数和可能发生的错误</span></span><br><span class="line"><span class="comment">// 底层调用了 `CopyBuffer(dst, src, nil)`, 使用默认的缓冲区,默认大小为 32 * 1024</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 从 src 拷贝 n 个字节数据到 dst,直到发生错误或 EOF.返回复制的字节数和可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyN</span><span class="params">(dst Writer, src Reader, n <span class="keyword">int64</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将 src 的数据拷贝到 dst.返回拷贝的字节数和可能发生的错误. buf 可以指定指定缓冲区的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将 r 中 min 个字节读取到 buf 中.返回复制的字节数及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>, min <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将 r 中 len(buf) 个字节读取到 buf 中.返回复制的字节数及可能发生的错误</span></span><br><span class="line"><span class="comment">// 其实是调用了,ReadAtLeast(r, buf, len(buf)).如果 n&lt;len(buf),则产生非 io.EOF 错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">//  将字符串 s 写入 w 中.返回写入的字节长度及可能发生的错误</span></span><br><span class="line"><span class="comment">//  如果 w 实现了 StringWriter 接口, `w.WriteString()` 将直接被调用.参见 https://github.com/golang/go/blob/master/src/io/io.go#L293</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>拷贝文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFileExample</span><span class="params">(src, dest <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    srcFile, err := os.Open(src)</span><br><span class="line">    <span class="keyword">defer</span> srcFile.Close()</span><br><span class="line">    destFile, err := os.OpenFile(dest, os.O_CREATE|os.O_RDWR|os.O_SYNC, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">defer</span> destFile.Close()</span><br><span class="line">    _, err = io.Copy(destFile, srcFile)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := copyFileExample(<span class="string">"src"</span>, <span class="string">"dest"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 http 包</title>
    <url>/2020/05/10/go-study-notes-package-http/</url>
    <content><![CDATA[<p><code>http</code> 包提供了 HTTP 客户端和服务端的实现.它提供了 HTTP 通信过程中各种对象的定义及实现.导入方式为 <code>import &quot;net/http&quot;</code></p>
<p>对于客户端,它可以使用 <code>Get</code>,<code>Head</code>,<code>Post</code>和<code>PostForm</code> 等方法直接发送对应的 HTTP 请求,也可以通过 <code>Client</code> 类型自定义客户端,从而调用其中方法发送 HTTP 请求.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接发送请求,并接收响应</span></span><br><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line">resp, err := http.PostForm(<span class="string">"http://example.com/form"</span>,</span><br><span class="line">    url.Values&#123;<span class="string">"key"</span>: &#123;<span class="string">"Value"</span>&#125;, <span class="string">"id"</span>: &#123;<span class="string">"123"</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// 客户端必须显式关闭响应体</span></span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 Client 实例对象,并使用该对象发送请求</span></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">    CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"http://example.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以预生成请求,然后由客户端发送</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>对于传输过程,它提供了支持代理,TLS 配置,keep-alive,压缩等传输方式的 <code>Transport</code> 类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 Transport 对象实例,并使参数在传输过程中生效</span></span><br><span class="line">tr := &amp;http.Transport&#123;</span><br><span class="line">    MaxIdleConns:       <span class="number">10</span>,</span><br><span class="line">    IdleConnTimeout:    <span class="number">30</span> * time.Second,</span><br><span class="line">    DisableCompression: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure>

<p>对于服务端,它提供了 <code>ListenAndServe</code> 函数使用给定的地址和处理程序启动 HTTP 服务器,还提供了 <code>Server</code> 类型用于自定义服务端及处理请求的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</span><br><span class="line">http.HandleFunc(<span class="string">"/bar"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := &amp;http.Server&#123;</span><br><span class="line">    Addr:           <span class="string">":8080"</span>,</span><br><span class="line">    Handler:        myHandler,</span><br><span class="line">    ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">    WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">    MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(s.ListenAndServe())</span><br></pre></td></tr></table></figure>

<p><code>http</code> 包的 <code>Transport</code> 和 <code>Server</code> 类型对于简单的配置都自动支持 HTTP/2 协议.要使用更为复杂的 HTTP/2 协议,请直接导入 <code>golang.org/x/net/http2</code>,并使用其 <code>ConfigureTransport</code> 或 <code>ConfigureServer</code> 类型的相关函数.</p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">// 客户端类型结构体定义,用于自定义客户端</span><br><span class="line"><span class="keyword">type</span> <span class="type">Client</span> struct &#123;</span><br><span class="line">    // 发出 <span class="type">HTTP</span> 请求机制.默认使用 `<span class="type">DefaultTransport</span>`</span><br><span class="line">    <span class="type">Transport</span> <span class="type">RoundTripper</span></span><br><span class="line">    // 指定重定向策略.如果不为 nil,则在 <span class="type">HTTP</span> 重定向之前调用它.否则使用默认策略,在连续 10 个请求后停止</span><br><span class="line">    // req 与 via 分别为即将到来的请求和已发出的请求.</span><br><span class="line">    <span class="type">CheckRedirect</span> func(req *<span class="type">Request</span>, via []*<span class="type">Request</span>) error</span><br><span class="line">    <span class="type">Jar</span> <span class="type">CookieJar</span>  // 指定 <span class="type">CookieJar</span></span><br><span class="line">    <span class="type">Timeout</span> time.<span class="type">Duration</span>  // 超时时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理请求的函数接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Handler</span> interface &#123;</span><br><span class="line">    <span class="type">ServeHTTP</span>(<span class="type">ResponseWriter</span>, *<span class="type">Request</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理请求的函数</span><br><span class="line"><span class="keyword">type</span> <span class="type">HandlerFunc</span> func(<span class="type">ResponseWriter</span>, *<span class="type">Request</span>)</span><br><span class="line"></span><br><span class="line">// 请求头</span><br><span class="line"><span class="keyword">type</span> <span class="type">Header</span> map[string][]string</span><br><span class="line"></span><br><span class="line">// 请求对象</span><br><span class="line"><span class="keyword">type</span> <span class="type">Request</span> struct &#123;</span><br><span class="line">    <span class="type">Method</span> string  // 请求方法</span><br><span class="line">    <span class="type">URL</span> *url.<span class="type">URL</span>  // 请求 <span class="type">URL</span></span><br><span class="line">    <span class="type">Proto</span>      string // 请求协议,对于客户端来说,默认是 <span class="type">HTTP</span>/1.1 或 <span class="type">HTTP</span>/2</span><br><span class="line">    <span class="type">Header</span> <span class="type">Header</span>  // 请求头</span><br><span class="line">    <span class="type">Body</span> io.<span class="type">ReadCloser</span>  // 请求体</span><br><span class="line">    <span class="type">GetBody</span> func() (io.<span class="type">ReadCloser</span>, error) // 获取请求体的方法</span><br><span class="line">    <span class="type">ContentLength</span> int64  // 请求长度,-1 表示未知</span><br><span class="line">    <span class="type">TransferEncoding</span> []string</span><br><span class="line">    <span class="type">Close</span> bool  // 发送请求后是否关闭 <span class="type">TCP</span> 连接</span><br><span class="line">    <span class="type">Host</span> string  // 请求主机,如果为空,则使用 <span class="type">URL</span>.<span class="type">Host</span> 的值</span><br><span class="line">    </span><br><span class="line">    // 以下三个属性需要调用`<span class="type">ParseForm</span>` 或 `<span class="type">ParseMultipartForm</span>` 后才可获取属性值</span><br><span class="line">    <span class="type">Form</span> url.<span class="type">Values</span>  // 已解析的表单数据,包含 <span class="type">URL</span> 参数,<span class="type">PATCH</span>,<span class="type">POST</span>,<span class="type">PUT</span> 表单数据.</span><br><span class="line">    <span class="type">PostForm</span> url.<span class="type">Values</span> // 已解析的表单数据,包含 <span class="type">PATCH</span>,<span class="type">POST</span>,<span class="type">PUT</span> 表单数据</span><br><span class="line">    <span class="type">MultipartForm</span> *multipart.<span class="type">Form</span> // 已解析的表单数据,主要用于文件上传</span><br><span class="line"></span><br><span class="line">    <span class="type">RemoteAddr</span> string  // 远程地址</span><br><span class="line">    <span class="type">RequestURI</span> string  // 请求 <span class="type">URI</span></span><br><span class="line">    <span class="type">TLS</span> *tls.<span class="type">ConnectionState</span>  // <span class="type">TLS</span> 连接信息</span><br><span class="line">    <span class="type">Response</span> *<span class="type">Response</span> // 响应</span><br><span class="line">    // contains filtered or unexported fields</span><br><span class="line">&#125;</span><br><span class="line">// 响应对象</span><br><span class="line"><span class="keyword">type</span> <span class="type">Response</span> struct &#123;</span><br><span class="line">    <span class="type">Status</span>     string // 状态</span><br><span class="line">    <span class="type">StatusCode</span> int    // 状态码</span><br><span class="line">    <span class="type">Proto</span>      string // 协议</span><br><span class="line">    <span class="type">Header</span> <span class="type">Header</span>  // 响应头</span><br><span class="line">    <span class="type">Body</span> io.<span class="type">ReadCloser</span>  // 响应体</span><br><span class="line">    <span class="type">ContentLength</span> int64  // 响应长度</span><br><span class="line">    <span class="type">Uncompressed</span> bool // 报告是否以压缩方式发送了响应</span><br><span class="line">    <span class="type">Request</span> *<span class="type">Request</span>  // 请求</span><br><span class="line">    <span class="type">TLS</span> *tls.<span class="type">ConnectionState</span> // <span class="type">TLS</span> 相关信息</span><br><span class="line">&#125;</span><br><span class="line">// 服务端结构体定义,用于自定义服务端</span><br><span class="line"><span class="keyword">type</span> <span class="type">Server</span> struct &#123;</span><br><span class="line">    <span class="type">Addr</span> string  // <span class="type">HTTP</span> 服务监听的地址,默认为":80"</span><br><span class="line">    <span class="type">Handler</span> <span class="type">Handler</span> // 调用处理请求的程序,默认为 `http.<span class="type">DefaultServeMux</span>`</span><br><span class="line">    <span class="type">TLSConfig</span> *tls.<span class="type">Config</span>  // <span class="type">TLS</span> 相关配置</span><br><span class="line">    <span class="type">ReadTimeout</span> time.<span class="type">Duration</span>  // 读取整个请求的超时时间 </span><br><span class="line">    <span class="type">ReadHeaderTimeout</span> time.<span class="type">Duration</span> // 读取请求头的超时时间</span><br><span class="line">    <span class="type">WriteTimeout</span> time.<span class="type">Duration</span>  // 响应的超时时间</span><br><span class="line">    <span class="type">IdleTimeout</span> time.<span class="type">Duration</span> // 启动 keep-alived 后,等待下一个请求的超时时间,</span><br><span class="line">    <span class="type">MaxHeaderBytes</span> int // 控制请求头的最大字节数</span><br><span class="line">    <span class="type">ConnState</span> func(net.<span class="type">Conn</span>, <span class="type">ConnState</span>) // 客户端连接状态更改时的回调函数</span><br><span class="line">    <span class="type">ErrorLog</span> *log.<span class="type">Logger</span> // 错误日志记录器.默认为 log 包提供的标准 logger</span><br><span class="line">    // contains filtered or unexported fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见 HTTP 响应状态码定义(仅包含常见部分),详见 https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusOK                   = <span class="number">200</span> <span class="comment">// RFC 7231, 6.3.1</span></span><br><span class="line">    StatusNoContent            = <span class="number">204</span> <span class="comment">// RFC 7231, 6.3.5</span></span><br><span class="line"></span><br><span class="line">    StatusMovedPermanently = <span class="number">301</span> <span class="comment">// RFC 7231, 6.4.2</span></span><br><span class="line">    StatusFound            = <span class="number">302</span> <span class="comment">// RFC 7231, 6.4.3</span></span><br><span class="line">    StatusTemporaryRedirect = <span class="number">307</span> <span class="comment">// RFC 7231, 6.4.7</span></span><br><span class="line">    StatusPermanentRedirect = <span class="number">308</span> <span class="comment">// RFC 7538, 3</span></span><br><span class="line"></span><br><span class="line">    StatusBadRequest                   = <span class="number">400</span> <span class="comment">// RFC 7231, 6.5.1</span></span><br><span class="line">    StatusUnauthorized                 = <span class="number">401</span> <span class="comment">// RFC 7235, 3.1</span></span><br><span class="line">    StatusPaymentRequired              = <span class="number">402</span> <span class="comment">// RFC 7231, 6.5.2</span></span><br><span class="line">    StatusForbidden                    = <span class="number">403</span> <span class="comment">// RFC 7231, 6.5.3</span></span><br><span class="line">    StatusNotFound                     = <span class="number">404</span> <span class="comment">// RFC 7231, 6.5.4</span></span><br><span class="line">    StatusMethodNotAllowed             = <span class="number">405</span> <span class="comment">// RFC 7231, 6.5.5</span></span><br><span class="line">    StatusRequestTimeout               = <span class="number">408</span> <span class="comment">// RFC 7231, 6.5.7</span></span><br><span class="line">    StatusRequestEntityTooLarge        = <span class="number">413</span> <span class="comment">// RFC 7231, 6.5.11</span></span><br><span class="line">    StatusRequestURITooLong            = <span class="number">414</span> <span class="comment">// RFC 7231, 6.5.12</span></span><br><span class="line">    StatusUnsupportedMediaType         = <span class="number">415</span> <span class="comment">// RFC 7231, 6.5.13</span></span><br><span class="line">    StatusTooManyRequests              = <span class="number">429</span> <span class="comment">// RFC 6585, 4</span></span><br><span class="line"></span><br><span class="line">    StatusInternalServerError           = <span class="number">500</span> <span class="comment">// RFC 7231, 6.6.1</span></span><br><span class="line">    StatusNotImplemented                = <span class="number">501</span> <span class="comment">// RFC 7231, 6.6.2</span></span><br><span class="line">    StatusBadGateway                    = <span class="number">502</span> <span class="comment">// RFC 7231, 6.6.3</span></span><br><span class="line">    StatusServiceUnavailable            = <span class="number">503</span> <span class="comment">// RFC 7231, 6.6.4</span></span><br><span class="line">    StatusGatewayTimeout                = <span class="number">504</span> <span class="comment">// RFC 7231, 6.6.5</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 默认的传输方式</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment,</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">        DualStack: <span class="literal">true</span>,</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">    MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">    IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">    TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">    ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认请求处理实例对象,该类型实现了 Handler 接口</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="http-包函数"><a href="#http-包函数" class="headerlink" title="http 包函数"></a><code>http</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 DefaultServeMux 中对给定的 pattern 注册请求处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听并使用 handler 处理请求.如果 handler 为 nil,则使用 `DefaultServeMux`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr, certFile, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Listener 实例及给定 handler 请求处理启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeTLS</span><span class="params">(l net.Listener, handler Handler, certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建请求对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequestWithContext</span><span class="params">(ctx context.Context, method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ServeMux 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">()</span> *<span class="title">ServeMux</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对应 Handler 对象,返回值可用于传入 Handle</span></span><br><span class="line"><span class="comment">// 以 root 目录作为根目录为 HTTP 请求提供服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileServer</span><span class="params">(root FileSystem)</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 使用 "404 page not found" 响应每个请求,响应状态码为 404</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFoundHandler</span><span class="params">()</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 重定向处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RedirectHandler</span><span class="params">(url <span class="keyword">string</span>, code <span class="keyword">int</span>)</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 从 URL 的路径中删除给定前缀并调用处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StripPrefix</span><span class="params">(prefix <span class="keyword">string</span>, h Handler)</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="comment">// 返回给定时间限制下的运行 h 的 Handler,并在超时时提示 msg</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeoutHandler</span><span class="params">(h Handler, dt time.Duration, msg <span class="keyword">string</span>)</span> <span class="title">Handler</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下函数多用于作为 handler 变量向 HandleFunc 传入或通过自定义 Handler 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFound</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br><span class="line"><span class="comment">// 使用给定文件或目录的内容答复请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeFile</span><span class="params">(w ResponseWriter, r *Request, name <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="comment">// 设置响应的 cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Client-结构体方法"><a href="#Client-结构体方法" class="headerlink" title="Client 结构体方法"></a><code>Client</code> 结构体方法</h2><p>``go<br>// 关闭等待连接<br>func (c <em>Client) CloseIdleConnections()<br>// 使用配置的客户端发送请求并返回响应<br>func (c *Client) Do(req *Request) (</em>Response, error)<br>// 向 url 发送 Get,Head,Post,Post(提交表单) 请求<br>func (c *Client) Get(url string) (resp *Response, err error)<br>func (c *Client) Head(url string) (resp *Response, err error)<br>func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error)<br>// 向 url 发送 Post 请求,data 的键值编码为请求正文.(<code>url.Values</code> 为 <code>map[string][]string</code> 格式的字典对象)<br>// 此时 Content-Type 请求头设置为 application/x-www-form-urlencoded<br>func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## `Header` 结构体方法</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func (h Header) <span class="constructor">Add(<span class="params">key</span>, <span class="params">value</span> <span class="params">string</span>)</span></span><br><span class="line">func (h Header) <span class="constructor">Clone()</span> Header</span><br><span class="line">func (h Header) <span class="constructor">Del(<span class="params">key</span> <span class="params">string</span>)</span></span><br><span class="line">func (h Header) <span class="constructor">Get(<span class="params">key</span> <span class="params">string</span>)</span> <span class="built_in">string</span></span><br><span class="line">func (h Header) <span class="constructor">Set(<span class="params">key</span>, <span class="params">value</span> <span class="params">string</span>)</span></span><br><span class="line">func (h Header) <span class="constructor">Values(<span class="params">key</span> <span class="params">string</span>)</span> <span class="literal">[]</span><span class="built_in">string</span></span><br><span class="line">func (h Header) <span class="constructor">Write(<span class="params">w</span> <span class="params">io</span>.Writer)</span> error</span><br><span class="line">func (h Header) <span class="constructor">WriteSubset(<span class="params">w</span> <span class="params">io</span>.Writer, <span class="params">exclude</span> <span class="params">map</span>[<span class="params">string</span>]<span class="params">bool</span>)</span> error</span><br></pre></td></tr></table></figure>

<h2 id="Request-结构体方法"><a href="#Request-结构体方法" class="headerlink" title="Request 结构体方法"></a><code>Request</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">AddCookie</span><span class="params">(c *Cookie)</span>  // 添加 <span class="title">cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">BasicAuth</span><span class="params">()</span> <span class="params">(username, password <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span> // 返回请求基本认证中的用户名密码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookie</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Cookie, error)</span> // 返回指定名称的 <span class="title">Cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span>  // 返回所有 <span class="title">cookie</span></span></span><br><span class="line"><span class="comment">// 返回表单中指定 key 中的第一个文件对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormFile</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(multipart.File, *multipart.FileHeader, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span> // 返回表单中 <span class="title">key</span> 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseForm</span><span class="params">()</span> <span class="title">error</span>  // 解析表单</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseMultipartForm</span><span class="params">(maxMemory <span class="keyword">int64</span>)</span> <span class="title">error</span> // 解析带有文件的表单</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Referer</span><span class="params">()</span> <span class="title">string</span>  // 返回引用 <span class="title">URL</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">SetBasicAuth</span><span class="params">(username, password <span class="keyword">string</span>)</span>  // 设置基本认证请求的用户名密码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">UserAgent</span><span class="params">()</span> <span class="title">string</span> // 返回请求的客户端代理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span> // 将请求写入文件</span></span><br></pre></td></tr></table></figure>
<h2 id="Response-结构体方法"><a href="#Response-结构体方法" class="headerlink" title="Response 结构体方法"></a><code>Response</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Response)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span>  // 响应的 <span class="title">cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Response)</span> <span class="title">Location</span><span class="params">()</span> <span class="params">(*url.URL, error)</span> // 返回响应的`<span class="title">Location</span>` 响应头</span></span><br></pre></td></tr></table></figure>

<h2 id="ServeMux-结构体方法"><a href="#ServeMux-结构体方法" class="headerlink" title="ServeMux 结构体方法"></a><code>ServeMux</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册处理请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class="line"><span class="comment">// 返回给定请求的处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Server-结构体方法"><a href="#Server-结构体方法" class="headerlink" title="Server 结构体方法"></a><code>Server</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即关闭服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"> <span class="comment">// 监听并启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServeTLS</span><span class="params">(certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 注册一个函数,当 server 关闭时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">RegisterOnShutdown</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br><span class="line"><span class="comment">// 在 listener 上接受连接,并为每个连接创建一个新的 goroutine 处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ServeTLS</span><span class="params">(l net.Listener, certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 设置是否启用 keep-alive</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">SetKeepAlivesEnabled</span><span class="params">(v <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 优雅的关闭服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// StripPrefix 用于将请求前缀删除,请求 `/tmpfiles/` 会请求到 `/`</span></span><br><span class="line">    <span class="comment">// http.Handle("/tmpfiles/", http.StripPrefix("/tmpfiles/", http.FileServer(http.Dir("/usr/share/doc"))))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会自动解析 index.html.如果没有,则会返回路径下的文件链接</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, http.FileServer(http.Dir(<span class="string">"/usr/share/doc"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用-PostForm-发送请求及数据"><a href="#调用-PostForm-发送请求及数据" class="headerlink" title="调用 PostForm 发送请求及数据"></a>调用 <code>PostForm</code> 发送请求及数据</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := url.Values&#123;</span><br><span class="line">        <span class="string">"name"</span>: []<span class="keyword">string</span>&#123;<span class="string">"name"</span>&#125;,</span><br><span class="line">        <span class="string">"age"</span>:  []<span class="keyword">string</span>&#123;<span class="string">"20"</span>&#125;,</span><br><span class="line">        <span class="string">"addr"</span>: []<span class="keyword">string</span>&#123;<span class="string">"beijing"</span>, <span class="string">"shanghai"</span>, <span class="string">"guangzhou"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    res, _ := http.PostForm(<span class="string">"http://www.httpbin.org/post"</span>, data)</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    n, _ := res.Body.Read(buf)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br></pre></td></tr></table></figure>

<h2 id="Handle-与-HandleFunc"><a href="#Handle-与-HandleFunc" class="headerlink" title="Handle 与 HandleFunc"></a><code>Handle</code> 与 <code>HandleFunc</code></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h1 := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">        io.WriteString(w, <span class="string">"Hello from a HandleFunc #1!\n"</span>)</span><br><span class="line">    h2 := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">        io.WriteString(w, <span class="string">"Hello from a HandleFunc #2!\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    http.HandleFunc(<span class="string">"/h1"</span>, h1)</span><br><span class="line">    http.HandleFunc(<span class="string">"/h2"</span>, h2)</span><br><span class="line">    http.Handle(<span class="string">"/notfount"</span>, http.NotFoundHandler())</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="自定义Handler"><a href="#自定义Handler" class="headerlink" title="自定义Handler"></a>自定义<code>Handler</code></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CustomHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"respose: %v"</span>, c.name) <span class="comment">// 向 w 中写入响应</span></span><br><span class="line">    http.ServeFile(w, req, c.name)  <span class="comment">// 会将文件内容返回给响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := CustomHandler&#123;<span class="string">"index.html"</span>&#125;</span><br><span class="line">    http.ListenAndServe(<span class="string">":80"</span>, http.TimeoutHandler(handler, time.Nanosecond, <span class="string">"请求超时"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 ioutil 包</title>
    <url>/2020/05/03/go-study-notes-package-ioutil/</url>
    <content><![CDATA[<p><code>ioutil</code> 包是 <code>io</code> 包的子包,它提供了一些基本 IO 操作的函数.导入方式为 <code>import &quot;io/ioutil&quot;</code></p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>以下是 <code>ioutil</code> 包中常用的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 r 读取所有数据,直到出现错误或 EOF.返回读取的数据及可能出现的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 读取指定目录下的文件.返回目录下按文件名排序的 `os.FileInfo` 列表及可能出现的错误.</span></span><br><span class="line"><span class="comment">// 只能读取一层.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span></span><br><span class="line"><span class="comment">// 返回读取的指定文件内容及可能出现的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定 dir 目录下创建带有 prefix 前缀的随机临时目录.返回创建的随机临时目录路径名及可能发生的错误</span></span><br><span class="line"><span class="comment">// dir 如果为空,则设定为 `os.TempDir()`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, prefix <span class="keyword">string</span>)</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 在指定 dir 目录下创建带有 pattern 前缀的随机临时目录.返回创建的随机文件的 `*os.File` 及可能发生的错误</span></span><br><span class="line"><span class="comment">// dir 如果为空,则设定为 `os.TempDir()`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(f *os.File, err error)</span></span></span><br><span class="line"><span class="comment">// 将 data 写入指定 filename.返回可能发生的错误</span></span><br><span class="line"><span class="comment">// 如果文件不存在,则以 perm 权限创建该文件;否则清空文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFileExample</span><span class="params">(src, dest <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    data, err := ioutil.ReadFile(src)</span><br><span class="line">    err = ioutil.WriteFile(dest, data, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := copyFileExample(<span class="string">"src"</span>, <span class="string">"dest"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取指定目录及其子目录所有文件"><a href="#读取指定目录及其子目录所有文件" class="headerlink" title="读取指定目录及其子目录所有文件"></a>读取指定目录及其子目录所有文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFile</span><span class="params">(dir <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    PathSeparator := <span class="keyword">string</span>(os.PathSeparator)</span><br><span class="line">    fileInfos, err := ioutil.ReadDir(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, fileInfo := <span class="keyword">range</span> fileInfos &#123;</span><br><span class="line">        <span class="keyword">if</span> fileInfo.IsDir() &#123;</span><br><span class="line">            dirname := strings.Join([]<span class="keyword">string</span>&#123;dir, fileInfo.Name()&#125;, PathSeparator)</span><br><span class="line">            findFile(dirname)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%v%v%v\n"</span>, dir, PathSeparator, fileInfo.Name())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    findFile(<span class="string">"."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 net 包</title>
    <url>/2020/05/10/go-study-notes-package-net/</url>
    <content><![CDATA[<p><code>net</code> 包为网络 I/O 提供了可移植的接口,包括 TCP/IP,UDP,域名解析和 Unix 套接字等.</p>
<p>该软件包提供了对底层网络原语的访问,大多数客户端仅需要 <code>net</code> 包提供的 <code>Dial</code> 和 <code>Listen</code> 函数, <code>Conn</code> 和 <code>Listener</code> 接口相关的的 <code>Accept</code> 方法. <code>crypto/tls</code> 软件包使用相同的接口提供 <code>Dial</code> 和 <code>Listen</code> 函数.</p>
<p>客户端与服务端最简单的通信主要代码示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略部分内容...</span></span><br><span class="line"><span class="comment">// 服务端,监听 tcp localhost:8080 端口</span></span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := ln.Accept()  <span class="comment">// 一直接收连接请求</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> handleConnection(conn)  <span class="comment">// 处理连接的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端调用 Dial 函数与 tcp localhost:8080 建立连接.</span></span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向 conn 写入数据,也就是向服务端发送请求,相关数据会交给服务端处理</span></span><br><span class="line">fmt.Fprintf(conn, <span class="string">"GET / HTTP/1.0\r\n\r\n"</span>)</span><br><span class="line"><span class="comment">// 服务端处理后的数据会写入 conn,客户端就可以从中读取相关响应</span></span><br><span class="line">status, err := bufio.NewReader(conn).ReadString(<span class="string">'\n'</span>)  </span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>域名解析</p>
</blockquote>
<p>域名解析相关方法因操作系统而异.</p>
<p>Unix 系统上,可以使用纯 Go 解析器将 DNS 请求直接发送到 <code>/etc/resolv.conf</code> 列出的两个 DNS 服务器,也可以使用 cgo 的解析器调用 C 语言库,如 getaddrinfo 和 getnameinfo.<br>默认情况下使用纯 Go 解释器,可通过如下方式进行修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GODEBUG=netdns=go    <span class="comment"># 强制使用 Go 解析器</span></span><br><span class="line"><span class="built_in">export</span> GODEBUG=netdns=cgo   <span class="comment"># 强制使用 cgo 解析器</span></span><br></pre></td></tr></table></figure>

<p>Windows 系统上,解析器始终调用 C 语言库函数,如 GetAddrInfo 和 DnsQuery</p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示网络端点地址</span></span><br><span class="line"><span class="comment">// 该接口的实现包括 IPAddr,IPNet,TCPAddr,UDPAddr,UnixAddr</span></span><br><span class="line"><span class="keyword">type</span> Addr <span class="keyword">interface</span> &#123;</span><br><span class="line">    Network() <span class="keyword">string</span> <span class="comment">// 网络类型</span></span><br><span class="line">    String() <span class="keyword">string</span>  <span class="comment">// 地址+端口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通用网络连接,多个 goroutine 可以安全调用 Conn 上的方法</span></span><br><span class="line"><span class="comment">// 该接口的实现包括 tls.Conn,IPConn,TCPConn,UDPConn,UnixConn</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error) <span class="comment">// 从连接中读数据</span></span><br><span class="line">    Write(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error) <span class="comment">// 向连接中写数据</span></span><br><span class="line">    Close() error <span class="comment">// 关闭连接</span></span><br><span class="line">    LocalAddr() Addr <span class="comment">// 连接的本地地址</span></span><br><span class="line">    RemoteAddr() Addr <span class="comment">// 连接的远程地址</span></span><br><span class="line">    SetDeadline(t time.Time) error <span class="comment">// 设置连接的截止时间,0 表示不会超时</span></span><br><span class="line">    SetReadDeadline(t time.Time) error</span><br><span class="line">    SetWriteDeadline(t time.Time) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听器接口定义</span></span><br><span class="line"><span class="comment">// 该接口的实现包括 TCPListener,UnixListener</span></span><br><span class="line"><span class="keyword">type</span> Listener <span class="keyword">interface</span> &#123;</span><br><span class="line">    Accept() (Conn, error)  <span class="comment">// 等待连接</span></span><br><span class="line">    Close() error  <span class="comment">// 关闭监听</span></span><br><span class="line">    Addr() Addr  <span class="comment">// 返回监听者的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h1 id="net-包函数"><a href="#net-包函数" class="headerlink" title="net 包函数"></a><code>net</code> 包函数</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向给定的 network, address 发起连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTimeout</span><span class="params">(network, address <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Conn, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给定的 network, address 进行监听.返回监听的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析给定 host 的 IP 地址,返回 IP 列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookupIP</span><span class="params">(host <span class="keyword">string</span>)</span> <span class="params">([]IP, error)</span></span></span><br><span class="line"><span class="comment">// 将给的字符串解析为 IP 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseIP</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">IP</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="简单通信"><a href="#简单通信" class="headerlink" title="简单通信"></a>简单通信</h2><ul>
<li>server.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"server listen %v\n"</span>, listener.Addr())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"conn established from remote %v\n"</span>, conn.RemoteAddr())</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rn, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        message := <span class="keyword">string</span>(buf[:rn])</span><br><span class="line">        fmt.Printf(<span class="string">"client send: %v\n"</span>, message)</span><br><span class="line">        response := <span class="string">"response:"</span> + message</span><br><span class="line">        conn.Write([]<span class="keyword">byte</span>(response))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>client.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"conn from %v to %v\n"</span>, conn.LocalAddr(), conn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(<span class="string">"send message"</span>))</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    n, err := conn.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"recv response: %v"</span>, <span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 os 包</title>
    <url>/2020/05/02/go-study-notes-package-os/</url>
    <content><![CDATA[<p><code>os</code> 包提供了与平台无关的接口以便于为我们提供对系统进行操作函数.导入方式为 <code>import &quot;os&quot;</code></p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件类型掩码封装</span></span><br><span class="line"><span class="keyword">type</span> FileMode <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件对象结构体</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件信息接口</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span>       <span class="comment">// 文件的名字（不含扩展名）</span></span><br><span class="line">    Size() <span class="keyword">int64</span>        <span class="comment">// 普通文件返回值表示其大小,其他文件的返回值含义各系统不同</span></span><br><span class="line">    Mode() FileMode     <span class="comment">// 文件的模式位</span></span><br><span class="line">    ModTime() time.Time <span class="comment">// 文件的修改时间</span></span><br><span class="line">    IsDir() <span class="keyword">bool</span>        <span class="comment">// 等价于Mode().IsDir()</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 底层数据来源（可以返回nil）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用常量及变量"><a href="#常用常量及变量" class="headerlink" title="常用常量及变量"></a>常用常量及变量</h1><p>以下提供了 <code>os</code> 包中的常用常量,包含文件的类型权限,属性等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    &#x2F;&#x2F; 单个字符是 String() 方法格式化的缩写</span><br><span class="line">    ModeDir        FileMode &#x3D; 1 &lt;&lt; (32 - 1 - iota) &#x2F;&#x2F; d: 目录</span><br><span class="line">    ModeAppend                                     &#x2F;&#x2F; a: 追加</span><br><span class="line">    ModeExclusive                                  &#x2F;&#x2F; l: 执行</span><br><span class="line">    ModeTemporary                                  &#x2F;&#x2F; T: 临时文件</span><br><span class="line">    ModeSymlink                                    &#x2F;&#x2F; L: 链接文件</span><br><span class="line">    ModeDevice                                     &#x2F;&#x2F; D: 设备文件</span><br><span class="line">    ModeNamedPipe                                  &#x2F;&#x2F; p: 管道文件(FIFO)</span><br><span class="line">    ModeSocket                                     &#x2F;&#x2F; S: Unix 套接字文件</span><br><span class="line">    ModeSetuid                                     &#x2F;&#x2F; u: setuid</span><br><span class="line">    ModeSetgid                                     &#x2F;&#x2F; g: setgid</span><br><span class="line">    ModeCharDevice                                 &#x2F;&#x2F; c: Unix 字符设备</span><br><span class="line">    ModeSticky                                     &#x2F;&#x2F; t: sticky</span><br><span class="line">    ModeIrregular                                  &#x2F;&#x2F; ?: 非常规文件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类型的掩码,对于常规文件,设置为 none</span><br><span class="line">    ModeType &#x3D; ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeCharDevice | ModeIrregular</span><br><span class="line"></span><br><span class="line">    ModePerm FileMode &#x3D; 0777 &#x2F;&#x2F; Unix 权限位</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    &#x2F;&#x2F; 必须指定 O_RDONLY, O_WRONLY, O_RDWR 之一</span><br><span class="line">    O_RDONLY int &#x3D; syscall.O_RDONLY &#x2F;&#x2F; 只读方式打开文件</span><br><span class="line">    O_WRONLY int &#x3D; syscall.O_WRONLY &#x2F;&#x2F; 只写方式打开文件</span><br><span class="line">    O_RDWR   int &#x3D; syscall.O_RDWR   &#x2F;&#x2F; 读写方式打开文件</span><br><span class="line">    &#x2F;&#x2F; 下面的值可以用来控制行为</span><br><span class="line">    O_APPEND int &#x3D; syscall.O_APPEND &#x2F;&#x2F; 追加写入数据</span><br><span class="line">    O_CREATE int &#x3D; syscall.O_CREAT  &#x2F;&#x2F; 文件不存在则创建</span><br><span class="line">    O_EXCL   int &#x3D; syscall.O_EXCL   &#x2F;&#x2F; 与 O_CREATE 一起使用,文件必须不存在</span><br><span class="line">    O_SYNC   int &#x3D; syscall.O_SYNC   &#x2F;&#x2F; 以同步 I&#x2F;O 方式打开</span><br><span class="line">    O_TRUNC  int &#x3D; syscall.O_TRUNC  &#x2F;&#x2F; 打开时清空文件内容</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    SEEK_SET int &#x3D; 0 &#x2F;&#x2F; 相对于文件开始位置,已过时,而使用 io.SeekStart</span><br><span class="line">    SEEK_CUR int &#x3D; 1 &#x2F;&#x2F; 相对于文件当前位置,已过时,而使用 io.SeekCurrent</span><br><span class="line">    SEEK_END int &#x3D; 2 &#x2F;&#x2F; 相对于文件结尾位置,已过时,而使用 io.SeekEnd</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    PathSeparator     &#x3D; &#39;&#x2F;&#39; &#x2F;&#x2F; Unix 操作系统指定的路径分隔符</span><br><span class="line">    PathListSeparator &#x3D; &#39;:&#39; &#x2F;&#x2F; Unix 操作系统指定的表分隔符</span><br><span class="line">)</span><br><span class="line">const (</span><br><span class="line">    PathSeparator     &#x3D; &#39;\\&#39; &#x2F;&#x2F; Windows 操作系统指定的路径分隔符</span><br><span class="line">    PathListSeparator &#x3D; &#39;;&#39; &#x2F;&#x2F; Windows 操作系统指定的表分隔符</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    Stdin  &#x3D; NewFile(uintptr(syscall.Stdin), &quot;&#x2F;dev&#x2F;stdin&quot;)</span><br><span class="line">    Stdout &#x3D; NewFile(uintptr(syscall.Stdout), &quot;&#x2F;dev&#x2F;stdout&quot;)</span><br><span class="line">    Stderr &#x3D; NewFile(uintptr(syscall.Stderr), &quot;&#x2F;dev&#x2F;stderr&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="os-包函数"><a href="#os-包函数" class="headerlink" title="os 包函数"></a><code>os</code> 包函数</h2><h3 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回系统主机名及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hostname</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 返回环境变量的字符串副本,形式为 "key=value"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Environ</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回指定环境变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getenv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span>  </span><br><span class="line"><span class="comment">// 设置环境变量(仅在当前进程生效),返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setenv</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 删除当前进程的所有环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clearenv</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 使程序按照给定的状态码退出,程序会立即终止, defer 函数不会执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exit</span><span class="params">(code <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getuid</span><span class="params">()</span> <span class="title">int</span>  // 返回调用者的用户<span class="title">ID</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getgid</span><span class="params">()</span> <span class="title">int</span>  // 返回调用者的组<span class="title">ID</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getpid</span><span class="params">()</span> <span class="title">int</span>  // 返回当前程序的进程<span class="title">ID</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getppid</span><span class="params">()</span> <span class="title">int</span>  // 返回当前进程的父进程<span class="title">ID</span></span></span><br></pre></td></tr></table></figure>

<h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回描述指定的文件的 FileInfo 及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo, err error)</span></span></span><br><span class="line"><span class="comment">// 采用 0666 模式创建文件,如果文件存在则清空.返回文件描述符为 O_RDWR 的 IO 文件对象及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br><span class="line"><span class="comment">// 以只读方式打开文件.返回文件描述符为 O_RDONLY 的只读文件对象及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br><span class="line"><span class="comment">// 以指定的文件描述符 flag,指定的模式打开或创建文件.返回文件对象及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(file *File, err error)</span></span></span><br><span class="line"><span class="comment">// 判断在文件操作过程中发生的错误是否是文件已存在的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断在文件操作过程中发生的错误是否是文件不存在的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断在文件操作过程中发生的错误是否是因权限问题而引发的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 返回当前工作目录路径.默认工作目录为 $GOPATH/src</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getwd</span><span class="params">()</span> <span class="params">(dir <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将当前工作目录修改为执行目录,并返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chdir</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改指定文件权限.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chmod</span><span class="params">(name <span class="keyword">string</span>, mode FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改指定文件属主属组.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改指定文件的访问时间和修改时间.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chtimes</span><span class="params">(name <span class="keyword">string</span>, atime time.Time, mtime time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用指定权限创建目录.如果上级目录不存存在,则会报错.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用指定权限创建目录.如果上级目录不存存在,则会递归创建.返回可能发生的错误.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(path <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 移动文件.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 删除文件或目录.如果目录不为空,则报错.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 删除 path 及其目录下所有文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 创建 newname 指向 oldname 的符号链.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Symlink</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回用于保存临时文件的默认目录.</span></span><br><span class="line"><span class="comment">// windows 下为 C:\Users\&lt;Username&gt;\AppData\Local\Temp, linux 下为 /tmp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h2 id="File-结构体方法"><a href="#File-结构体方法" class="headerlink" title="File 结构体方法"></a><code>File</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回文件的名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回描述指定的文件的 FileInfo 及可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Stat</span><span class="params">()</span> <span class="params">(fi FileInfo, err error)</span></span></span><br><span class="line"><span class="comment">// 返回文件的整数类型的Unix文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Fd</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="comment">// 修改文件权限,返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chmod</span><span class="params">(mode FileMode)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 修改文件属主属组,返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chown</span><span class="params">(uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 保留 size 大小的文件内容,多出的部分就会被丢弃.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Truncate</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 从文件对象中最多读取 len(b) 字节数据并写入 b.返回读取的字节数和可能遇到的任何错误.文件终止标志是读取 0 个字节且err 为 io.EOF</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 从指定的位置读取len(b)字节数据并写入b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 向文件中写入len(b)字节数据,返回写入的字节数和可能发生的错误,如果 n!=len(b), nil 不为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 向文件中写入字符串,类似于 Write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ret <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 向文件指定位置写入字节数据,类似于 Write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 设置下一次读/写的位置,返回新的偏移量(相对于开头)及可能发生的错误.</span></span><br><span class="line"><span class="comment">// offset 为相对偏移量,whence 决定相对位置: 0为相对文件开头,1为相对当前位置,2为相对文件结尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Sync</span><span class="params">()</span> <span class="params">(err error)</span></span></span><br><span class="line"><span class="comment">// 关闭文件.返回可能发生的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="文件读写示例"><a href="#文件读写示例" class="headerlink" title="文件读写示例"></a>文件读写示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">"filename"</span>, os.O_RDWR|os.O_CREATE|os.O_SYNC|os.O_APPEND, <span class="number">0</span>)  <span class="comment">// 打开文件方式为 读写,不存在则创建, 写同步, 追加</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"err"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件写入</span></span><br><span class="line">    <span class="keyword">var</span> bytes = []<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'\n'</span>&#125;</span><br><span class="line">    file.Write(bytes)  <span class="comment">// 以 []bete 方式写入文件</span></span><br><span class="line">    str := <span class="string">"this is string to write\n"</span></span><br><span class="line">    <span class="keyword">var</span> strBytes = []<span class="keyword">byte</span>(str)</span><br><span class="line">    file.Write(strBytes)</span><br><span class="line">    file.WriteString(str)  <span class="comment">// 向文件写入字符串</span></span><br><span class="line">    <span class="comment">// file.Sync() // 若 OpenFile 没有 os.O_TRUNC 标识,则需要显示同步,以上写入操作才会同步到文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件读取</span></span><br><span class="line">    buffer := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    file.Seek(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment">// 在写时,文件读取指针已经移到最后了,需要设置从文件开始位置开始读取. 如果是心打开的文件,可以不设置</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="built_in">len</span>, err := file.Read(buffer)  <span class="comment">// 读取文件内容到 buffer 中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span> == <span class="number">0</span> &amp;&amp; err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(<span class="keyword">string</span>(buffer[:<span class="built_in">len</span>]))  <span class="comment">// 输出文件内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os</code> 包没有直接提供对文件按行读取的方法,我们需要借助 <code><a href="/2020/05/01/go-study-notes-package-time/" title="bufio">bufio</a></code> 包来实现</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 sort 包</title>
    <url>/2020/05/16/go-study-notes-package-sort/</url>
    <content><![CDATA[<p><code>sort</code> 包提供了对于切片和用户定义的集合进行排序的原始函数,实现了 3 种基本的排序算法: 插入排序,快速排序和堆排序.它们只在 <code>sort</code> 包内部使用.用户无需考虑使用哪种排序方式. <code>sort</code> 包会根据实际数自动选择高效的排序算法.</p>
<p>在使用 <code>sort</code> 包对数据进行排序时,必须要求集合的元素由整数索引来枚举,那么我们只需要对该类型实现 <code>sort.Interface</code> 定义的三个方法即可.如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 集合中元素的数量</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 决定了如何进行排序,排序后索引为 i 的元素是否应该在 索引为 j 的元素之前</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 交换索引为 i 和 j  的元素</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort 包中提供了三种实现了 sort.Interface 接口的类型</span></span><br><span class="line"><span class="keyword">type</span> Float64Slice []<span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用函数定义"><a href="#常用函数定义" class="headerlink" title="常用函数定义"></a>常用函数定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对浮点型,整型,字符串切片进行升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Strings</span><span class="params">(a []<span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断浮点型,整型,字符串是否已经升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64sAreSorted</span><span class="params">(a []<span class="keyword">float64</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntsAreSorted</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringsAreSorted</span><span class="params">(a []<span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个实现了 sort.Interface 接口的对象是否已经排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用二分查找并返回 [0, n) 中 f(i) 为 true 的最小索引.</span></span><br><span class="line"><span class="comment">// 多用于查找升序排序(运算符: &gt;=)或降序排序(运算符: &lt;=)的数据中查找指定元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在已排序切片中搜索 x,若查到,则返回查到的索引;否则返回将 x 有序插入 a 后,x 的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用给定的 less 函数对 slice 进行排序. SliceStable 可保证排序是稳定的.</span></span><br><span class="line"><span class="comment">// 如果 slice 不是切片,则会引发 panics</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceStable</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span></span><br><span class="line"><span class="comment">// 测试切片是否已经使用 less 排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceIsSorted</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对实现了 sort.Interface  接口的类型对象进行排序. Stable 可保证排序是稳定的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stable</span><span class="params">(data Interface)</span></span></span><br><span class="line"><span class="comment">// 对数据进行反向排序,常用于 sort.Sort(sort.Reverse(data)) 对数据进行反向排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="使用-sort-Sort-或-sort-Slice-进行排序"><a href="#使用-sort-Sort-或-sort-Slice-进行排序" class="headerlink" title="使用 sort.Sort 或 sort.Slice 进行排序"></a>使用 <code>sort.Sort</code> 或 <code>sort.Slice</code> 进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 sort.Interface 接口,可对 []Person 切片按照指定方式进行排序</span></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="comment">// 使用 Person 的 Age 属性做比较,降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := []Person&#123;</span><br><span class="line">		&#123;<span class="string">"Bob"</span>, <span class="number">31</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"John"</span>, <span class="number">42</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Michael"</span>, <span class="number">17</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Jenny"</span>, <span class="number">26</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(people)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 sort.Sort 方法进行排序</span></span><br><span class="line">	sort.Sort(ByAge(people))</span><br><span class="line">	fmt.Println(people)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 sort.Slice 按指定 less 函数进行降序排序</span></span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> people[i].Age &gt; people[j].Age</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用指定的属性进行排序"><a href="#使用指定的属性进行排序" class="headerlink" title="使用指定的属性进行排序"></a>使用指定的属性进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Age   <span class="keyword">int</span></span><br><span class="line">	Score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d, %.2f"</span>, p.Name, p.Age, p.Score)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 "less" 函数类型,用于定义 Person 排序的方式</span></span><br><span class="line"><span class="keyword">type</span> By <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序的入口函数,传入 people 后构建 personSorter 对象,用于排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(by By)</span> <span class="title">Sort</span><span class="params">(people []Person)</span></span> &#123;</span><br><span class="line">	ps := &amp;personSorter&#123;</span><br><span class="line">		people: people,</span><br><span class="line">		by:     by, <span class="comment">// 使用函数的闭包将 by 对象(实际上是一个函数)作为 personSorter 的成员传入,</span></span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(ps)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// personSorter 类型封装了要排序的对象和如何进行排序的函数</span></span><br><span class="line"><span class="keyword">type</span> personSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	people []Person</span><br><span class="line">	by     <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span> // <span class="title">Closure</span> <span class="title">used</span> <span class="title">in</span> <span class="title">the</span> <span class="title">Less</span> <span class="title">method</span>.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *personSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s.people) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *personSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; s.people[i], s.people[j] = s.people[j], s.people[i] &#125;</span><br><span class="line"><span class="comment">// Less 方法滴啊用 by 成员(by 是一个函数),决定如何进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *personSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.by(&amp;s.people[i], &amp;s.people[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := []Person&#123;</span><br><span class="line">		&#123;<span class="string">"Bob"</span>, <span class="number">31</span>, <span class="number">83.5</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"John"</span>, <span class="number">42</span>, <span class="number">86.0</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Michael"</span>, <span class="number">17</span>, <span class="number">79.6</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Jenny"</span>, <span class="number">26</span>, <span class="number">89.3</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 定义排序的方式,按照 Person 各种属性进行排序,</span></span><br><span class="line">	name := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.Name &lt; p2.Name</span><br><span class="line">	&#125;</span><br><span class="line">	age := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.Age &lt; p2.Age</span><br><span class="line">	&#125;</span><br><span class="line">	score := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.Score &lt; p2.Score</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用 score 方法, p1,p2 调换位置,实现倒序</span></span><br><span class="line">	decreasingScore := <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> score(p2, p1)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照既定的方式进行排序</span></span><br><span class="line">	By(name).Sort(people)</span><br><span class="line">	fmt.Println(<span class="string">"By Name:"</span>, people)</span><br><span class="line">	By(age).Sort(people)</span><br><span class="line">	fmt.Println(<span class="string">"By Age:"</span>, people)</span><br><span class="line">	By(score).Sort(people)</span><br><span class="line">	fmt.Println(<span class="string">"By Score:"</span>, people)</span><br><span class="line">	By(decreasingScore).Sort(people)</span><br><span class="line">	fmt.Println(<span class="string">"By decreasing Score:"</span>, people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多个属性进行排序"><a href="#使用多个属性进行排序" class="headerlink" title="使用多个属性进行排序"></a>使用多个属性进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义待排序对象</span></span><br><span class="line"><span class="keyword">type</span> Change <span class="keyword">struct</span> &#123;</span><br><span class="line">	user     <span class="keyword">string</span></span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">	lines    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定以 "less" 函数,用于定义排序的方式</span></span><br><span class="line"><span class="keyword">type</span> lessFunc <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Change)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multiSorter 实现了 sort.Interface 接口,按照指定方式对 changes 属性进行排序</span></span><br><span class="line"><span class="keyword">type</span> multiSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	changes []Change</span><br><span class="line">	less    []lessFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(ms.changes) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; ms.changes[i], ms.changes[j] = ms.changes[j], ms.changes[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Less 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	p, q := &amp;ms.changes[i], &amp;ms.changes[j]</span><br><span class="line">	<span class="comment">// 依次按照 ms 中 less 中包含的函数进行判断,不包括最后一个</span></span><br><span class="line">	<span class="keyword">var</span> k <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">0</span>; k &lt; <span class="built_in">len</span>(ms.less)<span class="number">-1</span>; k++ &#123;</span><br><span class="line">		less := ms.less[k]</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> less(p, q):</span><br><span class="line">			<span class="comment">// p &lt; q, so we have a decision.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> less(q, p):</span><br><span class="line">			<span class="comment">// p &gt; q, so we have a decision.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// p == q; 进行下次比较</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 除最后一个,之前的函数都相等,此时 k = len(ms.less)-1,则按照最后一个函数进行判断</span></span><br><span class="line">	<span class="keyword">return</span> ms.less[k](p, q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序的入口函数,调用此方法对 changes 进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Sort</span><span class="params">(changes []Change)</span></span> &#123;</span><br><span class="line">	ms.changes = changes</span><br><span class="line">	sort.Sort(ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 multiSorter 对象调用其 Sort 方法进行排序</span></span><br><span class="line"><span class="comment">// 调用 Sort 方法后,该对象按照 less 函数定义的排序方式进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedBy</span><span class="params">(less ...lessFunc)</span> *<span class="title">multiSorter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;multiSorter&#123;</span><br><span class="line">		less: less,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> changes = []Change&#123;</span><br><span class="line">	&#123;<span class="string">"gri"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"ken"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"glenda"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"rsc"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"r"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"ken"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"dmr"</span>, <span class="string">"C"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"r"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"gri"</span>, <span class="string">"Smalltalk"</span>, <span class="number">80</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义排序的方式</span></span><br><span class="line">	user := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> c1.user &lt; c2.user &#125;</span><br><span class="line">	language := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> c1.language &lt; c2.language &#125;</span><br><span class="line">	increasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> c1.lines &lt; c2.lines &#125;</span><br><span class="line">	decreasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> increasingLines(c2, c1) &#125;</span><br><span class="line"></span><br><span class="line">	OrderedBy(user).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user:"</span>, changes)</span><br><span class="line">	<span class="comment">// 使用多键进行排序</span></span><br><span class="line">	OrderedBy(user, increasingLines).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user,&lt;lines:"</span>, changes)</span><br><span class="line">	OrderedBy(user, decreasingLines).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user,&gt;lines:"</span>, changes)</span><br><span class="line">	OrderedBy(language, increasingLines).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By language,&lt;lines:"</span>, changes)</span><br><span class="line">	OrderedBy(language, increasingLines, user).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By language,&lt;lines,user:"</span>, changes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用继承对数据进行排序"><a href="#使用继承对数据进行排序" class="headerlink" title="使用继承对数据进行排序"></a>使用继承对数据进行排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Grams <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Grams)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%dg"</span>, <span class="keyword">int</span>(g)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Organ <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Weight Grams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Organs []*Organ</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Organs)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Organs)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Organs 并实现 Less 方法,从而实现 Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> ByName <span class="keyword">struct</span>&#123; Organs &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByName)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s.Organs[i].Name &lt; s.Organs[j].Name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Organs 并实现 Less 方法,从而实现 Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> ByWeight <span class="keyword">struct</span>&#123; Organs &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByWeight)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s.Organs[i].Weight &lt; s.Organs[j].Weight &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []*Organ&#123;</span><br><span class="line">		&#123;<span class="string">"brain"</span>, <span class="number">1340</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"heart"</span>, <span class="number">290</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"liver"</span>, <span class="number">1494</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"pancreas"</span>, <span class="number">131</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"prostate"</span>, <span class="number">62</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"spleen"</span>, <span class="number">162</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(ByWeight&#123;s&#125;)</span><br><span class="line">	fmt.Println(<span class="string">"Organs by weight:"</span>)</span><br><span class="line">	printOrgans(s)</span><br><span class="line">	sort.Sort(ByName&#123;s&#125;)</span><br><span class="line">	fmt.Println(<span class="string">"Organs by name:"</span>)</span><br><span class="line">	printOrgans(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOrgans</span><span class="params">(s []*Organ)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%-8s (%v)\n"</span>, o.Name, o.Weight)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-sort-Search-查找指定元素"><a href="#使用-sort-Search-查找指定元素" class="headerlink" title="使用 sort.Search 查找指定元素"></a>使用 <code>sort.Search</code> 查找指定元素</h2><ul>
<li>升序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">55</span>&#125;</span><br><span class="line">	x := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">	i := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) &amp;&amp; a[i] == x &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"found %d at index %d in %v\n"</span>, x, i, a)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d not found in %v\n"</span>, x, a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>降序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">55</span>, <span class="number">45</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;</span><br><span class="line">	x := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">	i := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt;= x &#125;)</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) &amp;&amp; a[i] == x &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"found %d at index %d in %v\n"</span>, x, i, a)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d not found in %v\n"</span>, x, a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 sql 包</title>
    <url>/2020/05/06/go-study-notes-package-sql/</url>
    <content><![CDATA[<p><code>database/sql/driver</code> 包定义了 <code>database/sql</code> 包使用的数据库程序要实现的接口<br><code>database/sql</code> 包提供了有关 SQL 的数据库通用接口. sql 包必须与数据库驱动程序一起使用.相关程序列表,参见 <a href="https://github.com/golang/go/wiki/SQLDrivers" target="_blank" rel="noopener">https://github.com/golang/go/wiki/SQLDrivers</a></p>
<p>如连接 mysql 需要使用导入 mysql 的驱动程序包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line"></span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"user:password@/dbname"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列的类型</span></span><br><span class="line"><span class="keyword">type</span> ColumnType <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单个数据库连接.除非特别需要连续的单个数据库连接,否则最好 DB 对象</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据库对象,对于多个 goroutine 时并发安全的.会自动创建并释放连接</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库统计信息</span></span><br><span class="line"><span class="keyword">type</span> DBStats <span class="keyword">struct</span> &#123;</span><br><span class="line">    MaxOpenConnections <span class="keyword">int</span> <span class="comment">// 最大连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池状态</span></span><br><span class="line">    OpenConnections <span class="keyword">int</span> <span class="comment">// 使用和空闲的连接数</span></span><br><span class="line">    InUse           <span class="keyword">int</span> <span class="comment">// 正在使用的连接数</span></span><br><span class="line">    Idle            <span class="keyword">int</span> <span class="comment">// 空闲连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="comment">//等待</span></span><br><span class="line">    WaitCount         <span class="keyword">int64</span>         <span class="comment">// 等待的连接总数</span></span><br><span class="line">    WaitDuration      time.Duration <span class="comment">// 等待新连接的总时间</span></span><br><span class="line">    MaxIdleClosed     <span class="keyword">int64</span>         <span class="comment">// 由于 SetMaxIdleConns 而关闭的连接总数</span></span><br><span class="line">    MaxLifetimeClosed <span class="keyword">int64</span>         <span class="comment">// 由于 SetConnMaxLifetime 而关闭的连接总数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果信息接口</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回数据库为响应命令而生成的整数.通常用于插入新行的自增列</span></span><br><span class="line">    LastInsertId() (<span class="keyword">int64</span>, error)</span><br><span class="line">    <span class="comment">// 受更新,插入或删除影响的行数.</span></span><br><span class="line">    RowsAffected() (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QueryRow 产生的单行对象</span></span><br><span class="line"><span class="keyword">type</span> Row <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询的多行结果.它的光标从第一行开始,使用 `Next()` 逐行获取下一行的值</span></span><br><span class="line"><span class="keyword">type</span> Rows <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理的语句.可以被多个 goroutine 安全并发使用</span></span><br><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务</span></span><br><span class="line"><span class="keyword">type</span> Tx <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事务选项,定义了事务的隔离级别</span></span><br><span class="line"><span class="keyword">type</span> TxOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 事务的隔离级别</span></span><br><span class="line">    Isolation IsolationLevel</span><br><span class="line">    ReadOnly  <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隔离级别</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    LevelDefault IsolationLevel = <span class="literal">iota</span></span><br><span class="line">    LevelReadUncommitted</span><br><span class="line">    LevelReadCommitted</span><br><span class="line">    LevelWriteCommitted</span><br><span class="line">    LevelRepeatableRead</span><br><span class="line">    LevelSnapshot</span><br><span class="line">    LevelSerializable</span><br><span class="line">    LevelLinearizable</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="sql-包函数"><a href="#sql-包函数" class="headerlink" title="sql 包函数"></a><code>sql</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回已注册的驱动列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Drivers</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 注册驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, driver driver.Driver)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个由其数据库驱动名称 driverName 和特定驱动程序的数据源名称 dataSourceName 指定的数据库</span></span><br><span class="line"><span class="comment">// 该函数可能只验证参数而不创建与数据库的连接.要验证数据源名称是否有效,调用 Ping 函数</span></span><br><span class="line"><span class="comment">// 返回的数据库可安全的供多个 goroutine 并发使用,并维护自己的空闲连接池.因此此函数只需要调用一次</span></span><br><span class="line"><span class="comment">// dataSourceName 一般形式为 `username:password@protocol(address)/dbname?param=value`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span></span><br><span class="line"><span class="comment">// 使用连接器打开数据库,从而避免字符串的数据源名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenDB</span><span class="params">(c driver.Connector)</span> *<span class="title">DB</span></span></span><br></pre></td></tr></table></figure>

<h2 id="ColumnType-结构体方法"><a href="#ColumnType-结构体方法" class="headerlink" title="ColumnType 结构体方法"></a><code>ColumnType</code> 结构体方法</h2><p><code>ColumnType</code> 定义了列的类型,它包含以下方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回数据库中对应的列的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">DatabaseTypeName</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回小数类型的小数精度和位数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">DecimalSize</span><span class="params">()</span> <span class="params">(precision, scale <span class="keyword">int64</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回可变类型长度列类型(如 text 和 binary)的列类型长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">Length</span><span class="params">()</span> <span class="params">(length <span class="keyword">int64</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回列的名称或列的别名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 该列是否可为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">Nullable</span><span class="params">()</span> <span class="params">(nullable, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回适合使用 Rows.Scan 进行扫描的 Go 反射类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ColumnType)</span> <span class="title">ScanType</span><span class="params">()</span> <span class="title">reflect</span>.<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<h2 id="DB-结构体方法"><a href="#DB-结构体方法" class="headerlink" title="DB 结构体方法"></a><code>DB</code> 结构体方法</h2><p><code>DB</code> 定义了数据库的实例对象.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始事务,默认的隔离级别取决与驱动程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Begin</span><span class="params">()</span> <span class="params">(*Tx, error)</span></span></span><br><span class="line"><span class="comment">// 开始事务,在事务提交或回滚之前,将使用上下文.如果上下文被取消,事务将回滚</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">BeginTx</span><span class="params">(ctx context.Context, opts *TxOptions)</span> <span class="params">(*Tx, error)</span></span></span><br><span class="line"><span class="comment">// 关闭数据库连接,阻止启动新查询.很少用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 打开新连接或从连接池返回现有连接. Conn 将阻塞,直到返回连接池或取消 ctx.使用后必须调用 Conn.Close 将每个 Conn 返回到数据库连接池</span></span><br><span class="line"><span class="comment">// 在同一 Conn 上运行的查询将在同一数据库会话中运行.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Conn</span><span class="params">(ctx context.Context)</span> <span class="params">(*Conn, error)</span></span></span><br><span class="line"><span class="comment">// 底层驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Driver</span><span class="params">()</span> <span class="title">driver</span>.<span class="title">Driver</span></span></span><br><span class="line"><span class="comment">// 执行 query 语句,但不返回任何行.args 参数用于查询中的占位符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">ExecContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="comment">// 验证与数据库的连接是否存在,必要时建立连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">PingContext</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 为后续查询或执行做好准备.Stmt 可以并发执行多个查询或执行,当不需要 Stmt 时,需要调用 Stmt.Close 显式关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">PrepareContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br><span class="line"><span class="comment">// 执行查询语句,返回多行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="comment">// 执行查询语句,返回单行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryRowContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="comment">// 设置可重用连接的最长时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetConnMaxLifetime</span><span class="params">(d time.Duration)</span></span></span><br><span class="line"><span class="comment">// 设置空闲连接池中的最大连接数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxIdleConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 设置数据库打开的最大连接数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxOpenConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 返回数据库统计信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Stats</span><span class="params">()</span> <span class="title">DBStats</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Rows-结构体方法"><a href="#Rows-结构体方法" class="headerlink" title="Rows 结构体方法"></a><code>Rows</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回列的信息,如类型,长度,是否可为空.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">ColumnTypes</span><span class="params">()</span> <span class="params">([]*ColumnType, error)</span></span></span><br><span class="line"><span class="comment">// 返回列的名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Columns</span><span class="params">()</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="comment">// 准备下一行,以使用 Scan 方法获取.如果策成功,返回 ture.每次调用 Scan 时,都必须先调用该函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 准备下一个要读取的结果集.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">NextResultSet</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 将当前行的列复制到 dest 指向的值中. dest 中值的数量必须与"行"中列数相同.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span> <span class="title">Scan</span><span class="params">(dest ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Stmt-结构体方法"><a href="#Stmt-结构体方法" class="headerlink" title="Stmt 结构体方法"></a><code>Stmt</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 执行,并返回 Result 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Exec</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">ExecContext</span><span class="params">(ctx context.Context, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="comment">// 查询,并返回查询到的行对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">Query</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">QueryRow</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stmt)</span> <span class="title">QueryRowContext</span><span class="params">(ctx context.Context, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Tx-结构体方法"><a href="#Tx-结构体方法" class="headerlink" title="Tx 结构体方法"></a><code>Tx</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 执行查询,并返回查询结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Exec</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">ExecContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br><span class="line"><span class="comment">// 事务中创建 Stmt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Prepare</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">PrepareContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br><span class="line"><span class="comment">// 事务中查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">QueryRow</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">QueryRowContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Rollback</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用已有的 Stmt 创建 Stmt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Stmt</span><span class="params">(stmt *Stmt)</span> *<span class="title">Stmt</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">StmtContext</span><span class="params">(ctx context.Context, stmt *Stmt)</span> *<span class="title">Stmt</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cfg := mysql.Config&#123;</span><br><span class="line">        User:                 <span class="string">"username"</span>,</span><br><span class="line">        Passwd:               <span class="string">"password"</span>,</span><br><span class="line">        Net:                  <span class="string">"tcp"</span>,</span><br><span class="line">        Addr:                 <span class="string">"10.71.1.27:3306"</span>,</span><br><span class="line">        DBName:               <span class="string">"datastream-info"</span>,</span><br><span class="line">        AllowNativePasswords: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dataSourceName := cfg.FormatDSN() <span class="comment">// 支持使用 mysql 包中的配置转换方法转换 dataSourceName,也可以使用如下方式直接定义</span></span><br><span class="line">    <span class="comment">// dataSourceName := "username:password@tcp(10.71.1.27:3306)/test"</span></span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>, dataSourceName)</span><br><span class="line">    rows, err := db.Query(<span class="string">"select * from province_num"</span>)</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        id    <span class="keyword">int</span></span><br><span class="line">        name  <span class="keyword">string</span></span><br><span class="line">        value <span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> err = rows.Scan(&amp;id, &amp;name, &amp;value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(id, name, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 strings 包</title>
    <url>/2020/05/01/go-study-notes-package-strings/</url>
    <content><![CDATA[<p><code>strings</code> 包实现了用于操作字符的简单函数.导入方式为 <code>import &quot;strings&quot;</code></p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从字符串读取数据的封装,实现了 `io.Reader`,`io.Seeker`,`io.ReaderAt`,`io.WriterTo``io.ByteScanner`,`io.RuneScanner` 接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行字符替换的封装</span></span><br><span class="line"><span class="keyword">type</span> Replacer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h1 id="strings-包常用函数"><a href="#strings-包常用函数" class="headerlink" title="strings 包常用函数"></a><code>strings</code> 包常用函数</h1><p><code>strings</code> 包中提供了如下常用函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建从指定字符串读取数据的 Reader 对象实例.返回 Reader 对象的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="comment">// 使用多组 old,new 字符串创建 Replacer 对象.返回 Replacer 对象的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReplacer</span><span class="params">(oldnew ...<span class="keyword">string</span>)</span> *<span class="title">Replacer</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否有 prefix 前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否有 suffix 后缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否包含子串 substr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 判断字符串 s 是否包含字符串 chars 中的任一字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 字符串 s 中包含 sep 子串的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 子串 sep 在 s 中第一次出现的位置, 不存在则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 字符 c 在 s 中第一次出现的位置,不存在则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 子串 sep 在 s 中最后一次出现的位置, 不存在则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// s 中每个单词的首字母都改为标题格式的字符串拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将所有字母都转为对应的小写字母的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将所有字母都转为对应的大写字母的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回 count 个 s 串联的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 中前 n 个 old 子串都替换为 new 的新字符串, 如果 n&lt;0 会替换所有 old 子串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 前后 cutset 都删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 前后空白都删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 前面 cutset 删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回将 s 后面 cutset 删除的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 使用 sep 作为分隔符将 s 分割,返回分割后的字符串切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回分割后的字符串切片.n&gt;0,将 s 分割为 n 项, 最后一个子字符串包含未进行切割的部分, 并.如果 n 等于 0 , 返回 nil. n&lt;0,返回所有字符串切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将字符串切片 a 连接成一个字符串,中间用 sep 分割</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Reader-结构体方法"><a href="#Reader-结构体方法" class="headerlink" title="Reader 结构体方法"></a><code>Reader</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是 `io` 包中的相关接口的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(b <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Replacer-结构体方法"><a href="#Replacer-结构体方法" class="headerlink" title="Replacer 结构体方法"></a><code>Replacer</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回对字符串 s 替换进行完后的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">Replace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 向 w 中写入 s 的所有替换进行完后的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">WriteString</span><span class="params">(w io.Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 strconv 包</title>
    <url>/2020/05/03/go-study-notes-package-strconv/</url>
    <content><![CDATA[<p><code>strconv</code> 包实现了基本数据类型和其字符串表示的相互转换.导入方式为 <code>import &quot;strconv&quot;</code></p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>以下是 <code>strconv</code> 包中常用的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试将字符串转换为bool类型,否则返回错误</span></span><br><span class="line"><span class="comment">// 支持如下字符串`1,0,t,f,T,F,true,false,True,False,TRUE,FALSE` </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将字符串转换为整数,支持正负号. </span></span><br><span class="line"><span class="comment">// base 指定进制, 如果为0,会根据 s 自行判断("0x"是16进制,"0"是8进制,否则是10进制)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将字符串转换为浮点型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将布尔值转换为字符串, "true" 或 "false"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回i的base进制的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将浮点数弄表示为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 是 ParseInt(s, 10, 0)的简写.字符串转 int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(i <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 是 FormatInt(i, 10) 的简写. int 转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 runtime 包</title>
    <url>/2020/05/03/go-study-notes-package-runtime/</url>
    <content><![CDATA[<p><code>runtime</code> 包提供了与 Go 运行时系统交互操作的函数.导入方式为 <code>import &quot;runtime&quot;</code></p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>下面的主机上的环境变量控制 Go 程序的运行时行为,其用法和含义可能在各个版本间改变</p>
<h2 id="GOGC"><a href="#GOGC" class="headerlink" title="GOGC"></a><code>GOGC</code></h2><p><code>GOGC</code> 设置初始垃圾回收目标百分比.当新分配的数据与上一次垃圾回收之后的剩余数据之比达到此变量值时,将触发垃圾回收.默认 <code>GOGC=100</code>. <code>GOGC=off</code> 将完全禁用垃圾回收.<code>runtime/debug</code> 包的 <code>SetGCPercent</code> 函数可以在 Go 程序运行时修改此百分比.参见 <a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener">https://golang.org/pkg/runtime/debug/#SetGCPercent</a></p>
<h2 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a><code>GODEBUG</code></h2><p><code>GODEBUG</code> 环境变量控制运行时中的调试变量,它是一个用逗号分割的 <code>name=val</code> 列表,用于设置以下变量</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">allocfreetrace</span>: setting allocfreetrace=1 causes every allocation to be profiled and a stack trace printed on each object's allocation and free</span><br><span class="line"></span><br><span class="line"><span class="attribute">clobberfree</span>: setting clobberfree=1 causes the garbage collector to clobber the memory content of an object with bad content when it freesthe object.</span><br><span class="line"></span><br><span class="line"><span class="attribute">cgocheck</span>: setting cgocheck=0 disables all checks for packages using cgo to incorrectly pass Go pointers to non-Go code.</span><br><span class="line">Setting cgocheck=1 (the default) enables relatively cheap checks that may miss some errors.</span><br><span class="line">Setting cgocheck=2 enables expensive checks that should not miss any errors, but will cause your program to run slower.</span><br><span class="line"></span><br><span class="line"><span class="attribute">efence</span>: setting efence=1 causes the allocator to run in a mode where each object is allocated on a unique page and addresses are never recycled.</span><br></pre></td></tr></table></figure>

<ul>
<li>allocfreetrace: 设置 allocfreetrace=1 使每次分配内存都进行分析,并在每个对象的内存分配及释放时打印堆栈跟踪信息</li>
<li>clobberfree: 设置 clobberfree=1 使垃圾回收器在释放对象时用不好的内容破坏对象的内存内容</li>
<li>cgocheck：设置 cgocheck=0 将禁用所有使用 cgo 将包指针错误传递给非 Go 代码的包检查;cgocheck=1(默认) 将启用相对低耗的检查,可能会丢失一些错误;cgocheck=2 将启用高消耗的检查,不会遗漏任何错误,但会导致程序运行缓慢</li>
<li>efence：设置 efence=1 分配器以每个对象都分配唯一页面,并且地址从不回收的方式运行</li>
</ul>
<h2 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><code>GOMAXPROCS</code></h2><p><code>GOMAXPROCS</code> 环境变量限制了可同时执行用户级 Go 代码的操作系统线程的数量.对 Go 代码在系统调用中被阻塞的线程数量没有限制.那些不计入 <code>GOMAXPROCS</code> 限制. <code>runtime.GOMAXPROCS()</code> 函数查询并修改限制.</p>
<h2 id="GORACE"><a href="#GORACE" class="headerlink" title="GORACE"></a><code>GORACE</code></h2><p><code>GORACE</code> 环境变量为使用 <code>-race</code> 标志的构建程序配置了竞争检测器.详情参见 <a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">https://golang.org/doc/articles/race_detector.html</a></p>
<h2 id="GOTRACEBACK"><a href="#GOTRACEBACK" class="headerlink" title="GOTRACEBACK"></a><code>GOTRACEBACK</code></h2><p><code>GOTRACEBACK</code> 环境变量控制在 Go 程序由于未处理的异常或意外的运行时条件而失败时产生的输出量.默认情况下,产生错误时将打印当前 goroutine 的堆栈跟踪,忽略运行时系统的内部函数,然后以退出代码 2 退出.如果没有当前 goroutine 或故障是运行时内部的,则产生错误时会打印所有 goroutine 的堆栈跟踪信息.</p>
<ul>
<li><code>GOTRACEBACK=none</code> 表示完全省略 goroutine 堆栈跟踪信息</li>
<li><code>GOTRACEBACK=single</code>(默认)的行为如上所述</li>
<li><code>GOTRACEBACK=all</code> 表示为所有的用户创建的 goroutine 添加堆栈跟踪信息</li>
<li><code>GOTRACEBACK=system</code> 与 <code>all</code>类似,但为运行时函数添加了堆栈跟踪信息,并显示了在运行时内部创建的 goroutine</li>
<li><code>GOTRACEBACK=crash</code> 类似于 <code>system</code>,但多用于操作系统崩溃而不是程序退出</li>
</ul>
<p>GOTRACEBACK 设置 0,1 和 2 分别是 none,all 和 system 的同义词.<code>runtime/debug</code> 包的<code>SetTraceback</code> 函数允许在运行时增加输出量,但不能将其减少到环境变量指定的量以下.请参阅 <a href="https://golang.org/pkg/runtime/debug/#SetTraceback" target="_blank" rel="noopener">https://golang.org/pkg/runtime/debug/#SetTraceback</a></p>
<h2 id="GOARCH-GOOS-GOPATH-GOROOT"><a href="#GOARCH-GOOS-GOPATH-GOROOT" class="headerlink" title="GOARCH,GOOS,GOPATH,GOROOT"></a><code>GOARCH</code>,<code>GOOS</code>,<code>GOPATH</code>,<code>GOROOT</code></h2><p><code>GOARCH</code>,<code>GOOS</code>,<code>GOPATH</code>,<code>GOROOT</code> 环境变量完善了 Go 环境变量集.它们会影响 Go 程序的构建(请参阅 <a href="https://golang.org/cmd/go" target="_blank" rel="noopener">https://golang.org/cmd/go</a> 和 <a href="https://golang.org/pkg/go/build" target="_blank" rel="noopener">https://golang.org/pkg/go/build</a>).<code>GOARCH</code>,<code>GOOS</code>,<code>GOROOT</code> 会在编译时记录下来,并可以通过此包中的常量或函数来使用,但它们不会影响运行时系统的执行.</p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Func <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用内置常量及变量"><a href="#常用内置常量及变量" class="headerlink" title="常用内置常量及变量"></a>常用内置常量及变量</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Compiler = <span class="string">"gc"</span>  <span class="comment">// 编译器</span></span><br><span class="line"><span class="keyword">const</span> GOOS <span class="keyword">string</span> = sys.GOOS <span class="comment">// 操作系统,windows,linux,freebsd,darwin等</span></span><br><span class="line"><span class="keyword">const</span> GOARCH <span class="keyword">string</span> = sys.GOARCH <span class="comment">// 平台,386,amd64 或 arm</span></span><br><span class="line"><span class="keyword">var</span> MemProfileRate <span class="keyword">int</span> = <span class="number">512</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="runtime-包函数"><a href="#runtime-包函数" class="headerlink" title="runtime 包函数"></a><code>runtime</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 Go 的根目录.如果存在 GOROOT 环境变量,返回该变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOROOT</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回 Go 的版本字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Version</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回机器的逻辑 CPU 个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCPU</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 设置可同时执行(并行)的最大 CPU 数.返回先前的设置.如果 n&lt;1,则不会更改当前设置.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 设置 CPU profile记录的频率为每秒 hz 次.如果 hz&lt;=0,会关闭 profile 记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCPUProfileRate</span><span class="params">(hz <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 显式执行一次垃圾回收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 终止调用它的 goroutine.其它 goroutine 不受影响.</span></span><br><span class="line"><span class="comment">// 在终止 goroutine 之前会运行所有的延迟调用,且函数中的 recover 调用都将返回 nil. </span></span><br><span class="line"><span class="comment">// 在主 goroutine 调用该函数会终止该 goroutine,主函数不会返回.程序将执行其它 goroutine.如果所有其它 goroutine 退出,程序将崩溃</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 使当前 goroutine 释放处理器,允许其它 goroutine 运行.他不会挂起当前 goroutine,因此当前 goroutine 会自动恢复执行 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 绑定当前 goroutine 到它所在的操作系统线程.当前 goroutine将总是在该线程中执行,其它 goroutine 则不能进入该线程,除非调用相同次数的 UnlockOSThread.</span></span><br><span class="line"><span class="comment">// 如果调用的 goroutine 在没有解锁线程的情况下退出,则该线程将终止.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LockOSThread</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 解除当前 goroutine 与操作系统线程的绑定关系.若 goroutine 未调用 LockOSThread,则不做操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnlockOSThread</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 返回当前进程对 cgo 调用的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCgoCall</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="comment">// 返回当前存在的 goroutine 数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumGoroutine</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回 *Func 用于描述给定指针地址的函数或 nil.如果 pc 由于内联表示多个函数,则将返回描述最内部的函数 *Func,但带有外部函数成员地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> *<span class="title">Func</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Func-结构体方法"><a href="#Func-结构体方法" class="headerlink" title="Func 结构体方法"></a><code>Func</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回外部函数的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Entry</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="comment">// 返回函数名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 sync 包</title>
    <url>/2020/05/04/go-study-notes-package-sync/</url>
    <content><![CDATA[<p><code>sync</code> 包提供了基础的同步方法和锁机制.导入方式为 <code>import &quot;sync&quot;</code></p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locker 接口,表示可以解锁和加锁的对象</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="comment">// 互斥锁与 goroutine 没有关联,允许一个 goroutine 添加锁,另一个 goroutine 释放锁</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅执行一次动作</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源池对象</span></span><br><span class="line"><span class="comment">// 池中的任何对象都可能被随时删除,并且没有通知.如果池中的唯一对象被删除,则该资源池对象也会被释放</span></span><br><span class="line"><span class="comment">// 资源池对象中的实例可被多个 goroutine 安全使用</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以指定一个函数,用于为 Get 生成一个对象.否则 Get 返回 nil</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 goroutine 运行结束</span></span><br><span class="line"><span class="comment">// 主线程调用 Add 方法设置要等待的 goroutine 数量,每个 goroutine 在运行完成后调用 Done.同时,使用 Wait 阻塞主函数,直到所有 goroutine 完成</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="Mutex-结构体方法"><a href="#Mutex-结构体方法" class="headerlink" title="Mutex 结构体方法"></a><code>Mutex</code> 结构体方法</h2><p>互斥锁与 goroutine 没有关联,允许一个 goroutine 添加锁,另一个 goroutine 释放锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明方式 `var m sync.Mutex`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁.如果锁已在使用中,则阻塞,直到互斥锁可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 释放锁.如果未加锁,则会出现运行时错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Once-结构体方法"><a href="#Once-结构体方法" class="headerlink" title="Once 结构体方法"></a><code>Once</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明 `var o sync.Once`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当且仅当 o 第一次调用 Do 方法时,调用函数 f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="Pool-结构体方法"><a href="#Pool-结构体方法" class="headerlink" title="Pool 结构体方法"></a><code>Pool</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明方式 `var p sync.Pool` 或 `var bufPool sync.Pool = sync.Pool&#123;New: funName&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从池中任意取出一个实例,并返回.如果资源池为空,且 p.New 不为空时,Get 返回调用 p.New 的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将 x 放入 p 资源池中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="WaitGroup-结构体方法"><a href="#WaitGroup-结构体方法" class="headerlink" title="WaitGroup 结构体方法"></a><code>WaitGroup</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例声明 `var wg sync.WaitGroup`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加可能为负数的 delta 到计数器中.</span></span><br><span class="line"><span class="comment">// 如果计数器为 0,则释放调用 Wait 处于阻塞状态的所有 goroutine</span></span><br><span class="line"><span class="comment">// 如果计数器变为负数,发生错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 使用 wg 计数器减 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 阻塞当前 goroutine 直到 wg 计数器为 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="Once-使用示例"><a href="#Once-使用示例" class="headerlink" title="Once 使用示例"></a><code>Once</code> 使用示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"在 i=%v 时被调用\n"</span>, i)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下. 可看到匿名函数仅在第一次调用 `once.Do()` 时执行一次,以后的循环不再执行</span></span><br><span class="line"><span class="comment">// 在 i=0 时被调用</span></span><br></pre></td></tr></table></figure>

<h2 id="Pool-使用示例"><a href="#Pool-使用示例" class="headerlink" title="Pool 使用示例"></a><code>Pool</code> 使用示例</h2><ul>
<li>使用 <code>Pool</code> 返回 5 个随机数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">var</span> p sync.Pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">            <span class="keyword">return</span> rand.Intn(<span class="number">100</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(p.Get())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WaitGroup-使用示例"><a href="#WaitGroup-使用示例" class="headerlink" title="WaitGroup 使用示例"></a><code>WaitGroup</code> 使用示例</h2><ul>
<li>使用 <code>WaitGroup</code> 等待所有 goroutine 执行结束</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">"goroutine %v done\n"</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 time 包</title>
    <url>/2020/05/01/go-study-notes-package-time/</url>
    <content><![CDATA[<p><code>time</code> 包提供了时间日期操作的函数, 包括时间的显示和计算.导入方式为 <code>import &quot;time&quot;</code></p>
<h1 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 星期几封装</span></span><br><span class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 月份封装</span></span><br><span class="line"><span class="keyword">type</span> Month <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地点,以及该地点所在的时区封装</span></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间点封装</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个时间点间隔封装</span></span><br><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br></pre></td></tr></table></figure>

<h1 id="常用内置常量及变量"><a href="#常用内置常量及变量" class="headerlink" title="常用内置常量及变量"></a>常用内置常量及变量</h1><p><code>time</code> 包中提供了如下常用常量或变量的定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间对象与字符串表示相互转换时,请记住 2006-01-02 15:04:05,有如下的对应关系</span></span><br><span class="line"><span class="comment">// 2006: 年, 01: 月, 02: 日</span></span><br><span class="line"><span class="comment">// 15: 时, 04: 分, 05: 秒</span></span><br><span class="line"><span class="comment">// 不管位置如何,只要看到 2006/06 就表示对年进转换</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    January Month = <span class="number">1</span> + <span class="literal">iota</span></span><br><span class="line">    February</span><br><span class="line">    March</span><br><span class="line">    April</span><br><span class="line">    May</span><br><span class="line">    June</span><br><span class="line">    July</span><br><span class="line">    August</span><br><span class="line">    September</span><br><span class="line">    October</span><br><span class="line">    November</span><br><span class="line">    December</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> UTC *Location = &amp;utcLoc  <span class="comment">// UTC 时区表示</span></span><br><span class="line"><span class="keyword">var</span> Local *Location = &amp;localLoc  <span class="comment">// 当地时区表示</span></span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="time-包函数"><a href="#time-包函数" class="headerlink" title="time 包函数"></a><code>time</code> 包函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回表示当前时间的 `Time` 类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回由给定时间创建的 `Time` 类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="keyword">int</span>, month Month, day, hour, min, sec, nsec <span class="keyword">int</span>, loc *Location)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 根据 layout 指定的格式尝试将字符串转换为 `Time` 类型对象,转换成功则 `error = nil`.</span></span><br><span class="line"><span class="comment">// 其中 layout 必须是 `2006-01-02 15:04:05` 日期时间点, 格式可以随意变换.示例如下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="keyword">string</span>)</span> <span class="params">(Time, error)</span></span></span><br><span class="line"><span class="comment">// 休眠指定时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sleep</span><span class="params">(d Duration)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Time-结构体方法"><a href="#Time-结构体方法" class="headerlink" title="Time 结构体方法"></a><code>Time</code> 结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回根据 layout 指定的格式返回 t 代表的时间点的格式化文本表示. 示例如下所示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Format</span><span class="params">(layout <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 返回从 January 1, 1970 UTC 以来经过的秒数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Unix</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="comment">// 返回从 January 1, 1970 UTC 以来经过的纳秒数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UnixNano</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="comment">// 返回 UTC `Time` 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UTC</span><span class="params">()</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回时间对象 t 的年月日三个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Date</span><span class="params">()</span> <span class="params">(year <span class="keyword">int</span>, month Month, day <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 返回时间对象 t 的时分秒三个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Clock</span><span class="params">()</span> <span class="params">(hour, min, sec <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 返回 t 增加 d 时间后的时间对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回增加指定年月日后时间对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">AddDate</span><span class="params">(years <span class="keyword">int</span>, months <span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="comment">// 返回年份</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Year</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">//返回月份.是 Month 类型,可通过 int() 强转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Month</span><span class="params">()</span> <span class="title">Month</span></span></span><br><span class="line"><span class="comment">// 返回日</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Day</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回该日期是一年中的第几天,[1, 365]或[1, 366]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">YearDay</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回小时  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Hour</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回分钟</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Minute</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Second</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Nanosecond</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 返回星期几,是Weekday类型,可通过 int() 强转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Weekday</span><span class="params">()</span> <span class="title">Weekday</span></span></span><br><span class="line"><span class="comment">// 返回 Location 信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Location</span><span class="params">()</span> *<span class="title">Location</span></span></span><br><span class="line"><span class="comment">// 返回 Time 实例的时区规范名(如"CET")和该时区相对于 UTC 的时间偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Zone</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, offset <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// 时间比较, 是否在 u 之后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 时间比较, 是否在 u 之前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 是否与 u 相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// 返回 t-u 的时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span></span></span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="时间日志对象与字符串相互转换示例"><a href="#时间日志对象与字符串相互转换示例" class="headerlink" title="时间日志对象与字符串相互转换示例"></a>时间日志对象与字符串相互转换示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    <span class="comment">// layout 支持该日期时间点的部分随机组合, 可以这么理解 1 2 3 4 5 6 分别对应 月,日 时, 分, 秒, 年</span></span><br><span class="line">    <span class="comment">// layout 支持该日期时间点的短格式, 转换出来的字符串也为短格式</span></span><br><span class="line">    <span class="comment">// 将当前时间对象转换为 "yyyy-mm-dd hh:MM:ss" 形式输出</span></span><br><span class="line">    nowStr := now.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nowStr := now.Format("06-1-2 15:4:5")</span></span><br><span class="line">    <span class="comment">// nowStr := now.Format("01-02 15:04")</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(nowStr)</span><br><span class="line">    str := <span class="string">"2020年5月1日 15"</span></span><br><span class="line">    <span class="comment">// 当字符串为短格式时, layout 也必须为短格式</span></span><br><span class="line">    t := time.Parse(<span class="string">"2006年1月2日"</span>, str)</span><br><span class="line">    fmt.Printf(<span class="string">"%v, %T\n"</span>, t, t)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之包管理</title>
    <url>/2020/04/30/go-study-notes-package/</url>
    <content><![CDATA[<h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p>工作空间通常在 <code>GOPATH</code> 环境变量列表中定义(可通过 <code>go env</code> 查看), 由 src, bin, pkg 三个目录组成. <code>src</code> 用于保存源码文件, <code>bin,pkg</code> 主要影响 <code>go install/get</code> 命令, 它们将编译结果(可执行文件或静态库)安装到这两个目录下, 实现增量编译.</p>
<p>编译器按照 GOPATH 设置的路径搜索目标文件. 不同操作系统, GOPATH 列表分割符不同, Unix 使用 <code>:</code>, Windows 使用 <code>;</code>. <code>go get</code> 默认将下载的第三方包保存在列表的第一个工作空间内.</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>Go 语言使用包(package)来组织源代码, 包(package)是多个 Go 源码的集合.</p>
<p>任何源文件必须属于某个包, 同时源文件的第一行有效代码必须通过 <code>package pacakgeName</code> 语句声明该源文件所属的包.</p>
<p>一般来说, 包有以下特点或注意事项:</p>
<ul>
<li>包名一般小写, 使用简短且有意义的名称</li>
<li>包名一般要和所在的目录同名, 也可以不同, 包名中不能包含 <code>-</code> 等特殊符号</li>
<li>包一般使用域名作为目录名称,这样能保证包名的唯一性, 比如 GitHub 项目的包一般会放到 <code>GOPATH/src/github.com/userName/projectName</code> 目录下</li>
<li>包名为 <code>main</code> 的包为应用程序的入口包, 编译不包含 main 包的源码文件时不会得到可执行文件</li>
<li>一个文件夹下的所有源码文件只能属于同一个包, 同样属于同一个包的源码文件不能放在多个文件夹下</li>
</ul>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>要在代码中使用其它包, 需要使用 <code>import</code> 关键字导入. <code>import</code> 语句通常在包声明语句下面. 语法为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"path/to/package"</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"path/to/package1"</span></span><br><span class="line">    <span class="comment">//"path/to/package2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>一般情况下, 要导入的包名路径需要使用 <code>&quot;&quot;</code> 包裹, 且包名是以 <code>GOPATG/src/</code> 后开始计算的, 使用 <code>/</code> 进行路径分割. 如, <code>import &quot;custom/lib&quot;</code> 表示将 <code>GOPATH/src/custom/lib</code> 包中内容导入.</p>
<p>包支持 4 中引用格式:</p>
<ol>
<li>标准引用格式: <code>import &quot;fmt&quot;</code></li>
<li>自定义别名引用: <code>import f &quot;fmt&quot;</code>, 此时我们可以使用 <code>f.</code> 代替 <code>fmt.</code> 调用 fmt 包中的方法. 别名引用也多用于导入包重名或包名过长的情况</li>
<li>省略引用格式: <code>import . &quot;fmt&quot;</code>, 此时我们可不使用 <code>fmt.</code> 而直接调用 <code>fmt</code> 包内的方法, 如 <code>fmt.Println()</code> -&gt; <code>Println()</code></li>
<li>匿名格式引用: <code>import _ &quot;fmt&quot;</code>, 此时我们只是希望执行包内的初始化 <code>init()</code> 函数, 而不使用包的内容</li>
</ol>
<p>在导入包时, 有以下几点需要注意:</p>
<ul>
<li>而未使用的包导入会被编译器视为错误</li>
<li>一个包可以有多个 <code>init()</code> 函数, 包加载时会执行全部的 <code>init()</code> 函数, 但并不能保证执行顺序, 所以不建议在一个包中放入多个 <code>init()</code> 函数，而是将需要初始化的逻辑放到一个 <code>init()</code> 函数里面.</li>
<li>包不能出现环形引用的情况, 比如包 a 引用了 b, b 引用了 c, c 又引用了 a, 此时编译不能通过</li>
<li>包可以被重复引用, 且 Go 编译器能够保证被重复引用包的 <code>init()</code> 函数只会执行一次</li>
<li><strong>所有保存在 <code>internal</code> 目录下的包(包括自身)仅能被其父目录下的包(含所有层次的子目录)访问</strong></li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">|</span><br><span class="line"><span class="string">+-- main.go</span></span><br><span class="line">|</span><br><span class="line">+-- lib/            <span class="comment"># 内部包 internal/&#123;a, b&#125; 仅能被 lib, lib/x, lib/x/y 访问</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">	 +-- internal/  # 内部包之间可相互访问</span></span><br><span class="line">|<span class="string">	 </span>|<span class="string">      </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string">      +-- a/  # 可以导入外部包, 如 lib/x/y</span></span><br><span class="line">|<span class="string">	 </span>|<span class="string">      </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string">      +-- b/</span></span><br><span class="line">|<span class="string">	 </span>|</span><br><span class="line">|<span class="string">    +-- x/</span></span><br><span class="line">|<span class="string">        </span>|</span><br><span class="line">|<span class="string">        +-- y</span></span><br><span class="line">|</span><br><span class="line">+-- z/              <span class="comment"># z 包不可导入 lib/internal 下所有内容, 但可以导入 lib/x 包</span></span><br></pre></td></tr></table></figure>

<p>在执行 main 包的 main 函数之前, Go 程序先对整个程序的包进行初始化. 包内的源码文件都可以定义一到多个初始化函数, 编译器首先确保完成所有全局变量初始化, 然后开始执行 <code>init()</code> 初始化函数,直到这些全部结束后, 运行时才进入 <code>main.main</code> 入口函数.</p>
<ol>
<li>从 main 函数引用的包开始, 逐级查找包的引用, 直到找到没有引用其它包的包</li>
<li>单个包在初始化过程中, 先初始化常量, 然后是全局变量, 最后执行包的 init 函数</li>
</ol>
<p><img src="/2020/04/30/go-study-notes-package/package_initialization_process_in_go.jpg" alt="Go 包的初始化"></p>
<h3 id="包的封装"><a href="#包的封装" class="headerlink" title="包的封装"></a>包的封装</h3><p>所有成员在包内均可访问, 无论是否在同一源码文件中. 但只有名称首字母大写的成员为可导出成员, 可在包外访问, 类似于 java 中的 <code>public</code>. 名称首字母小写的成员不可导出, 仅能在本包中访问, 类似于 <code>private</code>.</p>
<p>可通过提供可导出的工厂模式的函数, 对外提供一个构造函数, 同时对其属性对外提供 Get/Set 方法.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/model/person.go</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span> <span class="comment">// 其它包不能直接访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;person&#123;name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"model"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := model.NewPerson(<span class="string">"smith"</span>)</span><br><span class="line">    p.SetAge(<span class="number">18</span>)</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Println(p.Name, <span class="string">" age ="</span>, p.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Go Modules 是 Go 语言的一种依赖管方式, 该功能是在 Go 1.11 版本中出现的, 且在 Go 1.12 版本不断改进, Go 1.13 版本完善优化后, 演变为官方推荐的包依赖管理方式.</p>
<p>Go Modules 使用 <code>go.mod</code> 和 <code>go.sum</code> 管理程序中第三方包的依赖. </p>
<p><code>go.mod</code> 定义了模块的名称(可用作导入的包名), Go 的版本以及第三方包模块的依赖及版本等信息, 并提供了<code>module</code>, <code>require</code>, <code>replace</code> 和 <code>exclude</code> 四个命令来实现 go module 的功能.</p>
<ul>
<li><code>module</code> 语句指定包的名字(路径)</li>
<li><code>require</code> 语句指定的依赖项模块</li>
<li><code>replace</code> 语句指定替换依赖项模块</li>
<li><code>exclude</code> 语句指定可以忽略依赖项模块</li>
</ul>
<p><a href="https://github.com/gin-gonic" target="_blank" rel="noopener">github.com/gin-gonic/gin</a> 示例如下:  </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">module github.com/gin-gonic/gin</span><br><span class="line"></span><br><span class="line">go <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/gin-contrib/sse v0<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">	github.com/go-playground/validator/v10 v10<span class="number">.2</span><span class="number">.0</span></span><br><span class="line">	github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">	github.com/json-iterator/go v1<span class="number">.1</span><span class="number">.9</span></span><br><span class="line">	github.com/mattn/go-isatty v0<span class="number">.0</span><span class="number">.12</span></span><br><span class="line">	github.com/stretchr/testify v1<span class="number">.4</span><span class="number">.0</span></span><br><span class="line">	github.com/ugorji/go/codec v1<span class="number">.1</span><span class="number">.7</span></span><br><span class="line">	gopkg.<span class="keyword">in</span>/yaml.v2 v2<span class="number">.2</span><span class="number">.8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>go.sum</code> 记录每个依赖包的版本和哈希值, 示例文件如下所示:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">github.<span class="keyword">com</span>/davecgh/<span class="keyword">go</span>-spew v1.<span class="number">1.0</span>/<span class="keyword">go</span>.<span class="keyword">mod</span> h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br><span class="line">github.<span class="keyword">com</span>/davecgh/<span class="keyword">go</span>-spew v1.<span class="number">1.1</span> h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=</span><br><span class="line">github.<span class="keyword">com</span>/davecgh/<span class="keyword">go</span>-spew v1.<span class="number">1.1</span>/<span class="keyword">go</span>.<span class="keyword">mod</span> h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br><span class="line">github.<span class="keyword">com</span>/gin-contrib/sse v0.<span class="number">1.0</span> h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p>那么如何使用 Go Modules 呢?</p>
<h3 id="启用-go-module-功能"><a href="#启用-go-module-功能" class="headerlink" title="启用 go module 功能"></a>启用 go module 功能</h3><ul>
<li>go 版本 &gt;= v1.11</li>
<li>设置 <code>GO111MODULE</code> 环境变量为 on. </li>
</ul>
<p><code>GO111MODULE</code> 有三个值, 默认为 <code>auto</code></p>
<ul>
<li><code>on</code>: 启用 go module, 编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖</li>
<li><code>off</code>: 禁用 go module, 编译时会从 GOPATH 和 vendor 文件夹中查找包</li>
<li><code>auto</code>: 当项目在 GOPATH/src 目录之外, 并且项目根目录有 go.mod 文件时，开启 go module</li>
</ul>
<p>可以通过设置 <code>GOPROXY</code> 环境变量设置获取依赖包时的代理.</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">go env -w <span class="attribute">GOPROXY</span>=https://goproxy.cn,direct</span><br><span class="line">或</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOPROXY</span>=https://goproxy.cn</span><br></pre></td></tr></table></figure>
<p>目前公开的代理服务地址有: </p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//goproxy.io/</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//goproxy.cn/</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//mirrors.aliyun.com/goproxy/</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="使用-go-module-功能"><a href="#使用-go-module-功能" class="headerlink" title="使用 go module 功能"></a>使用 go module 功能</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"># 初始化 <span class="built_in">go</span> module, 创建一个 <span class="built_in">go</span>.<span class="built_in">mod</span> 文件,包含 module 信息和 <span class="built_in">go</span> 版本信息</span><br><span class="line"><span class="built_in">go</span> <span class="built_in">mod</span> init  [module_name]</span><br><span class="line"># 自动将包及其依赖打包成 module, 并修改 <span class="built_in">go</span>.<span class="built_in">mod</span> 文件, 增加缺少的包,删除没有用到的包</span><br><span class="line"><span class="built_in">go</span> <span class="built_in">mod</span> tidy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>istio可扩展的策略和遥测</title>
    <url>/2020/04/03/istio-adapter-configuration/</url>
    <content><![CDATA[<blockquote>
<p>应用场景</p>
</blockquote>
<p>对服务进行全面管理,除了需要具备服务治理功能,还需要知道服务到底运行得怎么样,有没有问题,哪里有问题,这一般是 APM(Application Performance Management,应用性能管理) 的职能,其中涉及采集数据,存储数据和检索数据.</p>
<blockquote>
<p>实现方式</p>
</blockquote>
<p>Istio 将 Envoy 的遥测和策略功能提取出来,放到一个服务端组件 Mixer 上,在逻辑上将 Envoy 和各种遥测数据的收集解耦,并将 Envoy 和真正的遥测后端解耦.Envoy 和控制面组件 Mixer 的单条连接</p>
<p>基于 Mixer Adapter 提供的扩展机制,可以做到在遥测和策略执行时对业务代码的无侵入,解耦数据面 Envoy 和遥测与策略执行的后端服务,并开发自己的 Adapter,提供扩展和定制的能力,提供满足用户特定场景的服务运行监控和控制</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>简单来说,该流程主要有两步:</p>
<ol>
<li>Envoy 生成数据并将数据上报给 Mixer</li>
<li>Mixer 调用对应的服务后端处理收到的数据</li>
</ol>
<p>每个经过 Envoy 的请求都会调用 Mixer上报数据,Mixer将上报的这些数据作为策略和遥测报告的一部<br>分发送出来,并转换为对后端服务的调用</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote>
<p>属性定义</p>
</blockquote>
<p>Envoy 上报的数据在 Istio 中被称为属性(Attribute).严格来讲,在以上 Mixer 处理流程的两个阶段,从Envoy到Mixer及从Mixer到后端服务,处理的<br>对象都是属性</p>
<blockquote>
<p>属性表达式</p>
</blockquote>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">destination_service:</span> destination.service</span><br><span class="line"><span class="symbol">response_code:</span> response.code</span><br><span class="line"><span class="symbol">destination_version:</span> destination.labels[<span class="string">"version"</span>] | <span class="string">"unknown"</span></span><br></pre></td></tr></table></figure>
<p>更多属性表达式见 &lt;云原生服务网格 istio&gt; 表 4-1</p>
<blockquote>
<p>Mixer的配置模型</p>
</blockquote>
<p>Istio 主要通过 <code>Handler</code>(业务处理),<code>Instance</code>(数据定义)和 <code>Rule</code>(关联规则)这三个资源对象来描述对 Adapter 的配置</p>
<ul>
<li><code>Handler</code></li>
</ul>
<p>Handler 描述定义的 Adapters 及其配置,不同的 Adapter 有不同的配置.Handler 是 Adapter 定义的模板的实现,通过给模板上的参数赋值来进行实例化</p>
<p>示例如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">stdio</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">handler</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">outputAsJson:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">handler</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">requests_total</span></span><br><span class="line">    <span class="attr">instance_name:</span> <span class="string">requestcount.metric.istio-system</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">COUNTER</span></span><br><span class="line">    <span class="attr">label_names:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reporter</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_name</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">request_protocol</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">response_code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">connection_security_policy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">request_duration_seconds</span></span><br><span class="line">    <span class="attr">instance_name:</span> <span class="string">requestduration.metric.istio-system</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">DISTRIBUTION</span></span><br><span class="line">    <span class="attr">label_names:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reporter</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_app</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_principal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_workload_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_name</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">destination_service_namespace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">request_protocol</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">response_code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">connection_security_policy</span></span><br><span class="line">    <span class="attr">buckets:</span></span><br><span class="line">      <span class="attr">explicit_buckets:</span></span><br><span class="line">        <span class="attr">bounds:</span> <span class="string">[0.005,</span> <span class="number">0.01</span><span class="string">,</span> <span class="number">0.025</span><span class="string">,</span> <span class="number">0.05</span><span class="string">,</span> <span class="number">0.1</span><span class="string">,</span> <span class="number">0.25</span><span class="string">,</span> <span class="number">0.5</span><span class="string">,</span> <span class="number">1</span><span class="string">,</span> <span class="number">2.5</span><span class="string">,</span> <span class="number">5</span><span class="string">,</span> <span class="number">10</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Instance</code></li>
</ul>
<p>Instance 定义了 Adapter 要处理的数据对象,通过模板为 Adapter 提供对元数据的定义.Mixer 通过 Instance 把来自代理的属性拆分并分发给不通的适配器</p>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">logentry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">accesslog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">severity:</span> <span class="string">'"Info"'</span></span><br><span class="line">  <span class="attr">timestamp:</span> <span class="string">request.time</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">sourceIp:</span> <span class="string">source.ip</span> <span class="string">|</span> <span class="string">ip("0.0.0.0")</span></span><br><span class="line">    <span class="attr">sourceApp:</span> <span class="string">source.labels["app"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourcePrincipal:</span> <span class="string">source.principal</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceName:</span> <span class="string">source.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceWorkload:</span> <span class="string">source.workload.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceNamespace:</span> <span class="string">source.namespace</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">sourceOwner:</span> <span class="string">source.owner</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationApp:</span> <span class="string">destination.labels["app"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationIp:</span> <span class="string">destination.ip</span> <span class="string">|</span> <span class="string">ip("0.0.0.0")</span></span><br><span class="line">    <span class="attr">destinationServiceHost:</span> <span class="string">destination.service.host</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationWorkload:</span> <span class="string">destination.workload.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationName:</span> <span class="string">destination.name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationNamespace:</span> <span class="string">destination.namespace</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationOwner:</span> <span class="string">destination.owner</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">destinationPrincipal:</span> <span class="string">destination.principal</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">apiClaims:</span> <span class="string">request.auth.raw_claims</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">apiKey:</span> <span class="string">request.api_key</span> <span class="string">|</span> <span class="string">request.headers["x-api-key"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">request.scheme</span> <span class="string">|</span> <span class="string">context.protocol</span> <span class="string">|</span> <span class="string">"http"</span></span><br><span class="line">    <span class="attr">method:</span> <span class="string">request.method</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">request.path</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">responseCode:</span> <span class="string">response.code</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">responseSize:</span> <span class="string">response.size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">requestSize:</span> <span class="string">request.size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">requestId:</span> <span class="string">request.headers["x-request-id"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">clientTraceId:</span> <span class="string">request.headers["x-client-trace-id"]</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">latency:</span> <span class="string">response.duration</span> <span class="string">|</span> <span class="string">"0ms"</span></span><br><span class="line">    <span class="attr">connection_security_policy:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"unknown"</span><span class="string">,</span> <span class="string">conditional(connection.mtls</span> <span class="string">|</span> <span class="literal">false</span><span class="string">,</span> <span class="string">"mutual_tls"</span><span class="string">,</span> <span class="string">"none"</span><span class="string">))</span></span><br><span class="line">    <span class="attr">requestedServerName:</span> <span class="string">connection.requested_server_name</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">userAgent:</span> <span class="string">request.useragent</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">responseTimestamp:</span> <span class="string">response.time</span></span><br><span class="line">    <span class="attr">receivedBytes:</span> <span class="string">request.total_size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">sentBytes:</span> <span class="string">response.total_size</span> <span class="string">|</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">referer:</span> <span class="string">request.referer</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">httpAuthority:</span> <span class="string">request.headers[":authority"]</span> <span class="string">|</span> <span class="string">request.host</span> <span class="string">|</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">xForwardedFor:</span> <span class="string">request.headers["x-forwarded-for"]</span> <span class="string">|</span> <span class="string">"0.0.0.0"</span></span><br><span class="line">    <span class="attr">reporter:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"source"</span><span class="string">,</span> <span class="string">"destination"</span><span class="string">)</span></span><br><span class="line">  <span class="attr">monitored_resource_type:</span> <span class="string">'"global"'</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">metric</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">requestcount</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">"1"</span></span><br><span class="line">  <span class="attr">dimensions:</span></span><br><span class="line">    <span class="attr">reporter:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"source"</span><span class="string">,</span> <span class="string">"destination"</span><span class="string">)</span></span><br><span class="line">    <span class="attr">source_workload:</span> <span class="string">source.workload.name</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_workload_namespace:</span> <span class="string">source.workload.namespace</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_principal:</span> <span class="string">source.principal</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_app:</span> <span class="string">source.labels["app"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">source_version:</span> <span class="string">source.labels["version"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_workload:</span> <span class="string">destination.workload.name</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_workload_namespace:</span> <span class="string">destination.workload.namespace</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_principal:</span> <span class="string">destination.principal</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_app:</span> <span class="string">destination.labels["app"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_version:</span> <span class="string">destination.labels["version"]</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_service:</span> <span class="string">destination.service.host</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_service_name:</span> <span class="string">destination.service.name</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">destination_service_namespace:</span> <span class="string">destination.service.namespace</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">request_protocol:</span> <span class="string">api.protocol</span> <span class="string">|</span> <span class="string">context.protocol</span> <span class="string">|</span> <span class="string">"unknown"</span></span><br><span class="line">    <span class="attr">response_code:</span> <span class="string">response.code</span> <span class="string">|</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">connection_security_policy:</span> <span class="string">conditional((context.reporter.kind</span> <span class="string">|</span> <span class="string">"inbound"</span><span class="string">)</span> <span class="string">==</span> <span class="string">"outbound"</span><span class="string">,</span> <span class="string">"unknown"</span><span class="string">,</span> <span class="string">conditional(connection.mtls</span> <span class="string">|</span> <span class="literal">false</span><span class="string">,</span> <span class="string">"mutual_tls"</span><span class="string">,</span> <span class="string">"none"</span><span class="string">))</span></span><br><span class="line">  <span class="attr">monitored_resource_type:</span> <span class="string">'"UNSPECIFIED"'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Rule</code></li>
</ul>
<p>Rule 配置了一组规则,告诉 Mixer 有哪个 Instance 在什么时候被发送给哪个 Handler 来处理,一般包括一个匹配的表达式和执行动作(action)匹配表达式控制在什么时候调用 Adapter,在 Action 里配置 Adapter 和 Instance 的名称</p>
<p>字段如下</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必选</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">match</td>
<td align="center">是</td>
<td align="center">表示匹配条件,如果未定义条件,则判定为总是匹配</td>
</tr>
<tr>
<td align="center">actions</td>
<td align="center">是</td>
<td align="center">表示满足条件后执行的动作,是一个数组.包含 handler 和 instance 两个字段,用于指定 handler 和 instance 的名称(必须是全名,格式一般为 <code>&lt;name.kind&gt;</code>)</td>
</tr>
</tbody></table>
<p>示例如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">stdio</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">match:</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"http"</span> <span class="string">||</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"grpc"</span></span><br><span class="line">  <span class="attr">actions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">handler:</span> <span class="string">handler.stdio</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">accesslog.logentry</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">"config.istio.io/v1alpha2"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">promhttp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">match:</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"http"</span> <span class="string">||</span> <span class="string">context.protocol</span> <span class="string">==</span> <span class="string">"grpc"</span></span><br><span class="line">  <span class="attr">actions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">handler:</span> <span class="string">handler.prometheus</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">requestcount.metric</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">requestduration.metric</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">requestsize.metric</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">responsesize.metric</span></span><br></pre></td></tr></table></figure>

<h1 id="遥测适配器配置"><a href="#遥测适配器配置" class="headerlink" title="遥测适配器配置"></a>遥测适配器配置</h1><h2 id="Prometheus-适配器"><a href="#Prometheus-适配器" class="headerlink" title="Prometheus 适配器"></a>Prometheus 适配器</h2><blockquote>
<p>工作流程</p>
</blockquote>
<ol>
<li>Envoy 通过 Report 接口上报数据给 Mixer</li>
<li>Mixer 根据配置将请求分发给 Prometheus Adapter</li>
<li>Prometheus Adapter 通过 HTTP 接口发 布Metric 数据</li>
<li>Prometheus 服务作为 Addon 在集群中进行安装,拉取并存储 Metric 数据,提供 Query 接口进行检索</li>
<li>集群内的 Dashboard(如Grafana)通过 Prometheus 的检索 API 访问 Metric 数据</li>
</ol>
<blockquote>
<p>handler 配置定义</p>
</blockquote>
<p>handler 配置中最主要的字段是 <code>metrics</code>,用于在 Prometheus 中定义 metrics.它是一个数组,每个元素都具有如下属性</p>
<ul>
<li><code>name</code>: metric 的名称</li>
<li><code>instance_name</code>: instance 的全名称,格式为 <code>&lt;instance_name.kind.namespace&gt;</code></li>
<li><code>kind</code>: 定义指标类型,请求计数类型为 <code>COUNTER</code>,请求耗时类型为 <code>DISTRIBUTION</code>.DISTRIBUTION 类型的指标可以定义其 buckets</li>
<li><code>label_names</code>: 定义指标的标签,一般与 instance 中维度相同</li>
</ul>
<blockquote>
<p>instance 配置定义</p>
</blockquote>
<p>instance 配置中最主要的字段是 <code>dimensions</code> 和 <code>value</code>,分别用于记录数据的维度及对应的值.这两个字段均支持属性表达式.其中维度中的 key 多用于 prometheus-metrics 的标签</p>
<blockquote>
<p>rule 配置定义</p>
</blockquote>
<p>Rule 可以将 Handler 和 Instance建立关系,最主要的字段是 <code>match</code> 和 <code>actions</code>,分别用于匹配规则及匹配后的动作</p>
]]></content>
      <categories>
        <category>云原生应用</category>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初识istio</title>
    <url>/2020/04/03/istio-first-step/</url>
    <content><![CDATA[<p>本文章为<a href="https://item.jd.com/12538407.html" target="_blank" rel="noopener">《云原生服务网格Istio：原理、实践、架构与源码解析》</a>第 1-2 章读书笔记.如果在学习过程中有理解不准确的地方,请以原书为准.</p>
<h1 id="istio-简介"><a href="#istio-简介" class="headerlink" title="istio 简介"></a>istio 简介</h1><p><a href="https://istio.io/" target="_blank" rel="noopener">Istio</a> 是一个与 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 紧密结合的适用于云原生场景的 Service Mesh 形态的用于服务治理的开放平台</p>
<h2 id="istio-可以做什么"><a href="#istio-可以做什么" class="headerlink" title="istio 可以做什么"></a>istio 可以做什么</h2><ul>
<li>自动通过服务发现获取服务实例列表,并根据负载均衡策略选择一个服务实例</li>
<li>对服务双方启用双向认证和通道加密</li>
<li>设置最大连接数,最大请求数,访问超时及设置限流机制等对服务进行保护</li>
<li>对请求进行重试</li>
<li>将一定特征的服务重定向,实现灰度发布</li>
<li>记录调用链,进行分布式追踪.根据访问数据形成完整的应用访问拓扑</li>
</ul>
<h1 id="istio-架构概述"><a href="#istio-架构概述" class="headerlink" title="istio 架构概述"></a>istio 架构概述</h1><h2 id="istio-工作机制"><a href="#istio-工作机制" class="headerlink" title="istio 工作机制"></a>istio 工作机制</h2><p><img src="/2020/04/03/istio-first-step/istio_working_mechanism_and_architecture.jpg" alt="istio 工作机制和架构"></p>
<ul>
<li><code>自动注入</code>: 在创建应用程序时自动注入 Sidecar 代理.在 Kubernetes 场景下创建 Pod 时,Kube-apiserver 调用管理面组件的 Sidecar-Injector 服务,自动修改应用程序的描述信息并注入 Sidecar.在创建Pod时,在创建业务容器的同时在Pod中创建 Sidecar 容器</li>
<li><code>流量拦截</code>: 在 Pod 初始化时设置 iptables 规则,当有流量到来时,基于配置的 iptables 规则拦截业务容器的 Inbound 流量和 Outbound 流量到 Sidecar 上.应用程序感知不到 Sidecar的存在,还以原本的方式进行互相访问</li>
<li><code>服务发现</code>: 服务发起方的 Envoy 调用管理面组件 Pilot 的服务发现接口获取目标服务的实例列表</li>
<li><code>负载均衡</code>: 服务发起方的 Envoy 根据配置的负载均衡策略选择服务实例,并连接对应的实例地址</li>
<li><code>流量治理</code>: Envoy 从 Pilot 中获取配置的流量规则,在拦截到 Inbound 流量和 Outbound 流量时执行治理逻辑</li>
<li><code>访问安全</code>: 在服务间访问时通过双方的 Envoy 进行双向认证和通道加密,并基于服务的身份进行授权管理.证书和密钥由管理面组件 Citadel 维护</li>
<li><code>服务遥测</code>: 在服务间通信时,通信双方的 Envoy 都会连接管理面组件 Mixer 上报访问数据,并通过 Mixer 将数据转发给对应的监控后端</li>
<li><code>策略执行</code>: 在进行服务访问时,通过Mixer连接后端服务来控制服务间的访问,判断对访问是放行还是拒绝</li>
<li><code>外部访问</code>: 在网格的入口处有一个 Envoy 扮演入口网关的角色</li>
</ul>
<h2 id="istio-服务模型"><a href="#istio-服务模型" class="headerlink" title="istio 服务模型"></a>istio 服务模型</h2><p>istio 服务模型与 kubernetes 中服务模型对应关系如下</p>
<table>
<thead>
<tr>
<th align="center">istio</th>
<th align="center">kubernetes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">service</td>
<td align="center">service</td>
</tr>
<tr>
<td align="center">服务版本</td>
<td align="center">Deployment,使用 app 和 version 标签区分不同服务的不同版本</td>
</tr>
<tr>
<td align="center">服务实例</td>
<td align="center">Endpoint</td>
</tr>
</tbody></table>
<h2 id="istio-主要组件"><a href="#istio-主要组件" class="headerlink" title="istio 主要组件"></a>istio 主要组件</h2><blockquote>
<p>istio-pilot 服务发现和服务治理</p>
</blockquote>
<ul>
<li>服务发现</li>
</ul>
<p>pilot 提供各种服务发现的 adapter 实现服务发现机制,并将其构造和转换成 istio 的服务发现模型.如 kubernetes 源数据<code>service(service),endpoint(instance),deployment(version)</code></p>
<p><img src="/2020/04/03/istio-first-step/service_discovery_on_pilot.png" alt="pilot 服务发现"></p>
<ul>
<li>服务治理</li>
</ul>
<p>向数据面下发规则,pilot 负责将各种规则转换成 Envoy 可识别的格式,通过标准的 xDS 协议发送给 Envoy,指导Envoy完成动作.</p>
<p>其规则的实现方式包括 <code>VirtualService,DestinationRule,Gateway,ServiceEntry</code> 等流量治理规则,也包括认证授权等安全规则.</p>
<blockquote>
<p>istio-mixer 数据收集,策略执行</p>
</blockquote>
<ul>
<li>使用 telemetry 服务组件收集遥测数据</li>
</ul>
<p>当网格中的两个服务间有调用发生时,服务的代理 Envoy 就会上报遥测数据给 istio-telemetry 服务组件,istio-telemetry 服务组件则根据配置将生成访问 Metric 等数据分发给后端的遥测服务</p>
<ul>
<li>使用 policy 服务组件管理网络策略</li>
</ul>
<p>数据面在转发服务的请求前调用 istio-policy 的 Check 接口检查服务间通信的策略,然后根据配置将请求转发到对应的 adapter 进行检查,给代理返回允许访问还是拒绝</p>
<blockquote>
<p>istio-citadel 安全中心</p>
</blockquote>
<p>istio-citadel 是 istio 的核心安全组件,提供了自动生成,分发,轮换与撤销密钥和证书功能.</p>
<p>citadel 一直监听  kube-apiserver,以 secret 的形式为每个服务都生成证书密钥,并在 pod 创建时挂载到 pod 上,代理容器使用这些文件来做服务身份认证,进而代理两端服务实现双向 TLS 认证,通道加密,访问授权等安全功能</p>
<blockquote>
<p>istio-galley 控制面上的配置中心</p>
</blockquote>
<p>istio-galley 在控制面上向其它组件提供支持,它用于验证配置信息的格式和内容的正确性,并将这些配置信息提供给管理面的 Pilot 和 Mixer.</p>
<blockquote>
<p>istio-sidecar-injector 自动注入</p>
</blockquote>
<p>istio-sidecar-injector 主要负责自动注入,在创建 Pod 时自动调用 istio-sidecar-injector 向 pod 中注入 sideCar 容器</p>
<blockquote>
<p>istio-proxy,Envoy,Sidecar Istio数据面轻量代理</p>
</blockquote>
<p>综合/分析 pilot 中规则,配置到 proxy,类似于4 和 7 层代理.作为服务网格的数据面,Envoy 提供了动态服务发现,负载均衡,TLS,HTTP/2 及 gRPC代理,熔断器,健康检查,流量拆分,灰度发布,故障注入等功能</p>
<blockquote>
<p>istio-ingressgateway 服务网格入口网关</p>
</blockquote>
<p>istio-ingressgateway 是服务网格入口处的网关,从网格外访问网格内的服务就是通过这个组件进行的.该组件是一个 Loadbalancer 类型的 Service,并开放了一组端口,用于外部访问.</p>
<h1 id="非侵入的流量治理"><a href="#非侵入的流量治理" class="headerlink" title="非侵入的流量治理"></a>非侵入的流量治理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>目标</p>
</blockquote>
<p>以基础设施的方式提供给用户非侵入的流量治理能力,用户只需<br>关注自己的业务逻辑开发,无须关注服务访问管理</p>
<blockquote>
<p>流程</p>
</blockquote>
<ol>
<li>管理员通过命令行或 API 创建流量规则</li>
<li>Pilot 将流量规则转换为 Envoy 的标准格式,并下发给 Envoy(转向数据面)</li>
<li>Envoy 拦截 Pod 上本地容器的 Inbound 流量和 Outbound 流量</li>
<li>在流量经过 Envoy 时执行对应的流量规则,对流量进行治理</li>
</ol>
<blockquote>
<p>应用场景和功能</p>
</blockquote>
<ul>
<li>负载均衡</li>
</ul>
<p>服务注册: 各服务将服务名和服务实例的对应信息注册到服务注册中心<br>服务发现: 在客户端发起服务访问时,以同步或者异步的方式从服务注册中心获取服务对应的实例列表<br>负载均衡: 据配置的负载均衡算法从实例列表中选择一个服务实例.目前支持的负载均衡算法有轮询,随机和最小连接数算法</p>
<ul>
<li>服务熔断</li>
</ul>
<p>故障检测和处理逻辑,防止临时故障或意外导致系统整体不可用.最典型的场景是防止网络和服务调用故障级联发生,限制故障的影响范围,防止故障蔓延导致系统整体性能下降或雪崩</p>
<ul>
<li>故障注入</li>
</ul>
<p>主要用于测试其健壮性和应对故障的能力,例如异常处理,故障恢复等Istio 的故障注入是在网格中对特定的应用层协议进行故障注入,可以模拟出应用的故障场景.</p>
<p>如注入 HTTP Code 503(服务端异常),请求延时(模拟响应慢)</p>
<ul>
<li>灰度发布</li>
</ul>
<p>新老版本同时在线,新版本只切分少量流量出来,在确认新版本没有问题后,再逐步加大流量比例</p>
<p>其中灰度发布主要有金丝雀发布,蓝绿发布,AB 测试 3 种方式</p>
<ul>
<li>服务访问入口</li>
</ul>
<p>Istio 中通过 Ingress Gateway 访问网格内的服务,做四层到六层的端口,TLS配置等基本功能,VirtualService则定义七层路由等丰富内容</p>
<ul>
<li>外部接入服务治理</li>
</ul>
<p>Istio 通过 ServiceEntry 资源对象将网格外的服务注册到网格上,然后像对网格内的普通服务一样对网格外的服务访问进行治理.有时需<br>要有一个专门的 Egress Gateway 来提供统一的出口网关</p>
]]></content>
      <categories>
        <category>云原生应用</category>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之反射</title>
    <url>/2020/04/30/go-study-notes-reflect/</url>
    <content><![CDATA[<p>反射是值在程序运行期间对程序本身进行访问和修改的能力. 程序在编译时, 变量被转换为内存地址, 程序运行时, 程序无法获取自身的信息.</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息, 如字段名称, 类型信息, 结构体信息等整合到可执行文件中, 并给程序提供接口访问反射信息, 这样就可以在程序运行期获取类型的反射信息, 并且有能力修改它们.</p>
<p>任意接口值在反射中都可以理解为由 Type 和 Value 组成的. Go 语言的反射是由 <code>reflect</code> 包提供的, 它定义了两个重要的类型 <code>reflect.Type</code> 和 <code>reflect.Value</code>, 并提供了 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 函数来获取任意对象的 Value 和 Type.</p>
<h2 id="反射的类型接口-reflect-Type"><a href="#反射的类型接口-reflect-Type" class="headerlink" title="反射的类型接口 reflect.Type"></a>反射的类型接口 <code>reflect.Type</code></h2><p>在 Go 语言程序中, 使用 <code>reflect.TypeOf()</code> 函数可以获得任意值的 <code>reflect.Type</code> 接口对象, 程序通过类型对象可以访问对象的类型信息.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    typeOfn := reflect.TypeOf(n)  <span class="comment">// 获取 n 的 反射的类型对象 `reflect.Type`</span></span><br><span class="line">    fmt.Println(<span class="string">"type:"</span>, typeOfn.Name(), <span class="string">"kind:"</span>, typeOfn.Kind())  <span class="comment">// 输出为 type: int kind: int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型名称-Name-与种类-Kind"><a href="#类型名称-Name-与种类-Kind" class="headerlink" title="类型名称(Name)与种类(Kind)"></a>类型名称(Name)与种类(Kind)</h3><ul>
<li>Name(类型名称) 返回反射类型的的名称, 包括 Go 语言中原生数据类型及通过 type 关键字自定义的数据类型. 获取方式为 <code>reflect.Type</code> 的 <code>Name()</code> 方法</li>
<li>Kind(种类) 指反射类型所属的种类, 它仅包含 Go 语言中原生数据种类. 获取方式为 <code>reflect.Type</code> 的 <code>Kind()</code> 方法, 返回 <code>reflect.Kind</code> 类型的常量</li>
</ul>
<p>在如下示例中, <code>stu</code> 对象的反射类型名称为自定义的 <code>Student</code>, 而其所属的反射种类为 <code>struct</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Age   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">    	Name:  <span class="string">"tom"</span>,</span><br><span class="line">    	Age:   <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    typeOfstu := reflect.TypeOf(stu)</span><br><span class="line">    fmt.Println(<span class="string">"type:"</span>, typeOfstu.Name(), <span class="string">"kind:"</span>, typeOfstu.Kind())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// type: Student kind: struct</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊反射种类的类型名称"><a href="#特殊反射种类的类型名称" class="headerlink" title="特殊反射种类的类型名称"></a>特殊反射种类的类型名称</h3><p>获取反射种类(Kind)为 <code>Array</code>, <code>Chan</code>, <code>Map</code>, <code>Ptr</code> 或 <code>Slice</code> 的对象的反射类型名称时, 通过 <code>Name()</code> 方法获得的类型名称为空字符串(“”)</p>
<p>要想获取以上对象的反射类型名称, 需要通过 <code>Elem()</code> 方法获取反射类型的元素类型, 然后再通过 <code>Name()</code> 方法获取其反射类型的名称</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Age   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">    	Name:  <span class="string">"tom"</span>,</span><br><span class="line">    	Age:   <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ptrOfstu := &amp;stu</span><br><span class="line">    a:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    typeOfptr := reflect.TypeOf(a)  <span class="comment">// 获取 &amp;stu 的反射的类型对象 `reflect.Type`</span></span><br><span class="line">    fmt.Println(<span class="string">"type:"</span>, typeOfptr.Name(), <span class="string">"kind:"</span>, typeOfptr.Kind())  <span class="comment">// 输出为 type:  kind: ptr</span></span><br><span class="line">    elemType := typeOfptr.Elem()</span><br><span class="line">    fmt.Println(<span class="string">"elem's type:"</span>, elem.Name(), <span class="string">"elem's kind:"</span>, elem.Kind())  <span class="comment">// 输出为 elem's type: Student elem's kind: struct</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// type:  kind: ptr</span></span><br><span class="line"><span class="comment">// type: Student kind: struct</span></span><br></pre></td></tr></table></figure>

<p><code>reflect.Type</code> 的 <code>Elem()</code> 方法仅当反射类型的种类是 <code>Array</code>, <code>Chan</code>, <code>Map</code>, <code>Ptr</code> 或 <code>Slice</code> 时才可以获取其元素类型, 否则 <code>Elem()</code> 方法会引发 panics.</p>
<h3 id="使用反射获取结构体的成员及方法信息"><a href="#使用反射获取结构体的成员及方法信息" class="headerlink" title="使用反射获取结构体的成员及方法信息"></a>使用反射获取结构体的成员及方法信息</h3><p>通过 <code>reflect.TypeOf()</code> 获得反射对象信息后, 如果它所属种类是结构体，可通过 <code>reflect.Type</code> 的 <code>NumField()</code> 和 <code>Field()</code> 方法获得结构体成员的详细信息, 可通过<code>NumMethod()</code> 和 <code>Method()</code> 方法获取结构体的方法详细信息</p>
<p><code>reflect.Type</code> 中与成员及方法获取相关的方法如下表所示</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>NumField()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体成员字段数量</td>
</tr>
<tr>
<td align="center"><code>Field(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.StructField</td>
<td align="center">根据索引返回索引对应的结构体字段的信息</td>
</tr>
<tr>
<td align="center"><code>NumMethod()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体方法数量</td>
</tr>
<tr>
<td align="center"><code>Method(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.Method</td>
<td align="center">根据索引返回索引对应的结构体方法的信息, 方法的排序是根据 ascii 码的先后顺序进行排序的</td>
</tr>
</tbody></table>
<p>需要注意的是, 方法相关信息可直接通过 <code>reflect.TypeOf(&amp;object).Method()</code> 方法获取, 且通过这种方法获取的方法包括 receiver 为 <code>&amp;object</code> 的方法. <code>reflect.TypeOf(object).Method()</code> 仅返回 receiver 为 <code>object</code> 的方法. 而字段相关信息只能通过 <code>Elem()</code> 获取元素类型后获取字段相关信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span>  <span class="string">`json: "name"`</span></span><br><span class="line">	Age   <span class="keyword">int</span>     <span class="string">`json: "age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(*stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	stu.Name = name</span><br><span class="line">	stu.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu := Student&#123;</span><br><span class="line">		Name: <span class="string">"tom"</span>,</span><br><span class="line">		Age:  <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	typeOfstu := reflect.TypeOf(stu)</span><br><span class="line">	kindOfstu := typeOfstu.Kind()</span><br><span class="line">	typeOfptr := reflect.TypeOf(&amp;stu)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kindOfstu != reflect.Struct &#123;</span><br><span class="line">		fmt.Println(<span class="string">"except struct..."</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fieldNum := typeOfstu.NumField()</span><br><span class="line">	fmt.Println(<span class="string">"字段个数为: "</span>, fieldNum)  <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; fieldNum; i++ &#123;</span><br><span class="line">		field := typeOfstu.Field(i)</span><br><span class="line">		fmt.Println(field)</span><br><span class="line">		fmt.Printf(<span class="string">"字段名: %v, 字段类型: %v, 字段的 json 标签: %v\n"</span>, field.Name, field.Type, field.Tag.Get(<span class="string">"json"</span>))  <span class="comment">// Tag.Get(key) 方法可以返回键值对格式的的标签指定键的值</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	methodNumOfstu := typeOfstu.NumMethod()</span><br><span class="line">	fmt.Println(<span class="string">"stu方法个数为: "</span>, methodNumOfstu)  <span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfstu; i++ &#123;</span><br><span class="line">		method := typeOfstu.Method(i)</span><br><span class="line">		fmt.Println(method)</span><br><span class="line">		fmt.Printf(<span class="string">"方法名: %v, 方法类型: %v\n"</span>, method.Name, method.Type)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	methodNumOfptr := typeOfptr.NumMethod()</span><br><span class="line">	fmt.Println(<span class="string">"&amp;stu方法个数为: "</span>, methodNumOfptr)   <span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfptr; i++ &#123;</span><br><span class="line">		method := typeOfptr.Method(i)</span><br><span class="line">		fmt.Println(method)</span><br><span class="line">		fmt.Printf(<span class="string">"方法名: %v, 方法类型: %v, 方法对象\n"</span>, method.Name, method.Type, method.Func)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射的值对象-reflect-Value"><a href="#反射的值对象-reflect-Value" class="headerlink" title="反射的值对象 reflect.Value"></a>反射的值对象 <code>reflect.Value</code></h2><p>使用 <code>reflect.ValueOf()</code> 函数可以获得对象的反射值对象 <code>reflect.Value</code>. <code>reflect.Value</code> 对象可以通过调用 <code>Type()</code> 方法返回 <code>reflect.Type</code> 对象, 完成值到类型对象的转换.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    valueOfN := reflect.ValueOf(n)  <span class="comment">// 获取 n 的 反射的值对象 `reflect.Value`</span></span><br><span class="line">    typeOfN := valueOfN.Type() <span class="comment">// 值对象可以转换为类型对象, 等价于 reflect.TypeOf(n)</span></span><br><span class="line">    fmt.Printf(<span class="string">"值为: %v, 实际类型为 %T"</span>, valueOfN, valueOfN)  <span class="comment">// 输出为 值为: 20, 实际类型为 reflect.Value</span></span><br><span class="line">    n2, ok := valueOfN.Interface().(<span class="keyword">int</span>) <span class="comment">// 先将 reflect.Value 转换为 interface, 然后通过类型断言来转换为 int 类型</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">    	fmt.Printf(<span class="string">"转换后值为: %v, 类型为 %T"</span>, n2, n2)  <span class="comment">// 输出 转换后值为: 20, 类型为 int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/go-study-notes-reflect/conversion_between_actual_type_and_reflection.jpg" alt="实际类型与反射间的转换"></p>
<p>通过以上可以看得出, 实际类型对象将自身通过接口方式传入 <code>reflect.ValueOf(i interface{})</code> 方法, 返回 <code>reflect.Value</code> 对象. <code>reflect.Value</code> 对象通过调用自身 <code>Interface()</code> 方法, 返回接口类型, 该接口类型可通过类型断言转化为实际类型对象.</p>
<h3 id="使用反射获取结构体的成员值及方法信息"><a href="#使用反射获取结构体的成员值及方法信息" class="headerlink" title="使用反射获取结构体的成员值及方法信息"></a>使用反射获取结构体的成员值及方法信息</h3><p>通过 <code>reflect.ValueOf()</code> 获得反射对象值信息后, 如果它所属种类是结构体，可通过 <code>reflect.Value</code> 的 <code>NumField()</code> 和 <code>Field()</code> 方法获得结构体成员的值信息, 可通过<code>NumMethod()</code> 和 <code>Method()</code> 方法获取结构体的方法等信息</p>
<p><code>reflect.Value</code> 中与成员及方法获取相关的方法如下表所示:</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>NumField()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体成员字段数量</td>
</tr>
<tr>
<td align="center"><code>Field(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.Value</td>
<td align="center">根据索引返回结构体字段对应的值对象</td>
</tr>
<tr>
<td align="center"><code>NumMethod()</code></td>
<td align="center">-</td>
<td align="center">int</td>
<td align="center">返回结构体方法数量</td>
</tr>
<tr>
<td align="center"><code>Method(i int)</code></td>
<td align="center">字段索引,从 0 开始</td>
<td align="center">reflect.Value</td>
<td align="center">根据索引返回结构体方法对应的值对象, 输出为内存地址(尚不清楚是什么地址), 方法的排序是根据 ascii 码的先后顺序进行排序的</td>
</tr>
</tbody></table>
<p>需要注意的是, 方法相关信息可直接通过 <code>reflect.ValueOf(&amp;object).Method()</code> 方法获取, 且通过这种方法获取的方法包括 receiver 为 <code>&amp;object</code> 的方法. <code>reflect.ValueOf(object).Method()</code> 仅返回 receiver 为 <code>object</code> 的方法. 而字段值对象相关信息只能通过 <code>Elem()</code> 获取值元素后获取字段段值对象相关信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span>  <span class="string">`json: "name"`</span></span><br><span class="line">	Age   <span class="keyword">int</span>     <span class="string">`json: "age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(*stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	stu.Name = name</span><br><span class="line">	stu.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu := Student&#123;</span><br><span class="line">		Name: <span class="string">"tom"</span>,</span><br><span class="line">		Age:  <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	valueOfstu := reflect.ValueOf(stu)</span><br><span class="line">	kindOfstu := valueOfstu.Kind()</span><br><span class="line">	valueOfptr := reflect.ValueOf(&amp;stu)</span><br><span class="line">    typeOfStu := valueOfstu.Type()  <span class="comment">// 返回反射的类型</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kindOfstu != reflect.Struct &#123;</span><br><span class="line">		fmt.Println(<span class="string">"except struct..."</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fieldNum := typeOfstu.NumField()</span><br><span class="line">	fmt.Println(<span class="string">"字段个数为: "</span>, fieldNum)  <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; fieldNum; i++ &#123;</span><br><span class="line">		field := typeOfstu.Field(i)</span><br><span class="line">		fmt.Println(field)  <span class="comment">// 直接输出各个字段的值</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	methodNumOfstu := typeOfstu.NumMethod()</span><br><span class="line">	fmt.Println(<span class="string">"stu方法个数为: "</span>, methodNumOfstu)  <span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfstu; i++ &#123;</span><br><span class="line">		method := typeOfstu.Method(i)</span><br><span class="line">		fmt.Println(method)  <span class="comment">// 直接输出一个形如 0x4878c0 的地址, 但是不确定是什么, 而且所有都是相同的</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	methodNumOfptr := typeOfptr.NumMethod()</span><br><span class="line">	fmt.Println(<span class="string">"&amp;stu方法个数为: "</span>, methodNumOfptr)   <span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNumOfptr; i++ &#123;</span><br><span class="line">		method := typeOfptr.Method(i)</span><br><span class="line">		fmt.Println(method) <span class="comment">// 直接输出一个形如 0x4878c0 的地址, 但是不确定是什么, 而且所有都是相同的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用反射调用结构体的方法"><a href="#使用反射调用结构体的方法" class="headerlink" title="使用反射调用结构体的方法"></a>使用反射调用结构体的方法</h3><p>继续看上一个例子, 通过反射如何调用 <code>Student</code> 中的方法呢?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span>  <span class="string">`json: "name"`</span></span><br><span class="line">	Age   <span class="keyword">int</span>     <span class="string">`json: "age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(*stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	stu.Name = name</span><br><span class="line">	stu.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu := Student&#123;</span><br><span class="line">		Name: <span class="string">"tom"</span>,</span><br><span class="line">		Age:  <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	valueOfStu := reflect.ValueOf(&amp;stu)  <span class="comment">// 需要注意这里传入的是 &amp;stu, 使反射能够调用所有的方法, 并修改原始对象的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 reflect.Value 的 Call() 方法反射调用 GetSum(n1, n2 int) int 方法, Call()方法需传入 []reflect.Value 类型的值</span></span><br><span class="line">	<span class="keyword">var</span> paramsGetSum []reflect.Value</span><br><span class="line">	paramsGetSum = <span class="built_in">append</span>(paramsGetSum, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	paramsGetSum = <span class="built_in">append</span>(paramsGetSum, reflect.ValueOf(<span class="number">20</span>))</span><br><span class="line">	resGetSum := valueOfStu.Method(<span class="number">0</span>).Call(paramsGetSum)  <span class="comment">// 调用后返回值为 []reflect.Value, 因此需要根据返回值个数使用索引来获取返回值</span></span><br><span class="line">    fmt.Printf(<span class="string">"调用结果为 %v, 类型为 %T"</span>, resGetSum, resGetSum)  <span class="comment">// 输出为 :调用结果为 30, 类型为 []reflect.Value</span></span><br><span class="line">    resGetSum0 := resGetSum[<span class="number">0</span>]</span><br><span class="line">    fmt.Printf(<span class="string">"第一个返回值为 %v, 类型为 %T\n"</span>, resGetSum0, resGetSum0)  <span class="comment">// 输出为 :第一个返回值为 30, 类型为 reflect.Value</span></span><br><span class="line">	realRes0 := resGetSum[<span class="number">0</span>].Interface().(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"实际结果为 %v, 类型为 %T\n"</span>, realRes, realRes)  <span class="comment">// 输出为 :实际结果为 30, 类型为 int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 reflect.Value 的 Call() 方法反射调用 Print() 方法, Call()方法需传入 []reflect.Value 类型的值</span></span><br><span class="line">    <span class="keyword">var</span> paramsPrint []reflect.Value</span><br><span class="line">	resPrint := valueOfStu.Method(<span class="number">1</span>).Call(paramsPrint)</span><br><span class="line">	fmt.Printf(<span class="string">"调用结果为 %v, 类型为 %T"</span>, resPrint, resPrint)  <span class="comment">// 输出为 :调用结果为 [], 类型为 []reflect.Value</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 reflect.Value 的 Call() 方法反射调用 Set(name string, age int) 方法, Call()方法需传入 []reflect.Value 类型的值</span></span><br><span class="line">    <span class="keyword">var</span> paramsSet []reflect.Value</span><br><span class="line">	paramsSet = <span class="built_in">append</span>(paramsSet, reflect.ValueOf(<span class="string">"jack"</span>))</span><br><span class="line">	paramsSet = <span class="built_in">append</span>(paramsSet, reflect.ValueOf(<span class="number">30</span>))</span><br><span class="line">	resSet := valueOfStu.Method(<span class="number">2</span>).Call(paramsSet)</span><br><span class="line">	fmt.Printf(<span class="string">"调用结果为 %v, 类型为 %T\n"</span>, resSet, resSet) <span class="comment">// 输出为 :调用结果为 [], 类型为 []reflect.Value</span></span><br><span class="line">	fmt.Println(stu)  <span class="comment">// 可以看到 stu 已被修改为 &#123;jack 30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它类型结构体"><a href="#其它类型结构体" class="headerlink" title="其它类型结构体"></a>其它类型结构体</h2><h3 id="StructField-结构体字段"><a href="#StructField-结构体字段" class="headerlink" title="StructField 结构体字段"></a>StructField 结构体字段</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>          <span class="comment">// 字段名</span></span><br><span class="line">    PkgPath <span class="keyword">string</span>       <span class="comment">// 字段路径</span></span><br><span class="line">    Type      Type       <span class="comment">// 字段反射类型对象</span></span><br><span class="line">    Tag       StructTag  <span class="comment">// 字段的结构体标签</span></span><br><span class="line">    Offset    <span class="keyword">uintptr</span>    <span class="comment">// 字段在结构体中的相对偏移</span></span><br><span class="line">    Index     []<span class="keyword">int</span>      <span class="comment">// Type.FieldByIndex中的返回的索引值</span></span><br><span class="line">    Anonymous <span class="keyword">bool</span>       <span class="comment">// 是否为匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StructTag <span class="keyword">string</span></span><br></pre></td></tr></table></figure>

<h3 id="Method-方法"><a href="#Method-方法" class="headerlink" title="Method 方法"></a>Method 方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Method <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span> <span class="comment">// 方法名</span></span><br><span class="line">	PkgPath <span class="keyword">string</span> <span class="comment">// 方法路径</span></span><br><span class="line">	Type    Type   <span class="comment">// 方法类型</span></span><br><span class="line">	Func    Value  <span class="comment">// 以接收者为第一个参数的 func</span></span><br><span class="line">	Index   <span class="keyword">int</span>    <span class="comment">// Type.Method 的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>istio 可插拔的服务安全</title>
    <url>/2020/04/30/istio-security-service/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote>
<p>安全原理</p>
</blockquote>
<ul>
<li>安全核心组件 Citadel 用于密钥和证书管理</li>
<li>Envoy 作为数据面组件代理服务间的安全通信,包括认证,通道加密等</li>
<li>Pilot 作为配置管理服务,在安全场景下将安全相关的配置分发 Envoy</li>
<li>Mixer 可以通过配置 Adapter 来做授权和访问审计</li>
</ul>
<p>从控制面到数据面的配置流程:</p>
<ul>
<li>Citadel 监听Kube-apiserver,为每个 Service 都生成密钥和证书,并保存为 Kubernetes Secrets.当创建Pod时,Kubernetes 将包含密钥和证书的 Secret 挂载到对应的Pod中</li>
<li>Citadel会维护证书的生命周期,并根据配置定期重建 Kubernetes Secrets 以自动更新证书</li>
<li>Pilot生成配置信息,定义哪个 ServiceAccount 可以运行哪个服务，并将这个配置下发给 Envoy</li>
</ul>
<p>数据面主要流程如下:</p>
<ul>
<li>客户端的 Envoy 拦截到服务的 Outbound 流量</li>
<li>客户端的 Envoy 和服务端的 Envoy 进行双向 TLS 握手</li>
<li>在双向TLS建立后,请求到达服务端 Envoy,服务端 Envoy 将请求转发给本地服务</li>
</ul>
<p>Istio 提供的安全功能主要有认证和授权</p>
<blockquote>
<p>认证方式</p>
</blockquote>
<p>istio 中提供了两种认证方式:</p>
<ul>
<li>传输认证: 又称为从服务到服务的认证.Istio 基于双向 TLS 来实现传输认证,包括双向认证,通道安全和证书自动维护.基于双向TLS可以保护从服务到服务的通信</li>
<li>来源认证: 又称为最终用户认证,用于认证请求的最终用户或设备</li>
</ul>
<blockquote>
<p>授权</p>
</blockquote>
<p>istio 中的授权是基于角色的访问控制(RBAC)</p>
<blockquote>
<p>密钥证书管理</p>
</blockquote>
<p>Citadel 服务主要做 4 个操作</p>
<ul>
<li>给每个 Service Account 都生成 SPIFFE 密钥证书对</li>
<li>根据Service Account 给对应的 Pod 分发密钥和证书对</li>
<li>定期替换密钥证书</li>
<li>根据需要撤销证书</li>
</ul>
<h1 id="服务认证配置"><a href="#服务认证配置" class="headerlink" title="服务认证配置"></a>服务认证配置</h1><p>示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为 forecast 开启双向认证</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast-weather-mtls</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">targets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="认证策略定义"><a href="#认证策略定义" class="headerlink" title="认证策略定义"></a>认证策略定义</h2><p>认证策略定义过程中重要字段如下:</p>
<ul>
<li><code>targets</code>: 表示策略作用的目标对象,如果为空,则对策略作用范围内的所有服务都生效.该字段包含 <code>name</code> 和 <code>ports</code> 分别表示服务名称及端口</li>
<li><code>peers</code>: 描述传输认证的配置.一般被赋值为 mtls,表示启用双向认证.若不启用,则不用赋值</li>
<li><code>orgins</code>: 描述访问来源认证的配置.</li>
</ul>
<h2 id="认证策略典型应用"><a href="#认证策略典型应用" class="headerlink" title="认证策略典型应用"></a>认证策略典型应用</h2><blockquote>
<p>全网格服务启用双向 TLS 认证</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作用范围: 全网格,只能存在一个</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MeshPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>全名称空间服务启用双向 TLS 认证()</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作用范围: 名称空间,名称空间内只能存在一个</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对特定服务不启用双向 TLS 认证</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">enable_weather_tls</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">peers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mtls:</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">authentication.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">disable_adv_tls</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">targets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">advertisement</span></span><br></pre></td></tr></table></figure>

<h1 id="服务授权配置"><a href="#服务授权配置" class="headerlink" title="服务授权配置"></a>服务授权配置</h1><h2 id="授权启用配置"><a href="#授权启用配置" class="headerlink" title="授权启用配置"></a>授权启用配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRbacConfig</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="string">ClusterRbacConfig</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">"ON_WITH_INCLUSION"</span></span><br><span class="line">  <span class="comment"># 支持 4 种模式,OFF(所有关闭),ON(所有开启),ON_WITH_INCLUSION(只对 inclusion 启用授权),ON_WITH_EXCLUSION(只对 exclusion 禁用授权)</span></span><br><span class="line">  <span class="attr">inclusion:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather</span></span><br><span class="line">    <span class="comment"># services:</span></span><br><span class="line">    <span class="comment"># - weather_service</span></span><br></pre></td></tr></table></figure>
<h2 id="授权策略配置"><a href="#授权策略配置" class="headerlink" title="授权策略配置"></a>授权策略配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">binding-advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">source.namespace:</span> <span class="string">"terminal"</span></span><br><span class="line">  <span class="attr">roleRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>serviceRole 定义</p>
</blockquote>
<p>关键字 <code>rules</code>,表示权限的许可,元素 rule 通过如下字段来定义</p>
<ul>
<li><code>servces</code>: 必选字段,表示作用的服务的集合</li>
<li><code>paths</code>: 配置对应服务的接口列表.未指定时表示所有 path</li>
<li><code>methods</code>: 指定接口的方法,如 GET,POST 等</li>
<li><code>constraints</code>: 可选字段,可以理解为服务的扩展字段.常用扩展字段如下<ul>
<li><code>destination.labels</code>: 目标服务上的标签,如 destination.labels[version] 是 [v1] 来描述对特定版本的权限</li>
<li><code>request.headers</code>: 通过 Header 上取值 来描述规则</li>
<li><code>destination.ip</code>: 目标服务实例的 IP 地址</li>
<li><code>destination.port</code>: 目标服务端口</li>
<li><code>destination.namespace</code>: 目标服务名称空间</li>
<li><code>destination.user</code>: 目标服务负载上取到的标识</li>
</ul>
</li>
</ul>
<blockquote>
<p>serviceRoleBinding 定义</p>
</blockquote>
<p>serviceRoleBinding 作为绑定的定义,主要绑定两个对象,一个是定义的角色 <code>roleRef</code>,另一个是角色分配的目标对象 <code>subjects</code></p>
<ul>
<li><code>roleRef</code>: 必选字段,表示要绑定的角色.包含 <code>kind(角色类型,ServiceRole)</code> 和 <code>name(角色名称)</code> 两个字段</li>
<li><code>subjects</code>: 必选字段,表示角色分配的目标,是一个列表,可将角色分配到多个对象上.该字段有两个属性分类<ul>
<li><code>user</code>: 对应用户名或 ID. “*” 表示授权给所有用户和服务</li>
<li><code>properties</code>: 扩展属性.支持以下属性<ul>
<li><code>source.ip</code>: 源服务实例的 IP 地址</li>
<li><code>source.namespace</code>: 源服务实例的名称空间</li>
<li><code>source.principal</code>: 源服务实例标识</li>
<li><code>request.headers</code>: 请求 HTTP header</li>
<li><code>request.auth.principal</code>: 请求认证主体</li>
<li><code>request.auth.audiences</code>: 认证信息的目标受众</li>
<li><code>request.auth.presenter</code>: 授权的凭证提供者</li>
<li><code>request.auth.claims</code>: 来源JWT声明</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="授权策略典型应用"><a href="#授权策略典型应用" class="headerlink" title="授权策略典型应用"></a>授权策略典型应用</h2><blockquote>
<p>特定名称空间授权</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["*"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["*"]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">binding-advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">source.namespace:</span> <span class="string">"client"</span></span><br><span class="line">  <span class="attr">roleRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>特定服务授权</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>特定接口授权</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">paths:</span> <span class="string">["v2/weatherdata"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>特定版本授权</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">advertisement-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span> <span class="string">["advertisement.weather.svc.cluster.local"]</span></span><br><span class="line">    <span class="attr">methods:</span> <span class="string">["GET"]</span></span><br><span class="line">    <span class="attr">constraints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"destination.labels[version]"</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">["v2"]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>特定源授权</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: rbac.istio.io/v1alpha1</span><br><span class="line"><span class="attribute">kind</span>: ServiceRoleBinding</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: binding-advertisement-reader</span><br><span class="line">  <span class="attribute">namespace</span>: weather</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">subjects</span>:</span><br><span class="line">  - <span class="attribute">properties</span>:</span><br><span class="line">      source.<span class="attribute">ip</span>: <span class="string">"1.1.0.0/16"</span></span><br><span class="line">  <span class="attribute">roleRef</span>:</span><br><span class="line">    <span class="attribute">kind</span>: ServiceRole</span><br><span class="line">    <span class="attribute">name</span>: advertisement-reader</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云原生应用</category>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>istio Sidecar 机制</title>
    <url>/2020/04/30/istio-sidecar/</url>
    <content><![CDATA[<h1 id="Sidecar-注入"><a href="#Sidecar-注入" class="headerlink" title="Sidecar 注入"></a>Sidecar 注入</h1><p>在 Kubernetes 中,Sidecar 容器与应用容器共存于同一个 Pod 中,共享同一个 Network Namespaces,因此Sidecar容器与应用容器共享同一个网络协议栈,这是 Sidecar 能够通过 iptables 拦截应用进出口流量的根本原因</p>
<p>在 istio 进行 sidecar 注入有两种方式,一种是通过 istioctl 命令行注入,另一种是通过 Sidecar Injector 自动注入.这两种方式的最终目的都是在应用 Pod 中注入 init 和 istio-proxy 这两个 Sidecar 容器.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Sidecar Injector 是 Istio 中实现自动注入 Sidecar 的组件,它是以 Kubernetes 准入控制器 Admission Controller 的形式运行的.Admission Controller 的基本工作原理是拦截 Kube-apiserver 的请求,在对象持久化之前,认证鉴权之后进行拦截.Kubernetes 允许用户以 Webhook 的方式自定义准入控制器,Sidecar Injector 就是这样一种特殊的 MutatingAdmissionWebhook</p>
<p>Sidecar Injector 只在创建 Pod 时进行 Sidecar 容器注入,在 Pod 的创建请求到达 kube-apiserver 后,首先进行认证鉴权,然后在准入控制阶段,kube-apiserver 以 REST 的方式同步调用 Sidecar Injector Webhook 服务进行 init 与 istio-proxy 容器的注入,最后将 Pod 对象持久化存储到 etcd 中</p>
<p>Istio中的 MutatingWebhook 配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sidecar-injector</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">istio</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sidecar-injector.istio.io</span></span><br><span class="line">    <span class="attr">clientConfig:</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">istiod</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/inject"</span></span><br><span class="line">      <span class="attr">caBundle:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">operations:</span> <span class="string">[</span> <span class="string">"CREATE"</span> <span class="string">]</span></span><br><span class="line">        <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">        <span class="attr">apiVersions:</span> <span class="string">["v1"]</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="string">["pods"]</span></span><br><span class="line">    <span class="attr">failurePolicy:</span> <span class="string">Fail</span></span><br><span class="line">    <span class="attr">namespaceSelector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">istio-injection:</span> <span class="string">enabled</span></span><br></pre></td></tr></table></figure>
<p>由以上配置可见, Sidecar Injector 只对标签匹配 <code>istio-injection：enabled</code> 的命名空间下的Pod资源对象的创建生效</p>
<h1 id="Sidecar-流量拦截"><a href="#Sidecar-流量拦截" class="headerlink" title="Sidecar 流量拦截"></a>Sidecar 流量拦截</h1><p>Sidecar 流量拦截基于 iptables 规则(init 容器启动时设置规则),拦截应用容器 Inbound/Outbound 的流量</p>
<p><img src="/2020/04/30/istio-sidecar/istio_traffic_flow.png" alt="istio 流量流向"></p>
<ol>
<li>Inbound 流量在进入 Pod 的网络协议栈时首先被 iptables 规则拦截</li>
<li>iptables 规则将数据包转发给 Envoy</li>
<li>Envoy 再根据自身监听器的配置,将流量转发给应用进程</li>
<li>Outbound流量由应用发出,首先被 iptables 规则拦截</li>
<li>iptables 规则将出口数据包转发给Envoy</li>
<li>Envoy 再根据自身配置决定是否将流量转发到容器外</li>
</ol>
<h2 id="流量拦截原理"><a href="#流量拦截原理" class="headerlink" title="流量拦截原理"></a>流量拦截原理</h2><p>Istio中,流量拦截的实现依赖 initContainer iptables 规则的设置,目前有 <code>REDIRECT</code> 和 <code>TPROXY</code> 两种流量拦截模式.</p>
<p><code>REDIRECT</code> 模式虽然会进行源地址转换,但依旧是默认的设置.原因如下:</p>
<ul>
<li>配合 Istio 提供的遥测数据依然可以进行调用链分析</li>
<li>Kubernetes 平台上 Pod 及其 IP 地址并不是持久不变的</li>
</ul>
<p>istio 流量拦截的规则通过 initContainer 进行设置,initContainer 的启动参数及镜像如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-p"</span>  <span class="comment"># 指定 Envoy 转发 TCP 流量的端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">15001</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-z"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15006"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-u"</span>  <span class="comment"># 指定用户 id,由该用户发出的数据包不被 iptables 转发,防止死循环</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1337</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-m"</span>  <span class="comment"># 指定 iptables 拦截模式,默认为REDIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"REDIRECT"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-i"</span>  <span class="comment"># 目的地址在此范围内的数据包将会被转发到 Envoy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"*"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-x"</span>  <span class="comment"># 目的地址在此范围内的数据包不会被转发</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-b"</span>  <span class="comment"># 入口端口,进入目标端口的数据包会被转发到 Envoy,默认为应用服务监听端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"9080"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"-d"</span>  <span class="comment"># 入口端口,进入目标端口的数据包不会被转发到Envoy,默认为 15020,这是 Sidecar 容器的健康检查端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15020"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云原生应用</category>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>istio非侵入的流量治理</title>
    <url>/2020/04/03/istio-traffic-control/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>以基础设施的方式提供给用户非侵入的流量治理能力,用户只需关注自己的业务逻辑开发,无须关注服务访问管理</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>管理员通过命令行或 API 创建流量规则</li>
<li>Pilot 将流量规则转换为 Envoy 的标准格式,并下发给 Envoy(转向数据面)</li>
<li>Envoy 拦截 Pod 上本地容器的 Inbound 流量和 Outbound 流量</li>
<li>在流量经过 Envoy 时执行对应的流量规则,对流量进行治理</li>
</ol>
<h2 id="应用场景和功能"><a href="#应用场景和功能" class="headerlink" title="应用场景和功能"></a>应用场景和功能</h2><ul>
<li>负载均衡</li>
</ul>
<p>服务注册: 各服务将服务名和服务实例的对应信息注册到服务注册中心<br>服务发现: 在客户端发起服务访问时,以同步或者异步的方式从服务注册中心获取服务对应的实例列表<br>负载均衡: 据配置的负载均衡算法从实例列表中选择一个服务实例.目前支持的负载均衡算法有轮询,随机和最小连接数算法</p>
<ul>
<li>服务熔断</li>
</ul>
<p>故障检测和处理逻辑,防止临时故障或意外导致系统整体不可用.最典型的场景是防止网络和服务调用故障级联发生,限制故障的影响范围,防止故障蔓延导致系统整体性能下降或雪崩</p>
<ul>
<li>故障注入</li>
</ul>
<p>主要用于测试其健壮性和应对故障的能力,例如异常处理,故障恢复等Istio 的故障注入是在网格中对特定的应用层协议进行故障注入,可以模拟出应用的故障场景.</p>
<p>如注入 HTTP Code 503(服务端异常),请求延时(模拟响应慢)</p>
<ul>
<li>灰度发布</li>
</ul>
<p>新老版本同时在线,新版本只切分少量流量出来,在确认新版本没有问题后,再逐步加大流量比例</p>
<p>其中灰度发布主要有金丝雀发布,蓝绿发布,AB 测试 3 种方式</p>
<ul>
<li>服务访问入口</li>
</ul>
<p>Istio 中通过 Ingress Gateway 访问网格内的服务,做四层到六层的端口,TLS配置等基本功能,VirtualService则定义七层路由等丰富内容</p>
<ul>
<li>外部接入服务治理</li>
</ul>
<p>Istio 通过 ServiceEntry 资源对象将网格外的服务注册到网格上,然后像对网格内的普通服务一样对网格外的服务访问进行治理.有时需<br>要有一个专门的 Egress Gateway 来提供统一的出口网关</p>
<h1 id="VirtualService-路由规则配置"><a href="#VirtualService-路由规则配置" class="headerlink" title="VirtualService 路由规则配置"></a>VirtualService 路由规则配置</h1><p>VirtualService 定义了对特定目标服务的一组流量规则,它将满足条件的流量都转发到对应的服务后端,这个服务后端可以是一个服务,也可以是在 DestinationRule 中定义的服务的子集</p>
<h2 id="HTTP路由-HTTPRoute"><a href="#HTTP路由-HTTPRoute" class="headerlink" title="HTTP路由(HTTPRoute)"></a>HTTP路由(HTTPRoute)</h2><p>满足 <code>HTTPMatchRequest</code> 条件的流量都被路由到 <code>HTTPRouteDestination</code>,执行重定向 <code>HTTPRedirect</code>,重写 <code>HTTPRewrite</code>,重试 <code>HTTPRetry</code>,故障注入 <code>HTTPFaultInjection</code>,跨站 <code>CorsPolicy</code> 等策略</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">location:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">north</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">forecast</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>HTTPMatchRequest 定义匹配规则</p>
</blockquote>
<p>关键字: <code>match</code>,支持如下定义方式</p>
<ul>
<li><code>uri,scheme,method,authority,headers</code>: 支持 <code>exact(精确),prefix(前缀),regex(正则)</code> 方式的匹配</li>
<li><code>port</code>: 端口</li>
<li><code>sourceLabels</code>: 支持以特定的标签进行匹配,匹配满足该标签的 Pod 发送出来的流量</li>
</ul>
<blockquote>
<p>HTTPRouteDestination 定义路由目标</p>
</blockquote>
<p>关键字: <code>route</code>,支持如下定义方式</p>
<ul>
<li><code>destination</code>: 表示请求的目标,最终的流量要被送到这个目标上.通过 <code>host,subnet,port</code> 三个属性来描述<ul>
<li><code>host</code>: 必选字段,表示 istio 中注册的服务名.建议写全服务的全名 <code>&lt;hostname&gt;.&lt;namspace&gt;.svc.cluster.local</code></li>
<li><code>subset</code>: 表示 host 上定义的一个子集,用于表示不同版本的服务</li>
</ul>
</li>
<li><code>weight</code>: 表示请求流量分配的比例,当指定多个 destination 时需要配置,且weight 总和要求是 100</li>
<li><code>headers</code>: 对请求和响应的请求头进行修改</li>
</ul>
<blockquote>
<p>HTTPRedirect 定义重定向规则</p>
</blockquote>
<p>关键字: <code>redirect</code>,需要设置重定向的目标 <code>uri</code>.这里需要注意的是重定向的 <code>uri</code> 会替换原请求中完整的 uri 路径</p>
<blockquote>
<p>HTTPRewrite 定义 url 重写规则</p>
</blockquote>
<p>关键字: <code>rewrite</code>,需要设置重写的 <code>uri</code>.这里需要注意,与重定向不同,重写的 <code>uri</code> 只会会替换原请求中匹配部分的 uri</p>
<blockquote>
<p>HTTPRetry 定义请求失败时重试策略</p>
</blockquote>
<p>关键字 <code>retries</code>,需要设置重试次数(attempts),超时(perTryTimeout),重试条件(retryOn)等.</p>
<ul>
<li><code>attempts</code>: 必选字段,定义重试次数</li>
<li><code>perTryTimeout</code>: 每次重试的超时时间,单位可以是 ms,s,m,h</li>
<li><code>retryOn</code>: 进行重试的条件,以逗号分割.重试条件包含如下:<ul>
<li>5xx: 上游服务返回5xx应答,或没有返回时</li>
<li>gateway-error: 只对502,503和504应答码进行重试</li>
<li>connect-failure：在连接上游服务失败时重试</li>
<li>retriable-4xx：在上游服务返回可重试的4xx应答码时执行重试</li>
<li>refused-stream：在上游服务使用REFUSED_STREAM错误码重置时执行重试</li>
<li>cancelled：在gRPC应答的Header中状态码是cancelled时执行重试</li>
<li>deadline-exceeded：在gRPC应答的Header中状态码是deadline-exceeded时执行重试</li>
<li>internal：在gRPC应答的Header中状态码是internal时执行重试</li>
<li>resource-exhausted：在gRPC应答的Header中状态码是resource-exhausted时执行重试</li>
<li>unavailable：在gRPC应答的Header中状态码是unavailable时执行重试</li>
</ul>
</li>
</ul>
<blockquote>
<p>Mirror 流量镜像</p>
</blockquote>
<p>关键字 <code>mirror</code>,指在将流量转发到原目标地址的同时将流量给另外一个目标地址镜像一份,用于真实流量请求</p>
<blockquote>
<p>HTTPFaultInjection 故障注入</p>
</blockquote>
<p>关键字 <code>fault</code>,支持 <code>delay</code> 和 <code>abort</code> 两个字段配置延时和中止两种故障</p>
<ul>
<li><code>delay</code>: 用于延迟故障注入,主要设置如下两个字段<ul>
<li><code>fixedDelay</code>: 必选字段,表示延迟时间,单位可以是 ms,s,m,h</li>
<li><code>percentage</code>: 延迟故障作用的请求比例</li>
</ul>
</li>
<li><code>abort</code>: 用于中止故障注入,主要设置如下两个字段<ul>
<li><code>httpStatus</code>: 必选字段,中止的 HTTP 状态码</li>
<li><code>percentage</code>: 延迟故障作用的请求比例</li>
</ul>
</li>
</ul>
<blockquote>
<p>CorsPolicy 跨域资源共享</p>
</blockquote>
<p>关键字 <code>corsPolicy</code>,用于通过跨域资源共享(Cross<br>Origin Resource Sharing)机制可允许 Web 应用服务器进行跨域访问控制,使跨域数据传输安全进行</p>
<ul>
<li><code>allowMethods</code>: 允许访问资源的 HTTP 方法列表,内容被序列化到 Access-Control-Allow-Methods 的<br>Header上</li>
<li><code>allowHeaders</code>: 请求资源的 HTTP Header 列表,内容被序列化到 Access-Control-Allow-Headers 的 Header 上</li>
<li><code>exposeHeaders</code>: 浏览器允许访问的 HTTP Header 的白名单,内容被序列化到 Access-Control-Expose-Headers 的 Header 上</li>
<li><code>maxAge</code>: 请求缓存的时长,被转化为 Access-Control-Max-Age 的 Header</li>
<li><code>allowCredentials</code>: 是否允许服务调用方使用凭据发起实际请求,被转化为 Access-Control-Allow-Credentials 的 Header</li>
</ul>
<h2 id="TLS路由-TLSRoute"><a href="#TLS路由-TLSRoute" class="headerlink" title="TLS路由(TLSRoute)"></a>TLS路由(TLSRoute)</h2><p>满足 <code>TLSMatchAttributes</code> 条件的 TLS 和 HTTPS 流量都被路由到 <code>RouteDestination</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">total-weather-tls</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"*.weather.com"</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"ingress-gateway"</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">sniHosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend.weather.com</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">frontend</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">sniHosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">recommendation.weather.com</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">recommendation</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>TLSMatchAttributes TLS匹配规则</p>
</blockquote>
<p>关键字 <code>match</code>,表示 TLS的匹配条件,支持如下定义方式:</p>
<ul>
<li><code>sniHosts</code>: 必选字段，用来匹配 TLS 请求的 SNI ,SNI 的值必须是 VirtualService 的 hosts 的子集</li>
<li><code>port</code>: 访问的目标端口</li>
<li><code>destinationSubnets</code>: 目标IP地址匹配的IP子网</li>
<li><code>sourceLabels</code>: 匹配来源负载的标签</li>
</ul>
<p>一般用法是匹配 <code>sniHosts</code> 和 <code>port</code></p>
<blockquote>
<p>RouteDestination 定义路由目标</p>
</blockquote>
<p>关键字: <code>route</code>,包含如下两个属性,用法和约束同 <code>HTTPRouteDestination</code> 的对应字段</p>
<ul>
<li><code>destination</code>: 表示请求的目标,最终的流量要被送到这个目标上.通过 <code>host,subnet,port</code> 三个属性来描述<ul>
<li><code>host</code>: 必选字段,表示 istio 中注册的服务名.建议写全服务的全名 <code>&lt;hostname&gt;.&lt;namspace&gt;.svc.cluster.local</code></li>
<li><code>subset</code>: 表示 host 上定义的一个子集,用于表示不同版本的服务</li>
</ul>
</li>
<li><code>weight</code>: 表示请求流量分配的比例,当指定多个 destination 时需要配置,且weight 总和要求是 100</li>
</ul>
<h2 id="TCP路由-TCPRoute"><a href="#TCP路由-TCPRoute" class="headerlink" title="TCP路由(TCPRoute)"></a>TCP路由(TCPRoute)</h2><p>所有不满足以上HTTP和TLS条件的流量都会应用TCP流量规则</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">tcp:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">23003</span></span><br><span class="line">    <span class="attr">route:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">inner-forecast</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">3003</span></span><br></pre></td></tr></table></figure>
<p>==满足 TCP 特有的 4 层匹配规则 <code>L4MatchAttribute</code> 条件的流量转发到对应的目标后端==</p>
<blockquote>
<p>L4MatchAttribute 四层匹配规则</p>
</blockquote>
<p>关键字 <code>match</code>,支持以下匹配属性</p>
<ul>
<li><code>destinationSubnets</code>: 目标IP地址匹配的 IP 子网</li>
<li><code>port</code>: 访问的目标端口<br><code>sourceLabels</code>：源工作负载标签</li>
</ul>
<blockquote>
<p>RouteDestination 目标后端 与 TLS 定义方式相同</p>
</blockquote>
<h2 id="三种协议路由规则汇总"><a href="#三种协议路由规则汇总" class="headerlink" title="三种协议路由规则汇总"></a>三种协议路由规则汇总</h2><table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">路由规则</th>
<th align="center">支持的流量匹配条件</th>
<th align="center">条件属性</th>
<th align="center">支持的流量操作</th>
<th align="center">目标路由定义</th>
<th align="center">目标路由属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HTTP</td>
<td align="center">HTTPRoute</td>
<td align="center">HTTPMatchRequest</td>
<td align="center">uri,scheme,method,port,sourceLabels</td>
<td align="center">route,redirect,rewrite,retry,timeout,faultInjection,corsPolicy</td>
<td align="center">HTTPRouteDestination</td>
<td align="center">destination,weight,headers</td>
</tr>
<tr>
<td align="center">TLS</td>
<td align="center">TLSRoute</td>
<td align="center">TLSMatchAttribute</td>
<td align="center">sniHost,port,destinationSubnets,sourceLabels</td>
<td align="center">route</td>
<td align="center">RouteDestination</td>
<td align="center">destination,weight</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">TCPRoute</td>
<td align="center">L4MatchAttribute</td>
<td align="center">destinationSubnets,port,sourceLabels</td>
<td align="center">route</td>
<td align="center">RouteDestination</td>
<td align="center">destination,weight</td>
</tr>
</tbody></table>
<h1 id="DestinationRule-目标规则配置"><a href="#DestinationRule-目标规则配置" class="headerlink" title="DestinationRule 目标规则配置"></a>DestinationRule 目标规则配置</h1><p>DestinationRule 定义了满足路由规则的流量到达后端后的访问策略.在 Istio 中可以配置目标服务的负载均衡策略,连接池大小,异常实例驱除规则等功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alph3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">forecast</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">forecast</span></span><br><span class="line">  <span class="attr">subnet:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span> </span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span> </span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">RANDON</span></span><br></pre></td></tr></table></figure>
<p>DestinationRule 重要属性如下:</p>
<ul>
<li><code>host</code>: 必选字段,表示使用规则的对象,取值是在服务注册中心注册的服务名.host如果取短域名,则会根据规则所在的命名空间进行解析.所以尽量填写全名</li>
<li><code>trafficPolicy</code>: 规则内容的定义,包括负载均衡,连接池策略,异常点检查等</li>
<li><code>PortTrafficPolicy</code>: 需设定关键字 port 表示流量策略要应用的服务端口,其余和 TrafficPolicy 没有很大差别</li>
<li><code>subsets</code>: 定义服务的一个子集,经常用来定义一个服务版本.包含如下重要属性<ul>
<li><code>name</code>: 必选字段,subnet 名称</li>
<li><code>labels</code>: Subset 上的标签,通过一组标签定义了属于这个 Subset 的服务实例</li>
</ul>
</li>
<li><code>exportTo</code>: 控制 DestinationRule 跨名称空间的可见性.可选值为 “.” 或 “*”,表示当前名称空间或所有名称空间</li>
</ul>
<h2 id="TrafficPolicy-流量策略"><a href="#TrafficPolicy-流量策略" class="headerlink" title="TrafficPolicy 流量策略"></a>TrafficPolicy 流量策略</h2><p>流量策略包含以下 4 种重要配置</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">loadBalancer</td>
<td align="center">LoadBalancerSettings</td>
<td align="center">描述服务的负载均衡算法</td>
</tr>
<tr>
<td align="center">connectionPool</td>
<td align="center">ConnectionPoolSettings</td>
<td align="center">描述服务的连接池配置</td>
</tr>
<tr>
<td align="center">outlierDetection</td>
<td align="center">OutlierDetection</td>
<td align="center">描述服务的异常点检查</td>
</tr>
<tr>
<td align="center">tls</td>
<td align="center">TLSSettings</td>
<td align="center">描述服务的TLS连接设置</td>
</tr>
</tbody></table>
<blockquote>
<p>loadBalancer 负载均衡设置</p>
</blockquote>
<p>负载均衡设置支持 <code>simple(简单)</code> 和 <code>consistentHash(一致性 hash)</code> 两个字段.其中,一致性哈希是一种高级的负载均衡策略,只对 HTTP 有效</p>
<ul>
<li><code>simple</code> 字段定义了 <code>ROUND_ROBIN(轮询,默认)</code>,<code>LEAST_CONN(最小连接)</code>,<code>RANDOM(随机)</code>,<code>PASSTHROUGH(直接转发)</code> 等几种负载均衡算法</li>
<li><code>consistentHash</code> 定义了 <code>httpHeaderName(请求头)</code>,<code>httpCookie(cookie)</code>,<code>useSourceIp(源 IP)</code> 等几种负载均衡算法.还提供 <code>minimumRingSize(哈希环上虚拟节点数的最小值)</code> 属性,用于增加 hash 节点数量(节点数越多则负载均衡越精细)</li>
</ul>
<blockquote>
<p>connectionPool 连接池设置</p>
</blockquote>
<p>Istio 连接池管理支持 <code>tcp(TCP流量)</code> 和 <code>http(HTTP流量)</code> 两个字段.</p>
<p><code>tcp</code> 字段定义了如下属性</p>
<ul>
<li><code>maxConnections</code>: 表示为上游服务的所有实例建立的最大连接数,默认1024</li>
<li><code>connectTimeout</code>: TCP连接超时,表示主机网络连接超时</li>
<li><code>tcpKeepalive</code>: 设置TCP keepalives(TCP keepalive).它包含三个字段,如下<ul>
<li><code>probes</code> 表示多少次探测没有应答则断开,默认是9</li>
<li><code>time</code> 表示在发送探测前连接空闲了多长时间,默认2h</li>
<li><code>interval</code> 表示探测间隔,默认 75s</li>
</ul>
</li>
</ul>
<p><code>http</code> 字段定义了如下属性</p>
<ul>
<li><code>http1MaxPendingRequests</code>: 最大等待 HTTP 请求数,默认1024</li>
<li><code>http2MaxRequests</code>: 最大请求数,默认1024</li>
<li><code>maxRequestsPerConnection</code>: 每个连接的最大请求数</li>
<li><code>maxRetries</code>: 最大重试次数,默认3</li>
<li><code>idleTimeout</code>: 空闲超时,在多长时间内没有活动请求则关闭连接</li>
</ul>
<blockquote>
<p>outlierDetection 异常实例检查</p>
</blockquote>
<p>异常点检查就是定期考察被访问的服务实例的工作情况,如果连续出现访问异常,则将服务实例标记为异常并进行隔离,在一段时间内不为其分配流量,待恢复后重新恢复流量.可用于熔断模型</p>
<p>异常实例检查可通过如下字段来控制检查驱逐的逻辑</p>
<ul>
<li><code>consecutiveErrors</code>: 实例被驱逐前的连续错误次数,默认5</li>
<li><code>interval</code>: 驱逐的时间间隔,默认 10s</li>
<li><code>baseEjectionTime</code>: 最小驱逐时间,默认30s.实例被驱逐的时间等于这个最小驱逐时间乘以驱逐的次数</li>
<li><code>maxEjectionPercent</code>: 负载均衡池中可以被驱逐的故障实例的最大比例,默认是10%.避免太多实例被驱逐而导致整体服务能力下降</li>
<li><code>minHealthPercent</code>: 最小健康比例,当可用实例数的比例小于这个比例时,异常点检查功能将被禁用.默认 50%</li>
</ul>
<blockquote>
<p>tls TLS连接设置</p>
</blockquote>
<p>istio TLS 连接设置支持以下字段属性:</p>
<ul>
<li><code>mode</code>: tls 认证方式.支持如下4种模式<ul>
<li><code>Disable</code>: 不使用 TLS 认证</li>
<li><code>SIMPLE</code>: 单向认证</li>
<li><code>MUTUAL</code>: 双向认证.需要应用程序提供客户端证书,在配置中指定证书文件路径</li>
<li><code>ISTIO_MUTUAL</code>: 双向认证.证书由Istio自动生成,不用指定证书路径</li>
</ul>
</li>
<li><code>privateKey</code>: 客户端私钥路径</li>
<li><code>clientCertificate</code>: 客户端证书路径</li>
<li><code>caCertificates</code>: 验证服务端证书的 CA 文件路径</li>
</ul>
<h1 id="Gateway-服务网关配置"><a href="#Gateway-服务网关配置" class="headerlink" title="Gateway 服务网关配置"></a>Gateway 服务网关配置</h1><p>Gateway 在网格边缘接收外部访问,并将流量转发到网格内的服务.Istio 通过 Gateway 将网格内的服务发布成外部可访问的服务,还可以通过 Gateway 配置外部访问的端口,协议及与内部服务的映射关系</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istio.gateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mesh</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">location:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">north</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destionation:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">frontend</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destionation:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">frontend</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>
<p>Gateway 定义了 <code>selector(标签选择)</code> 和 <code>servers(开放的服务列表)</code> 两个关键必选字段.</p>
<blockquote>
<p>server 后端服务</p>
</blockquote>
<p>server 真正定义了服务的访问入口,可通过如下字段来配置多个 server</p>
<ul>
<li><code>port</code>: 必选字段,描述服务在哪个端口开放,是对外监听的端口</li>
<li><code>hosts</code>: 为 gateway 发布的服务地址,是一个 FQDN 域名</li>
<li><code>defaultEndpoint</code>: 表示流量默认转发的后端</li>
<li><code>tls</code>: 安全服务接口相关内容.可通过如下字段进行配置<ul>
<li><code>httpsRedirect</code>: 是否要做 HTTPS 重定向</li>
<li><code>mode</code>: TLS 模式,<code>PASSTHROUGH(不做处理,直接转发,TLS证书相关设置在后端负载),SIMPLE(单向认证),MUTUAL(双向认证),AUTO_PASSTHROUGH</code></li>
<li><code>serverCertificate</code>: 服务端证书路径,在 SIMPLE,MUTUAL 时必须配置</li>
<li><code>privateKey</code>: 服务端密钥路径,在 SIMPLE,MUTUAL 时必须配置</li>
<li><code>caCertificates</code>: CA证书路径,在 MUTUAL 时必须配置</li>
<li><code>credentialName</code>: Gateway 使用 <code>credentialName</code> 从远端的凭据存储(Kubernetes-Secrets)中获取证书和密钥,而不是挂载</li>
<li><code>subjectAltNames</code>: SAN 列表</li>
<li><code>minProtocolVersion</code>,<code>maxProtocolVersion</code>: TLS 协议最小,最大版本</li>
<li><code>cipherSuites</code>: 指定加密套件,默认使用 Envoy 支持的加密套件</li>
</ul>
</li>
</ul>
<h2 id="Gateway-典型应用"><a href="#Gateway-典型应用" class="headerlink" title="Gateway 典型应用"></a>Gateway 典型应用</h2><blockquote>
<ol>
<li>将网格内的 HTTPS 服务发布为 HTTPS 外部访问</li>
</ol>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">PASSTHROUGH</span></span><br></pre></td></tr></table></figure>
<p>这种场景下,后端服务需要配置证书,协议为 HTTPS.istio 只是提供了通道和机制,通过 Gateway 将一个内部的 HTTPS 服务发布出去.</p>
<blockquote>
<ol start="2">
<li>将网格内的 HTTP 服务发布为 HTTPS 外部访问</li>
</ol>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="comment"># 指定服务端证书路径,需要将证书文件挂载在 ingressgateway pod 中.可以通过证书文件创建 k8s-secrets 后进行挂载</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.key</span></span><br><span class="line">      <span class="comment"># 直接指定 k8s-secrets 名称,istio 会自动配置对应的证书及密钥(推荐)</span></span><br><span class="line">      <span class="comment"># credentialName: weather-com-secrets</span></span><br></pre></td></tr></table></figure>
<p>这种场景下,后端服务不需要配置证书,协议为 HTTP.istio 将证书配置在 Gateway 上,并通过 Gateway 将一个内部的 HTTP 服务以 HTTPS 方式发布出去.</p>
<blockquote>
<ol start="3">
<li>将网格内的 HTTP 服务发布为双向 HTTPS 外部访问</li>
</ol>
</blockquote>
<p>在某些场景下,比如调用入口服务的是另一个服务,在服务端需要对客户端进行身份校验,这就需要用到 TLS 的双向认证.应用场景如银行 APP</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">weather.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">MUTUAL</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/etc/istio/gateway-weather-certs/tls.key</span></span><br><span class="line">      <span class="comment"># 用于验证客户端证书</span></span><br><span class="line">      <span class="attr">caCertificates:</span> <span class="string">/etc/istio/gateway-weather-certs/ca.crt</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li>将网格内的 HTTP 服务发布为 HTTPS 外部访问 和HTTPS 内部访问</li>
</ol>
</blockquote>
<p>此场景与场景2 中 Gateway 的 Manifest 完全相同,我们只需知道 istio 可以透明地给网格内的服务启用双向 TLS,并且自动维护证书和密钥.</p>
<p>网关 Gateway 服务和后端 frontend 在这种场景下的工作机制如下</p>
<ul>
<li>frontend 服务自身还是HTTP,不涉及证书密钥的事情</li>
<li>流量进入网格前,Gateway 作为 frontend 服务的入口网关,对外提供 HTTPS 的访问.外部访问到的是在 Gateway 上发布的 HTTPS 服务,使用 Gateway 上的配置提供服务端证书和密钥</li>
<li>流量进入网格后,Gateway 作为客户端访问 frontend 服务的代理(Envoy,Sidecar),对 frontend 服务发起另一个 HTTPS 请求,使用的是 Citadel 分发和维护的客户端证书和密钥,与 frontend 服务代理(Envoy,Sidecar)的服务端证书和密钥进行双向 TLS 认证和通信.(该过程称为 mTLS 双向认证)</li>
</ul>
<h1 id="ServiceEntry-外部服务配置"><a href="#ServiceEntry-外部服务配置" class="headerlink" title="ServiceEntry 外部服务配置"></a>ServiceEntry 外部服务配置</h1><p>ServiceEntry 用于将网格外的服务加入网格中,并像网格内的服务一样进行管理,在实现上就是把外部服务加入 istio 的服务发现</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">weather-external</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure>
<p>ServiceEntry 主要包含如下几个字段</p>
<ul>
<li><code>hosts</code>: 必选字段,表示与 ServiceEntry 相关的主机名.当 resolution 被设置为 DN S类型并且没有指定 endpoints 时,这个字段将用作后端的域名来进行路由</li>
<li><code>ports</code>: 必选字段,表示与外部服务关联的端口</li>
<li><code>resolution</code>: 必选字段,表示服务发现的模式,有以下3种模式可选<ul>
<li><code>NONE</code>: 用于当连接的目标地址已经是一个明确 IP 的场景</li>
<li><code>STATIC</code>: 用在已经用 endpoints 设置了服务实例的地址场景中,即不用解析</li>
<li><code>DNS</code>: 表示用查询环境中的 DNS 进行解析.如果没有设置 endpoints,代理就会使用在<code>hosts</code>中指定的 DNS 地址进行解析</li>
</ul>
</li>
<li><code>addresses</code>: 与服务关联的虚拟IP地址</li>
<li><code>location</code>: <code>MESH_EXTERNAL</code>(网格外部) 或 <code>MESH_INTERNAL</code>(网格内部).当和网格外部服务通信时,mTLS 双向认证将被禁用,并且策略只能在客户端执行,不能在服务端执行.对于外部服务,我们不可能注入一个 Sidecar 来进行双向认证等操作</li>
<li><code>endpoints</code>:表示与网格服务关联的网络地址,可以是一个IP,也可以是一个主机名.包含如下字段<ul>
<li><code>address</code>: 必选字段,表示网络后端的地址.当 resolution 设置为 DNS 时,可以使用域名</li>
<li><code>ports</code>: 端口列表</li>
<li><code>labels</code>: 后端标签</li>
<li><code>weight</code>: 权重</li>
</ul>
</li>
</ul>
<h2 id="ServiceEntry-典型应用"><a href="#ServiceEntry-典型应用" class="headerlink" title="ServiceEntry 典型应用"></a>ServiceEntry 典型应用</h2><blockquote>
<p>通过配置 ServiceEntry + Egressgateway + VirtualService 访问外部服务</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 www.weatherdb.com 外部服务</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">weather-external</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br><span class="line"><span class="comment"># 定义 www.weatherdb.com 服务的 egress-gateway 网关出口</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">egress-gateway</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">istio:</span> <span class="string">egressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">egress-wearthdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.weatherdb.com</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">egress-gateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mesh</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">gateways:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mesh</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">egress-gateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">gateways:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">egress-gateway.istio-system.svc.cluster.local</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">www.weatherdb.com</span></span><br></pre></td></tr></table></figure>
<p>在此场景中,定义了两个 route</p>
<ul>
<li>网格内流量: 这个 route 的 gateways 是 mesh,表示来自网格内的流量在访问 <a href="http://www.weatherdb.com" target="_blank" rel="noopener">www.weatherdb.com</a> 这个外部地址时,将被路由到 egressgateway 网关上</li>
<li>网格外流量: 这个 route 的 gateways 是 egress,表示来自 egress 的流量在访问 <a href="http://www.weatherdb.com" target="_blank" rel="noopener">www.weatherdb.com</a> 这个外部地址时,将被路由到外部服务 <a href="http://www.weatherdb.com" target="_blank" rel="noopener">www.weatherdb.com</a> 上</li>
</ul>
<h1 id="Sidecar-代理规则配置"><a href="#Sidecar-代理规则配置" class="headerlink" title="Sidecar 代理规则配置"></a>Sidecar 代理规则配置</h1><p>用于对 istio数据面的行为进行更精细的控制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">SideCar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">weather</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"istio-system/*"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"news/*"</span></span><br></pre></td></tr></table></figure>
<p>在Sidecar上主要通过三个字段来描述规则</p>
<ul>
<li><code>workloadSelector</code>: 表示工作负载的选择器(pod 标签选择器),如果为空,则应用到整个命名空间</li>
<li><code>egress</code>: 配置 sidecar 对网格内其它服务的访问.如果没有配置,则只要名称空间可见,服务就可见<ul>
<li><code>hosts</code>: 监听的服务,为 <code>namespace/dnsName</code> 格式,</li>
<li><code>port</code>: 监听器关联的端口</li>
<li><code>bind</code>: 监听器绑定的地址</li>
<li><code>captureMode</code>: 配置如何捕获监听器的流量.有 <code>DEFAULT(默认),IPTABLES(基于 iptables 的流量拦截),NONE(没有流量拦截)</code>.</li>
</ul>
</li>
<li><code>ingress</code>: 配置 Sidecar 对应工作负载的 Inbound流量.<ul>
<li><code>port</code>: 必选字段,监听器关联的端口</li>
<li><code>defaultEndpoint</code>: 必选字段,为流量转发的目标地址</li>
<li><code>bind</code>: 监听器绑定的地址</li>
<li><code>captureMode</code>: 配置如何捕获监听器的流量</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>云原生应用</category>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes相关错误及其解决</title>
    <url>/2020/04/03/k8s-errors-and-resolve/</url>
    <content><![CDATA[<h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/etcd-io/etcd/issues/10174" target="_blank" rel="noopener">执行命令时间太长</a></li>
</ul>
</blockquote>
<p>日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-07-22 03:33:16.621867 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;namespaces&#x2F;kube-system\&quot; &quot; with result &quot;range_response_count:1 size:177&quot; took too long (265.312097ms) to execute</span><br><span class="line">2019-07-22 03:33:16.622103 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;health\&quot; &quot; with result &quot;range_response_count:0 size:4&quot; took too long (255.015614ms) to execute</span><br><span class="line">2019-07-22 03:33:16.622848 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;clusterroles&#x2F;\&quot; range_end:\&quot;&#x2F;registry&#x2F;clusterroles0\&quot; &quot; with result &quot;range_response_count:0 size:4&quot; took too long (266.165829ms) to execute</span><br><span class="line">2019-07-22 03:33:16.625493 W | etcdserver: read-only range request &quot;key:\&quot;&#x2F;registry&#x2F;health\&quot; &quot; with result &quot;range_response_count:0 size:4&quot; took too long (231.260569ms) to execute</span><br></pre></td></tr></table></figure>
<p>原因</p>
<ul>
<li><a href="https://github.com/etcd-io/etcd/blob/master/Documentation/faq.md#what-does-the-etcd-warning-apply-entries-took-too-long-mean" target="_blank" rel="noopener">磁盘IO瓶颈</a></li>
</ul>
<blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/etcd-io/etcd/issues/5154" target="_blank" rel="noopener">负载过高</a></li>
</ul>
</blockquote>
<p>环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># etcd 二进制启动</span></span><br><span class="line">etcd --name vm1 --initial-advertise-peer-urls http://192.168.2.3:12380 \</span><br><span class="line">  --listen-peer-urls http://192.168.2.3:12380 \</span><br><span class="line">  --listen-client-urls http://192.168.2.3:12379,http://127.0.0.1:12379 \</span><br><span class="line">  --advertise-client-urls http://192.168.2.3:12379 \</span><br><span class="line">  --initial-cluster-token etcd-cluster-bin \</span><br><span class="line">  --initial-cluster vm1=http://192.168.2.3:12380,vm2=http://192.168.2.4:12380 \</span><br><span class="line">  --initial-cluster-state new</span><br></pre></td></tr></table></figure>
<p>日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-08-20 16:58:45.366953 W | etcdserver: failed to send out heartbeat on time (exceeded the 100ms timeout for 154.491083ms, to 7ceb206ff2a779a3)</span><br><span class="line">2019-08-20 16:58:45.366979 W | etcdserver: server is likely overloaded</span><br><span class="line">2019-08-20 16:59:14.442020 W | etcdserver: failed to send out heartbeat on time (exceeded the 100ms timeout for 44.374276ms, to 7ceb206ff2a779a3)</span><br><span class="line">2019-08-20 16:59:14.442049 W | etcdserver: server is likely overloaded</span><br><span class="line">2019-08-20 16:59:38.078540 W | etcdserver: failed to send out heartbeat on time (exceeded the 100ms timeout for 380.617868ms, to 7ceb206ff2a779a3)</span><br></pre></td></tr></table></figure>
<p>解决: 添加<code>--heartbeat-interval 250 --election-timeout 1250</code>启动参数</p>
<h1 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h1><blockquote>
<ul>
<li><input disabled type="checkbox"> <a href="https://github.com/kubernetes/kubernetes/issues/76956" target="_blank" rel="noopener">unknow</a></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E0722 03:32:55.266253       1 prometheus.go:55] failed to register depth metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266276       1 prometheus.go:68] failed to register adds metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266294       1 prometheus.go:82] failed to register latency metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266308       1 prometheus.go:96] failed to register workDuration metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266330       1 prometheus.go:112] failed to register unfinished metric admission_quota_controller: duplicate metrics collector registration attempted</span><br><span class="line">E0722 03:32:55.266346       1 prometheus.go:126] failed to register unfinished metric admission_quota_controller: duplicate metrics collector registration attempted</span><br></pre></td></tr></table></figure>

<h1 id="metrics-server"><a href="#metrics-server" class="headerlink" title="metrics-server"></a>metrics-server</h1><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/kubernetes-incubator/metrics-server/issues/247" target="_blank" rel="noopener">metrics 不可用</a></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E0821 01:20:44.192985       1 reststorage.go:128] unable to fetch node metrics for node &quot;vm1&quot;: no metrics known for node</span><br><span class="line">E0821 01:20:44.193003       1 reststorage.go:128] unable to fetch node metrics for node &quot;vm2&quot;: no metrics known for node</span><br><span class="line">E0821 01:25:06.254119       1 reststorage.go:147] unable to fetch pod metrics for pod default&#x2F;bbox: no metrics known for pod</span><br><span class="line">E0821 01:25:06.254143       1 reststorage.go:147] unable to fetch pod metrics for pod default&#x2F;nginx: no metrics known for pod</span><br><span class="line">E0821 01:25:43.654288       1 manager.go:111] unable to fully collect metrics: [unable to fully scrape metrics from source kubelet_summary:vm2: unable to fetch metrics from Kubelet vm2 (vm2): Get https:&#x2F;&#x2F;vm2:10250&#x2F;stats&#x2F;summary&#x2F;: x509: certificate signed by unknown authority, unable to fully scrape metrics from source kubelet_summary:vm1: unable to fetch metrics from Kubelet vm1 (vm1): Get https:&#x2F;&#x2F;vm1:10250&#x2F;stats&#x2F;summary&#x2F;: x509: certificate signed by unknown authority]</span><br></pre></td></tr></table></figure>
<p>解决: 在<code>metrics-server-deployment.yaml</code>文件中的容器参数中添加<code>args: [ &quot;--kubelet-insecure-tls&quot; ]</code></p>
<blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://www.cnblogs.com/vincenshen/p/9638162.html" target="_blank" rel="noopener">权限问题</a></li>
</ul>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">E1218 <span class="number">10</span>:<span class="number">26</span>:<span class="number">36.104471</span>       <span class="number">1</span> manager.go:<span class="number">111</span>] unable to fully collect metrics: [unable to fully scrape metrics <span class="keyword">from</span> source kubelet_summary:master: unable to fetch metrics <span class="keyword">from</span> Kubelet master (<span class="number">10.168</span><span class="number">.67</span><span class="number">.6</span>): request failed - <span class="string">"403 Forbidden"</span>, response: <span class="string">"Forbidden (user=system:serviceaccount:kube-system:metrics-server, verb=get, resource=nodes, subresource=stats)"</span>]</span><br></pre></td></tr></table></figure>
<p>原因</p>
<ul>
<li>clusterrole<code>system:metrics-server</code>对<code>nodes/stats</code>资源没有相关权限</li>
</ul>
<p>解决: 在资源中添加对<code>nodes/stats</code>资源的 get 权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get clusterrole system:metrics-server -o yaml &gt; metrics-server-clusterrole.yaml</span><br><span class="line">kubectl apply -f metrics-server-clusterrole.yaml</span><br></pre></td></tr></table></figure>

<h1 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h1><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/kubernetes/kubernetes/issues/60987#issuecomment-529107444" target="_blank" rel="noopener">已被删除的容器还在磁盘上</a></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;var&#x2F;log&#x2F;kubernetes&#x2F;kubelet.log</span><br><span class="line">E0214 17:00:33.187665    1547 kubelet_volumes.go:154] Orphaned pod &quot;8d73e524-fb7c-4b25-a907-3c18b78f587d&quot; found, but volume paths are still present on disk : There were a total of 1 errors similar to this. Turn up verbosity to see them.</span><br><span class="line">E0214 17:00:35.188258    1547 kubelet_volumes.go:154] Orphaned pod &quot;8d73e524-fb7c-4b25-a907-3c18b78f587d&quot; found, but volume paths are still present on disk : There were a total of 1 errors similar to this. Turn up verbosity to see them.</span><br></pre></td></tr></table></figure>
<p>解决: 找到出现问题的Pod的id后,删除该目录即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -fu kubelet | awk -F<span class="string">'"'</span> <span class="string">'&#123; print $2&#125;'</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/kubelet/pods</span><br><span class="line">rm -rf &lt;pod id<span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h1><blockquote>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://www.orchome.com/1977" target="_blank" rel="noopener">helm 连接 tiller 报错</a></li>
</ul>
</blockquote>
<p>环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f - &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">EOF</span><br><span class="line">helm init --service-account tiller</span><br><span class="line">helm version</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Client: &amp;version.Version&#123;SemVer:<span class="string">"v2.12.0"</span>, GitCommit:<span class="string">"d325d2a9c179b33af1a024cdb5a4472b6288016a"</span>, GitTreeState:<span class="string">"clean"</span>&#125;</span><br><span class="line">E0311 14:30:57.739137    2268 portforward.go:331] an <span class="builtin-name">error</span> occurred forwarding 37108 -&gt; 44134: <span class="builtin-name">error</span> forwarding<span class="built_in"> port </span>44134 <span class="keyword">to</span> pod 656c9a0a94968a3ef99a17bba846c4617d8afd1b6f9a375890a86b965cd9fa5f, uid : unable <span class="keyword">to</span> <span class="keyword">do</span><span class="built_in"> port </span>forwarding: socat <span class="keyword">not</span> found</span><br><span class="line">Error: cannot connect <span class="keyword">to</span> Tiller</span><br></pre></td></tr></table></figure>
<p>解决: 所有设备上安装<code>socat</code>包</p>
<h1 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h1><blockquote>
<ul>
<li><input checked disabled type="checkbox"> 虚拟机关机重启后,不同节点间的 Pod 不能互 ping</li>
</ul>
</blockquote>
<p>环境: 检查发现 node 节点的 flannel.1 网卡 down,与该<a href="https://www.oschina.net/question/2344660_2286913" target="_blank" rel="noopener">博客</a>描述基本相符<br>解决: 删除 cni0,flannel.1 网桥后重新启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop kubelet </span><br><span class="line">systemctl stop docker </span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down </span><br><span class="line">ifconfig docker0 down </span><br><span class="line">ip link delete cni0 </span><br><span class="line">ip link delete flannel.1 </span><br><span class="line">systemctl start docker </span><br><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><input checked disabled type="checkbox"> kubernetes无法删除Terminating状态的namespace</li>
</ul>
</blockquote>
<p>解决: 删除对应namespace json文件的<code>spec</code>字段后,重新发起请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get namespace &lt;namespace-name&gt; -o json &gt; tmp.json</span><br><span class="line"><span class="comment"># 编辑 tmp.json,删除 "spec" 字段部分</span></span><br><span class="line">curl -k -XPUT -H <span class="string">"Content-Type: application/json"</span> --data-binary @tmp.json http://127.0.0.1:8001/api/v1/namespaces/istio-system/finalize</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>云原生应用</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义kube-prometheus添加etcd监控</title>
    <url>/2020/04/03/monitor-etcd-with-kube-prometheus/</url>
    <content><![CDATA[<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y go</span><br><span class="line">go get github.com/jsonnet-bundler/jsonnet-bundler/cmd/jb <span class="comment"># jsonnet 的包管理器</span></span><br><span class="line">go get github.com/brancz/gojsontoyaml <span class="comment"># go 语言编写的 json 转化为 yaml 工具</span></span><br><span class="line"><span class="comment"># 安装好的二进制包在 ~/go/bin/ 目录下</span></span><br><span class="line"><span class="built_in">cd</span> ~/go/bin/</span><br><span class="line">cp jb gojsontoyaml /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure>

<h1 id="自定义-jsonnet"><a href="#自定义-jsonnet" class="headerlink" title="自定义 jsonnet"></a>自定义 jsonnet</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-kube-prometheus <span class="comment"># 在 自定义 kube-prometheus</span></span><br><span class="line">jb init  <span class="comment"># 创建初始化空文件 jsonnetfile.json</span></span><br><span class="line"><span class="comment"># 安装 kube-prometheus 依赖.花费时间较长</span></span><br><span class="line"><span class="comment"># 该版本较老,推荐使用 github.com/coreos/kube-prometheus/jsonnet/kube-prometheus@master</span></span><br><span class="line">jb install github.com/coreos/kube-prometheus/jsonnet/kube-prometheus@release-0.1 </span><br><span class="line">jb update</span><br></pre></td></tr></table></figure>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>使用 <code>build.sh</code> 进行编译,以 <code>etcd.jsonnet</code> 为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line">rm -rf manifests</span><br><span class="line">mkdir -p manifests/setup</span><br><span class="line"></span><br><span class="line">jsonnet -J vendor -m manifests <span class="string">"<span class="variable">$&#123;1-etcd.jsonnet&#125;</span>"</span> | xargs -I&#123;&#125; sh -c <span class="string">'cat &#123;&#125; | gojsontoyaml &gt; &#123;&#125;.yaml; rm -f &#123;&#125;'</span> -- &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;coreos&#x2F;kube-prometheus&#x2F;blob&#x2F;master&#x2F;examples&#x2F;etcd.jsonnet</span><br><span class="line">local kp &#x3D; (import &#39;kube-prometheus&#x2F;kube-prometheus.libsonnet&#39;) +</span><br><span class="line">           (import &#39;kube-prometheus&#x2F;kube-prometheus-static-etcd.libsonnet&#39;) + &#123;</span><br><span class="line">  _config+:: &#123;</span><br><span class="line">    namespace: &#39;monitoring&#39;,</span><br><span class="line">    etcd+:: &#123;</span><br><span class="line">      &#x2F;&#x2F; 配置 etcd 集群的 IP 地址,使用 逗号 隔开</span><br><span class="line">      ips: [&#39;10.168.67.6&#39;, &#39;10.168.67.7&#39;, &#39;10.168.67.8&#39;],</span><br><span class="line">      clientCA: importstr &#39;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt&#39;,</span><br><span class="line">      clientCert: importstr &#39;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt&#39;,</span><br><span class="line">      clientKey: importstr &#39;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key&#39;,</span><br><span class="line">      &#x2F;&#x2F; 指定 serverName 或 insecureSkipVerify 其中一个.</span><br><span class="line">      &#x2F;&#x2F; 若指定 serverName,你应该指定 openssl.cnf 中填写的 etcd 的包含证书的 DNS名称,否则会报 x509 错误.且 serverName 可以被 nslookup 解析</span><br><span class="line">      &#x2F;&#x2F; 若指定 insecureSkipVerify,会跳过认证</span><br><span class="line">      serverName: &#39;etcd.kube-system.svc.cluster.local&#39;,</span><br><span class="line">      &#x2F;&#x2F;insecureSkipVerify: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123; [&#39;00namespace-&#39; + name]: kp.kubePrometheus[name] for name in std.objectFields(kp.kubePrometheus) &#125; +</span><br><span class="line">&#123; [&#39;0prometheus-operator-&#39; + name]: kp.prometheusOperator[name] for name in std.objectFields(kp.prometheusOperator) &#125; +</span><br><span class="line">&#123; [&#39;node-exporter-&#39; + name]: kp.nodeExporter[name] for name in std.objectFields(kp.nodeExporter) &#125; +</span><br><span class="line">&#123; [&#39;kube-state-metrics-&#39; + name]: kp.kubeStateMetrics[name] for name in std.objectFields(kp.kubeStateMetrics) &#125; +</span><br><span class="line">&#123; [&#39;alertmanager-&#39; + name]: kp.alertmanager[name] for name in std.objectFields(kp.alertmanager) &#125; +</span><br><span class="line">&#123; [&#39;prometheus-&#39; + name]: kp.prometheus[name] for name in std.objectFields(kp.prometheus) &#125; +</span><br><span class="line">&#123; [&#39;grafana-&#39; + name]: kp.grafana[name] for name in std.objectFields(kp.grafana) &#125;</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>重新应用编译后产生的 <code>manifests</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f manifests/setup</span><br><span class="line">kubectl apply -f manifests/</span><br></pre></td></tr></table></figure>

<p>如果想要在已有 <code>kube-prometheus</code> 的基础上作出修改,只需要执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jb init</span><br><span class="line">jb update</span><br><span class="line">build.sh</span><br><span class="line">kubectl apply -f manifests/setup</span><br><span class="line">kubectl apply -f manifests/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>云原生应用</category>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>etcd</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构</title>
    <url>/2020/05/17/data-structure/</url>
    <content><![CDATA[<blockquote>
<p>数据结构</p>
</blockquote>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合.我们可以将数据结构分为逻辑结构和物理结构.</p>
<ul>
<li>逻辑结构是指数据对象中数据元素之间存在逻辑上的相互关系.如集合,线性结构,树形结构,图形结构等</li>
<li>物理结构是指数据的在计算机中的存储形式.如顺序存储,链式存储.其中,顺序存储时把数据元素存放在地址连续的存储单元中,链式存储是把数据元素存放在任意存储单元中,再通过逻辑上的指针将各个元素串联起来</li>
</ul>
<blockquote>
<p>算法</p>
</blockquote>
<p>算法是解决特定问题求解步骤的描述,具有如下 5 个特性:</p>
<ul>
<li>输入输出: 算法具有零个或多个输入,至少有一个或多个输出</li>
<li>有穷性: 算法在执行有限步骤后,自动结束而不会出现无线循环,且每个步骤在可接收的时间内完成</li>
<li>确定性: 算法的每个步骤都有确定的含义,不会出现分歧</li>
<li>可行性: 算法的每一步都是可行的</li>
</ul>
<blockquote>
<p>算法的时间复杂度</p>
</blockquote>
<p>算法的时间复杂度可使用大 O 阶进行表示,我们按照如下方式推导大 O 阶:</p>
<ol>
<li>用常数 1 表示运行时间中所有加法常数</li>
<li>在修改后的运行次数函数中,只保留最高阶项</li>
<li>如果最高阶项存在且不是 1,则去除与这个项相乘的常数,得到的结果就是大 O 阶</li>
</ol>
<p>常用时间复杂度所耗费的时间从小到大是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n^2) &lt; O(2^n)  &lt; O(n!) &lt; O(n^n)</span><br></pre></td></tr></table></figure>

<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是一个序列,元素之间是有顺序的.若元素存在多个,则第一个元素无前驱,最后一个元素无后继,其它每个元素有且仅有一个前驱和后继.常见的表示形式是数组和链表</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是指用一段连续的存储单元依次存储相同类型数据的数据结构.它主要有如下特性</p>
<ul>
<li>具有连续的内存,有上界和下界</li>
<li>数据是连续的,随机访问速度快(查找较快),时间复杂度为 O(1)</li>
<li>增删元素较慢,需要重新分配内存空间并将元素进行平移,时间复杂度为 O(n)</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>节点的链接方向是单向的</li>
<li>相对于数组来说,单链表的的随机访问速度较慢,只能从链表开头进行依次查找)</li>
<li>删除/添加数据的效率很高,只需要修改插入/删除位置的 next 指针即可</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>栈中数据是按照”后进先出(LIFO, Last In First Out)”方式进出栈的</li>
<li>向栈中添加/删除数据时,只能从栈顶进行操作</li>
</ul>
<p>栈通常包括的三种操作:push(向栈中添加元素), peek(返回栈顶元素), pop(返回并弹出栈顶元素)</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>队列中数据是按照”先进先出(FIFO, First-In-First-Out)”方式进出队列的</li>
<li>队列只允许在”队首”进行删除操作,而在”队尾”进行插入操作。</li>
</ul>
<p>队列通常包括的两种操作:入队列和出队列</p>
<h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是每个结点最多有两个子树的树结构,通常子树被称作”左子树(left subtree)”和”右子树(right subtree)”.二叉树常被用于实现二叉查找树和二叉堆</p>
<blockquote>
<p>满二叉树: 所有层都是满的.即深度为k,且有 2^k - 1 个节点的二叉树<br>完全二叉树: 除最后一层外,若其余层都是满的,并且最后一层或者是满的,或者是在右边缺少连续若干节点,则此二叉树为</p>
</blockquote>
<p>先序遍历 = 根-&gt;左子树-&gt;右子树</p>
<p>中序遍历 = 左子树-&gt;根-&gt;右子树</p>
<p>后序遍历 = 左子树-&gt;右子树-&gt;根</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><ul>
<li>左子树上所有结点的值均小于它的根结点的值,右子树上所有结点的值均大于它的根结点的值</li>
<li>任意节点的左,右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<blockquote>
<p>局限:如果我们的根节点选择是最小或者最大的数,那么二叉查找树就完全退化成了线性结构(链表)</p>
</blockquote>
<h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h2><p>带有平衡条件的二叉查找树,所有节点的左右子树高度差不超过1.</p>
<p>只要不满足这个条件,就要通过旋转来保持平衡,而旋转是非常耗时的.AVL树适合用于插入删除次数比较少,但查找多的情况.</p>
<p>维护这种高度平衡所付出的代价比从中获得的效率收益还大,实际的应用不多</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色,非黑即红</p>
<ul>
<li>每个节点非红即黑</li>
<li>根节点是黑的</li>
<li>每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的</li>
<li>如果一个节点是红的,那么它的两儿子都是黑的</li>
<li>对于任意节点而言,其到叶子点树NULL指针的每条路径都包含相同数目的黑节点</li>
<li>每条路径都包含相同的黑节点</li>
</ul>
<blockquote>
<p>应用</p>
</blockquote>
<ol>
<li>广泛用于C++的STL中,Map和Set都是用红黑树实现的</li>
<li>著名的Linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块,进程的虚拟内存区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址虚拟存储区域,右指针指向相邻的高地址虚拟地址空间</li>
<li>IO多路复用epoll的实现采用红黑树组织管理sockfd,以支持快速的增删改查</li>
<li>Nginx中用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器</li>
<li>Java中TreeMap的实现</li>
</ol>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种多路搜索树,它的每个节点可以拥有多于两个孩子节点,M路的B树最多能拥有M个孩子节点</p>
<ul>
<li>根节点至少有两个子节点</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>其它节点至少有M/2个子节点</li>
</ul>
<p>多路是为了降低树的高度,但是无线多路会退化成有序数组</p>
<p>B树多用于文件系统索引.<br>文件系统和数据库的索引都是存在硬盘上的,并且如果数据量大的话,不一定能一次性加载到内存中.<br>这时候,B树的多路存储为例就出来了,可以每次加载B数的一个节点,然后一步一步往下找</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><a href="https://blog.csdn.net/qq_26222859/article/details/80631121" target="_blank" rel="noopener">伯乐在线_什么是B+树</a></p>
<p>B+树是在B树的基础上进行改造的,它的数据都在叶子节点.<br>叶子节点之间还加了指针形成双向链表</p>
<p>这么设计的原因是与和使用场景相关的,数据库中 Select 数据,不一定只选一条,很多时候会选多条.<br>如果是多条的话,B 树需要做局部的中序遍历,可能要跨层访问.<br>而 B+ 树由于所有数据都在叶子结点,不用跨层,同时由于有链表结构,只需要找到首尾,通过链表就能把所有数据取出来了</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆是完全二元树或者是近似完全二元树,按照数据的排列方式可以分为两种:最大堆和最小堆</p>
<ul>
<li>最大堆:父结点的键值总是大于或等于任何一个子节点的键值</li>
<li>最小堆:父结点的键值总是小于或等于任何一个子节点的键值</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序会遍历若干次要排序的数列,每次遍历时,它都会从前往后依次的比较两个数的大小.如果前者比后者大,则交换它们的位置.一次遍历完成后,最大的元素就在数列的末尾.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 之技术总览</title>
    <url>/2020/05/22/ELK-Stack/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">ELK Stack</a> 是以 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch</a>, <a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">Logstash</a>, <a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">Kibana</a> 三个开源软件为主的数据处理工具链,是目前比较流行的开源实时日志数据分析解决方案.随着技术的演进,Logstash 由于其量级过重而被逐渐被人们替换为更轻量的 <a href="https://www.elastic.co/guide/en/beats/libbeat/current/beats-reference.html" target="_blank" rel="noopener">Beats</a> 或 <a href="https://www.fluentd.org/" target="_blank" rel="noopener">Fluentd</a>. ELK Stack 也逐渐演变为 EFK Stack.</p>
<p>在 ELK/EFK 栈中,</p>
<ul>
<li>Elasticsearch 是整个技术栈的核心,主要负责将数据转化为内部的数据以指定的方式保存起来,它提供了对其中数据增删查改的 API 使用户可以对数据进行操作</li>
<li>Logstash 负责数据的收集,过滤处理和格式化.它提供了多种 <code>input</code>, <code>filter</code> 和 <code>output</code> 插件分别对数据进行输入,分析过滤及输出.它多用于对数据进行过滤或格式化处理.</li>
<li>Beats 主要负责数据的收集,它提供了多种数据的输入类型,包括日志数据,指标数据,网络数据,审计数据,心跳数据等.它多用于将数据收集汇总后,输出到消息队列或 Logstash 中.</li>
<li>Fluentd 与 Logstash 类似,负责数据的收集,处理和过滤.它提供了多种插件对数据进行输入,过滤,路由或输出.它多用于对数据进行过滤或格式化处理.</li>
<li>Kibana 主要对 Elasticsearch 中数据的统计展示和可视化,它提供了 UI 界面,并将用户在界面上的操作转化为 Elasticsearch API 的请求,查询后再显示在 UI 界面中.</li>
</ul>
<h2 id="常见架构"><a href="#常见架构" class="headerlink" title="常见架构"></a>常见架构</h2><h3 id="最简单架构"><a href="#最简单架构" class="headerlink" title="最简单架构"></a>最简单架构</h3><p>Logstash 通过输入插件从多种数据源获取数据,经过过滤插件对数据进行筛选,格式化,然后通过输出插件输出到 Elasticsearch 中,通过 Kibana 展示.</p>
<p><img src="/2020/05/22/ELK-Stack/the-simplest-architecture.png" alt="最简单架构"></p>
<p>这种架构十分简单,使用场景也有限.初学者可以通过此架构了解 ELK 如何工作</p>
<h3 id="多个-LogStash-用于数据收集"><a href="#多个-LogStash-用于数据收集" class="headerlink" title="多个 LogStash 用于数据收集"></a>多个 LogStash 用于数据收集</h3><p><img src="/2020/05/22/ELK-Stack/multi-logstash.png" alt="多个 LogStash 用于数据收集"></p>
<p>这种架构需要在各个服务器上部署 Logstash,而 Logstash 比较重量级,服务器性能会有所下降,甚至可能导致应用无法正常工作</p>
<h3 id="Beats-作为日志收集器"><a href="#Beats-作为日志收集器" class="headerlink" title="Beats 作为日志收集器"></a>Beats 作为日志收集器</h3><p>Beats 将搜集到的数据发送到 Logstash,经 Logstash 解析,过滤后，将其发送到 Elasticsearch 存储,并由 Kibana 呈现给用户.</p>
<p><img src="/2020/05/22/ELK-Stack/beat-for-data-collection.png" alt="Beats 作为日志收集器"></p>
<p>这种方式解决了 Logstash 在各个服务器上占用系统资源过高的情况,相比于 Logstash,Beats 更加轻量,系统资源占用也比较低.且支持 SSL 加密传输,保证通信安全</p>
<h3 id="引入消息队列机制"><a href="#引入消息队列机制" class="headerlink" title="引入消息队列机制"></a>引入消息队列机制</h3><p>无论是 Beat 还是 Logstash 均支持消息队列的输入输出,目前支持 Kafka,Redis,RabbitMQ 等常见消息队列.可以由 Beats 收集数据后,通过消息队列输出插件将数据写入到消息队列中,然后 Logstash 通过消息队列输入插件从消息队列中读取数据进行处理后传入到 Elasticsearch 存储,并由 Kibana 呈现给用户.</p>
<p><img src="/2020/05/22/ELK-Stack/introduce-message-queue.png" alt="引入消息队列机制"></p>
<p>当数据量较大时,可在合适的位置添加消息队列,减少 Logstash 的负荷.引入消息队列,可以降低由于数据量过大而导致某些组件的性能瓶颈,降低了数据丢失的可能性.同时,Elasticsearch 可以做成集群模式或增加节点数量,以便增加其性能.</p>
<h2 id="部署-Elasticsearch"><a href="#部署-Elasticsearch" class="headerlink" title="部署 Elasticsearch"></a>部署 Elasticsearch</h2><h3 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.7.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xzf elasticsearch-7.7.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> elasticsearch-7.7.0/</span><br></pre></td></tr></table></figure>

<h3 id="必须的系统配置"><a href="#必须的系统配置" class="headerlink" title="必须的系统配置"></a>必须的系统配置</h3><ul>
<li>禁用 <code>swap</code>.可在 <code>/etc/fstab</code> 种永久关闭</li>
<li>设置文件描述符至少为 65535.可在 <code>/etc/security/limits.conf</code> 设置<code>nofile</code> 的值</li>
<li>设置线程数量至少为 4096.可在 <code>/etc/security/limits.conf</code> 设置 <code>nproc</code> 的值</li>
<li>设置虚拟内存至少为 262144.可在 <code>/etc/sysctl.conf</code> 中永久设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line"><span class="built_in">ulimit</span> -n 65535</span><br><span class="line"><span class="built_in">ulimit</span> -u 4096</span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>

<h3 id="重要的-Elasticsearch-配置"><a href="#重要的-Elasticsearch-配置" class="headerlink" title="重要的 Elasticsearch 配置"></a>重要的 Elasticsearch 配置</h3><p>Elasticsearch 的配置文件在 <code>config</code> 目录下,其中</p>
<ul>
<li><code>elasticsearch.yml</code> 包含 Elasticsearch 配置信息</li>
<li><code>jvm.options</code> 包含 Elasticsearch JVM 配置信息</li>
<li><code>log4j2.properties</code> 包含 Elasticsearch 日志信息</li>
</ul>
<p>下面列出了 <code>elasticsearch.yml</code> 中一些重要的 Elasticsearch 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">elasticsearch</span> <span class="comment"># 集群名称,默认为 elasticsearch</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">$&#123;HOSTNAME&#125;</span> <span class="comment"># elasticsearch 节点名称,默认为节点主机名</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">["/es-data1",</span> <span class="string">"es-data2"</span><span class="string">]</span> <span class="comment"># 数据目录,默认为解压目录中的 data 目录,可以指定多个,相同分片会保存到统一目录下</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/log/elasticsearch</span> <span class="comment"># 日志目录,,默认为解压目录中的 logs 目录</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">"0.0.0.0"</span>  <span class="comment"># elasticsearch 监听地址,默认为 127.0.0.1</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span> <span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">discovery.send_hosts:</span> <span class="string">["vm1:9300",</span> <span class="string">"vm2:9300"</span><span class="string">,</span> <span class="string">"vm3:9300"</span><span class="string">]</span> <span class="comment"># 广播发现集群的地址列表,默认在 9300 端口进行广播通信</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> <span class="string">["vm1:9200",</span> <span class="string">"vm2:9200"</span><span class="string">,</span> <span class="string">"vm3:9200"</span><span class="string">]</span> <span class="comment"># 集群主节点列表,首次启动时生效</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span> <span class="comment"># 是否启用 xpack-security 安全认证插件</span></span><br></pre></td></tr></table></figure>

<p>下面列出了 <code>jvm.options</code> 中一些重要的 Elasticsearch JVM 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure>

<p>默认情况下,Elasticsearch JVM 设置为使用 1G 的堆内存.但是在生产环境中,需要遵循如下配置:</p>
<ul>
<li>设置两个配置参数相等</li>
<li>将 <code>Xmx</code> 和 <code>Xms</code> 设置为不超过物理内存的 <code>50%</code></li>
<li>一般来说,配置参数越大,性能越好,但不超过 32G</li>
</ul>
<h3 id="启动-Elasticsearch"><a href="#启动-Elasticsearch" class="headerlink" title="启动 Elasticsearch"></a>启动 Elasticsearch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">bin/elasticsearch -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定启动过程中的参数</span></span><br><span class="line">-E &lt;KeyValuePair&gt;</span><br><span class="line"><span class="comment"># -Epath.data=data -Epath.logs=log</span></span><br></pre></td></tr></table></figure>

<p>可通过 <code>curl http://localhost:9200</code> 查看 Elasticsearch 的启动信息</p>
<h2 id="部署-Kibana"><a href="#部署-Kibana" class="headerlink" title="部署 Kibana"></a>部署 Kibana</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://artifacts.elastic.co/downloads/kibana/kibana-7.7.0-linux-x86_64.tar.gz</span><br><span class="line">tar -xzf kibana-7.7.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kibana-7.7.0-linux-x86_64/</span><br><span class="line">bin/kibana</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"192.168.2.3"</span></span><br><span class="line"><span class="comment"># server.name: "your-hostname"</span></span><br><span class="line"><span class="attr">elasticsearch.url:</span> <span class="string">"http://localhost:9200"</span></span><br><span class="line"><span class="attr">kibana.index:</span> <span class="string">".kibana"</span></span><br><span class="line"><span class="comment"># xpack.security.enabled: false</span></span><br><span class="line"><span class="comment"># elasticsearch.username: "user"</span></span><br><span class="line"><span class="comment"># elasticsearch.password: "pass"</span></span><br><span class="line"><span class="comment"># server.ssl.enabled: false</span></span><br><span class="line"><span class="comment"># server.ssl.certificate: /path/to/your/server.crt</span></span><br><span class="line"><span class="comment"># server.ssl.key: /path/to/your/server.key</span></span><br><span class="line"><span class="comment"># elasticsearch.ssl.certificate: /path/to/your/client.crt</span></span><br><span class="line"><span class="comment"># elasticsearch.ssl.key: /path/to/your/client.key</span></span><br><span class="line"><span class="comment"># elasticsearch.ssl.certificateAuthorities: [ "/path/to/your/CA.pem" ]</span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html" target="_blank" rel="noopener">ELK 架构和 Filebeat 工作原理详解</a></li>
</ul>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 之 Logstash 插件介绍</title>
    <url>/2020/05/22/ELK-Stack-Logstash-plugins/</url>
    <content><![CDATA[<p>Logstash 是高度插件化的日志数据收集工具,常用插件包括 <code>input</code>, <code>filter</code>, <code>output</code></p>
<p>Logstash 的工作流程 <code>input &gt; filter &gt; output</code>.如无需要对数据进行额外处理,则 <code>filter</code> 可省略</p>
<h2 id="input-插件"><a href="#input-插件" class="headerlink" title="input 插件"></a><code>input</code> 插件</h2><p><a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="noopener"><code>input</code></a> 插件用于设置 Logstash 获取数据的数据源.</p>
<p>它包含一些通用的字段,用于配置进入 Logstash 数据的属性,用于后续的处理过程.常用字段如下:</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add_field</td>
<td align="center">为数据内容添加字段键值对映射</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">设置 input 插件的唯一标识</td>
</tr>
<tr>
<td align="center">tags</td>
<td align="center">设置数据属性标签数组</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">设置数据类型</td>
</tr>
</tbody></table>
<h3 id="beats"><a href="#beats" class="headerlink" title="beats"></a><code>beats</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-beats.html" target="_blank" rel="noopener"><code>beats</code></a> 输入插件用于从 Beats 中接收数据</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">port</td>
<td align="center">Logstash 监听的端口</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">host</td>
<td align="center">Logstash 监听的地址</td>
<td align="center">否</td>
<td align="center">“0.0.0.0”</td>
</tr>
<tr>
<td align="center">ssl</td>
<td align="center">是否启用 ssl 加密相关</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">ssl_certificate</td>
<td align="center">ssl 证书</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">ssl_key</td>
<td align="center">ssl 密钥文件</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    host =&gt; <span class="string">"0.0.0.0"</span></span><br><span class="line">    port =&gt; <span class="number">5044</span></span><br><span class="line">    ssl =&gt; <span class="literal">true</span></span><br><span class="line">    ssl_certificate =&gt; <span class="string">"/path/to/ssl/cert"</span></span><br><span class="line">    ssl_key =&gt; <span class="string">"/path/to/ssl/key"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="file"><a href="#file" class="headerlink" title="file"></a><code>file</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html" target="_blank" rel="noopener"><code>file</code></a> 输入插件用于读取文件数据.它使用一个名为 sincedb 的单独文件中来跟踪每个文件中的当前位置,这样就可以停止或重新启动 Logstash,并使它从中断处开始读取,而不会丢失 Logstash 停止时读取数据的位置.</p>
<ul>
<li>支持多文件读取</li>
<li>支持 <code>tail</code> 模式(没有 EOF)或直接读取 <code>read</code> 模式(有EOF)</li>
</ul>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">path</td>
<td align="center">指定要读取的文件列表或模式匹配</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">close_older</td>
<td align="center">指定多少秒无新数据则关闭文件,检测到新数后重新打开</td>
<td align="center">否</td>
<td align="center">“1 hour”</td>
</tr>
<tr>
<td align="center">delimiter</td>
<td align="center">换行符</td>
<td align="center">否</td>
<td align="center">“\n”</td>
</tr>
<tr>
<td align="center">exclude</td>
<td align="center">当 path 为模式匹配时,排除读取指定文件</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">file_chunk_count</td>
<td align="center">读取文件块数量</td>
<td align="center">否</td>
<td align="center">4611686018427387903</td>
</tr>
<tr>
<td align="center">file_chunk_size</td>
<td align="center">读取文件块大小</td>
<td align="center">否</td>
<td align="center">32KB</td>
</tr>
<tr>
<td align="center">file_completed_action</td>
<td align="center">读取文件 EOF 后的操作,delete, log, log_and_delete</td>
<td align="center">否</td>
<td align="center">“delete”</td>
</tr>
<tr>
<td align="center">file_completed_log_path</td>
<td align="center">读取文件 EOF 后记录的文件位置</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">file_sort_direction</td>
<td align="center">排序方式,asc,desc</td>
<td align="center">否</td>
<td align="center">“asc”</td>
</tr>
<tr>
<td align="center">ignore_older</td>
<td align="center">忽略指定修改时间前的文件</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">mode</td>
<td align="center">指定文件的读取模式, tail, read</td>
<td align="center">否</td>
<td align="center">“tail”</td>
</tr>
<tr>
<td align="center">sincedb_path</td>
<td align="center">指定保存 sincedb 文件的目录,默认会在 <code>&lt;path.data&gt;/plugins/inputs/file/</code></td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">start_position</td>
<td align="center">指定从何处开始读取,start, end</td>
<td align="center">否</td>
<td align="center">“end”</td>
</tr>
<tr>
<td align="center">stat_interval</td>
<td align="center">指定读取时间间隔</td>
<td align="center">否</td>
<td align="center">“1 second”</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<ul>
<li>以 <code>read</code> 模式读取昨天新产生的文件,而不读取 “*.gz” 文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [<span class="string">"/path/to/nginx-80-*.log"</span>,<span class="string">"/path/to/nginx-443-*.log"</span>]</span><br><span class="line">    exclude =&gt; <span class="string">"*.gz"</span></span><br><span class="line">    mode =&gt; <span class="string">"read"</span></span><br><span class="line">    file_sort_direction =&gt; <span class="string">"desc"</span></span><br><span class="line">    ignore_older =&gt; <span class="string">"1d"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以 <code>tail</code> 模式实时读取文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [<span class="string">"/path/to/nginx-80.log"</span>,<span class="string">"/path/to/nginx-443.log"</span>]</span><br><span class="line">    mode =&gt; <span class="string">"tail"</span></span><br><span class="line">    stat_interval =&gt; <span class="string">"5 second"</span></span><br><span class="line">    close_older =&gt; <span class="string">"5"</span></span><br><span class="line">    start_position =&gt; <span class="string">"end"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a><code>redis</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-redis.html" target="_blank" rel="noopener"><code>redis</code></a> 输入插件用于从 Redis 实例中读取事件数据,支持 Redis channels 和 lists.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">Redis 数据库主机地址</td>
<td align="center">否</td>
<td align="center">“127.0.0.1”</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">Redis 数据库监听端口</td>
<td align="center">否</td>
<td align="center">6379</td>
</tr>
<tr>
<td align="center">passwd</td>
<td align="center">Redis 数据库连接密码</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">db</td>
<td align="center">Redis 的数据库</td>
<td align="center">否</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">data_type</td>
<td align="center">指定从 Redis 指定对象中读取数据, list, channel, pattern_channel</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">Redis list 或 channel 的名称</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">batch_count</td>
<td align="center">从 Redis 返回的事件数</td>
<td align="center">否</td>
<td align="center">125</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    host =&gt; <span class="string">"192.168.1.2"</span></span><br><span class="line">    port =&gt; <span class="number">6379</span></span><br><span class="line">    passwd =&gt; <span class="string">"passwd"</span></span><br><span class="line">    db =&gt; <span class="number">0</span></span><br><span class="line">    data_type =&gt; <span class="string">"list"</span></span><br><span class="line">    key =&gt; <span class="string">"logstash"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a><code>stdin</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html" target="_blank" rel="noopener"><code>stdin</code></a> 输入插件从标准输入读取数据,多用于测试</p>
<h2 id="filter-插件"><a href="#filter-插件" class="headerlink" title="filter 插件"></a><code>filter</code> 插件</h2><p><a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="noopener"><code>filter</code></a> 插件用于过滤或处理进入 Logstash 的数据.</p>
<p>它包含一些通用的字段,用于配置从 Logstash 输出数据的属性,用于后续的处理过程.常用字段如下</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add_field</td>
<td align="center">为数据内容添加字段键值对映射</td>
</tr>
<tr>
<td align="center">add_tag</td>
<td align="center">为数据属性添加标签属性</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">设置 filter 插件的唯一标识</td>
</tr>
<tr>
<td align="center">remove_field</td>
<td align="center">删除数据内容中指定字段</td>
</tr>
<tr>
<td align="center">remove_tag</td>
<td align="center">删除数据属性中指定标签</td>
</tr>
</tbody></table>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a><code>date</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html" target="_blank" rel="noopener"><code>date</code></a> 过滤插件用于解析字段中的日期,然后使用该日期或时间戳作为时间戳</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">match</td>
<td align="center">指定字段及日期格式</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">当解析失败时添加列表中标签</td>
<td align="center">否</td>
<td align="center">[“_dateparsefailure”]</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">解析成功后保存的字段名</td>
<td align="center">否</td>
<td align="center">“@timestamp”</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  date &#123;</span><br><span class="line">    <span class="comment"># log_time 变量包含 dd/MMM/yyyy:HH:mm:ss Z 格式的日期</span></span><br><span class="line">    match =&gt; [<span class="string">"log_time"</span>,<span class="string">"dd/MMM/yyyy:HH:mm:ss Z"</span>]</span><br><span class="line">    target =&gt; <span class="string">"@log_time"</span></span><br><span class="line">    tag_on_failure =&gt; [<span class="string">"_dateparsefailure"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a><code>drop</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-drop.html" target="_blank" rel="noopener"><code>drop</code></a> 过滤插件用于删除事件数据</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  <span class="keyword">if</span> [loglevel] == <span class="string">"debug"</span> &#123;</span><br><span class="line">    drop &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="geoip"><a href="#geoip" class="headerlink" title="geoip"></a><code>geoip</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-geoip.html" target="_blank" rel="noopener"><code>geoip</code></a> 过滤插件用于根据来自 Maxmind GeoLite2 数据库的数据添加有关 IP 地址地理位置的信息</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">database</td>
<td align="center">指定 Maxmind GeoLite2 数据库地址</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">source</td>
<td align="center">指定要解析的 IP 地址或主机名</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">指定解析后数据存储到的字段名称</td>
<td align="center">否</td>
<td align="center">“geoip”</td>
</tr>
<tr>
<td align="center">fields</td>
<td align="center">指定解析后数据要保留的字段列表</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">当解析失败时添加列表中标签</td>
<td align="center">否</td>
<td align="center">[“_geoip_lookup_failure”]</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  geoip &#123;</span><br><span class="line">    <span class="comment"># remote_addr 变量表示 IP 地址,用于对</span></span><br><span class="line">    source =&gt; <span class="string">"remote_addr"</span></span><br><span class="line">    target =&gt; <span class="string">"geoip"</span></span><br><span class="line">    database =&gt; <span class="string">"/home/elk/logstash-6.4.2/config/GeoLite2-City.mmdb"</span></span><br><span class="line">    fields =&gt; [<span class="string">"city_name"</span>,<span class="string">"country_name"</span>,<span class="string">"region_name"</span>,<span class="string">"location"</span>]</span><br><span class="line">    tag_on_failure =&gt; [<span class="string">"_geoip_lookup_failure"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grok"><a href="#grok" class="headerlink" title="grok"></a><code>grok</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html" target="_blank" rel="noopener"><code>grok</code></a> 过滤插件基于正则表达式解析任意文本并将其结构化,是将非结构化日志数据解析为结构化和可查询内容的好方法.</p>
<p><code>grok</code> 默认包含 120 种的模式,您可以在 <a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns" target="_blank" rel="noopener">Github</a> 或 <code>${LOGSTASH_HOME}/vendor/bundle/jruby/2.3.0/gems/logstash-patterns-core-4.1.2/patterns/</code> 找到对应的正则表达式</p>
<p><code>grok</code> 的基本语法为 <code>%{SYNTAX:SEMANTIC}</code>.<code>SYNTAX</code> 是指定用于匹配文本的模式名称,正则表达式的内容可以在如上位置找到.<code>SEMANTIC</code> 为匹配到的文本提供标识符,将匹配到的文本写入到变量中,后续可以直接使用此标识符引用文本.</p>
<p>另外,我们可以按照 <code>PATTERN_NAME PATTERN</code> 的方式自定义匹配模式,并在 <code>pattern_definitions</code> 选项字段中进行引用.或将匹配模式定义写入到文件中,通过 <code>pattern_dir</code> 和 <code>patterns_files_glob</code> 字段对该文件进行引用.</p>
<p>可以在 <a href="http://grokdebug.herokuapp.com/" target="_blank" rel="noopener">http://grokdebug.herokuapp.com/</a> 查看文本与模式是否匹配.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">match</td>
<td align="center">定义了待匹配的文本和匹配模式的映射,匹配模式可以以列表形式定义多个</td>
<td align="center">否</td>
<td align="center">{}</td>
</tr>
<tr>
<td align="center">overwrite</td>
<td align="center">指定模式匹配后的字段覆盖列表中的字段</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">pattern_definitions</td>
<td align="center">自定义模式的名称和内容的映射</td>
<td align="center">否</td>
<td align="center">{}</td>
</tr>
<tr>
<td align="center">patterns_dir</td>
<td align="center">自定义模式文件的目录</td>
<td align="center">否</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">patterns_files_glob</td>
<td align="center">使用 glob 匹配 patterns_dir 目录下文件用于自定义模式匹配</td>
<td align="center">否</td>
<td align="center">“*”</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">匹配失败后添加的标签</td>
<td align="center">否</td>
<td align="center">[“_grokparsefailure”]</td>
</tr>
<tr>
<td align="center">tag_on_timeout</td>
<td align="center">匹配超时时添加的标签</td>
<td align="center">否</td>
<td align="center">“_groktimeout”</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">定义匹配到的文本保存的字段名称,类似于 <code>geoip.target</code></td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">break_on_match</td>
<td align="center">是否在首次匹配成功后则跳出匹配,如果想让尝试所有的模式匹配,则设置为 false</td>
<td align="center">否</td>
<td align="center">true</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    <span class="comment"># "message" 为 nginx 数据</span></span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"\[%&#123;HTTPDATE:log_time&#125;\] - %&#123;NUMBER:timestamp&#125; - (%&#123;IP_X:remote_addr&#125;|-) - %&#123;USER:remote_user&#125; \"%&#123;WORD:request_method&#125; %&#123;URIHOST:server_host&#125;(%&#123;URIPATH:request_uri&#125;|-)(%&#123;NOTSPACE:request_param&#125;)? HTTP\/%&#123;NUMBER:http_version&#125;\" %&#123;NUMBER:response_code&#125; %&#123;NUMBER:response_body_bytes&#125; - %&#123;DATA:ssl_protocol&#125; %&#123;NUMBER:request_time&#125; - (%&#123;HOSTPORT:upstream_addr&#125;|-) (%&#123;NUMBER:upstream_response_time&#125;|-) %&#123;GREEDYDATA:other&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    remove_field =&gt; [ <span class="string">"@version"</span>, <span class="string">"host"</span>, <span class="string">"path"</span>, <span class="string">"type"</span>, <span class="string">"message"</span>, <span class="string">"remote_user"</span>, <span class="string">"request_method"</span>, <span class="string">"http_version"</span>, <span class="string">"request_param"</span>, <span class="string">"ssl_protocol"</span>, <span class="string">"request_time"</span>, <span class="string">"upstream_addr"</span>, <span class="string">"upstream_response_time"</span>, <span class="string">"other"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[19&#x2F;May&#x2F;2020:16:40:04 +0800] - 1589877604.781 - 42.236.82.156 - - &quot;GET reg.cntv.cn&#x2F; HTTP&#x2F;1.1&quot; 302 0 - - 0.003 - 192.168.2.3:8082 0.003 - 100148273 - 1 - Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;46.0.2490.86 Safari&#x2F;537.36 &quot;-&quot;</span><br></pre></td></tr></table></figure>

<h3 id="json"><a href="#json" class="headerlink" title="json"></a><code>json</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-json.html" target="_blank" rel="noopener"><code>json</code></a> 过滤插件将 JSON 格式的数据解析为 Logstash 内部格式的数据</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">source</td>
<td align="center">指定要解析的字段</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">解析后数据存储到的字段名称</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">解码失败后添加的标签</td>
<td align="center">否</td>
<td align="center">[“_jsonparsefailure”]</td>
</tr>
<tr>
<td align="center">skip_on_invalid_json</td>
<td align="center">是否跳过无效的 JSON</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    <span class="comment"># "message 变量为 json 格式数据</span></span><br><span class="line">    source =&gt; <span class="string">"message"</span></span><br><span class="line">    skip_on_invalid_json =&gt; <span class="string">"true"</span></span><br><span class="line">    target =&gt; <span class="string">"doc"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;method&quot;:[&quot;user.getName&quot;],&quot;client&quot;:[&quot;client&quot;],&quot;snap&quot;:[&quot;120x120&quot;],&quot;userid&quot;:[&quot;12345678&quot;]&#125;</span><br><span class="line">解析为</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot; &#x3D;&gt; &#123;</span><br><span class="line">    &quot;snap&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;120x120&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;client&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;client&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;userid&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;12345678&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;method&quot; &#x3D;&gt; [</span><br><span class="line">      [0] &quot;user.getName&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="urldecode"><a href="#urldecode" class="headerlink" title="urldecode"></a><code>urldecode</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-urldecode.html" target="_blank" rel="noopener"><code>urldecode</code></a> 过滤插件用于对 urlencoded 的字段解码</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">field</td>
<td align="center">指定要解码的字段</td>
<td align="center">否</td>
<td align="center">“message”</td>
</tr>
<tr>
<td align="center">charset</td>
<td align="center">指定字符编码</td>
<td align="center">否</td>
<td align="center">“UTF-8”</td>
</tr>
<tr>
<td align="center">tag_on_failure</td>
<td align="center">解码失败后添加的标签</td>
<td align="center">否</td>
<td align="center">[“_urldecodefailure”]</td>
</tr>
<tr>
<td align="center">all_field</td>
<td align="center">是否对所有字段进行解码</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  urldecode &#123;</span><br><span class="line">    <span class="comment"># request_url 包含已经编码或未编码的信息</span></span><br><span class="line">    field =&gt; <span class="string">"request_url"</span></span><br><span class="line">    charset =&gt; <span class="string">"UTF-8"</span></span><br><span class="line">    tag_on_failure =&gt; [<span class="string">"_urldecodefailure"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;client&#x3D;6&amp;data&#x3D;%7B%22uid%22%3A73023332%2C%22vid%22%3A%2264d68733bd5343d2bc69334e804ce036%22%2C%22position%22%3A%220%22%7D&amp;method&#x3D;videoformobile.setVideoPosition&quot;</span><br><span class="line"></span><br><span class="line">解析为</span><br><span class="line"></span><br><span class="line">&quot;client&#x3D;6&amp;data&#x3D;&#123;\&quot;uid\&quot;:73023332,\&quot;vid\&quot;:\&quot;64d68733bd5343d2bc69334e804ce036\&quot;,\&quot;position\&quot;:\&quot;0\&quot;&#125;&amp;method&#x3D;videoformobile.setVideoPosition\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="output-插件"><a href="#output-插件" class="headerlink" title="output 插件"></a><code>output</code> 插件</h2><p><a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="noopener"><code>output</code></a>插件将事件数据发送到指定的目的地,是事件管道中的最后阶段.</p>
<p>它包含一些通用的字段,用于配置 Logstash 输出数据的属性.常用字段如下:</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">codec</td>
<td align="center">指定输出数据的解码器.默认值为 “rubydebug”,可选做 “json”</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">设置 output 插件的唯一标识</td>
</tr>
</tbody></table>
<h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a><code>elasticsearch</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html" target="_blank" rel="noopener"><code>elasticsearch</code></a> 输出插件将 Logstash 数据导入到 Elasticsearch.</p>
<p>此插件尝试通过单个请求发送批量事件数据.如果一个请求超过 <code>20MB</code>,我们会将其分解为多个批处理请求.如果单个文档超过<code>20MB</code>,它将作为单个请求发送.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hosts</td>
<td align="center">指定 Elasticsearch 服务的地址,支持指定多个协议和端口</td>
<td align="center">否</td>
<td align="center">[“127.0.0.1:9200”]</td>
</tr>
<tr>
<td align="center">user, password</td>
<td align="center">指定 Elasticsearch 服务的用户名密码</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">指定索引</td>
<td align="center">否</td>
<td align="center">“logstash-%{+yyyy.MM.dd}”</td>
</tr>
<tr>
<td align="center">action</td>
<td align="center">Elasticsearch 内部执行的操作,index,delete,create,update</td>
<td align="center">否</td>
<td align="center">“index”</td>
</tr>
<tr>
<td align="center">document_id</td>
<td align="center">指定文档索引,会自动生成</td>
<td align="center">否 “”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ssl</td>
<td align="center">是否使用 ssl</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">cacert</td>
<td align="center">证书文件路径</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
</tbody></table>
<h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a><code>mongodb</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-mongodb.html" target="_blank" rel="noopener"><code>mongodb</code></a> 输出插件将事件数据写入到 MongoDB.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bulk</td>
<td align="center">是否启用批量插入</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">bulk_interval</td>
<td align="center">批量插入的时间间隔</td>
<td align="center">否</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">bulk_size</td>
<td align="center">批量插入的事件数据数</td>
<td align="center">否</td>
<td align="center">900</td>
</tr>
<tr>
<td align="center">collection</td>
<td align="center">数据写入 MongoDB 的集合名称,支持动态选择</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">database</td>
<td align="center">数据写入 MongoDB 的数据库名称</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">uri</td>
<td align="center">指定连接 MongoDB 的地址</td>
<td align="center">是</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">generateId</td>
<td align="center">是否生成 “_id” 字段插入到 MongoDB 文档中.如果设置为 true,则使用事件数据的时间戳,且覆盖现有 “_id” 字段</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">retry_delay</td>
<td align="center">失败后重试的等待时间</td>
<td align="center">否</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">isodate</td>
<td align="center">是否将 @timestamp 作为 ISODate 类型保存在 MongoDB 中</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
</tbody></table>
<h3 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a><code>redis</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-redis.html" target="_blank" rel="noopener"><code>redis</code></a> 输出插件将事件数据写入到 Redis.</p>
<blockquote>
<p>常用配置字段</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
<th align="center">是否必需</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">Redis 数据库主机地址</td>
<td align="center">否</td>
<td align="center">[“127.0.0.1”]</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">Redis 数据库监听端口</td>
<td align="center">否</td>
<td align="center">6379</td>
</tr>
<tr>
<td align="center">passwd</td>
<td align="center">Redis 数据库连接密码</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">db</td>
<td align="center">Redis 的数据库</td>
<td align="center">否</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">data_type</td>
<td align="center">指定向 Redis 写入数据的对象, list, channel</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">Redis list 或 channel 的名称,可以使用动态名称</td>
<td align="center">否</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">batch</td>
<td align="center">是否使用 RPUSH 向 Redis list 中批量写入数据</td>
<td align="center">否</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">batch_events</td>
<td align="center">RPUSH 默认向 Redis list 中写入的数据量</td>
<td align="center">否</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">batch_timeout</td>
<td align="center">RPUSH 的超时时间</td>
<td align="center">否</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">reconnect_interval</td>
<td align="center">重试连接的时间间隔</td>
<td align="center">否</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">连接的超时时间</td>
<td align="center">否</td>
<td align="center">5</td>
</tr>
</tbody></table>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a><code>stdout</code></h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-stdout.html" target="_blank" rel="noopener"><code>stdout</code></a> 输出插件将事件数据打印到标准输出,多用于测试.</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab CI/CD 管道配置详解</title>
    <url>/2020/05/22/gitlab-ci-pipeline-configuration/</url>
    <content><![CDATA[<p>在每个 GitLab 项目中,使用名为 <code>.gitlab-ci.yml</code> 的 YAML 文件配置 GitLab CI/CD  pipelines (管道).</p>
<p><code>.gitlab-ci.yml</code> 文件定义 pipeline 的结构和执行顺序,并确定了如下内容</p>
<ul>
<li>GitLab Runner(负责运行管道的实例)执行什么任务</li>
<li>GitLab Runner 的高级配置,可用于配置 GitLab Runner</li>
</ul>
<p>有关 <code>.gitlab-ci.yml</code> 文件示例参考可从如下位置找到</p>
<ul>
<li><a href="https://docs.gitlab.com/ee/ci/examples/README.html" target="_blank" rel="noopener">GitLab CI/CD Examples</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab/blob/master/.gitlab-ci.yml" target="_blank" rel="noopener">gitlab 的 .gitlab-ci.yml 文件</a></li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>pipeline 配置从 job(作业)开始.作业是组成 <code>.gitlab-ci.yml</code> 的最基本元素.它主要有下功能或特性</p>
<ul>
<li>定义约束,指出应在什么条件下执行它们</li>
<li>任意名称的顶级元素,至少包含 <code>script</code> 子句</li>
<li>可以定义多个</li>
</ul>
<p>简单示例如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">"execute-script-for-job1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">"execute-script-for-job2"</span></span><br></pre></td></tr></table></figure>

<p>以上两个示例是具有两个单独作业的 CI/CD 配置,每个作业执行一个命令.当然,此命令可以在存储库中直接执行代码或运行脚本.</p>
<p>作业由 Runner 提取并在 Runner 系统环境中运行.每个作业彼此独立运行.</p>
<h3 id="验证-gitlab-ci-yml"><a href="#验证-gitlab-ci-yml" class="headerlink" title="验证 .gitlab-ci.yml"></a>验证 <code>.gitlab-ci.yml</code></h3><p>每个 GitLab CI/CD 实例都有一个成为 Lint 的嵌入式调试工具,该工具可验证 <code>.gitlab-ci.yml</code> 文件的内容,您可以在项目名称空间的 <code>$PATH_TO_PROJECT/-/ci/lint</code>($PATH_TO_PROJECT=$GitLab_URL/user_or_group_name/project_name)路径下找到.如 <code>https://gitlab.example.com/gitlab-org/project-123/-/ci/lint</code>.</p>
<h3 id="作业命名规范"><a href="#作业命名规范" class="headerlink" title="作业命名规范"></a>作业命名规范</h3><p>每个作业都有唯一的名称,且以下保留关键字不能作为作业的名称:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image</span><br><span class="line">services</span><br><span class="line">stages</span><br><span class="line">types</span><br><span class="line">before_script</span><br><span class="line">after_script</span><br><span class="line">variables</span><br><span class="line">cache</span><br><span class="line">include</span><br></pre></td></tr></table></figure>

<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>作业通过一系列参数定义作业的行为.以下列出了作业的可用参数:</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>script</code></td>
<td align="center">由 Runner 执行的脚本</td>
</tr>
<tr>
<td align="center"><code>image</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>services</code></td>
<td align="center">使用 docker 服务镜像.也可用 <code>services:name</code>, <code>services:alias</code>, <code>services:entrypoint</code>, <code>services:command</code></td>
</tr>
<tr>
<td align="center"><code>before_script</code></td>
<td align="center">包含执行作业之前的一组命令</td>
</tr>
<tr>
<td align="center"><code>after_script</code></td>
<td align="center">包含执行作业之后的一组命令</td>
</tr>
<tr>
<td align="center"><code>stage</code></td>
<td align="center">定义作业的阶段(默认值为 <code>test</code>)</td>
</tr>
<tr>
<td align="center"><code>only</code></td>
<td align="center">限定作业何时创建.也可用 <code>only:refs</code>, <code>only:kubernetes</code>, <code>only:variables</code>, <code>only:changes</code></td>
</tr>
<tr>
<td align="center"><code>except</code></td>
<td align="center">限定作业不创建.也可用  <code>except:refs</code>, <code>except:kubernetes</code>, <code>except:variables</code>, <code>except:changes</code></td>
</tr>
<tr>
<td align="center"><code>rules</code></td>
<td align="center">根据作业的属性评估确定是否创建工作的条件列表.不得与 <code>only/except</code> 一起使用</td>
</tr>
<tr>
<td align="center"><code>tags</code></td>
<td align="center">用于选择 Runner(运行器) 的标签列表</td>
</tr>
<tr>
<td align="center"><code>allow_failure</code></td>
<td align="center">是否允许作业失败</td>
</tr>
<tr>
<td align="center"><code>when</code></td>
<td align="center">限定什么时候开始作业.也可用<code>when:manual</code>, <code>when:delayed</code></td>
</tr>
<tr>
<td align="center"><code>environment</code></td>
<td align="center">作业部署到的环境名称.也可用 <code>environment:name</code>, <code>environment:url</code>, <code>environment:on_stop</code>, <code>environment:auto_stop_in</code>, <code>environment:action</code></td>
</tr>
<tr>
<td align="center"><code>cache</code></td>
<td align="center">缓存文件列表,以备在后续的作业中使用.也可用 <code>cache:paths</code>, <code>cache:key</code>, <code>cache:untracked</code>, <code>cache:policy</code></td>
</tr>
<tr>
<td align="center"><code>artifacts</code></td>
<td align="center">成功时附加到作业的文件和目录列表</td>
</tr>
<tr>
<td align="center"><code>dependencies</code></td>
<td align="center">指定本次作业的依赖作业列表,该列表中作业由 <code>artifacts</code> 附加的文件或目录会作为本次作业的依赖</td>
</tr>
<tr>
<td align="center"><code>coverage</code></td>
<td align="center">提供正则表达式,从作业输出中提取指定的内容</td>
</tr>
<tr>
<td align="center"><code>retry</code></td>
<td align="center">出现问题时可自动重试作业的条件和次数</td>
</tr>
<tr>
<td align="center"><code>timeout</code></td>
<td align="center">定义作业级别的超时时间</td>
</tr>
<tr>
<td align="center"><code>parallel</code></td>
<td align="center">可并行运行的作业实例个数</td>
</tr>
<tr>
<td align="center"><code>trigger</code></td>
<td align="center">定义下游管道触发器</td>
</tr>
<tr>
<td align="center"><code>include</code></td>
<td align="center">此作业包含的外部 yaml 文件.也可用 <code>include:local</code>, <code>include:file</code>, <code>include:template</code>, <code>include:remote</code></td>
</tr>
<tr>
<td align="center"><code>extends</code></td>
<td align="center">该作业要继承的配置条目</td>
</tr>
<tr>
<td align="center"><code>pages</code></td>
<td align="center">上传作业结果,用于在 GitLab Pages 展示</td>
</tr>
<tr>
<td align="center"><code>variables</code></td>
<td align="center">定义作业级别的变量</td>
</tr>
<tr>
<td align="center"><code>interruptible</code></td>
<td align="center">定义新的作业运行是否可以取消作业</td>
</tr>
<tr>
<td align="center"><code>resource_group</code></td>
<td align="center">限制作业并发</td>
</tr>
</tbody></table>
<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><p>可以在全局级别定义一些参数,这会影响管道中的所有作业.</p>
<p>以下参数可以使用 <code>default</code> 关键字配置块将某些全局参数设置为所有作业的默认值.作业可以覆盖这些默认值.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image</span><br><span class="line">services</span><br><span class="line">before_script</span><br><span class="line">after_script</span><br><span class="line">tags</span><br><span class="line">cache</span><br><span class="line">artifacts</span><br><span class="line">retry</span><br><span class="line">timeout</span><br><span class="line">interruptible</span><br></pre></td></tr></table></figure>

<p>示例如下,默认使用 <code>image: ruby:2.5</code> 镜像,而 <code>rspec 2.6</code> 作业使用 <code>image: ruby:2.6</code> 镜像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ruby:2.5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec 2.6:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ruby:2.6</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a><code>stages</code></h3><p><code>stages</code> 用于定义使用的阶段作业,且是全局的</p>
<p><code>stages</code> 允许具有灵活的多级管道,<code>stages</code> 中的元素定义了作业执行的顺序:</p>
<ul>
<li>同一阶段的作业并行运行</li>
<li>前一阶段的作业成功运行后,才运行下一阶段作业</li>
</ul>
<p>还有两种情况需要注意:</p>
<ul>
<li>如果 <code>.gitlab-ci.yml</code> 中未定义 <code>stages</code>,默认运行 <code>build</code>, <code>test</code>, <code>deploy</code> 阶段的作业</li>
<li>如果作业没有指定阶段,则默认将该作业分配为 <code>test</code> 阶段</li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h3><p><code>include</code> 关键字用于包含外部 YAML 文件,可将 CI/CD 配置分解为多个文件,提高配置文件的可读性.</p>
<p><code>include</code> 要求外部 YAML 文件具有 <code>.yml</code> 或 <code>.yaml</code> 后缀名,否则不会被导入</p>
<p><code>include</code> 支持如下方法,默认方法是 <code>local</code>.在进行 include 配置时支持直接引入对应文件路径,<code>include</code> 会自动分析方法. <a href="https://docs.gitlab.com/ee/ci/yaml/includes.html" target="_blank" rel="noopener">示例</a></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>local</code></td>
<td align="left">本项目代码库中的文件</td>
</tr>
<tr>
<td align="center"><code>file</code></td>
<td align="left">其它项目代码库中的文件</td>
</tr>
<tr>
<td align="center"><code>remote</code></td>
<td align="left">远程 URL 的文件</td>
</tr>
<tr>
<td align="center"><code>template</code></td>
<td align="left">GitLab 提供的模版</td>
</tr>
</tbody></table>
<h4 id="include-local"><a href="#include-local" class="headerlink" title="include:local"></a><code>include:local</code></h4><p><code>include:local</code> 用于引入与 <code>.gitlab-ci.yml</code> 来自同一代码库同一分支的文件,请确保 <code>.gitlab-ci.yml</code> 与要引入的文件在同一分支上</p>
<p><code>include:local</code> 使用代码仓库 <code>/</code> 根路径进行引用.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">local:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">include:</span> <span class="string">'.gitlab-ci-production.yml'</span></span><br></pre></td></tr></table></figure>

<h4 id="include-file"><a href="#include-file" class="headerlink" title="include:file"></a><code>include:file</code></h4><p><code>include:file</code> 支持引入同一个 GitLab 实例中另一个代码仓库中的文件. 并使用代码仓库 <code>/</code> 根路径进行引用.</p>
<p>您也可以通过 <code>ref</code> 指定代码仓库的分支或 <code>HEAD</code> 以确保引入正确仓库分支中的文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">'my-group/my-project'</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">'my-group/my-project'</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">'my-group/my-project'</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">787123b47f14b552955ca2786bc9542ae66fee5b</span> <span class="comment"># Git SHA</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">'/templates/.gitlab-ci-template.yml'</span></span><br></pre></td></tr></table></figure>

<h4 id="include-remote"><a href="#include-remote" class="headerlink" title="include:remote"></a><code>include:remote</code></h4><p><code>include:remote</code> 支持通过 HTTP/HTTPS 引入来自其他位置中的文件,远程文件必须可通过 GET 请求公开访问</p>
<p>远程文件使用完整 URL 引用.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">remote:</span> <span class="string">'https://gitlab.com/awesome-project/raw/master/.gitlab-ci-template.yml'</span></span><br></pre></td></tr></table></figure>

<h4 id="include-template"><a href="#include-template" class="headerlink" title="include:template"></a><code>include:template</code></h4><p><code>include:template</code> 支持引入 GitLab 提供的 <code>.gitlab-ci.yml</code> 模版文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">Auto-DevOps.gitlab-ci.yml</span></span><br></pre></td></tr></table></figure>

<h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3><p>指定一个 Docker 镜像来运行作业.详见<a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml" target="_blank" rel="noopener">使用 Docker 镜像</a></p>
<h3 id="script"><a href="#script" class="headerlink" title="script"></a><code>script</code></h3><p><code>script</code> 是脚本所必须的关键字,它是由 Runner 执行的 shell 脚本.支持使用包含多个命令的数组以便顺序执行命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<p>如果有命令的退出代码不为 0,则作业将失败,且不会执行其他命令.通过将退出代码存储在变量中,可以避免这种情况:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">false</span> <span class="string">||</span> <span class="string">exit_code=$?</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">if</span> <span class="string">[</span> <span class="string">$exit_code</span> <span class="string">-ne</span> <span class="number">0</span> <span class="string">];</span> <span class="string">then</span> <span class="string">echo</span> <span class="string">"Previous command failed"</span><span class="string">;</span> <span class="string">fi;</span></span><br></pre></td></tr></table></figure>

<h3 id="before-script-和-after-script"><a href="#before-script-和-after-script" class="headerlink" title="before_script 和 after_script"></a><code>before_script</code> 和 <code>after_script</code></h3><p><code>before_script</code> 用于定义在每个作业(包括部署作业)之前运行的命令,<code>after_script</code> 用于定义在每个作业(包括失败的作业)之后运行的命令.它们都是一个数组</p>
<p><code>before_script</code> 中指定的脚本与主脚本中指定的脚本串联在一起,并在单个 shell 中一起执行</p>
<p><code>after_script</code> 中指定的脚本在新的shell中执行,与任何 <code>before_script</code> 或 <code>script</code> 定义的命令分开.</p>
<p>它们有如下需要注意的地方:</p>
<ul>
<li>当前工作目录设置为默认目录</li>
<li>无法访问 <code>before_script</code> 或 <code>script</code> 定义的脚本完成的修改.<ul>
<li><code>script</code> 中定义的命令别名和变量</li>
<li>由 before_script 或 <code>script</code> 安装的软件</li>
</ul>
</li>
<li>独立的超时时间,默认为 5 分钟</li>
<li>不影响作业的退出代码.如果 <code>script</code> 成功,但 <code>after_script</code> 超时或失败,作业将标记为成功作业</li>
</ul>
<h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a><code>stage</code></h3><p><code>stage</code> 是按照每个作业定义的,且依赖于全局定义的 <code>stages</code>. 它将作业分为不同的阶段,同一阶段的作业可以并行执行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 0:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">.pre</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">something</span> <span class="string">useful</span> <span class="string">before</span> <span class="string">build</span> <span class="string">stage</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 1:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">dependencies</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 2:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">artifacts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 3:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 4:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 5:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">.post</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">something</span> <span class="string">useful</span> <span class="string">at</span> <span class="string">the</span> <span class="string">end</span> <span class="string">of</span> <span class="string">pipeline</span></span><br></pre></td></tr></table></figure>

<p>默认情况下,GitLab Runner 一次仅运行一个作业.可通过设置作业在不同的 Runner 上运行或修改 Runner 的 <code>concurrent</code> 配置来使作业并行运行.</p>
<blockquote>
<p>(GitLab 12.4 新增)无论在 <code>stages</code> 中 顺序如何,<code>.per</code> 始终是管道中的第一个阶段.<code>.post</code> 始终是管道中的最后一个阶段.用户定义的阶段在这两个阶段之间运行</p>
</blockquote>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a><code>extends</code></h3><p><code>extends</code> 定义使用 <code>extends</code> 关键字的作业(子作业)要继承的作业(父作业).<code>extends</code> 会将子作业内容递归合并到父作业中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.tests:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">branches</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.tests</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$RSPEC</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">rspec</span>  <span class="comment"># 作业中相同关键字的 key 已经被重写</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span>             <span class="comment"># 子作业中没有的关键字会继承父作业中关键字及其值</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">branches</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$RSPEC</span></span><br></pre></td></tr></table></figure>

<p>且如果 <code>extends</code> 包含多个值,则会按照 <code>extends</code> 中定义的作业列表顺序进行继承.如果作业列表有相同的关键字,则后面作业中关键字的值会覆盖前面作业关键字的值.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.only-important:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"><span class="string">.in-docker:</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">extends:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.only-important</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.in-docker</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rake</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a><code>rules</code></h3><blockquote>
<p>GitLab 12.3 新增</p>
</blockquote>
<p><code>rules</code> 将按照顺序评估列表中的规则,直到有规则匹配到,实现为作业动态提供属性的功能.<code>rules</code> 不能与 <code>only/except</code> 同时使用,它旨在替换该功能</p>
<p>可用的规则字句字段包括</p>
<ul>
<li><code>if</code>(与 <code>only:variables</code> 类似)</li>
<li><code>changes</code> (与 <code>only:changes</code> 类似)</li>
<li><code>exists</code></li>
</ul>
<h4 id="rules-if"><a href="#rules-if" class="headerlink" title="rules:if"></a><code>rules:if</code></h4><p><code>rules:if</code> 使用定义的 if 规则设置作业执行的时机</p>
<p><code>rules:if</code> 与 <code>only:variables</code> 略有不同.<code>only:variables</code> 仅接收单个表达式字符串,而 <code>rules:if</code> 支持表达式字符串数组形式,支持多个条件判断.支持使用 <code>&amp;&amp;</code> 或 <code>||</code> 将表达式集合组合为一个表达式,且支持使用变量匹配语法.</p>
<p>如果提供的规则均不匹配,则作业将被默认设置为 <code>when:never</code>,且不包含在执行作业的管道中.如果配置中不包含 <code>rules:when</code>,则继承 <code>job:when</code> 的值,默认为 <code>on_success</code>.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">"echo Hello, Rules!"</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$NAME =~ /^always/ # 如果变量 NAME 匹配 always,则设置 when: always</span></span><br><span class="line"><span class="string">      when: always</span></span><br><span class="line"><span class="string">    - if: '</span><span class="string">$NAME</span> <span class="string">=~</span> <span class="string">/^manual/</span> <span class="comment"># 如果变量 NAME 匹配 manual,则设置为 when: manual</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">manual</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$NAME'</span>  <span class="comment"># 如果变量 NAME 设置了,且不为空,则设置为 when: on_success</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果以上均没有匹配,则设置 when: never</span></span><br></pre></td></tr></table></figure>

<h4 id="rules-changes"><a href="#rules-changes" class="headerlink" title="rules:changes"></a><code>rules:changes</code></h4><p><code>rules:changes</code> 与 <code>only:changes</code> 和 <code>except:changes</code> 工作方式相同,它接受路径的数组,并监控它.如果没有对监控中的文件路径做修改,则不会返回 true</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker build:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">my-image:$CI_COMMIT_REF_SLUG</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">changes:</span> <span class="comment"># 如果 Dockerfile 文件被修改,则将其设置为 `when: manual`</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>

<h4 id="rules-exists"><a href="#rules-exists" class="headerlink" title="rules:exists"></a><code>rules:exists</code></h4><blockquote>
<p>GitLab 12.4 新增</p>
</blockquote>
<p><code>rules:exists</code> 接受文件路径或文件路径匹配的数组.如果其中任何一个文件路径在代码仓库中存在,则将匹配,作业将在管道中运行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">exists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spec/**.rb</span></span><br></pre></td></tr></table></figure>

<h4 id="rules-allow-failure"><a href="#rules-allow-failure" class="headerlink" title="rules:allow_failure"></a><code>rules:allow_failure</code></h4><blockquote>
<p>GitLab 12.8 新增</p>
</blockquote>
<p>您可以在规则中使用 <code>allow_failure: true</code>,在不停止作业管道的情况下允许作业失败或手动作业等待操作.所有使用规则的作业默认为 <code>allow_failure: false</code>.</p>
<h3 id="only-except"><a href="#only-except" class="headerlink" title="only/except"></a><code>only/except</code></h3><p><code>only</code> 和 <code>except</code> 是用于限制什么时候创建作业的两个参数.<code>only</code> 用于定义要运行的作业的分支和标签.<code>except</code> 恰好相反,用于定义不运行的作业的分支和标签.</p>
<ul>
<li>它支持正则表达式匹配.</li>
<li>它支持直接指定存储库路径以便于过滤仓库 fork 的作业</li>
</ul>
<p><code>only</code> 和 <code>except</code> 允许使用如下关键字,且如果有作业没有关键字限定,则 <code>only</code> 默认为 <code>[&#39;branches&#39;, &#39;tags&#39;]</code>,<code>except</code> 默认为空.</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>branches</code></td>
<td align="left">当管道的 git 引用是分支时</td>
</tr>
<tr>
<td align="center"><code>tags</code></td>
<td align="left">当管道的 git 引用是标签时</td>
</tr>
<tr>
<td align="center"><code>external</code></td>
<td align="left">当时用 GitLab 以外的 CI 服务时</td>
</tr>
<tr>
<td align="center"><code>pushes</code></td>
<td align="left">由用户的 git push 触发</td>
</tr>
<tr>
<td align="center"><code>schedules</code></td>
<td align="left">用于自动调度的管道</td>
</tr>
<tr>
<td align="center"><code>triggers</code></td>
<td align="left">使用触发令牌创建的管道</td>
</tr>
<tr>
<td align="center"><code>web</code></td>
<td align="left">对于在 GitLab UI 中使用 “Run” 按钮创建的管道</td>
</tr>
<tr>
<td align="center"><code>merge_requests</code></td>
<td align="left">在创建或更新合并请求时</td>
</tr>
</tbody></table>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/^issue-.*$/i</span>  <span class="comment"># 使用正则表达式,`i` 表示忽略大小写</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches</span>  <span class="comment"># 使用关键字,所有的分支都将被跳过</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches@gitlab-org/gitlab</span>  <span class="comment"># 仅对 branches 仓库执行作业,而不对其 fork 执行</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master@gitlab-org/gitlab</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/^release/.*$/@gitlab-org/gitlab</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>only:refs/except:refs</code>: 语法与上述一致</li>
<li><code>only:kubernetes/except:kubernetes</code>: 仅接受 <code>active</code> 参数,表示仅当 kubernetes 服务启动时才执行此作业</li>
<li><code>only:variables/except:variables</code>: 接受自定义变量表达式,以此决定是否创建作业</li>
<li><code>only:changes/except:changes</code>: 接受文件路径,并监控是否改变,以此决定是否创建作业</li>
</ul>
<p>单个关键字中定义的条件列表是<strong>或</strong>的关系,有一个条件满足,则可以认为该关键字表示为 true.</p>
<p>对于 <code>only</code> 创建作业来说,以上关键字之间是<strong>与</strong>的关系,当定义的以上关键字均为 true 时候,才会创建作业.对于 <code>except</code> 不创建作业来说,以上关键字之间是<strong>或</strong>的关系,当定义的以上关键字任意一个为 true 时候,则不会创建作业.</p>
<p>示例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该作业在以下条件均满足时创建</span></span><br><span class="line"><span class="comment"># - 管道是被调度的或在 `master` 分支上运行</span></span><br><span class="line"><span class="comment"># - $CI_COMMIT_MESSAGE 变量正则匹配 /run-end-to-end-tests/</span></span><br><span class="line"><span class="comment"># - kubernetes 服务运行</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">schedules</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$CI_COMMIT_MESSAGE</span> <span class="string">=~</span> <span class="string">/run-end-to-end-tests/</span></span><br><span class="line">    <span class="attr">kubernetes:</span> <span class="string">active</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该作业任意条件满足时不创建</span></span><br><span class="line"><span class="comment"># - 管道是被调度的或在 `master` 分支上运行</span></span><br><span class="line"><span class="comment"># - README.md 文件被修改</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">changes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"README.md"</span></span><br></pre></td></tr></table></figure>

<h3 id="needs"><a href="#needs" class="headerlink" title="needs"></a><code>needs</code></h3><p><code>needs</code> 关键字允许不按照 stages 顺序执行作业,而按照依赖顺序执行作业.这样无需考虑阶段顺序,可以让多个阶段同时运行.</p>
<p>示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">linux:build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mac:build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">lint:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">[]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linux:rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["linux:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linux:rubocop:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["linux:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mac:rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["mac:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mac:rubocop:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">needs:</span> <span class="string">["mac:build"]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Linux 作业线: <code>linux:build</code> 作业完成后,将立即运行 <code>linux:rspec</code> 和 <code>linux:rubocop</code> 作业,而无需等待 <code>mac:build</code> 结束</li>
<li>macOS 作业线: <code>mac:build</code> 作业完成后,将立即运行 <code>mac:rspec</code> 和 <code>mac:rubocop</code> 作业,而无需等待 <code>linux:build</code> 结束</li>
<li>production 作业会等待 <code>deploy</code> 阶段之前的作业完成后再运行</li>
</ul>
<h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a><code>tags</code></h3><p><code>tags</code> 用于从允许运行该项目的所有 Runner 列表中选择特定的 Runner.在注册 Runner 时,您可以指定 Runner 的标签,例如 ruby,postgres,development 等.</p>
<p><code>tags</code> 也是在不同平台上运行不同作业的好方法.例如，给定带有 <code>osx</code> 标签的 OS X Runner 和带有 <code>windows</code> 标签的 Windows Runner,以下作业将在各自的平台上运行:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">windows job:</span></span><br><span class="line">  <span class="attr">stage:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">windows</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">Hello,</span> <span class="string">%USERNAME%!</span></span><br><span class="line"></span><br><span class="line"><span class="attr">osx job:</span></span><br><span class="line">  <span class="attr">stage:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">osx</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"Hello, $USER!"</span></span><br></pre></td></tr></table></figure>

<h3 id="allow-failure"><a href="#allow-failure" class="headerlink" title="allow_failure"></a><code>allow_failure</code></h3><p><code>allow_failure</code> 关键字用于指定作业可以失败,而不会影响其余的作业.</p>
<p>设置为 true 后,如果该作业失败，该作业将在用户界面中显示橙色警告,管道的逻辑流程将认为作业成功/通过,并且不会被阻塞</p>
<h3 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h3><p><code>when</code> 关键字用于在发生故障或发生故障时运行的作业.支持以下值</p>
<ul>
<li><code>on_success</code>: 前面阶段的所有作业都成功时,才执行作业.是默认值</li>
<li><code>on_failure</code>: 仅在前面阶段至少一个作业失败时才执行作业.</li>
<li><code>always</code>: 总是执行作业,不管前面作业的执行状态</li>
<li><code>manual</code>: 手动执行作业时才执行此作业</li>
<li><code>delayed</code>: 一段时间后执行此作业.需要设置 <code>start_in</code> 关键字,并设置 <strong>1 周</strong>之内的延迟时间,用于表示在指定延迟时间后开始作业.支持 seconds,minutes,hours,days,week 单位,默认单位是 seconds</li>
</ul>
<h3 id="其它常用"><a href="#其它常用" class="headerlink" title="其它常用"></a>其它常用</h3><ul>
<li><code>retry</code> 允许你在失败的情况下重试作业的次数.重试值必须是一个整数,等于或大于0,但小于等于2</li>
<li><code>timeout</code> 设置指定作业的超时时间,</li>
<li><code>parallel</code> 配置并行运行的作业实例,名称为 <code>job_name 1/N</code> 到 <code>job_name N/N</code> (2&lt;=N&lt;=50)</li>
<li><code>trigger</code> 用于定义触发的下游管道的触发器.当定义 <code>trigger</code> 的作业完成时,将触发下一个作业的执行</li>
<li><code>variables</code> 用于在 <code>.gitlab-ci.yml</code> 中定义变量,然后在作业中使用.</li>
</ul>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 x509 包</title>
    <url>/2020/05/22/go-study-notes-package-x509/</url>
    <content><![CDATA[<p><code>crypto/x509</code> 包主要用于解析 X.509 编码的密钥和证书.</p>
<p><code>crypto/x509/pkix</code> 包含用于 X.509 证书,CRL 和 OCSP 的 ASN.1 解析和序列化的共享低级结构</p>
<p>在 Unix 系统上,可使用环境变量 SSL_CERT_FILE 和 SSL_CERT_DIR 覆盖系统证书文件和证书文件目录的默认位置</p>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// certificates 证书的集合</span></span><br><span class="line"><span class="keyword">type</span> CertPool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X509 证书</span></span><br><span class="line"><span class="keyword">type</span> Certificate <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 证书的 subject 信息,包含 CN,O,L,S,C等字段</span></span><br><span class="line">    Subject pkix.Name</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key 的扩展用法</span></span><br><span class="line"><span class="keyword">type</span> ExtKeyUsage <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Key 的用法</span></span><br><span class="line"><span class="keyword">type</span> KeyUsage <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 证书签署请求</span></span><br><span class="line"><span class="keyword">type</span> CertificateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 签名</span></span><br><span class="line">    Signature          []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 签名算法</span></span><br><span class="line">    SignatureAlgorithm SignatureAlgorithm</span><br><span class="line">    <span class="comment">// 私钥算法</span></span><br><span class="line">    PublicKeyAlgorithm PublicKeyAlgorithm</span><br><span class="line">    <span class="comment">// 私钥</span></span><br><span class="line">    PublicKey          <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 证书签署请求的 subject</span></span><br><span class="line">    Subject pkix.Name</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证的选项</span></span><br><span class="line"><span class="keyword">type</span> VerifyOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    DNSName       <span class="keyword">string</span></span><br><span class="line">    Intermediates *CertPool</span><br><span class="line">    Roots         *CertPool <span class="comment">// 默认使用系统根证书</span></span><br><span class="line">    CurrentTime   time.Time <span class="comment">// 当前时间</span></span><br><span class="line">    KeyUsages []ExtKeyUsage</span><br><span class="line">    MaxConstraintComparisions <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 私钥算法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UnknownPublicKeyAlgorithm PublicKeyAlgorithm = <span class="literal">iota</span></span><br><span class="line">    RSA</span><br><span class="line">    DSA</span><br><span class="line">    ECDSA</span><br><span class="line">    Ed25519</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 签名算法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UnknownSignatureAlgorithm SignatureAlgorithm = <span class="literal">iota</span></span><br><span class="line">    MD2WithRSA</span><br><span class="line">    MD5WithRSA</span><br><span class="line">    SHA1WithRSA</span><br><span class="line">    SHA256WithRSA</span><br><span class="line">    SHA384WithRSA</span><br><span class="line">    SHA512WithRSA</span><br><span class="line">    DSAWithSHA1</span><br><span class="line">    DSAWithSHA256</span><br><span class="line">    ECDSAWithSHA1</span><br><span class="line">    ECDSAWithSHA256</span><br><span class="line">    ECDSAWithSHA384</span><br><span class="line">    ECDSAWithSHA512</span><br><span class="line">    SHA256WithRSAPSS</span><br><span class="line">    SHA384WithRSAPSS</span><br><span class="line">    SHA512WithRSAPSS</span><br><span class="line">    PureEd25519</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 扩展 Key 用法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ExtKeyUsageAny ExtKeyUsage = <span class="literal">iota</span></span><br><span class="line">    ExtKeyUsageServerAuth</span><br><span class="line">    ExtKeyUsageClientAuth</span><br><span class="line">    ExtKeyUsageCodeSigning</span><br><span class="line">    ExtKeyUsageEmailProtection</span><br><span class="line">    ExtKeyUsageIPSECEndSystem</span><br><span class="line">    ExtKeyUsageIPSECTunnel</span><br><span class="line">    ExtKeyUsageIPSECUser</span><br><span class="line">    ExtKeyUsageTimeStamping</span><br><span class="line">    ExtKeyUsageOCSPSigning</span><br><span class="line">    ExtKeyUsageMicrosoftServerGatedCrypto</span><br><span class="line">    ExtKeyUsageNetscapeServerGatedCrypto</span><br><span class="line">    ExtKeyUsageMicrosoftCommercialCodeSigning</span><br><span class="line">    ExtKeyUsageMicrosoftKernelCodeSigning</span><br><span class="line">)</span><br><span class="line"><span class="comment">// key 用法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    KeyUsageDigitalSignature KeyUsage = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">    KeyUsageContentCommitment</span><br><span class="line">    KeyUsageKeyEncipherment</span><br><span class="line">    KeyUsageDataEncipherment</span><br><span class="line">    KeyUsageKeyAgreement</span><br><span class="line">    KeyUsageCertSign</span><br><span class="line">    KeyUsageCRLSign</span><br><span class="line">    KeyUsageEncipherOnly</span><br><span class="line">    KeyUsageDecipherOnly</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="x509-包函数"><a href="#x509-包函数" class="headerlink" title="x509 包函数"></a><code>x509</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 template 创建一个新的由 parent 签署的 X509 v3 证书.返回 DER 编码的证书</span></span><br><span class="line"><span class="comment">// 如果 parent=template,则该证书是自签证书.</span></span><br><span class="line"><span class="comment">// 如果是自签证书生成证书的 AuthorityKeyId 会从父级的 SubjectKeyId 中获取,否则使用 template 中的值</span></span><br><span class="line"><span class="comment">// pub,priv 分别为签署人的公钥和私钥, priv 必须是实现 `crypto.Signal` 接口的 `PrivateKey` 类型.当前支持的类型为 *rsa.PublicKey,*ecdsa.PublicKey 和 *ed25519.PublicKey.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateCertificate</span><span class="params">(rand io.Reader, template, parent *Certificate, pub, priv <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(cert []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 基于 template 创建一个证书签署请求</span></span><br><span class="line"><span class="comment">// priv 是用于签署 CSR 的私钥,并将其公钥放在 CSR 中,priv 必须实现 `crypto.Signal` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateCertificateRequest</span><span class="params">(rand io.Reader, template *CertificateRequest, priv <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(csr []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 使用 password 对 PEM 块进行解密,返回 DER 编码的字节切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptPEMBlock</span><span class="params">(b *pem.Block, password []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="comment">// 使用指定 alg 和 password 对给定 DER 编码的 data 进行加密.返回加密后的 PEM 块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptPEMBlock</span><span class="params">(rand io.Reader, blockType <span class="keyword">string</span>, data, password []<span class="keyword">byte</span>, alg PEMCipher)</span> <span class="params">(*pem.Block, error)</span></span></span><br><span class="line"><span class="comment">// 判断 PEM 块是否使用密码加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsEncryptedPEMBlock</span><span class="params">(b *pem.Block)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个空的 CertPool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCertPool</span><span class="params">()</span> *<span class="title">CertPool</span></span></span><br><span class="line"><span class="comment">// 返回系统证书池的副本.CertPool 的任何变动都不会写入磁盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemCertPool</span><span class="params">()</span> <span class="params">(*CertPool, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 ASN.1 数据中解析证书.返回证书或证书列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseCertificate</span><span class="params">(asn1Data []<span class="keyword">byte</span>)</span> <span class="params">(*Certificate, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseCertificates</span><span class="params">(asn1Data []<span class="keyword">byte</span>)</span> <span class="params">([]*Certificate, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="CertPool-结构体方法"><a href="#CertPool-结构体方法" class="headerlink" title="CertPool 结构体方法"></a><code>CertPool</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向证书池中添加证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CertPool)</span> <span class="title">AddCert</span><span class="params">(cert *Certificate)</span></span></span><br><span class="line"><span class="comment">// 尝试解析 PEM 编码的证书,并将其添加到证书池中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CertPool)</span> <span class="title">AppendCertsFromPEM</span><span class="params">(pemCerts []<span class="keyword">byte</span>)</span> <span class="params">(ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 返回证书池中所有证书的 DER 编码的 subject 的列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CertPool)</span> <span class="title">Subjects</span><span class="params">()</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Certificate-结构体方法"><a href="#Certificate-结构体方法" class="headerlink" title="Certificate 结构体方法"></a><code>Certificate</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查 crl 中签名是否来自 c</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CheckCRLSignature</span><span class="params">(crl *pkix.CertificateList)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 使用指定签名算法 algo 验证 signature 是否是通过 c 的私钥签署了 signed 签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CheckSignature</span><span class="params">(algo SignatureAlgorithm, signed, signature []<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 验证 c 上的签名是否是来自 parent 的有效签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CheckSignatureFrom</span><span class="params">(parent *Certificate)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回证书签名的 DER 编码的 CRL 证书吊销列表,包含指定的的吊销证书列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">CreateCRL</span><span class="params">(rand io.Reader, priv <span class="keyword">interface</span>&#123;&#125;, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time)</span> <span class="params">(crlBytes []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 使用 opts.Roots 中的证书,验证 c</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">Verify</span><span class="params">(opts VerifyOptions)</span> <span class="params">(chains [][]*Certificate, err error)</span></span></span><br><span class="line"><span class="comment">// 验证 c 是否是指定主机的有效证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Certificate)</span> <span class="title">VerifyHostname</span><span class="params">(h <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="生成自签书-并使用自签证书签署"><a href="#生成自签书-并使用自签证书签署" class="headerlink" title="生成自签书,并使用自签证书签署"></a>生成自签书,并使用自签证书签署</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/x509"</span></span><br><span class="line">    <span class="string">"crypto/x509/pkix"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"math/big"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ca 证书</span></span><br><span class="line">    ca := &amp;x509.Certificate&#123;</span><br><span class="line">        SerialNumber: big.NewInt(<span class="number">1653</span>),</span><br><span class="line">        Subject: pkix.Name&#123;</span><br><span class="line">            Country:            []<span class="keyword">string</span>&#123;<span class="string">"China"</span>&#125;,</span><br><span class="line">            Organization:       []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">            OrganizationalUnit: []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        NotBefore:             time.Now(),</span><br><span class="line">        NotAfter:              time.Now().AddDate(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        SubjectKeyId:          []<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        BasicConstraintsValid: <span class="literal">true</span>,</span><br><span class="line">        IsCA:                  <span class="literal">true</span>,</span><br><span class="line">        ExtKeyUsage:           []x509.ExtKeyUsage&#123;x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth&#125;,</span><br><span class="line">        KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私钥及公钥 rsa 格式</span></span><br><span class="line">    caSelfSignedPrivateKey, _ := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line">    caSelfSignedPublicKey := &amp;caSelfSignedPrivateKey.PublicKey</span><br><span class="line">    <span class="comment">// 自签证书 []byte</span></span><br><span class="line">    caSelfSigned, err := x509.CreateCertificate(rand.Reader, ca, ca, caSelfSignedPublicKey, caSelfSignedPrivateKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"create ca failed"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    caSelfSignedFile := <span class="string">"ca.pem"</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, caSelfSignedFile)</span><br><span class="line">    ioutil.WriteFile(caSelfSignedFile, caSelfSigned, <span class="number">0777</span>) <span class="comment">// 将自签证书写入文件</span></span><br><span class="line"></span><br><span class="line">    caSelfSignedPrivateKeyFile := <span class="string">"ca.key"</span></span><br><span class="line">    caSelfSignedPrivateKeyDER := x509.MarshalPKCS1PrivateKey(caSelfSignedPrivateKey) <span class="comment">// 将私钥转换为 DER 格式</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, caSelfSignedPrivateKeyFile)</span><br><span class="line">    ioutil.WriteFile(caSelfSignedPrivateKeyFile, caSelfSignedPrivateKeyDER, <span class="number">0777</span>) <span class="comment">// 将 DER 编码私钥写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待签署证书及其私钥公钥</span></span><br><span class="line">    cert := &amp;x509.Certificate&#123;</span><br><span class="line">        SerialNumber: big.NewInt(<span class="number">1658</span>),</span><br><span class="line">        Subject: pkix.Name&#123;</span><br><span class="line">            Country:            []<span class="keyword">string</span>&#123;<span class="string">"China"</span>&#125;,</span><br><span class="line">            Organization:       []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">            OrganizationalUnit: []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        NotBefore:    time.Now(),</span><br><span class="line">        NotAfter:     time.Now().AddDate(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        SubjectKeyId: []<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        ExtKeyUsage:  []x509.ExtKeyUsage&#123;x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth&#125;,</span><br><span class="line">        KeyUsage:     x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,</span><br><span class="line">    &#125;</span><br><span class="line">    certPrivateKey, _ := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line">    certPublicKey := &amp;certPrivateKey.PublicKey</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自签CA 对 证书签署</span></span><br><span class="line">    certSigned, err2 := x509.CreateCertificate(rand.Reader, cert, ca, certPublicKey, caSelfSignedPrivateKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"create cert2 failed"</span>, err2)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    certFile := <span class="string">"cert.pem"</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, certFile)</span><br><span class="line">    ioutil.WriteFile(certFile, certSigned, <span class="number">0777</span>) <span class="comment">// cert 写入文件</span></span><br><span class="line"></span><br><span class="line">    certPrivateKeyFile := <span class="string">"cert.key"</span></span><br><span class="line">    certPrivateKeyDER := x509.MarshalPKCS1PrivateKey(certPrivateKey) <span class="comment">// 将私钥转换为 DER 编码格式</span></span><br><span class="line">    log.Println(<span class="string">"write to"</span>, certPrivateKeyFile)</span><br><span class="line">    ioutil.WriteFile(certPrivateKeyFile, certPrivateKeyDER, <span class="number">0777</span>) <span class="comment">// 私钥写入文件</span></span><br><span class="line"></span><br><span class="line">    ca_tr, _ := x509.ParseCertificate(caSelfSigned)</span><br><span class="line">    cert_tr, _ := x509.ParseCertificate(certSigned)</span><br><span class="line">    err = cert_tr.CheckSignatureFrom(ca_tr)</span><br><span class="line">    log.Println(<span class="string">"check signature"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>go 学习笔记之 tls 包</title>
    <url>/2020/05/22/go-study-notes-package-tls/</url>
    <content><![CDATA[<p>tls 包定义并提供了 TLS 1.2 及 TLS 1.3 传输层安全协议通信过程中使用的对象,函数,方法及加密算法等,为通信双方提供了安全的通信连接.</p>
<h2 id="常用类型定义"><a href="#常用类型定义" class="headerlink" title="常用类型定义"></a>常用类型定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tls 证书</span></span><br><span class="line"><span class="keyword">type</span> Certificate <span class="keyword">struct</span> &#123;</span><br><span class="line">    Certificate [][]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// PrivateKey 包含与 Leaf 中公钥对应的私钥.该对象必须以 RSA,ECDSA 或 Ed25519 算法实现 crypto.Signer 接口</span></span><br><span class="line">    <span class="comment">// 对于 TLS1.2 以下的服务,它可以使用 RSA PublicKey 实现 crypto.Decrypter 接口</span></span><br><span class="line">    PrivateKey crypto.PrivateKey</span><br><span class="line">    <span class="comment">// PrivateKey 可使用的签名算法列表</span></span><br><span class="line">    SupportedSignatureAlgorithms []SignatureScheme <span class="comment">// Go 1.14</span></span><br><span class="line">    <span class="comment">// 客户端请求的 OCSP 响应</span></span><br><span class="line">    OCSPStaple []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 请求它的客户端的证书时间戳列表</span></span><br><span class="line">    SignedCertificateTimestamps [][]<span class="keyword">byte</span> <span class="comment">// Go 1.5</span></span><br><span class="line">    <span class="comment">// 叶子证书的解析形式,可使用 x509.ParseCertificate 对其进行初始化,以减少每次握手的过程.如果为 nil,则根据需要解析叶子证书</span></span><br><span class="line">    Leaf *x509.Certificate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来自服务端的 CertificateRequest 消息的信息,该消息用于向客户端索取证书协商协议</span></span><br><span class="line"><span class="keyword">type</span> CertificateRequestInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含0个或多个 DER 编码的 X.501 专有名称.</span></span><br><span class="line">    <span class="comment">// 这些是服务端希望返回的由其根或中间 CA 签名的证书名称</span></span><br><span class="line">    <span class="comment">// 空切片表示服务端没有首选项</span></span><br><span class="line">    AcceptableCAs [][]<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 服务端支持的验证签名方案</span></span><br><span class="line">    SignatureSchemes []SignatureScheme</span><br><span class="line">    <span class="comment">// 为此连接协商的 TLS 版本.</span></span><br><span class="line">    Version <span class="keyword">uint16</span> <span class="comment">// Go 1.14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端 TLS 连接状态</span></span><br><span class="line"><span class="keyword">type</span> ClientSessionState <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器遵循的 TLS 客户端身份验证策略</span></span><br><span class="line"><span class="keyword">type</span> ClientAuthType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 ClientHello 消息信息</span></span><br><span class="line"><span class="keyword">type</span> ClientHelloInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端支持的加密套件</span></span><br><span class="line">    CipherSuites []<span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// 客户端请求的 ServerName</span></span><br><span class="line">    ServerName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    SupportedCurves []CurveID</span><br><span class="line">    SupportedPoints []<span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端支持的签名和哈希方案</span></span><br><span class="line">    SignatureSchemes []SignatureScheme <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 客户端支持的应用层协议</span></span><br><span class="line">    SupportedProtos []<span class="keyword">string</span> <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 客户端支持的 TLS 版本</span></span><br><span class="line">    SupportedVersions []<span class="keyword">uint16</span> <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 底层连接对象,net.Conn 实例</span></span><br><span class="line">    Conn net.Conn <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 包含过滤或未导出的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientSessionState 对象的缓存</span></span><br><span class="line"><span class="keyword">type</span> ClientSessionCache <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Get搜索与给出的键相关联的*ClientSessionState并用ok说明是否找到</span></span><br><span class="line">    Get(sessionKey <span class="keyword">string</span>) (session *ClientSessionState, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// Put将*ClientSessionState与给出的键关联并写入缓存中</span></span><br><span class="line">    Put(sessionKey <span class="keyword">string</span>, cs *ClientSessionState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tls 相关配置</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 随机数生成,默认使用 `crypto/rand` 包中加密随机数生成器</span></span><br><span class="line">    <span class="comment">// 必须可以安全地被多个 goroutine  使用</span></span><br><span class="line">    Rand io.Reader</span><br><span class="line">    <span class="comment">// 返回当前时间的函数.默认使用 time.Now</span></span><br><span class="line">    Time <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line">    <span class="comment">// 一个或多个证书链以呈现给连接另一端.将自动选择与之匹配的证书</span></span><br><span class="line">    <span class="comment">// 服务端必须设置 Certificates,GetCertificate 或 GetConfigForClient 之一</span></span><br><span class="line">    <span class="comment">// 客户端可以设置 Certificates 或 GetCertificate</span></span><br><span class="line">    <span class="comment">// 注意: 如果有多个证书,且没有设置可选的 Leaf 字段,选择证书过程可能会导致大量的握手成本</span></span><br><span class="line">    Certificates []Certificate</span><br><span class="line">    <span class="comment">// 证书名称到 Certificates 的映射</span></span><br><span class="line">    NameToCertificate <span class="keyword">map</span>[<span class="keyword">string</span>]*Certificate</span><br><span class="line">    <span class="comment">// 返回基于给定 ClientHelloInfo 的证书.当客户端提供 SNI 信息或 Certificates 为空时,才会调用该方法</span></span><br><span class="line">    GetCertificate <span class="function"><span class="keyword">func</span><span class="params">(*ClientHelloInfo)</span> <span class="params">(*Certificate, error)</span> // <span class="title">Go</span> 1.4</span></span><br><span class="line">    <span class="comment">// 服务端从客户端请求证书时,调用该函数获取客户端证书.如果定义了此成员变量,Certificates 内容将被忽略</span></span><br><span class="line">    GetClientCertificate <span class="function"><span class="keyword">func</span><span class="params">(*CertificateRequestInfo)</span> <span class="params">(*Certificate, error)</span> // <span class="title">Go</span> 1.8</span></span><br><span class="line">    <span class="comment">// 收到客户端 ClientHello 后调用此函数为获取客户端配置</span></span><br><span class="line">    GetConfigForClient <span class="function"><span class="keyword">func</span><span class="params">(*ClientHelloInfo)</span> <span class="params">(*Config, error)</span> // <span class="title">Go</span> 1.8</span></span><br><span class="line">    <span class="comment">// TLS 客户端或服务端进行常规证书验证后,调用该函数进行 TLS 握手验证</span></span><br><span class="line">    VerifyPeerCertificate <span class="function"><span class="keyword">func</span><span class="params">(rawCerts [][]<span class="keyword">byte</span>, verifiedChains [][]*x509.Certificate)</span> <span class="title">error</span> // <span class="title">Go</span> 1.8</span></span><br><span class="line">    <span class="comment">// 客户端验证服务端证书 CA</span></span><br><span class="line">    <span class="comment">// 如果为 nil,则使用主机的 CA 集合</span></span><br><span class="line">    RootCAs *x509.CertPool</span><br><span class="line">    <span class="comment">// 按优先级顺序列出支持的应用层协议</span></span><br><span class="line">    NextProtos []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// TLS 服务端主机名称,用于验证证书的主机名.除非使用 InsecureSkipVerify 跳过主机名认证</span></span><br><span class="line">    ServerName <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// TLS 服务端对客户端身份验证的策略,默认为 NoClientCert,不对客户端做身份验证</span></span><br><span class="line">    ClientAuth ClientAuthType</span><br><span class="line">    <span class="comment">// 客户端证书颁发机构,如果 ClientAuth 设置需要验证客户端证书,服务端将使用这些证书颁发机构</span></span><br><span class="line">    ClientCAs *x509.CertPool</span><br><span class="line">    <span class="comment">// 客户端是否跳过验证服务端证书和主机名</span></span><br><span class="line">    InsecureSkipVerify <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 直到 TLS1.2 版本支持的密码套件列表</span></span><br><span class="line">    CipherSuites []<span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// 是否优先选择服务端密码套件</span></span><br><span class="line">    PreferServerCipherSuites <span class="keyword">bool</span> <span class="comment">// Go 1.1</span></span><br><span class="line">    <span class="comment">// 是否禁用 ticket 会话和 PSK 会话支持</span></span><br><span class="line">    SessionTicketsDisabled <span class="keyword">bool</span> <span class="comment">// Go 1.1</span></span><br><span class="line">    <span class="comment">// 使用 SessionTicketKey 提供会话恢复</span></span><br><span class="line">    SessionTicketKey [<span class="number">32</span>]<span class="keyword">byte</span> <span class="comment">// Go 1.1</span></span><br><span class="line">    <span class="comment">// 客户端 ClientSessionState 缓存</span></span><br><span class="line">    ClientSessionCache ClientSessionCache <span class="comment">// Go 1.3</span></span><br><span class="line">    <span class="comment">// 支持的最低版本,TLs 1.0 为最小值</span></span><br><span class="line">    MinVersion <span class="keyword">uint16</span> <span class="comment">// Go 1.2</span></span><br><span class="line">    <span class="comment">// 支持的最高版本,TLS 1.3 为最大值</span></span><br><span class="line">    MaxVersion <span class="keyword">uint16</span> <span class="comment">// Go 1.2</span></span><br><span class="line"></span><br><span class="line">    CurvePreferences []CurveID <span class="comment">// Go 1.3</span></span><br><span class="line">    DynamicRecordSizingDisabled <span class="keyword">bool</span> <span class="comment">// Go 1.7</span></span><br><span class="line">    Renegotiation RenegotiationSupport <span class="comment">// Go 1.7</span></span><br><span class="line">    KeyLogWriter io.Writer <span class="comment">// Go 1.8</span></span><br><span class="line">    <span class="comment">// 包含其它过滤或未导出的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全连接.实现了 `net.Conn` 接口</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接状态信息</span></span><br><span class="line"><span class="keyword">type</span> ConnectionState <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 连接使用的 TLS 版本</span></span><br><span class="line">    Version <span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// TLS 握手是否完成</span></span><br><span class="line">    HandshakeComplete <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 是否连接恢复先前的TLS连接</span></span><br><span class="line">    DidResume <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 使用的加密套件</span></span><br><span class="line">    CipherSuite <span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// 协商的协议</span></span><br><span class="line">    NegotiatedProtocol <span class="keyword">string</span></span><br><span class="line">    NegotiatedProtocolIsMutual <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 客户端请求的主机名</span></span><br><span class="line">    ServerName <span class="keyword">string</span></span><br><span class="line">    PeerCertificates []*x509.Certificate</span><br><span class="line">    VerifiedChains [][]*x509.Certificate</span><br><span class="line">    SignedCertificateTimestamps [][]<span class="keyword">byte</span></span><br><span class="line">    OCSPResponse []<span class="keyword">byte</span></span><br><span class="line">    TLSUnique []<span class="keyword">byte</span> <span class="comment">// Go 1.4</span></span><br><span class="line">    <span class="comment">// 包含过滤或未导出的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 签名算法</span></span><br><span class="line"><span class="keyword">type</span> SignatureScheme <span class="keyword">uint16</span></span><br></pre></td></tr></table></figure>

<h2 id="常量及变量"><a href="#常量及变量" class="headerlink" title="常量及变量"></a>常量及变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密套件</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// TLS 1.0 - 1.2 cipher suites.</span></span><br><span class="line">    TLS_RSA_WITH_RC4_128_SHA                      <span class="keyword">uint16</span> = <span class="number">0x0005</span></span><br><span class="line">    TLS_RSA_WITH_3DES_EDE_CBC_SHA                 <span class="keyword">uint16</span> = <span class="number">0x000a</span></span><br><span class="line">    TLS_RSA_WITH_AES_128_CBC_SHA                  <span class="keyword">uint16</span> = <span class="number">0x002f</span></span><br><span class="line">    TLS_RSA_WITH_AES_256_CBC_SHA                  <span class="keyword">uint16</span> = <span class="number">0x0035</span></span><br><span class="line">    TLS_RSA_WITH_AES_128_CBC_SHA256               <span class="keyword">uint16</span> = <span class="number">0x003c</span></span><br><span class="line">    TLS_RSA_WITH_AES_128_GCM_SHA256               <span class="keyword">uint16</span> = <span class="number">0x009c</span></span><br><span class="line">    TLS_RSA_WITH_AES_256_GCM_SHA384               <span class="keyword">uint16</span> = <span class="number">0x009d</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA              <span class="keyword">uint16</span> = <span class="number">0xc007</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA          <span class="keyword">uint16</span> = <span class="number">0xc009</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA          <span class="keyword">uint16</span> = <span class="number">0xc00a</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_RC4_128_SHA                <span class="keyword">uint16</span> = <span class="number">0xc011</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA           <span class="keyword">uint16</span> = <span class="number">0xc012</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA            <span class="keyword">uint16</span> = <span class="number">0xc013</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA            <span class="keyword">uint16</span> = <span class="number">0xc014</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256       <span class="keyword">uint16</span> = <span class="number">0xc023</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256         <span class="keyword">uint16</span> = <span class="number">0xc027</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256         <span class="keyword">uint16</span> = <span class="number">0xc02f</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256       <span class="keyword">uint16</span> = <span class="number">0xc02b</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         <span class="keyword">uint16</span> = <span class="number">0xc030</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384       <span class="keyword">uint16</span> = <span class="number">0xc02c</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   <span class="keyword">uint16</span> = <span class="number">0xcca8</span></span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 <span class="keyword">uint16</span> = <span class="number">0xcca9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS 1.3 cipher suites.</span></span><br><span class="line">    TLS_AES_128_GCM_SHA256       <span class="keyword">uint16</span> = <span class="number">0x1301</span></span><br><span class="line">    TLS_AES_256_GCM_SHA384       <span class="keyword">uint16</span> = <span class="number">0x1302</span></span><br><span class="line">    TLS_CHACHA20_POLY1305_SHA256 <span class="keyword">uint16</span> = <span class="number">0x1303</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator</span></span><br><span class="line">    <span class="comment">// that the client is doing version fallback. See RFC 7507.</span></span><br><span class="line">    TLS_FALLBACK_SCSV <span class="keyword">uint16</span> = <span class="number">0x5600</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Legacy names for the corresponding cipher suites with the correct _SHA256</span></span><br><span class="line">    <span class="comment">// suffix, retained for backward compatibility.</span></span><br><span class="line">    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305   = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</span><br><span class="line">    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</span><br><span class="line">)</span><br><span class="line"><span class="comment">// TLS 版本</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    VersionTLS10 = <span class="number">0x0301</span></span><br><span class="line">    VersionTLS11 = <span class="number">0x0302</span></span><br><span class="line">    VersionTLS12 = <span class="number">0x0303</span></span><br><span class="line">    VersionTLS13 = <span class="number">0x0304</span></span><br><span class="line">    <span class="comment">// 过时</span></span><br><span class="line">    VersionSSL30 = <span class="number">0x0300</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 客户端认证类别</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    NoClientCert ClientAuthType = <span class="literal">iota</span></span><br><span class="line">    RequestClientCert</span><br><span class="line">    RequireAnyClientCert</span><br><span class="line">    VerifyClientCertIfGiven</span><br><span class="line">    RequireAndVerifyClientCert</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 签名算法</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// RSASSA-PKCS1-v1_5 algorithms.</span></span><br><span class="line">    PKCS1WithSHA256 SignatureScheme = <span class="number">0x0401</span></span><br><span class="line">    PKCS1WithSHA384 SignatureScheme = <span class="number">0x0501</span></span><br><span class="line">    PKCS1WithSHA512 SignatureScheme = <span class="number">0x0601</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RSASSA-PSS algorithms with public key OID rsaEncryption.</span></span><br><span class="line">    PSSWithSHA256 SignatureScheme = <span class="number">0x0804</span></span><br><span class="line">    PSSWithSHA384 SignatureScheme = <span class="number">0x0805</span></span><br><span class="line">    PSSWithSHA512 SignatureScheme = <span class="number">0x0806</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.</span></span><br><span class="line">    ECDSAWithP256AndSHA256 SignatureScheme = <span class="number">0x0403</span></span><br><span class="line">    ECDSAWithP384AndSHA384 SignatureScheme = <span class="number">0x0503</span></span><br><span class="line">    ECDSAWithP521AndSHA512 SignatureScheme = <span class="number">0x0603</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// EdDSA algorithms.</span></span><br><span class="line">    Ed25519 SignatureScheme = <span class="number">0x0807</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Legacy signature and hash algorithms for TLS 1.2.</span></span><br><span class="line">    PKCS1WithSHA1 SignatureScheme = <span class="number">0x0201</span></span><br><span class="line">    ECDSAWithSHA1 SignatureScheme = <span class="number">0x0203</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="tls-包函数"><a href="#tls-包函数" class="headerlink" title="tls 包函数"></a><code>tls</code> 包函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定 Network 和 addr 创建 TLS 监听器, config 必须至少包含一个证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, laddr <span class="keyword">string</span>, config *Config)</span> <span class="params">(net.Listener, error)</span></span></span><br><span class="line"><span class="comment">// 通过 inner 监听器创建一个新监听器,并包装与服务端的每个连接.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewListener</span><span class="params">(inner net.Listener, config *Config)</span> <span class="title">net</span>.<span class="title">Listener</span></span></span><br><span class="line"><span class="comment">// 读取并解析一对文件获取公钥私钥.这些文件必须是  pem 编码的.返回文件中包含的证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadX509KeyPair</span><span class="params">(certFile, keyFile <span class="keyword">string</span>)</span> <span class="params">(cert Certificate, err error)</span></span></span><br><span class="line"><span class="comment">// 解析一对 pem 编码格式的数据获取公钥私钥.返回数据中包含的证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">X509KeyPair</span><span class="params">(certPEMBlock, keyPEMBlock []<span class="keyword">byte</span>)</span> <span class="params">(cert Certificate, err error)</span></span></span><br><span class="line"><span class="comment">// 创建 LRU(最近最少使用) 缓存策略的 ClientSessionState.如果 capacity&lt;1 会使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUClientSessionCache</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">ClientSessionCache</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 conn 作为下层传输接口返回一个 TL S连接的客户端.config 必须是非 nil 的且必须设置了 ServerName 或者 InsecureSkipVerify 字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Client</span><span class="params">(conn net.Conn, config *Config)</span> *<span class="title">Conn</span></span></span><br><span class="line"><span class="comment">// 使用 conn 作为下层传输接口返回一个 TLS 连接的服务端.config 必须是非 nil 的且必须含有至少一个证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Server</span><span class="params">(conn net.Conn, config *Config)</span> *<span class="title">Conn</span></span></span><br><span class="line"><span class="comment">// 使用 net.Dial 连接指定 network(协议)和 addr(地址),然后根据 config 发起 TLS 握手.返回生成的 TLS 连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, addr <span class="keyword">string</span>, config *Config)</span> <span class="params">(*Conn, error)</span></span></span><br><span class="line"><span class="comment">// 使用 net.Dialer 连接指定地址,然后发起 TLS 握手,返回生成的 TLS 连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialWithDialer</span><span class="params">(dialer *net.Dialer, network, addr <span class="keyword">string</span>, config *Config)</span> <span class="params">(*Conn, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Conn-结构体方法"><a href="#Conn-结构体方法" class="headerlink" title="Conn 结构体方法"></a><code>Conn</code> 结构体方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回当前连接的状态信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">ConnectionState</span><span class="params">()</span> <span class="title">ConnectionState</span></span></span><br><span class="line"><span class="comment">// 握手.本包大多数不需要显示调用,第一次 Read 或 Write 会自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Handshake</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 返回本地网络地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">LocalAddr</span><span class="params">()</span> <span class="title">net</span>.<span class="title">Addr</span></span></span><br><span class="line"><span class="comment">// 从 TLS 服务器返回装订的 OCSP 响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">OCSPResponse</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="comment">// 从连接中读取数据到 b.可能会超时返回一个 net.Error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// 远程网络地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">RemoteAddr</span><span class="params">()</span> <span class="title">net</span>.<span class="title">Addr</span></span></span><br><span class="line"><span class="comment">// 设置与连接关联的读写期限.t=0表示完全不会超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetReadDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetWriteDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 检查连接的证书链对于 host 是否有效.返回问题的描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">VerifyHostname</span><span class="params">(host <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 将数据写入连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK 之 Elasticsearch 查询介绍</title>
    <url>/2020/05/22/ELK-Stack-Elasticsearch-search/</url>
    <content><![CDATA[<p>Elasticsearch(ES)是一个基于 <a href="https://lucene.apache.org/" target="_blank" rel="noopener">Apache Lucene(TM)</a> 构建的开源分布式全文搜索引擎.它通过 RESTful API 来隐藏 Lucene 的复杂性,从而让全文搜索变得简单.它作为分布式文档数据库,其中存储的每个字段及值均可被索引.</p>
<p>Elasticsearch 有如下特性:</p>
<ul>
<li>分布式的数据存储工具,实时分析搜索引擎.存储在其中的每个字段都被索引并可被搜索</li>
<li>提供 RESTful 风格的 API 接口,简单易用</li>
<li>易扩展.它可以扩展到上百台服务器,处理 PB 级结构化或非结构化数据</li>
</ul>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><code>index</code> 索引</li>
</ul>
<p>索引是多个具有相似特性的文档集合.ES 中可以创建任意数量的索引,但索引名必须使用小写字母</p>
<ul>
<li><code>type</code> 类型</li>
</ul>
<p>类型是索引内部的逻辑分区.一般来说,类型定义为具有公共字段集的文档</p>
<ul>
<li><code>document</code> 文档</li>
</ul>
<p>文档是可以被搜索的基本单位,它基于 JSON 格式表示,一般包含多个字段.</p>
<p>可以简单的将 ES 中基本概念与关系型数据库概念对应起来:</p>
<table>
<thead>
<tr>
<th align="center">Elasticsearch</th>
<th align="center">关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">index 索引</td>
<td align="center">database 数据库</td>
</tr>
<tr>
<td align="center">type 类型</td>
<td align="center">table 表</td>
</tr>
<tr>
<td align="center">document 文档</td>
<td align="center">row 数据行</td>
</tr>
<tr>
<td align="center">field 字段</td>
<td align="center">column 数据列</td>
</tr>
<tr>
<td align="center">mapping 映射</td>
<td align="center">data_type 数据类型</td>
</tr>
</tbody></table>
<h3 id="集群概念"><a href="#集群概念" class="headerlink" title="集群概念"></a>集群概念</h3><ul>
<li><code>node</code> 节点</li>
</ul>
<p>节点是运行 Elasticsearch 实例的主机.它用于存储数据,参与集群索引及搜索操作.同一个集群内的节点名必须唯一,通过 <code>node.name</code> 进行设置</p>
<ul>
<li><code>cluster</code> 集群</li>
</ul>
<p>集群是一个或多个 Elasticsearch 节点的集合.这些节点共同存储整个数据,并在所有节点上提供联合索引和搜索功能.一个节点只能加入一个集群</p>
<ul>
<li><code>shard</code> 分片</li>
</ul>
<p>Elasticsearch 将索引切为多个小的片段,每一个片段都是一个分片.分片都是独立且完整的小索引,提供分布式读写负载均衡功能</p>
<p>用户可以通过 <code>index.number_of_shards</code> 设定分片数量,设定后不可更改.默认为 5</p>
<ul>
<li><code>replica</code> 副本</li>
</ul>
<p>ES 将分片保存为多个副本,提供冗余高可用.副本之间为主从机制,可能存在主从数据不同步的问题.主读写,从只读</p>
<p>用户可以通过 <code>index.number_of_replicas</code> 设置副本数量,设置后可进行更改</p>
<h2 id="ES-Cluster-工作原理"><a href="#ES-Cluster-工作原理" class="headerlink" title="ES Cluster 工作原理"></a>ES Cluster 工作原理</h2><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><ol>
<li>ES 启动时,通过多播(默认)或单播的方式在 tcp/9300 查找同一集群中的其它节点,并与之建立通信</li>
<li>集群中选举出一个主节点负责管理整个集群状态,以及在集群范围内决定各个分片的分配方式.站在用户角度而言,每个节点均可接收并响应用户的各类请求</li>
<li>假如集群中某一节点故障,主节点会读取集群状态信息,并启动修复过程,进入修复模式.此时,集群处于 yellow 状态,所有的副本分片处于为未分配状态.</li>
<li>在此时模式中,主节点会检查所有可用分片,并确定各主分片及其对应的副本数量是否满足配额.假如故障节点包含某一主分片,则需要从各个副本分片中选举出一个作为主分片.假如故障节点包含某一副本分片,则集群会启动处理过程,为之重新建立副本,直到满足配额.</li>
</ol>
<p>集群状态: green(健康), yellow(亚健康,修复模式), red(故障)</p>
<h3 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h3><p>在搜索过程中,由于不知道哪个分片中的文档会匹配到搜索条件,所以一个搜索请求不得不通过查询每一个我们感兴趣的索引的分片副本来查看是否含有任何匹配的文档.该过程称为<code>查询</code>.</p>
<p>但是,找到所有匹配的文档只完成了这件事的一半.在搜索 <code>_search</code> API 返回结果前,来自多个分片的结果必须被组合放到一个有序列表中.该过程称为<code>取回</code></p>
<blockquote>
<ul>
<li>查询阶段</li>
</ul>
</blockquote>
<p>当搜索请求被发送到 ES 节点,这个节点就变成了协调节点.这个节点的工作是向指定索引的所有分片广播搜索请求并且把它们的响应整合成一个全局的有序结果集.</p>
<p>在初始化查询阶段,查询请求会向索引中的每个分片副本广播,每个分片在本地执行搜索并建立匹配文档的优先队列.一个优先队列只是一个存有前 n 个匹配文档的有序列表.这个优先队列的大小由分页参数 <code>from</code> 和 <code>size</code> 决定,一般为 <code>from + size</code></p>
<blockquote>
<ul>
<li>取回阶段</li>
</ul>
</blockquote>
<p>协调节点辨别出哪个文档需要取回,并且向相关分片发出 GET 请求.每个分片加载文档并且根据需要处理它们,然后再将文档返回协调节点.等到所有符合条件的文档都被取回,协调节点会将结果返回给客户端.</p>
<h2 id="Document-APIs"><a href="#Document-APIs" class="headerlink" title="Document APIs"></a>Document APIs</h2><p>文档由元数据和内容组成.一般来说,元数据包括文档的 <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code> 等字段组成, 其中 <code>_index</code>, <code>_type</code>, <code>_id</code> 可用于唯一确定一个文档.<code>_version</code> 用于标识该文档的版本信息.文档内容由 <code>_source</code> 字段组成,其中包含我们存储文档时提交的 JSON 信息.</p>
<h3 id="通用请求路径参数"><a href="#通用请求路径参数" class="headerlink" title="通用请求路径参数"></a>通用请求路径参数</h3><p>以下是通用的路径请求参数,在不同 API 中可能有不同的选填或必填需求.</p>
<ul>
<li><code>index</code>: 指定索引名称.必填参数</li>
<li><code>_id</code>: 文档的唯一标识.PUT,GET,HEAD,DELETE 请求必填.POST 请求可以省略,会自动生成.</li>
</ul>
<h3 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h3><p>将 JSON 文档添加到指定索引并使其可搜索,如果文档已存在,更新文档并增加其版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;&lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_doc&#x2F;</span><br><span class="line">PUT &#x2F;&lt;index&gt;&#x2F;_create&#x2F;&lt;_id&gt;</span><br><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_create&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Get-API"><a href="#Get-API" class="headerlink" title="Get API"></a>Get API</h3><p>使用 Get 请求从特定索引中检索文档或字段,使用 HEAD 请求验证文档是否存在. 使用 <code>_source</code> 对文档内容操作.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br><span class="line">HEAD &lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br><span class="line">GET &lt;index&gt;&#x2F;_source&#x2F;&lt;_id&gt;</span><br><span class="line">HEAD &lt;index&gt;&#x2F;_source&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求参数</p>
</blockquote>
<ul>
<li><code>routing</code>: 只在指定分片中进行搜索.我们可以在建立索引时提供一个自定义的 <code>routing</code> 参数来保证所有相关的文档(如属于单个用户的文档)被存放在一个单独的分片中.在搜索时,我们可以指定一个或多个 <code>routing</code> 值来限制只搜索指定的分片.</li>
<li><code>_source</code>: 是否返回 _source 文档内容,默认为 true</li>
<li><code>_source_excludes</code>: 从返回的 _source 字段中排除的字段列表</li>
<li><code>_source_includes</code>: 从 _source 字段提取并返回的字段列表</li>
</ul>
<h3 id="Delete-API"><a href="#Delete-API" class="headerlink" title="Delete API"></a>Delete API</h3><p>从指定的索引中删除指定的文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;&lt;index&gt;&#x2F;_doc&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Delete-by-query-API"><a href="#Delete-by-query-API" class="headerlink" title="Delete by query API"></a>Delete by query API</h3><p>删除与指定查询匹配的文档,<code>&lt;index&gt;</code> 为选填参数,且支持使用逗号指定多个,默认为 <code>_all</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_delete_by_query</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求参数</p>
</blockquote>
<ul>
<li><code>from</code>: 文档的开始位置.默认为 0</li>
<li><code>max_docs</code>: 要处理的最大文档数,默认为所有</li>
<li><code>q</code>: 使用 Lucene 查询语法查询</li>
<li><code>routing</code>: 只在指定分片中进行搜索</li>
<li><code>scroll_size</code>: 操作滚动的大小,默认 100</li>
<li><code>sort</code>: 排序,以逗号分隔的 <code>&lt;field&gt;:&lt;direction&gt;</code> 列表</li>
<li><code>_source</code>: 是否返回 _source 文档内容,默认为 true</li>
<li><code>_source_excludes</code>: 从返回的 _source 字段中排除的字段列表</li>
<li><code>_source_includes</code>: 从 _source 字段提取并返回的字段列表</li>
</ul>
<blockquote>
<p>请求体</p>
</blockquote>
<ul>
<li><code>query</code>: <code>Query DSL</code> 格式的请求,用于筛选文档</li>
</ul>
<h3 id="Update-API"><a href="#Update-API" class="headerlink" title="Update API"></a>Update API</h3><p>使用指定内容或脚本更新指定文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;&lt;index&gt;&#x2F;_update&#x2F;&lt;_id&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志处理</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 必须知道的知识点</title>
    <url>/2020/05/29/docker-need-to-know/</url>
    <content><![CDATA[<h2 id="docker-配置"><a href="#docker-配置" class="headerlink" title="docker 配置"></a>docker 配置</h2><p>docker 默认配置见官方文档 <a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">daemon.json</a> 示例.且提供了众多<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon" target="_blank" rel="noopener">命令行参数</a>.下面介绍一些常用配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进程相关</span><br><span class="line">--config-file string: 指定配置文件,默认是 &#96;&#x2F;etc&#x2F;docker&#x2F;daemon.json&#96;</span><br><span class="line">-p, --pidfile string: 指定 PID 文件.默认是 &#96;&#x2F;var&#x2F;run&#x2F;docker.pid&#96;</span><br><span class="line">--containerd string: 指定 grpc 地址</span><br><span class="line">--data-root string: 指定 docker 镜像和容器相关文件保存位置.默认是 &#96;&#x2F;var&#x2F;lib&#x2F;docker&#96;</span><br><span class="line">--log-driver string: 指定日志驱动.默认为 &#96;json-file&#96;</span><br><span class="line">--log-level string: 指定日志级别.可选值为 debug,info,warn,error,fatal.默认 &#96;info&#96;</span><br><span class="line"></span><br><span class="line">log-opts: 指定日志选项,只能用于配置文件中.&#96;max-size&#96; 指定日志文件大小,&#96;max-file&#96; 指定日志文件个数</span><br><span class="line"></span><br><span class="line"># 镜像相关</span><br><span class="line">--insecure-registry list: 指定不安全的镜像仓库地址</span><br><span class="line">--registry-mirror list: 指定安全的镜像仓库.配置文件中为 &#96;registry-mirrors&#96;</span><br><span class="line"></span><br><span class="line"># 网络相关</span><br><span class="line">--bip string: 指定 docker0 网桥 IP 地址</span><br><span class="line">--default-gateway string: 子网 IPv4 默认网关</span><br><span class="line">--default-gateway-v6 string: 子网 IPv6 默认网关</span><br><span class="line">--fixed-cidr string: 指定子网 IPv4 地址</span><br><span class="line">--fixed-cidr-v6 string: 指定子网 IPv6 地址</span><br><span class="line">--mtu int: 指定容器最大传输单元</span><br><span class="line">--dns list: 指定容器使用的 DNS 地址</span><br><span class="line"></span><br><span class="line"># 调试</span><br><span class="line">-D, --debug: 开启 debug 模式,多用于调试</span><br></pre></td></tr></table></figure>

<h2 id="docker-底层原理"><a href="#docker-底层原理" class="headerlink" title="docker 底层原理"></a>docker 底层原理</h2><p>docker 使用 Go 语言编写,并利用 Linux 内核的多个功能来实现其功能.</p>
<h3 id="Namespaces-名称空间"><a href="#Namespaces-名称空间" class="headerlink" title="Namespaces 名称空间"></a>Namespaces 名称空间</h3><p>docker 使用一种称为 <code>namespaces</code> 的技术来为容器提供运行环境的隔离.运行容器时,docker 引擎会为该容器创建一组如下的名称空间</p>
<table>
<thead>
<tr>
<th align="center">名称空间</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PID</td>
<td align="left">提供进程隔离.每个容器中都有独立的进程号</td>
</tr>
<tr>
<td align="center">Network</td>
<td align="left">提供网络资源隔离.每个容器都有独立的网络设备接口, IPv4, IPv6 协议栈,路由表,防火墙等</td>
</tr>
<tr>
<td align="center">IPC</td>
<td align="left">提供进程间间通信资源隔离.容器中进程间通信仍然使用 Linux 进程间通信方法,信号量,消息队列,共享内存等</td>
</tr>
<tr>
<td align="center">Mount</td>
<td align="left">提供文件系统隔离.每个容器都有独立的 <code>/</code> 根文件系统</td>
</tr>
<tr>
<td align="center">UTS</td>
<td align="left">提供容器主机名和域名隔离.每个容器都有独立的主机名和域名,其主机名一般为容器 ID</td>
</tr>
<tr>
<td align="center">User</td>
<td align="left">提供用户及用户组隔离.每个容器都有独立的用户,用户组及其相关访问权限</td>
</tr>
</tbody></table>
<h3 id="Control-groups"><a href="#Control-groups" class="headerlink" title="Control groups"></a>Control groups</h3><p>控制组(cgroups)以一组进程为目标进行系统资源分配和控制,它提供了如下功能:</p>
<ul>
<li>Resource limitation,资源限制,如内存,CPU 等硬件资源</li>
<li>Prioritization,优先级控制</li>
<li>Accounting,审计或统计</li>
<li>Controll,进程控制,如进程挂起与恢复</li>
</ul>
<p>系统管理员可更具体地控制对系统资源的分配,优先顺序,拒绝,管理和监控.可更好地根据任务和用户分配硬件资源,提高总体效率.在实践中,系统管理员一般会利用 CGroup 做下面这些事:</p>
<ul>
<li>隔离进程集合,并限制他们所消耗的资源</li>
<li>为这组进程分配其足够使用的内存,网络带宽和磁盘存储限制</li>
<li>限制访问某些设备</li>
</ul>
<h3 id="Union-file-systems"><a href="#Union-file-systems" class="headerlink" title="Union file systems"></a>Union file systems</h3><p>Union file systems(联合文件系统)是通过创建层级进行操作的文件系统,它将对文件系统的修改作为一次提交来一层层的叠加.常用的包含 overlay2 aufs</p>
<p>overlay2 采用三层结构:</p>
<ul>
<li>lowerdir: 只读层,镜像层</li>
<li>uperdir: 读写层.创建容器时创建,所有对容器的改动发生在这里</li>
<li>merged: 容器挂载点,将以上两层进行合并后看到的内容</li>
</ul>
<h2 id="docker-几种网络模型"><a href="#docker-几种网络模型" class="headerlink" title="docker 几种网络模型"></a>docker 几种网络模型</h2><p>可以使用 <code>docker run --net=xxx</code> 指定容器使用的网络类型</p>
<ul>
<li><code>bridge</code>: 桥接,默认的网络模型.为主机上的容器分配单独的网络名称空间,IP 等,并将容器中的网络接口连接到虚拟网桥上(docker0)</li>
<li><code>host</code>: 与宿主机共用网络名称空间,容器使用宿主机的 IP 和端口</li>
<li><code>overlay</code>: 与其它容器共用网络名称空间,使容器间能够通过 lo 进行通信</li>
<li><code>none</code>: 容器有独立的网络名称空间,但不进行任何网络配置,只有本地地址</li>
<li><code>macvlan</code>: 为容器分配 MAC 地址,使其在网络上显示为物理设备.可通过 MAC 地址直接将流量路由到容器.</li>
</ul>
<h2 id="docker-开发最佳实践"><a href="#docker-开发最佳实践" class="headerlink" title="docker 开发最佳实践"></a>docker 开发最佳实践</h2><h3 id="保持镜像尽可能的小"><a href="#保持镜像尽可能的小" class="headerlink" title="保持镜像尽可能的小"></a>保持镜像尽可能的小</h3><ul>
<li><p>尽量使用 <code>ENV</code> 和 <code>ARG</code> 让人不改或者少改 Dockerfile 即可做构建对应版本的镜像</p>
</li>
<li><p>尽量减少 Dockerfile 中单独的 RUN 命令的数量来减少镜像的层数</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /data</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> touch /data/index.html</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /data &amp;&amp; touch /data/index.html</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从适当的基础镜像开始.例如,如果您需要 JDK,请考虑基于正式的 openjdk 镜像,而不是基于 ubuntu 镜像开始,再将 openjdk 的安装作为 Dockerfile 的一部分</li>
<li>可以在官方 Dockerfile 里添加一些常见的排错命令,也可以将二进制及其依赖库添加到镜像中,参见<a href="https://docs.lvrui.io/2018/10/19/%E4%B8%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%9A%E5%88%B6%E5%AE%89%E8%A3%85Linux%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">为容器镜像定制安装Linux工具</a>.如</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本示例仅作为示例演示,并没有实际意义</span></span><br><span class="line"><span class="comment"># 系统环境 CentOS 7.5.1804,发现 centos:centos7.5.1804 没有 lsof 工具.添加一下</span></span><br><span class="line"><span class="comment"># 首先在宿主机中安装 lsof 工具,并通过 ldd 查看其依赖库 `ldd $(which lsof)`</span></span><br><span class="line"><span class="comment"># 在 centos:centos7.5.1804 镜像启动的容器中查找 lsof 的依赖库,可看到都是存在的.因此直接将二进制文件复制进入即可</span></span><br><span class="line"><span class="keyword">FROM</span> centos:centos7.<span class="number">5.1804</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> lsof /usr/sbin/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用多阶段构建.例如,您可以使用 maven 镜像构建 Java 应用程序,然后使用 tomcat 镜像并将构建的 Java 程序复制到正确的位置.这意味着您最终构建的镜像不包括构建所引入的所有库和依赖项.见如下示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span>.<span class="number">6</span>-alpine3.<span class="number">10</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -o /demo</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./demo"</span>]</span></span><br><span class="line"><span class="comment"># 此时我们构建的镜像包括 go 的运行环境,相关源码或依赖文件,二进制可执行文件.镜像较大</span></span><br><span class="line"><span class="comment"># 其中运行环境与源码或依赖对于容器的运行来说都是多余的.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span>.<span class="number">6</span>-alpine3.<span class="number">10</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . <span class="variable">$GOPATH</span>/src/demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -o /demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /demo .</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./demo"</span>]</span></span><br><span class="line"><span class="comment"># 此时我们构建镜像仅包含二进制可执行文件.可以理解为 builder 构建完成后就将其丢弃了.镜像较小</span></span><br></pre></td></tr></table></figure>

<ul>
<li>尝试将共享的运行环境或依赖构建为独立的镜像,然后在此基础上构建其它镜像.Docker 只需要加载一次公共层,然后将它们缓存,可以更快的构建.如多个应用都需要自定义的 Tomcat 环境,可以将自定义 Tomcat 构建为单独镜像,而不需要每次构建应用时从最初始自定义 Tomcat 环境开始构建</li>
<li>容器时区问题可以在构建镜像的时候安装 <code>tzdate</code> 包，然后声明变量 <code>TZ</code> 即可声明容器运行的时区,或者构建的时候复制宿主机的<code>/etc/localtime</code>或者运行的时候挂载宿主机的<code>/etc/localtime</code></li>
</ul>
<h3 id="在何处以及如何保留数据"><a href="#在何处以及如何保留数据" class="headerlink" title="在何处以及如何保留数据"></a>在何处以及如何保留数据</h3><ul>
<li>避免将数据存储在容器的可写层中,这会增加容器大小,且效率不如使用 volumes 或 bind 挂载</li>
<li>bind 挂载多用于开发或测试过程中.对于生产环境,请使用 volumes</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -`</span><br></pre></td></tr></table></figure>

<p><code>docker build</code> 命令从 <code>Dockerfile</code> 及上下文构建镜像,构建的上下文是位于 <code>PATH</code> 或 <code>URL</code> 指定的位置的文件集合.<code>PATH</code> 是本地文件系统上的目录,<code>URL</code>是一个 Git 仓库位置.</p>
<p>上下文是递归处理的.因此 <code>PATH</code> 包括任何子目录,<code>URL</code> 包括仓库及其子模块.</p>
<p>构建过程是 Docker 守护进程进行的.构建的第一件事就是将整个上下文目录及其子目录发送到守护进程中.因此,最好以空目录作为上下文,仅包含 Dockerfile 及 Dockerfile 构建过程中所需要的文件.</p>
<h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><p>通过在上下文中添加 <code>.dockerignore</code> 文件可以排除构建上下文中包含的文件或目录.</p>
<p><code>.dockerignore</code> 文件使用 <code>#</code> 作为注释,每行包含一个忽略的文件或目录,支持使用 <code>*</code>,<code>?</code>,<code>**</code> 作为通配符匹配.分别表示所有文件,单个字符,目录递归.</p>
<p>在使用 <code>*</code> 忽略所有文件后,可以使用 <code>!</code> 向上下文中添加被忽略的文件</p>
<h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p><code>ARG</code> 定义一个变量,用户也可以在构建时使用 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 传入构建参数.如果该参数没有在 Dockerfile 中定义,则输出警告信息.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><code>FROM</code> 指定构建过程的基础镜像,一个有效的 Dockerfile 必须以 <code>FROM</code> 指令启动.它支持使用 <code>ARG</code> 定义的变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p><code>RUN</code> 指令从当前镜像最新层执行命令并提交结果.生成的镜像层用于 Dockerfile 中下一步.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> COMMAND</span></span><br></pre></td></tr></table></figure>

<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p><code>LABEL</code> 指令为镜像打标签</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>

<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE</code> 指令暴露 Docker 容器监听的端口</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>

<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p><code>ENV</code> 指令定义环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p><code>WORKDIR</code> 指令定义工作目录,相当于 <code>cd</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure>

<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p><code>USER</code> 指令指定运行镜像时使用的用户名及可选组</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p><code>VOLUME</code> 指定挂载点</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/path"</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><ul>
<li><code>ADD</code> 指令支持拷贝压缩文件到镜像中,并自动解压</li>
<li><code>ADD</code> 指令支持从源文件来自指定URL,构建容器时会自动下载到指定目录</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 指令设置容器启动后要执行的命令.使用 <code>--entrypoint</code> 指令进行替换.它有两种形式</p>
<p><code>--entrypoint</code> 指令指定的命令会覆盖原有所有命令及参数</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exec 形式,是推荐的形式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell 形式. 容器启动后默认执行 `/bin/sh -c command param1 param2`,这种方式启动的容器会自动回收孤儿进程与僵尸进程</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>

<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p><code>CMD</code> 指令一般用来设置容器启动后执行命令的默认参数.如果是参数,则必须指定 <code>ENTRYPOINT</code> 指令.如果包含多个 <code>CMD</code> 指令,以最后一个为准.</p>
<p><code>docker run [command]</code> 时会覆盖 <code>CMD</code> 指令内容,对 <code>ENTRYPOINT</code> 无影响</p>
<p><code>CMD</code> 指令有 3 种形式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exec 形式,是推荐的形式.该形式不会支持管道或变量替换.容器中 `executable` 进程 ID 为 1</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell 形式. 容器会默认使用 `/bin/sh -c command param1 param2` 启动容器,这种方式启动的容器会自动回收孤儿进程与僵尸进程</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作为 ENTRYPOINT 的默认参数,此时 ENTRYPOINT 必须使用 exec 形式</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"param1"</span>,<span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure>

<p>下表列出了不同 <code>ENTRYPOINT</code> 与 <code>CMD</code> 指令在容器启动时运行的命令:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">No ENTRYPOINT</th>
<th align="center"><code>ENTRYPOINT exec_entry p_entry</code></th>
<th align="center"><code>ENTRYPOINT [&quot;exec_entry&quot;, &quot;p_entry&quot;]</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">No CMD</td>
<td align="center">error</td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry</code></td>
</tr>
<tr>
<td align="center"><code>CMD [&quot;exec_cmd p_cmd&quot;]</code></td>
<td align="center"><code>exec_cmd p_c</code></td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry exec_cmd p_cmd</code></td>
</tr>
<tr>
<td align="center"><code>CMD [&quot;p1_cmd&quot;, &quot;p2_cmd&quot;]</code></td>
<td align="center"><code>p1_cmd p2_cmd</code></td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry p1_cmd p2_cmd</code></td>
</tr>
<tr>
<td align="center"><code>CMD exec_cmd p_cmd</code></td>
<td align="center"><code>exec_cmd p_cmd</code></td>
<td align="center"><code>/bin/sh -c exec_entry p_entry</code></td>
<td align="center"><code>exec_entry p_entry /bin/sh -c exec_cmd _cmd</code></td>
</tr>
</tbody></table>
<p>可以在 <a href="https://github.com/docker-library/" target="_blank" rel="noopener">GitHub</a> 上查看官方镜像的 Dockerfile</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
