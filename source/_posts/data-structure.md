---
title: 算法与数据结构
tags:
  - 数据结构
  - 算法
categories:
  - 算法与数据结构
abbrlink: 51507
description: 数据结构是相互之间存在一种或多种特定关系的数据元素的集合.算法是解决特定问题求解步骤的描述
---

> 数据结构

数据结构是相互之间存在一种或多种特定关系的数据元素的集合.我们可以将数据结构分为逻辑结构和物理结构.

- 逻辑结构是指数据对象中数据元素之间存在逻辑上的相互关系.如集合,线性结构,树形结构,图形结构等
- 物理结构是指数据的在计算机中的存储形式.如顺序存储,链式存储.其中,顺序存储时把数据元素存放在地址连续的存储单元中,链式存储是把数据元素存放在任意存储单元中,再通过逻辑上的指针将各个元素串联起来

> 算法

算法是解决特定问题求解步骤的描述,具有如下 5 个特性:

- 输入输出: 算法具有零个或多个输入,至少有一个或多个输出
- 有穷性: 算法在执行有限步骤后,自动结束而不会出现无线循环,且每个步骤在可接收的时间内完成
- 确定性: 算法的每个步骤都有确定的含义,不会出现分歧
- 可行性: 算法的每一步都是可行的

> 算法的时间复杂度

算法的时间复杂度可使用大 O 阶进行表示,我们按照如下方式推导大 O 阶:

1. 用常数 1 表示运行时间中所有加法常数
2. 在修改后的运行次数函数中,只保留最高阶项
3. 如果最高阶项存在且不是 1,则去除与这个项相乘的常数,得到的结果就是大 O 阶

常用时间复杂度所耗费的时间从小到大是:

```text
O(1) < O(log n) < O(n) < O(nlog n) < O(n^2) < O(2^n)  < O(n!) < O(n^n)
```

# 线性表

线性表是一个序列,元素之间是有顺序的.若元素存在多个,则第一个元素无前驱,最后一个元素无后继,其它每个元素有且仅有一个前驱和后继.常见的表示形式是数组和链表

## 数组

数组是指用一段连续的存储单元依次存储相同类型数据的数据结构.它主要有如下特性

- 具有连续的内存,有上界和下界
- 数据是连续的,随机访问速度快(查找较快),时间复杂度为 O(1)
- 增删元素较慢,需要重新分配内存空间并将元素进行平移,时间复杂度为 O(n)

## 链表

- 节点的链接方向是单向的
- 相对于数组来说,单链表的的随机访问速度较慢,只能从链表开头进行依次查找)
- 删除/添加数据的效率很高,只需要修改插入/删除位置的 next 指针即可

## 栈

- 栈中数据是按照"后进先出(LIFO, Last In First Out)"方式进出栈的
- 向栈中添加/删除数据时,只能从栈顶进行操作

栈通常包括的三种操作:push(向栈中添加元素), peek(返回栈顶元素), pop(返回并弹出栈顶元素)


## 队列

- 队列中数据是按照"先进先出(FIFO, First-In-First-Out)"方式进出队列的
- 队列只允许在"队首"进行删除操作,而在"队尾"进行插入操作。

队列通常包括的两种操作:入队列和出队列

# 树形结构

## 二叉树

二叉树是每个结点最多有两个子树的树结构,通常子树被称作"左子树(left subtree)"和"右子树(right subtree)".二叉树常被用于实现二叉查找树和二叉堆

> 满二叉树: 所有层都是满的.即深度为k,且有 2^k - 1 个节点的二叉树
> 完全二叉树: 除最后一层外,若其余层都是满的,并且最后一层或者是满的,或者是在右边缺少连续若干节点,则此二叉树为

先序遍历 = 根->左子树->右子树

中序遍历 = 左子树->根->右子树

后序遍历 = 左子树->右子树->根

## 二叉查找树

- 左子树上所有结点的值均小于它的根结点的值,右子树上所有结点的值均大于它的根结点的值
- 任意节点的左,右子树也分别为二叉查找树
- 没有键值相等的节点

> 局限:如果我们的根节点选择是最小或者最大的数,那么二叉查找树就完全退化成了线性结构(链表)

## 平衡二叉树 AVL

带有平衡条件的二叉查找树,所有节点的左右子树高度差不超过1.

只要不满足这个条件,就要通过旋转来保持平衡,而旋转是非常耗时的.AVL树适合用于插入删除次数比较少,但查找多的情况.

维护这种高度平衡所付出的代价比从中获得的效率收益还大,实际的应用不多

## 红黑树

一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色,非黑即红

- 每个节点非红即黑
- 根节点是黑的
- 每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的
- 如果一个节点是红的,那么它的两儿子都是黑的
- 对于任意节点而言,其到叶子点树NULL指针的每条路径都包含相同数目的黑节点
- 每条路径都包含相同的黑节点

> 应用

1. 广泛用于C++的STL中,Map和Set都是用红黑树实现的
2. 著名的Linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块,进程的虚拟内存区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址虚拟存储区域,右指针指向相邻的高地址虚拟地址空间
3. IO多路复用epoll的实现采用红黑树组织管理sockfd,以支持快速的增删改查
4. Nginx中用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器
5. Java中TreeMap的实现

## B树

B树是一种多路搜索树,它的每个节点可以拥有多于两个孩子节点,M路的B树最多能拥有M个孩子节点

- 根节点至少有两个子节点
- 每个节点有M-1个key，并且以升序排列
- 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
- 其它节点至少有M/2个子节点

多路是为了降低树的高度,但是无线多路会退化成有序数组

B树多用于文件系统索引.
文件系统和数据库的索引都是存在硬盘上的,并且如果数据量大的话,不一定能一次性加载到内存中.
这时候,B树的多路存储为例就出来了,可以每次加载B数的一个节点,然后一步一步往下找

## B+树

[伯乐在线_什么是B+树](https://blog.csdn.net/qq_26222859/article/details/80631121)

B+树是在B树的基础上进行改造的,它的数据都在叶子节点.
叶子节点之间还加了指针形成双向链表

这么设计的原因是与和使用场景相关的,数据库中 Select 数据,不一定只选一条,很多时候会选多条.
如果是多条的话,B 树需要做局部的中序遍历,可能要跨层访问.
而 B+ 树由于所有数据都在叶子结点,不用跨层,同时由于有链表结构,只需要找到首尾,通过链表就能把所有数据取出来了

## 堆

### 二叉堆

二叉堆是完全二元树或者是近似完全二元树,按照数据的排列方式可以分为两种:最大堆和最小堆

- 最大堆:父结点的键值总是大于或等于任何一个子节点的键值
- 最小堆:父结点的键值总是小于或等于任何一个子节点的键值

# 排序算法

## 冒泡排序

冒泡排序会遍历若干次要排序的数列,每次遍历时,它都会从前往后依次的比较两个数的大小.如果前者比后者大,则交换它们的位置.一次遍历完成后,最大的元素就在数列的末尾.

```python

```