---
title: 运维面试题之 TCP/IP
date: 2020/06/04
tags:
  - TCP/IP
categories:
  - 面试题
  - TCP/IP
abbrlink: 
description: 总结整理常见 TCP/IP 面试题,以作备忘
---

## OSI 七层模型,TCP/IP 四层模型

OSI从上到下依次是 应用层 -> 表示层 -> 会话层 -> 传输层 -> 网络层 -> 数据链路层 -> 物理层

TCP/IP 从上到下依次是 应用层 -> 传输层 -> IP层 -> 网络接口层

## TCP 三次握手,四次挥手过程

TCP 三次握手

1. 客户端发送 `SYN(syn=x)` 包到服务器,并进入 `SYN_SEND` 状态,等待服务端确认
2. 服务端收到后,回传一个带有 `ACK(ack=x+1)` 标志的数据包以示传达确认信息,同时自己也发送一个 `SYN(syn=y)` 数据包,此时服务器进入 `SYN_RECV` 状态
3. 客户端收服务端的 SYN+ACK 包,向服务器发送 `ACK(ack=y+1)` 包.随后,客户端与服务端建立连接,进入 `ESTABLISHED` 状态,完成三次握手

TCP 四次挥手

1. 客户端发送连接释放报文(`FIN=1,seq=u`),并停止发送数据,客户端进入 `FIN_WAIT_1` 状态
2. 服务器收到连接释放报文,发出确认报文(`ACK=1,ack=u+1,seq=v`),服务器进入 `CLOSE_WAIT` 状态
3. 客户端接收到服务器的确认请求后,客户端进入`FIN_WAIT_2` 状态,等待服务器发送连接释放报文.此时客户端不再向服务端发送数据,若服务端发送数据,客户端依然接受.
4. 服务端将最后的数据发送完毕后,向客户端发送释放报文(`FIN=1,seq=w`),服务端进入 `LAST_ACK` 状态.
5. 客户端收到服务端连接释放报文后,必须回复确认(`ACK=1,ack=w+1,seq=u+1`),客户端进入 `TIME_WAIT` 状态,时长为 2∗MSL(报文最长寿命).

### 为什么最后要等待 2 * MSL

- 保证客户端发送的最后一个 ACK 报文能够到达服务器,保证可靠的终止 TCP 连接.TCP 内部存在超时重传机制,如果服务端在发出释放报文后,没有收到确认报文,服务端会重新发送一次,客户端就能够在 2 * MSL 内收到重传报文
- 保证新连接中不会出现旧连接的请求报文.客户端发送完最后一个确认报文后,在这个 2 * MSL 时间中,就可以使本连接持续的时间内所产生的所有报文段都从网络中消失.

### 为什么需要三次握手,两次不行吗?

主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判,造成服务端资源/时间的浪费.

### 为什么建立连接是三次握手,而关闭连接却是四次挥手呢?

- 建立连接

因为服务端在 LISTEN 状态下,收到建立连接请求的SYN报文后,把ACK和SYN放在一个报文里发送给客户端.

- 关闭连接

当收到对方的 FIN 报文时,仅表示对方不再发送数据但还能接收收据,我们也未必把全部数据都发给了对方,所以我们可以立即关闭,也可以发送一些数据给对方后,再发送 FIN 报文给对方表示同意关闭连接.因此关闭连接的 ACK 和 FIN 一般会分开发送.

### 三次握手有什么缺陷

伪造IP大量的向 server 发送 TCP 连接请求报文包,从而将 server 的半连接队列(即 server 收到连接请求 SYN 之后将 client 加入半连接队列中)占满,从而使得 server 拒绝其他正常的连接请求,即拒绝服务攻击.

### TCP 以什么方式提供数据可靠性

- 将数据切分为最合适发送的数据块
- 计时,收到后确认与超时重传.当 TCP 发出一个段后,它会启动一个定时器,等待目的端确认收到这个报文段.如果不能及时收到一个确认,将重发这个报文
- 首部与数据校验和确保数据在传输过程中的任何变化
- 重新排序机制确保收到的数据以正确的顺序交给应用层
- 丢弃重复数据
- 流量控制,防止较快主机致使较慢主机的缓冲区溢出

## DNS 域名解析过程

1. 应用首先检查缓存中有没有这个域名对应的解析过的 IP 地址.如果缓存中有,则返回缓存中的 IP 地址.否则进行下一步
2. 查找本机的 host 文件, Linux 为 `/etc/hosts`,Windows 为 `C:\Windows\System32\drivers\etc\hosts`.若查到,则返回.否则进行下一步
3. 发送请求到 DNS 服务器 Linux 为 `/etc/resolv.conf`.DNS 服务器在收到客户机的请求后,首先检查 DNS 服务器的缓存,若查到请求的地址或名字,即向客户机发出应答信息.否则在数据库中查找,若查到请求的地址或名字,即向客户机发出应答信息
4. 若没有找到,则将请求发给根域 DNS 服务器,并依序从根域查找顶级域,由顶级域查找二级域...直至找到要解析的地址或名字,即向客户机所在网络的 DNS 服务器发出应答信息,DNS 服务器收到应答后现在缓存中存储,然后,将解析结果发给客户机
